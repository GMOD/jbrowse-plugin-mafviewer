"use strict";
var JBrowsePluginMsaView = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // global-externals:@jbrowse/core/Plugin
  var require_Plugin = __commonJS({
    "global-externals:@jbrowse/core/Plugin"(exports, module) {
      module.exports = JBrowseExports["@jbrowse/core/Plugin"];
    }
  });

  // global-externals:@jbrowse/core/configuration
  var require_configuration = __commonJS({
    "global-externals:@jbrowse/core/configuration"(exports, module) {
      module.exports = JBrowseExports["@jbrowse/core/configuration"];
    }
  });

  // global-externals:@jbrowse/core/util
  var require_util = __commonJS({
    "global-externals:@jbrowse/core/util"(exports, module) {
      module.exports = JBrowseExports["@jbrowse/core/util"];
    }
  });

  // global-externals:@mui/material/utils
  var require_utils = __commonJS({
    "global-externals:@mui/material/utils"(exports, module) {
      module.exports = JBrowseExports["@mui/material/utils"];
    }
  });

  // node_modules/@mui/icons-material/esm/utils/createSvgIcon.js
  var import_utils;
  var init_createSvgIcon = __esm({
    "node_modules/@mui/icons-material/esm/utils/createSvgIcon.js"() {
      "use client";
      import_utils = __toESM(require_utils(), 1);
    }
  });

  // global-externals:react/jsx-runtime
  var require_jsx_runtime = __commonJS({
    "global-externals:react/jsx-runtime"(exports, module) {
      module.exports = JBrowseExports["react/jsx-runtime"];
    }
  });

  // global-externals:mobx-state-tree
  var require_mobx_state_tree = __commonJS({
    "global-externals:mobx-state-tree"(exports, module) {
      module.exports = JBrowseExports["mobx-state-tree"];
    }
  });

  // global-externals:react
  var require_react = __commonJS({
    "global-externals:react"(exports, module) {
      module.exports = JBrowseExports["react"];
    }
  });

  // global-externals:mobx-react
  var require_mobx_react = __commonJS({
    "global-externals:mobx-react"(exports, module) {
      module.exports = JBrowseExports["mobx-react"];
    }
  });

  // global-externals:tss-react/mui
  var require_mui = __commonJS({
    "global-externals:tss-react/mui"(exports, module) {
      module.exports = JBrowseExports["tss-react/mui"];
    }
  });

  // global-externals:@jbrowse/core/pluggableElementTypes
  var require_pluggableElementTypes = __commonJS({
    "global-externals:@jbrowse/core/pluggableElementTypes"(exports, module) {
      module.exports = JBrowseExports["@jbrowse/core/pluggableElementTypes"];
    }
  });

  // global-externals:@jbrowse/core/data_adapters/BaseAdapter
  var require_BaseAdapter = __commonJS({
    "global-externals:@jbrowse/core/data_adapters/BaseAdapter"(exports, module) {
      module.exports = JBrowseExports["@jbrowse/core/data_adapters/BaseAdapter"];
    }
  });

  // node_modules/tslib/tslib.es6.mjs
  function __extends(d3, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d3, b2);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  }
  function __values(o2) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
    if (m2) return m2.call(o2);
    if (o2 && typeof o2.length === "number") return {
      next: function() {
        if (o2 && i2 >= o2.length) o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o2, n2) {
    var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
    if (!m2) return o2;
    var i2 = m2.call(o2), r2, ar = [], e2;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
    } catch (error2) {
      e2 = { error: error2 };
    } finally {
      try {
        if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
      } finally {
        if (e2) throw e2.error;
      }
    }
    return ar;
  }
  function __spreadArray(to, from2, pack) {
    if (pack || arguments.length === 2) for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from2)) {
        if (!ar) ar = Array.prototype.slice.call(from2, 0, i2);
        ar[i2] = from2[i2];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from2));
  }
  var extendStatics;
  var init_tslib_es6 = __esm({
    "node_modules/tslib/tslib.es6.mjs"() {
      extendStatics = function(d3, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
          d4.__proto__ = b3;
        } || function(d4, b3) {
          for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
        };
        return extendStatics(d3, b2);
      };
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/isFunction.js
  function isFunction(value) {
    return typeof value === "function";
  }
  var init_isFunction = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/isFunction.js"() {
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
  function createErrorClass(createImpl) {
    var _super = function(instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }
  var init_createErrorClass = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js"() {
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
  var UnsubscriptionError;
  var init_UnsubscriptionError = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js"() {
      init_createErrorClass();
      UnsubscriptionError = createErrorClass(function(_super) {
        return function UnsubscriptionErrorImpl(errors) {
          _super(this);
          this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err2, i2) {
            return i2 + 1 + ") " + err2.toString();
          }).join("\n  ") : "";
          this.name = "UnsubscriptionError";
          this.errors = errors;
        };
      });
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
  function arrRemove(arr, item) {
    if (arr) {
      var index3 = arr.indexOf(item);
      0 <= index3 && arr.splice(index3, 1);
    }
  }
  var init_arrRemove = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/arrRemove.js"() {
    }
  });

  // node_modules/rxjs/dist/esm5/internal/Subscription.js
  function isSubscription(value) {
    return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
  }
  function execFinalizer(finalizer) {
    if (isFunction(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  }
  var Subscription, EMPTY_SUBSCRIPTION;
  var init_Subscription = __esm({
    "node_modules/rxjs/dist/esm5/internal/Subscription.js"() {
      init_tslib_es6();
      init_isFunction();
      init_UnsubscriptionError();
      init_arrRemove();
      Subscription = (function() {
        function Subscription2(initialTeardown) {
          this.initialTeardown = initialTeardown;
          this.closed = false;
          this._parentage = null;
          this._finalizers = null;
        }
        Subscription2.prototype.unsubscribe = function() {
          var e_1, _a, e_2, _b;
          var errors;
          if (!this.closed) {
            this.closed = true;
            var _parentage = this._parentage;
            if (_parentage) {
              this._parentage = null;
              if (Array.isArray(_parentage)) {
                try {
                  for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                    var parent_1 = _parentage_1_1.value;
                    parent_1.remove(this);
                  }
                } catch (e_1_1) {
                  e_1 = { error: e_1_1 };
                } finally {
                  try {
                    if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
                  } finally {
                    if (e_1) throw e_1.error;
                  }
                }
              } else {
                _parentage.remove(this);
              }
            }
            var initialFinalizer = this.initialTeardown;
            if (isFunction(initialFinalizer)) {
              try {
                initialFinalizer();
              } catch (e2) {
                errors = e2 instanceof UnsubscriptionError ? e2.errors : [e2];
              }
            }
            var _finalizers = this._finalizers;
            if (_finalizers) {
              this._finalizers = null;
              try {
                for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                  var finalizer = _finalizers_1_1.value;
                  try {
                    execFinalizer(finalizer);
                  } catch (err2) {
                    errors = errors !== null && errors !== void 0 ? errors : [];
                    if (err2 instanceof UnsubscriptionError) {
                      errors = __spreadArray(__spreadArray([], __read(errors)), __read(err2.errors));
                    } else {
                      errors.push(err2);
                    }
                  }
                }
              } catch (e_2_1) {
                e_2 = { error: e_2_1 };
              } finally {
                try {
                  if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
                } finally {
                  if (e_2) throw e_2.error;
                }
              }
            }
            if (errors) {
              throw new UnsubscriptionError(errors);
            }
          }
        };
        Subscription2.prototype.add = function(teardown) {
          var _a;
          if (teardown && teardown !== this) {
            if (this.closed) {
              execFinalizer(teardown);
            } else {
              if (teardown instanceof Subscription2) {
                if (teardown.closed || teardown._hasParent(this)) {
                  return;
                }
                teardown._addParent(this);
              }
              (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
            }
          }
        };
        Subscription2.prototype._hasParent = function(parent) {
          var _parentage = this._parentage;
          return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
        };
        Subscription2.prototype._addParent = function(parent) {
          var _parentage = this._parentage;
          this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
        };
        Subscription2.prototype._removeParent = function(parent) {
          var _parentage = this._parentage;
          if (_parentage === parent) {
            this._parentage = null;
          } else if (Array.isArray(_parentage)) {
            arrRemove(_parentage, parent);
          }
        };
        Subscription2.prototype.remove = function(teardown) {
          var _finalizers = this._finalizers;
          _finalizers && arrRemove(_finalizers, teardown);
          if (teardown instanceof Subscription2) {
            teardown._removeParent(this);
          }
        };
        Subscription2.EMPTY = (function() {
          var empty = new Subscription2();
          empty.closed = true;
          return empty;
        })();
        return Subscription2;
      })();
      EMPTY_SUBSCRIPTION = Subscription.EMPTY;
    }
  });

  // node_modules/rxjs/dist/esm5/internal/config.js
  var config;
  var init_config = __esm({
    "node_modules/rxjs/dist/esm5/internal/config.js"() {
      config = {
        onUnhandledError: null,
        onStoppedNotification: null,
        Promise: void 0,
        useDeprecatedSynchronousErrorHandling: false,
        useDeprecatedNextContext: false
      };
    }
  });

  // node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
  var timeoutProvider;
  var init_timeoutProvider = __esm({
    "node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js"() {
      init_tslib_es6();
      timeoutProvider = {
        setTimeout: function(handler, timeout3) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var delegate = timeoutProvider.delegate;
          if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
            return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout3], __read(args)));
          }
          return setTimeout.apply(void 0, __spreadArray([handler, timeout3], __read(args)));
        },
        clearTimeout: function(handle) {
          var delegate = timeoutProvider.delegate;
          return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
        },
        delegate: void 0
      };
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
  function reportUnhandledError(err2) {
    timeoutProvider.setTimeout(function() {
      var onUnhandledError = config.onUnhandledError;
      if (onUnhandledError) {
        onUnhandledError(err2);
      } else {
        throw err2;
      }
    });
  }
  var init_reportUnhandledError = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js"() {
      init_config();
      init_timeoutProvider();
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/noop.js
  function noop() {
  }
  var init_noop = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/noop.js"() {
    }
  });

  // node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
  function errorNotification(error2) {
    return createNotification("E", void 0, error2);
  }
  function nextNotification(value) {
    return createNotification("N", value, void 0);
  }
  function createNotification(kind, value, error2) {
    return {
      kind,
      value,
      error: error2
    };
  }
  var COMPLETE_NOTIFICATION;
  var init_NotificationFactories = __esm({
    "node_modules/rxjs/dist/esm5/internal/NotificationFactories.js"() {
      COMPLETE_NOTIFICATION = (function() {
        return createNotification("C", void 0, void 0);
      })();
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/errorContext.js
  function captureError(err2) {
    if (config.useDeprecatedSynchronousErrorHandling && context) {
      context.errorThrown = true;
      context.error = err2;
    }
  }
  var context;
  var init_errorContext = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/errorContext.js"() {
      init_config();
      context = null;
    }
  });

  // node_modules/rxjs/dist/esm5/internal/Subscriber.js
  function bind(fn, thisArg) {
    return _bind.call(fn, thisArg);
  }
  function handleUnhandledError(error2) {
    if (config.useDeprecatedSynchronousErrorHandling) {
      captureError(error2);
    } else {
      reportUnhandledError(error2);
    }
  }
  function defaultErrorHandler(err2) {
    throw err2;
  }
  function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = config.onStoppedNotification;
    onStoppedNotification && timeoutProvider.setTimeout(function() {
      return onStoppedNotification(notification, subscriber);
    });
  }
  var Subscriber, _bind, ConsumerObserver, SafeSubscriber, EMPTY_OBSERVER;
  var init_Subscriber = __esm({
    "node_modules/rxjs/dist/esm5/internal/Subscriber.js"() {
      init_tslib_es6();
      init_isFunction();
      init_Subscription();
      init_config();
      init_reportUnhandledError();
      init_noop();
      init_NotificationFactories();
      init_timeoutProvider();
      init_errorContext();
      Subscriber = (function(_super) {
        __extends(Subscriber2, _super);
        function Subscriber2(destination) {
          var _this = _super.call(this) || this;
          _this.isStopped = false;
          if (destination) {
            _this.destination = destination;
            if (isSubscription(destination)) {
              destination.add(_this);
            }
          } else {
            _this.destination = EMPTY_OBSERVER;
          }
          return _this;
        }
        Subscriber2.create = function(next2, error2, complete) {
          return new SafeSubscriber(next2, error2, complete);
        };
        Subscriber2.prototype.next = function(value) {
          if (this.isStopped) {
            handleStoppedNotification(nextNotification(value), this);
          } else {
            this._next(value);
          }
        };
        Subscriber2.prototype.error = function(err2) {
          if (this.isStopped) {
            handleStoppedNotification(errorNotification(err2), this);
          } else {
            this.isStopped = true;
            this._error(err2);
          }
        };
        Subscriber2.prototype.complete = function() {
          if (this.isStopped) {
            handleStoppedNotification(COMPLETE_NOTIFICATION, this);
          } else {
            this.isStopped = true;
            this._complete();
          }
        };
        Subscriber2.prototype.unsubscribe = function() {
          if (!this.closed) {
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
            this.destination = null;
          }
        };
        Subscriber2.prototype._next = function(value) {
          this.destination.next(value);
        };
        Subscriber2.prototype._error = function(err2) {
          try {
            this.destination.error(err2);
          } finally {
            this.unsubscribe();
          }
        };
        Subscriber2.prototype._complete = function() {
          try {
            this.destination.complete();
          } finally {
            this.unsubscribe();
          }
        };
        return Subscriber2;
      })(Subscription);
      _bind = Function.prototype.bind;
      ConsumerObserver = (function() {
        function ConsumerObserver2(partialObserver) {
          this.partialObserver = partialObserver;
        }
        ConsumerObserver2.prototype.next = function(value) {
          var partialObserver = this.partialObserver;
          if (partialObserver.next) {
            try {
              partialObserver.next(value);
            } catch (error2) {
              handleUnhandledError(error2);
            }
          }
        };
        ConsumerObserver2.prototype.error = function(err2) {
          var partialObserver = this.partialObserver;
          if (partialObserver.error) {
            try {
              partialObserver.error(err2);
            } catch (error2) {
              handleUnhandledError(error2);
            }
          } else {
            handleUnhandledError(err2);
          }
        };
        ConsumerObserver2.prototype.complete = function() {
          var partialObserver = this.partialObserver;
          if (partialObserver.complete) {
            try {
              partialObserver.complete();
            } catch (error2) {
              handleUnhandledError(error2);
            }
          }
        };
        return ConsumerObserver2;
      })();
      SafeSubscriber = (function(_super) {
        __extends(SafeSubscriber2, _super);
        function SafeSubscriber2(observerOrNext, error2, complete) {
          var _this = _super.call(this) || this;
          var partialObserver;
          if (isFunction(observerOrNext) || !observerOrNext) {
            partialObserver = {
              next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
              error: error2 !== null && error2 !== void 0 ? error2 : void 0,
              complete: complete !== null && complete !== void 0 ? complete : void 0
            };
          } else {
            var context_1;
            if (_this && config.useDeprecatedNextContext) {
              context_1 = Object.create(observerOrNext);
              context_1.unsubscribe = function() {
                return _this.unsubscribe();
              };
              partialObserver = {
                next: observerOrNext.next && bind(observerOrNext.next, context_1),
                error: observerOrNext.error && bind(observerOrNext.error, context_1),
                complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
              };
            } else {
              partialObserver = observerOrNext;
            }
          }
          _this.destination = new ConsumerObserver(partialObserver);
          return _this;
        }
        return SafeSubscriber2;
      })(Subscriber);
      EMPTY_OBSERVER = {
        closed: true,
        next: noop,
        error: defaultErrorHandler,
        complete: noop
      };
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/lift.js
  function hasLift(source) {
    return isFunction(source === null || source === void 0 ? void 0 : source.lift);
  }
  function operate(init) {
    return function(source) {
      if (hasLift(source)) {
        return source.lift(function(liftedSource) {
          try {
            return init(liftedSource, this);
          } catch (err2) {
            this.error(err2);
          }
        });
      }
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }
  var init_lift = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/lift.js"() {
      init_isFunction();
    }
  });

  // node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
  function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
  }
  var OperatorSubscriber;
  var init_OperatorSubscriber = __esm({
    "node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js"() {
      init_tslib_es6();
      init_Subscriber();
      OperatorSubscriber = (function(_super) {
        __extends(OperatorSubscriber2, _super);
        function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
          var _this = _super.call(this, destination) || this;
          _this.onFinalize = onFinalize;
          _this.shouldUnsubscribe = shouldUnsubscribe;
          _this._next = onNext ? function(value) {
            try {
              onNext(value);
            } catch (err2) {
              destination.error(err2);
            }
          } : _super.prototype._next;
          _this._error = onError ? function(err2) {
            try {
              onError(err2);
            } catch (err3) {
              destination.error(err3);
            } finally {
              this.unsubscribe();
            }
          } : _super.prototype._error;
          _this._complete = onComplete ? function() {
            try {
              onComplete();
            } catch (err2) {
              destination.error(err2);
            } finally {
              this.unsubscribe();
            }
          } : _super.prototype._complete;
          return _this;
        }
        OperatorSubscriber2.prototype.unsubscribe = function() {
          var _a;
          if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
            var closed_1 = this.closed;
            _super.prototype.unsubscribe.call(this);
            !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
          }
        };
        return OperatorSubscriber2;
      })(Subscriber);
    }
  });

  // node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
  var EmptyError;
  var init_EmptyError = __esm({
    "node_modules/rxjs/dist/esm5/internal/util/EmptyError.js"() {
      init_createErrorClass();
      EmptyError = createErrorClass(function(_super) {
        return function EmptyErrorImpl() {
          _super(this);
          this.name = "EmptyError";
          this.message = "no elements in sequence";
        };
      });
    }
  });

  // node_modules/rxjs/dist/esm5/internal/firstValueFrom.js
  function firstValueFrom(source, config2) {
    var hasConfig = typeof config2 === "object";
    return new Promise(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          resolve(value);
          subscriber.unsubscribe();
        },
        error: reject,
        complete: function() {
          if (hasConfig) {
            resolve(config2.defaultValue);
          } else {
            reject(new EmptyError());
          }
        }
      });
      source.subscribe(subscriber);
    });
  }
  var init_firstValueFrom = __esm({
    "node_modules/rxjs/dist/esm5/internal/firstValueFrom.js"() {
      init_EmptyError();
      init_Subscriber();
    }
  });

  // node_modules/rxjs/dist/esm5/internal/types.js
  var init_types = __esm({
    "node_modules/rxjs/dist/esm5/internal/types.js"() {
    }
  });

  // node_modules/rxjs/dist/esm5/internal/operators/scanInternals.js
  function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
    return function(source, subscriber) {
      var hasState = hasSeed;
      var state = seed;
      var index3 = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        var i2 = index3++;
        state = hasState ? accumulator(state, value, i2) : (hasState = true, value);
        emitOnNext && subscriber.next(state);
      }, emitBeforeComplete && (function() {
        hasState && subscriber.next(state);
        subscriber.complete();
      })));
    };
  }
  var init_scanInternals = __esm({
    "node_modules/rxjs/dist/esm5/internal/operators/scanInternals.js"() {
      init_OperatorSubscriber();
    }
  });

  // node_modules/rxjs/dist/esm5/internal/operators/reduce.js
  function reduce(accumulator, seed) {
    return operate(scanInternals(accumulator, seed, arguments.length >= 2, false, true));
  }
  var init_reduce = __esm({
    "node_modules/rxjs/dist/esm5/internal/operators/reduce.js"() {
      init_scanInternals();
      init_lift();
    }
  });

  // node_modules/rxjs/dist/esm5/internal/operators/toArray.js
  function toArray() {
    return operate(function(source, subscriber) {
      reduce(arrReducer, [])(source).subscribe(subscriber);
    });
  }
  var arrReducer;
  var init_toArray = __esm({
    "node_modules/rxjs/dist/esm5/internal/operators/toArray.js"() {
      init_reduce();
      init_lift();
      arrReducer = function(arr, value) {
        return arr.push(value), arr;
      };
    }
  });

  // node_modules/rxjs/dist/esm5/index.js
  var init_esm5 = __esm({
    "node_modules/rxjs/dist/esm5/index.js"() {
      init_firstValueFrom();
      init_types();
      init_toArray();
    }
  });

  // src/BgzipFastaMsaAdapter/BgzipFastaMsaAdapter.ts
  var BgzipFastaMsaAdapter_exports = {};
  __export(BgzipFastaMsaAdapter_exports, {
    default: () => BgzipFastaMsaAdapter
  });
  var import_configuration2, import_BaseAdapter, BgzipFastaMsaAdapter;
  var init_BgzipFastaMsaAdapter = __esm({
    "src/BgzipFastaMsaAdapter/BgzipFastaMsaAdapter.ts"() {
      "use strict";
      import_configuration2 = __toESM(require_configuration());
      import_BaseAdapter = __toESM(require_BaseAdapter());
      init_esm5();
      BgzipFastaMsaAdapter = class extends import_BaseAdapter.BaseAdapter {
        async configurePre() {
          const getSubAdapter = this.getSubAdapter;
          if (getSubAdapter) {
            const adapter = await getSubAdapter({
              ...(0, import_configuration2.readConfObject)(this.config),
              type: "BgzipFastaAdapter"
            });
            return adapter.dataAdapter;
          } else {
            throw new Error("no get subadapter");
          }
        }
        configure() {
          this.configureP ??= this.configurePre().catch((e2) => {
            this.configureP = void 0;
            throw e2;
          });
          return this.configureP;
        }
        async getMSARefs() {
          this.refNamesP ??= this.configure().then((adapter) => adapter.getRefNames()).catch((e2) => {
            this.refNamesP = void 0;
            throw e2;
          });
          return this.refNamesP;
        }
        async getMSAList() {
          const refNames = await this.getMSARefs();
          const list = /* @__PURE__ */ new Set();
          const val = this.getConf("msaRegex");
          const re = new RegExp(val);
          for (let i2 = 0, l2 = refNames.length; i2 < l2; i2++) {
            list.add(refNames[i2].split(re)[0]);
          }
          return [...list];
        }
        async getMSA(id) {
          const adapter = await this.configure();
          const refNames = await adapter.getRefNames();
          const rows = [];
          for (let i2 = 0, l2 = refNames.length; i2 < l2; i2++) {
            const refName = refNames[i2];
            if (refName.startsWith(id)) {
              rows.push(refName);
            }
          }
          return firstValueFrom(
            adapter.getFeaturesInMultipleRegions(
              rows.map((refName) => ({
                refName,
                start: 0,
                end: 1e9,
                assemblyName: ""
              }))
            ).pipe(toArray())
          );
        }
      };
    }
  });

  // global-externals:@jbrowse/core/ui
  var require_ui = __commonJS({
    "global-externals:@jbrowse/core/ui"(exports, module) {
      module.exports = JBrowseExports["@jbrowse/core/ui"];
    }
  });

  // global-externals:@mui/material
  var require_material = __commonJS({
    "global-externals:@mui/material"(exports, module) {
      module.exports = JBrowseExports["@mui/material"];
    }
  });

  // node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
  var require_use_sync_external_store_shim_development = __commonJS({
    "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
      "use strict";
      (function() {
        function is(x2, y2) {
          return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
        }
        function useSyncExternalStore$2(subscribe, getSnapshot) {
          didWarnOld18Alpha || void 0 === React79.startTransition || (didWarnOld18Alpha = true, console.error(
            "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
          ));
          var value = getSnapshot();
          if (!didWarnUncachedGetSnapshot) {
            var cachedValue = getSnapshot();
            objectIs(value, cachedValue) || (console.error(
              "The result of getSnapshot should be cached to avoid an infinite loop"
            ), didWarnUncachedGetSnapshot = true);
          }
          cachedValue = useState27({
            inst: { value, getSnapshot }
          });
          var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
          useLayoutEffect5(
            function() {
              inst.value = value;
              inst.getSnapshot = getSnapshot;
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            },
            [subscribe, value, getSnapshot]
          );
          useEffect17(
            function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
              return subscribe(function() {
                checkIfSnapshotChanged(inst) && forceUpdate({ inst });
              });
            },
            [subscribe]
          );
          useDebugValue2(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          inst = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(inst, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot) {
          return getSnapshot();
        }
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
        var React79 = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is, useState27 = React79.useState, useEffect17 = React79.useEffect, useLayoutEffect5 = React79.useLayoutEffect, useDebugValue2 = React79.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
        exports.useSyncExternalStore = void 0 !== React79.useSyncExternalStore ? React79.useSyncExternalStore : shim;
        "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
      })();
    }
  });

  // node_modules/use-sync-external-store/shim/index.js
  var require_shim = __commonJS({
    "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_use_sync_external_store_shim_development();
      }
    }
  });

  // node_modules/@mui/icons-material/esm/Settings.js
  var import_jsx_runtime3, Settings_default;
  var init_Settings = __esm({
    "node_modules/@mui/icons-material/esm/Settings.js"() {
      "use client";
      init_createSvgIcon();
      import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
      Settings_default = (0, import_utils.createSvgIcon)(/* @__PURE__ */ (0, import_jsx_runtime3.jsx)("path", {
        d: "M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6"
      }), "Settings");
    }
  });

  // node_modules/@mui/icons-material/esm/OpenInNew.js
  var import_jsx_runtime4, OpenInNew_default;
  var init_OpenInNew = __esm({
    "node_modules/@mui/icons-material/esm/OpenInNew.js"() {
      "use client";
      init_createSvgIcon();
      import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
      OpenInNew_default = (0, import_utils.createSvgIcon)(/* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", {
        d: "M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3z"
      }), "OpenInNew");
    }
  });

  // src/components/ExternalLink.tsx
  function ExternalLink(props) {
    const { children, ...rest } = props;
    return /* @__PURE__ */ import_react15.default.createElement(import_material6.Link, { ...rest, target: "_blank", rel: "noreferrer" }, children, " ", /* @__PURE__ */ import_react15.default.createElement(OpenInNew_default, { fontSize: "small" }));
  }
  var import_react15, import_material6;
  var init_ExternalLink = __esm({
    "src/components/ExternalLink.tsx"() {
      "use strict";
      import_react15 = __toESM(require_react());
      init_OpenInNew();
      import_material6 = __toESM(require_material());
    }
  });

  // node_modules/@gmod/bgzf-filehandle/dist/long.js
  var require_long = __commonJS({
    "node_modules/@gmod/bgzf-filehandle/dist/long.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TWO_PWR_32_DBL = exports.TWO_PWR_16_DBL = void 0;
      exports.longFromBytesToUnsigned = longFromBytesToUnsigned;
      exports.TWO_PWR_16_DBL = 1 << 16;
      exports.TWO_PWR_32_DBL = exports.TWO_PWR_16_DBL * exports.TWO_PWR_16_DBL;
      function longFromBytesToUnsigned(source, i2 = 0) {
        const low = source[i2] | source[i2 + 1] << 8 | source[i2 + 2] << 16 | source[i2 + 3] << 24;
        const high = source[i2 + 4] | source[i2 + 5] << 8 | source[i2 + 6] << 16 | source[i2 + 7] << 24;
        return (high >>> 0) * exports.TWO_PWR_32_DBL + (low >>> 0);
      }
    }
  });

  // node_modules/@gmod/bgzf-filehandle/dist/gziIndex.js
  var require_gziIndex = __commonJS({
    "node_modules/@gmod/bgzf-filehandle/dist/gziIndex.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var long_ts_1 = require_long();
      var UNCOMPRESSED_POSITION = 1;
      function compare2(position2, entry, nextEntry) {
        const uncompressedPosition = entry[UNCOMPRESSED_POSITION];
        const nextUncompressedPosition = nextEntry ? nextEntry[UNCOMPRESSED_POSITION] : Infinity;
        if (uncompressedPosition <= position2 && nextUncompressedPosition > position2) {
          return 0;
        } else if (uncompressedPosition < position2) {
          return -1;
        } else {
          return 1;
        }
      }
      var GziIndex = class {
        constructor({ filehandle }) {
          this.filehandle = filehandle;
        }
        _getIndex() {
          if (!this.index) {
            this.index = this._readIndex().catch((e2) => {
              this.index = void 0;
              throw e2;
            });
          }
          return this.index;
        }
        async _readIndex() {
          const buf = await this.filehandle.read(8, 0);
          const numEntries = (0, long_ts_1.longFromBytesToUnsigned)(buf);
          if (!numEntries) {
            return [[0, 0]];
          }
          const entries = new Array(numEntries + 1);
          entries[0] = [0, 0];
          const bufSize = 8 * 2 * numEntries;
          if (bufSize > Number.MAX_SAFE_INTEGER) {
            throw new TypeError("integer overflow");
          }
          const b2 = await this.filehandle.read(bufSize, 8);
          for (let entryNumber = 0; entryNumber < numEntries; entryNumber += 1) {
            const compressedPos = (0, long_ts_1.longFromBytesToUnsigned)(b2, entryNumber * 16);
            const uncompressedPos = (0, long_ts_1.longFromBytesToUnsigned)(b2, entryNumber * 16 + 8);
            entries[entryNumber + 1] = [compressedPos, uncompressedPos];
          }
          return entries;
        }
        async getLastBlock() {
          const entries = await this._getIndex();
          return entries.at(-1);
        }
        async getRelevantBlocksForRead(length2, position2) {
          const endPosition = position2 + length2;
          if (length2 === 0) {
            return [];
          }
          const entries = await this._getIndex();
          const relevant = [];
          let lowerBound = 0;
          let upperBound2 = entries.length - 1;
          let searchPosition = Math.floor(entries.length / 2);
          let comparison = compare2(position2, entries[searchPosition], entries[searchPosition + 1]);
          while (comparison !== 0) {
            if (comparison > 0) {
              upperBound2 = searchPosition - 1;
            } else if (comparison < 0) {
              lowerBound = searchPosition + 1;
            }
            searchPosition = Math.ceil((upperBound2 - lowerBound) / 2) + lowerBound;
            comparison = compare2(position2, entries[searchPosition], entries[searchPosition + 1]);
          }
          relevant.push(entries[searchPosition]);
          let i2 = searchPosition + 1;
          for (; i2 < entries.length; i2 += 1) {
            relevant.push(entries[i2]);
            if (entries[i2][UNCOMPRESSED_POSITION] >= endPosition) {
              break;
            }
          }
          if (relevant[relevant.length - 1][UNCOMPRESSED_POSITION] < endPosition) {
            relevant.push([]);
          }
          return relevant;
        }
      };
      exports.default = GziIndex;
    }
  });

  // node_modules/pako-esm2/dist/zlib/constants.js
  var require_constants = __commonJS({
    "node_modules/pako-esm2/dist/zlib/constants.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Z_DEFLATED = exports.Z_UNKNOWN = exports.Z_TEXT = exports.Z_BINARY = exports.Z_DEFAULT_STRATEGY = exports.Z_FIXED = exports.Z_RLE = exports.Z_HUFFMAN_ONLY = exports.Z_FILTERED = exports.Z_DEFAULT_COMPRESSION = exports.Z_BEST_COMPRESSION = exports.Z_BEST_SPEED = exports.Z_NO_COMPRESSION = exports.Z_BUF_ERROR = exports.Z_DATA_ERROR = exports.Z_STREAM_ERROR = exports.Z_ERRNO = exports.Z_NEED_DICT = exports.Z_STREAM_END = exports.Z_OK = exports.Z_TREES = exports.Z_BLOCK = exports.Z_FINISH = exports.Z_FULL_FLUSH = exports.Z_SYNC_FLUSH = exports.Z_PARTIAL_FLUSH = exports.Z_NO_FLUSH = void 0;
      exports.Z_NO_FLUSH = 0;
      exports.Z_PARTIAL_FLUSH = 1;
      exports.Z_SYNC_FLUSH = 2;
      exports.Z_FULL_FLUSH = 3;
      exports.Z_FINISH = 4;
      exports.Z_BLOCK = 5;
      exports.Z_TREES = 6;
      exports.Z_OK = 0;
      exports.Z_STREAM_END = 1;
      exports.Z_NEED_DICT = 2;
      exports.Z_ERRNO = -1;
      exports.Z_STREAM_ERROR = -2;
      exports.Z_DATA_ERROR = -3;
      exports.Z_BUF_ERROR = -5;
      exports.Z_NO_COMPRESSION = 0;
      exports.Z_BEST_SPEED = 1;
      exports.Z_BEST_COMPRESSION = 9;
      exports.Z_DEFAULT_COMPRESSION = -1;
      exports.Z_FILTERED = 1;
      exports.Z_HUFFMAN_ONLY = 2;
      exports.Z_RLE = 3;
      exports.Z_FIXED = 4;
      exports.Z_DEFAULT_STRATEGY = 0;
      exports.Z_BINARY = 0;
      exports.Z_TEXT = 1;
      exports.Z_UNKNOWN = 2;
      exports.Z_DEFLATED = 8;
    }
  });

  // node_modules/pako-esm2/dist/utils/common.js
  var require_common = __commonJS({
    "node_modules/pako-esm2/dist/utils/common.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Buf32 = exports.Buf16 = exports.Buf8 = exports.flattenChunks = exports.arraySet = void 0;
      exports.assign = assign3;
      exports.shrinkBuf = shrinkBuf;
      exports.setTyped = setTyped;
      function _has2(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
      }
      function assign3(obj) {
        var sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
          var source = sources.shift();
          if (!source) {
            continue;
          }
          if (typeof source !== "object") {
            throw new TypeError(source + "must be non-object");
          }
          for (var p2 in source) {
            if (_has2(source, p2)) {
              obj[p2] = source[p2];
            }
          }
        }
        return obj;
      }
      function shrinkBuf(buf, size4) {
        if (buf.length === size4) {
          return buf;
        }
        if (buf.subarray) {
          return buf.subarray(0, size4);
        }
        buf.length = size4;
        return buf;
      }
      var fnTyped = {
        arraySet: function(dest, src, src_offs, len2, dest_offs) {
          if (src.subarray && dest.subarray) {
            dest.set(src.subarray(src_offs, src_offs + len2), dest_offs);
            return;
          }
          for (var i2 = 0; i2 < len2; i2++) {
            dest[dest_offs + i2] = src[src_offs + i2];
          }
        },
        // Join array of chunks to single array.
        flattenChunks: function(chunks) {
          var i2, l2, len2, pos, chunk, result;
          len2 = 0;
          for (i2 = 0, l2 = chunks.length; i2 < l2; i2++) {
            len2 += chunks[i2].length;
          }
          result = new Uint8Array(len2);
          pos = 0;
          for (i2 = 0, l2 = chunks.length; i2 < l2; i2++) {
            chunk = chunks[i2];
            result.set(chunk, pos);
            pos += chunk.length;
          }
          return result;
        },
        Buf8: function(size4) {
          return new Uint8Array(size4);
        },
        Buf16: function(size4) {
          return new Uint16Array(size4);
        },
        Buf32: function(size4) {
          return new Int32Array(size4);
        }
      };
      var fnUntyped = {
        arraySet: function(dest, src, src_offs, len2, dest_offs) {
          for (var i2 = 0; i2 < len2; i2++) {
            dest[dest_offs + i2] = src[src_offs + i2];
          }
        },
        // Join array of chunks to single array.
        flattenChunks: function(chunks) {
          return [].concat.apply([], chunks);
        },
        Buf8: function(size4) {
          return new Array(size4);
        },
        Buf16: function(size4) {
          return new Array(size4);
        },
        Buf32: function(size4) {
          return new Array(size4);
        }
      };
      var typedOK = () => {
        const supported = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
        typedOK = () => supported;
        return supported;
      };
      var arraySet = (dest, src, src_offs, len2, dest_offs) => {
        exports.arraySet = typedOK() ? fnTyped.arraySet : fnUntyped.arraySet;
        return (0, exports.arraySet)(dest, src, src_offs, len2, dest_offs);
      };
      exports.arraySet = arraySet;
      var flattenChunks2 = (chunks) => {
        exports.flattenChunks = typedOK() ? fnTyped.flattenChunks : fnUntyped.flattenChunks;
        return (0, exports.flattenChunks)(chunks);
      };
      exports.flattenChunks = flattenChunks2;
      var Buf8 = (size4) => {
        exports.Buf8 = typedOK() ? fnTyped.Buf8 : fnUntyped.Buf8;
        return (0, exports.Buf8)(size4);
      };
      exports.Buf8 = Buf8;
      var Buf16 = (size4) => {
        exports.Buf16 = typedOK() ? fnTyped.Buf16 : fnUntyped.Buf16;
        return (0, exports.Buf16)(size4);
      };
      exports.Buf16 = Buf16;
      var Buf32 = (size4) => {
        exports.Buf32 = typedOK() ? fnTyped.Buf32 : fnUntyped.Buf32;
        return (0, exports.Buf32)(size4);
      };
      exports.Buf32 = Buf32;
      function setTyped(on) {
        exports.arraySet = on ? fnTyped.arraySet : fnUntyped.arraySet;
        exports.flattenChunks = on ? fnTyped.flattenChunks : fnUntyped.flattenChunks;
        exports.Buf8 = on ? fnTyped.Buf8 : fnUntyped.Buf8;
        exports.Buf16 = on ? fnTyped.Buf16 : fnUntyped.Buf16;
        exports.Buf32 = on ? fnTyped.Buf32 : fnUntyped.Buf32;
      }
    }
  });

  // node_modules/pako-esm2/dist/utils/strings.js
  var require_strings = __commonJS({
    "node_modules/pako-esm2/dist/utils/strings.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.string2buf = string2buf2;
      exports.buf2binstring = buf2binstring2;
      exports.binstring2buf = binstring2buf;
      exports.buf2string = buf2string2;
      exports.utf8border = utf8border2;
      var common_js_1 = require_common();
      var strApplyOK = function() {
        let result = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (_) {
          result = false;
        }
        strApplyOK = () => result;
        return result;
      };
      var strApplyUintOK = function() {
        let result = true;
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (_) {
          result = false;
        }
        strApplyUintOK = () => result;
        return result;
      };
      var utf8len = function(c2) {
        var table2 = (0, common_js_1.Buf8)(256);
        for (var q = 0; q < 256; q++) {
          table2[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
        }
        table2[254] = table2[254] = 1;
        utf8len = (arg) => table2[arg];
        return table2[c2];
      };
      function string2buf2(str) {
        var buf, c2, c22, m_pos, i2, str_len = str.length, buf_len = 0;
        for (m_pos = 0; m_pos < str_len; m_pos++) {
          c2 = str.charCodeAt(m_pos);
          if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
            c22 = str.charCodeAt(m_pos + 1);
            if ((c22 & 64512) === 56320) {
              c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
              m_pos++;
            }
          }
          buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
        }
        buf = new Uint8Array(buf_len);
        for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
          c2 = str.charCodeAt(m_pos);
          if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
            c22 = str.charCodeAt(m_pos + 1);
            if ((c22 & 64512) === 56320) {
              c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
              m_pos++;
            }
          }
          if (c2 < 128) {
            buf[i2++] = c2;
          } else if (c2 < 2048) {
            buf[i2++] = 192 | c2 >>> 6;
            buf[i2++] = 128 | c2 & 63;
          } else if (c2 < 65536) {
            buf[i2++] = 224 | c2 >>> 12;
            buf[i2++] = 128 | c2 >>> 6 & 63;
            buf[i2++] = 128 | c2 & 63;
          } else {
            buf[i2++] = 240 | c2 >>> 18;
            buf[i2++] = 128 | c2 >>> 12 & 63;
            buf[i2++] = 128 | c2 >>> 6 & 63;
            buf[i2++] = 128 | c2 & 63;
          }
        }
        return buf;
      }
      function _buf2binstring(buf, len2) {
        if (len2 < 65534) {
          if (buf.subarray && strApplyUintOK() || !buf.subarray && strApplyOK()) {
            return String.fromCharCode.apply(null, (0, common_js_1.shrinkBuf)(buf, len2));
          }
        }
        var result = "";
        for (var i2 = 0; i2 < len2; i2++) {
          result += String.fromCharCode(buf[i2]);
        }
        return result;
      }
      function buf2binstring2(buf) {
        return _buf2binstring(buf, buf.length);
      }
      function binstring2buf(str) {
        var buf = new Uint8Array(str.length);
        for (var i2 = 0, len2 = buf.length; i2 < len2; i2++) {
          buf[i2] = str.charCodeAt(i2);
        }
        return buf;
      }
      function buf2string2(buf, max3) {
        var i2, out, c2, c_len;
        var len2 = max3 || buf.length;
        var utf16buf = new Array(len2 * 2);
        for (out = 0, i2 = 0; i2 < len2; ) {
          c2 = buf[i2++];
          if (c2 < 128) {
            utf16buf[out++] = c2;
            continue;
          }
          c_len = utf8len(c2);
          if (c_len > 4) {
            utf16buf[out++] = 65533;
            i2 += c_len - 1;
            continue;
          }
          c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
          while (c_len > 1 && i2 < len2) {
            c2 = c2 << 6 | buf[i2++] & 63;
            c_len--;
          }
          if (c_len > 1) {
            utf16buf[out++] = 65533;
            continue;
          }
          if (c2 < 65536) {
            utf16buf[out++] = c2;
          } else {
            c2 -= 65536;
            utf16buf[out++] = 55296 | c2 >> 10 & 1023;
            utf16buf[out++] = 56320 | c2 & 1023;
          }
        }
        return _buf2binstring(utf16buf, out);
      }
      function utf8border2(buf, max3) {
        var pos;
        max3 = max3 || buf.length;
        if (max3 > buf.length) {
          max3 = buf.length;
        }
        pos = max3 - 1;
        while (pos >= 0 && (buf[pos] & 192) === 128) {
          pos--;
        }
        if (pos < 0) {
          return max3;
        }
        if (pos === 0) {
          return max3;
        }
        return pos + utf8len(buf[pos]) > max3 ? pos : max3;
      }
    }
  });

  // node_modules/pako-esm2/dist/zlib/gzheader.js
  var require_gzheader = __commonJS({
    "node_modules/pako-esm2/dist/zlib/gzheader.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = GZheader2;
      function GZheader2() {
        this.text = 0;
        this.time = 0;
        this.xflags = 0;
        this.os = 0;
        this.extra = null;
        this.extra_len = 0;
        this.name = "";
        this.comment = "";
        this.hcrc = 0;
        this.done = false;
      }
    }
  });

  // node_modules/pako-esm2/dist/zlib/adler32.js
  var require_adler32 = __commonJS({
    "node_modules/pako-esm2/dist/zlib/adler32.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = adler322;
      function adler322(adler, buf, len2, pos) {
        var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n2 = 0;
        while (len2 !== 0) {
          n2 = len2 > 2e3 ? 2e3 : len2;
          len2 -= n2;
          do {
            s1 = s1 + buf[pos++] | 0;
            s2 = s2 + s1 | 0;
          } while (--n2);
          s1 %= 65521;
          s2 %= 65521;
        }
        return s1 | s2 << 16 | 0;
      }
    }
  });

  // node_modules/pako-esm2/dist/zlib/crc32.js
  var require_crc32 = __commonJS({
    "node_modules/pako-esm2/dist/zlib/crc32.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = crc322;
      function makeTable2() {
        var c2, table2 = [];
        for (var n2 = 0; n2 < 256; n2++) {
          c2 = n2;
          for (var k2 = 0; k2 < 8; k2++) {
            c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
          }
          table2[n2] = c2;
        }
        return table2;
      }
      var crcTable2 = function() {
        const table2 = makeTable2();
        crcTable2 = () => table2;
        return table2;
      };
      function crc322(crc, buf, len2, pos) {
        var t2 = crcTable2(), end = pos + len2;
        crc ^= -1;
        for (var i2 = pos; i2 < end; i2++) {
          crc = crc >>> 8 ^ t2[(crc ^ buf[i2]) & 255];
        }
        return crc ^ -1;
      }
    }
  });

  // node_modules/pako-esm2/dist/zlib/inffast.js
  var require_inffast = __commonJS({
    "node_modules/pako-esm2/dist/zlib/inffast.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = inflate_fast2;
      var BAD2 = 30;
      var TYPE2 = 12;
      function inflate_fast2(strm, start) {
        var state;
        var _in;
        var last;
        var _out;
        var beg;
        var end;
        var dmax;
        var wsize;
        var whave;
        var wnext;
        var s_window;
        var hold;
        var bits;
        var lcode;
        var dcode;
        var lmask;
        var dmask;
        var here;
        var op;
        var len2;
        var dist;
        var from2;
        var from_source;
        var input, output;
        state = strm.state;
        _in = strm.next_in;
        input = strm.input;
        last = _in + (strm.avail_in - 5);
        _out = strm.next_out;
        output = strm.output;
        beg = _out - (start - strm.avail_out);
        end = _out + (strm.avail_out - 257);
        dmax = state.dmax;
        wsize = state.wsize;
        whave = state.whave;
        wnext = state.wnext;
        s_window = state.window;
        hold = state.hold;
        bits = state.bits;
        lcode = state.lencode;
        dcode = state.distcode;
        lmask = (1 << state.lenbits) - 1;
        dmask = (1 << state.distbits) - 1;
        top: do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen: for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len2 = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len2 += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist: for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD2;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD2;
                        break top;
                      }
                    }
                    from2 = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from2 += wsize - op;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output[_out++] = s_window[from2++];
                        } while (--op);
                        from2 = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from2 += wsize + wnext - op;
                      op -= wnext;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output[_out++] = s_window[from2++];
                        } while (--op);
                        from2 = 0;
                        if (wnext < len2) {
                          op = wnext;
                          len2 -= op;
                          do {
                            output[_out++] = s_window[from2++];
                          } while (--op);
                          from2 = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from2 += wnext - op;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output[_out++] = s_window[from2++];
                        } while (--op);
                        from2 = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len2 > 2) {
                      output[_out++] = from_source[from2++];
                      output[_out++] = from_source[from2++];
                      output[_out++] = from_source[from2++];
                      len2 -= 3;
                    }
                    if (len2) {
                      output[_out++] = from_source[from2++];
                      if (len2 > 1) {
                        output[_out++] = from_source[from2++];
                      }
                    }
                  } else {
                    from2 = _out - dist;
                    do {
                      output[_out++] = output[from2++];
                      output[_out++] = output[from2++];
                      output[_out++] = output[from2++];
                      len2 -= 3;
                    } while (len2 > 2);
                    if (len2) {
                      output[_out++] = output[from2++];
                      if (len2 > 1) {
                        output[_out++] = output[from2++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD2;
                  break top;
                }
                break;
              }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = TYPE2;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = BAD2;
              break top;
            }
            break;
          }
        } while (_in < last && _out < end);
        len2 = bits >> 3;
        _in -= len2;
        bits -= len2 << 3;
        hold &= (1 << bits) - 1;
        strm.next_in = _in;
        strm.next_out = _out;
        strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
        strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
        state.hold = hold;
        state.bits = bits;
        return;
      }
    }
  });

  // node_modules/pako-esm2/dist/zlib/inftrees.js
  var require_inftrees = __commonJS({
    "node_modules/pako-esm2/dist/zlib/inftrees.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = inflate_table2;
      var common_js_1 = require_common();
      var MAXBITS2 = 15;
      var ENOUGH_LENS2 = 852;
      var ENOUGH_DISTS2 = 592;
      var CODES2 = 0;
      var LENS2 = 1;
      var DISTS2 = 2;
      var lbase2 = [
        /* Length codes 257..285 base */
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        15,
        17,
        19,
        23,
        27,
        31,
        35,
        43,
        51,
        59,
        67,
        83,
        99,
        115,
        131,
        163,
        195,
        227,
        258,
        0,
        0
      ];
      var lext2 = [
        /* Length codes 257..285 extra */
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        17,
        17,
        17,
        17,
        18,
        18,
        18,
        18,
        19,
        19,
        19,
        19,
        20,
        20,
        20,
        20,
        21,
        21,
        21,
        21,
        16,
        72,
        78
      ];
      var dbase2 = [
        /* Distance codes 0..29 base */
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        13,
        17,
        25,
        33,
        49,
        65,
        97,
        129,
        193,
        257,
        385,
        513,
        769,
        1025,
        1537,
        2049,
        3073,
        4097,
        6145,
        8193,
        12289,
        16385,
        24577,
        0,
        0
      ];
      var dext2 = [
        /* Distance codes 0..29 extra */
        16,
        16,
        16,
        16,
        17,
        17,
        18,
        18,
        19,
        19,
        20,
        20,
        21,
        21,
        22,
        22,
        23,
        23,
        24,
        24,
        25,
        25,
        26,
        26,
        27,
        27,
        28,
        28,
        29,
        29,
        64,
        64
      ];
      function inflate_table2(type, lens, lens_index, codes, table2, table_index, work, opts) {
        var bits = opts.bits;
        var len2 = 0;
        var sym = 0;
        var min2 = 0, max3 = 0;
        var root = 0;
        var curr = 0;
        var drop = 0;
        var left = 0;
        var used = 0;
        var huff = 0;
        var incr;
        var fill;
        var low;
        var mask;
        var next2;
        var base4 = null;
        var base_index = 0;
        var end;
        var count3 = (0, common_js_1.Buf16)(MAXBITS2 + 1);
        var offs = (0, common_js_1.Buf16)(MAXBITS2 + 1);
        var extra = null;
        var extra_index = 0;
        var here_bits, here_op, here_val;
        for (len2 = 0; len2 <= MAXBITS2; len2++) {
          count3[len2] = 0;
        }
        for (sym = 0; sym < codes; sym++) {
          count3[lens[lens_index + sym]]++;
        }
        root = bits;
        for (max3 = MAXBITS2; max3 >= 1; max3--) {
          if (count3[max3] !== 0) {
            break;
          }
        }
        if (root > max3) {
          root = max3;
        }
        if (max3 === 0) {
          table2[table_index++] = 1 << 24 | 64 << 16 | 0;
          table2[table_index++] = 1 << 24 | 64 << 16 | 0;
          opts.bits = 1;
          return 0;
        }
        for (min2 = 1; min2 < max3; min2++) {
          if (count3[min2] !== 0) {
            break;
          }
        }
        if (root < min2) {
          root = min2;
        }
        left = 1;
        for (len2 = 1; len2 <= MAXBITS2; len2++) {
          left <<= 1;
          left -= count3[len2];
          if (left < 0) {
            return -1;
          }
        }
        if (left > 0 && (type === CODES2 || max3 !== 1)) {
          return -1;
        }
        offs[1] = 0;
        for (len2 = 1; len2 < MAXBITS2; len2++) {
          offs[len2 + 1] = offs[len2] + count3[len2];
        }
        for (sym = 0; sym < codes; sym++) {
          if (lens[lens_index + sym] !== 0) {
            work[offs[lens[lens_index + sym]]++] = sym;
          }
        }
        if (type === CODES2) {
          base4 = extra = work;
          end = 19;
        } else if (type === LENS2) {
          base4 = lbase2;
          base_index -= 257;
          extra = lext2;
          extra_index -= 257;
          end = 256;
        } else {
          base4 = dbase2;
          extra = dext2;
          end = -1;
        }
        huff = 0;
        sym = 0;
        len2 = min2;
        next2 = table_index;
        curr = root;
        drop = 0;
        low = -1;
        used = 1 << root;
        mask = used - 1;
        if (type === LENS2 && used > ENOUGH_LENS2 || type === DISTS2 && used > ENOUGH_DISTS2) {
          return 1;
        }
        for (; ; ) {
          here_bits = len2 - drop;
          if (work[sym] < end) {
            here_op = 0;
            here_val = work[sym];
          } else if (work[sym] > end) {
            here_op = extra[extra_index + work[sym]];
            here_val = base4[base_index + work[sym]];
          } else {
            here_op = 32 + 64;
            here_val = 0;
          }
          incr = 1 << len2 - drop;
          fill = 1 << curr;
          min2 = fill;
          do {
            fill -= incr;
            table2[next2 + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
          } while (fill !== 0);
          incr = 1 << len2 - 1;
          while (huff & incr) {
            incr >>= 1;
          }
          if (incr !== 0) {
            huff &= incr - 1;
            huff += incr;
          } else {
            huff = 0;
          }
          sym++;
          if (--count3[len2] === 0) {
            if (len2 === max3) {
              break;
            }
            len2 = lens[lens_index + work[sym]];
          }
          if (len2 > root && (huff & mask) !== low) {
            if (drop === 0) {
              drop = root;
            }
            next2 += min2;
            curr = len2 - drop;
            left = 1 << curr;
            while (curr + drop < max3) {
              left -= count3[curr + drop];
              if (left <= 0) {
                break;
              }
              curr++;
              left <<= 1;
            }
            used += 1 << curr;
            if (type === LENS2 && used > ENOUGH_LENS2 || type === DISTS2 && used > ENOUGH_DISTS2) {
              return 1;
            }
            low = huff & mask;
            table2[low] = root << 24 | curr << 16 | next2 - table_index | 0;
          }
        }
        if (huff !== 0) {
          table2[next2 + huff] = len2 - drop << 24 | 64 << 16 | 0;
        }
        opts.bits = root;
        return 0;
      }
    }
  });

  // node_modules/pako-esm2/dist/zlib/inflate.js
  var require_inflate = __commonJS({
    "node_modules/pako-esm2/dist/zlib/inflate.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.inflateInfo = void 0;
      exports.inflateResetKeep = inflateResetKeep2;
      exports.inflateReset = inflateReset3;
      exports.inflateReset2 = inflateReset22;
      exports.inflateInit2 = inflateInit22;
      exports.inflateInit = inflateInit3;
      exports.inflate = inflate2;
      exports.inflateEnd = inflateEnd2;
      exports.inflateGetHeader = inflateGetHeader2;
      exports.inflateSetDictionary = inflateSetDictionary2;
      var adler32_js_1 = __importDefault(require_adler32());
      var crc32_js_1 = __importDefault(require_crc32());
      var inffast_js_1 = __importDefault(require_inffast());
      var inftrees_js_1 = __importDefault(require_inftrees());
      var common_js_1 = require_common();
      var CODES2 = 0;
      var LENS2 = 1;
      var DISTS2 = 2;
      var Z_FINISH2 = 4;
      var Z_BLOCK2 = 5;
      var Z_TREES2 = 6;
      var Z_OK2 = 0;
      var Z_STREAM_END2 = 1;
      var Z_NEED_DICT2 = 2;
      var Z_STREAM_ERROR2 = -2;
      var Z_DATA_ERROR2 = -3;
      var Z_MEM_ERROR2 = -4;
      var Z_BUF_ERROR2 = -5;
      var Z_DEFLATED2 = 8;
      var HEAD2 = 1;
      var FLAGS2 = 2;
      var TIME2 = 3;
      var OS2 = 4;
      var EXLEN2 = 5;
      var EXTRA2 = 6;
      var NAME2 = 7;
      var COMMENT3 = 8;
      var HCRC2 = 9;
      var DICTID2 = 10;
      var DICT2 = 11;
      var TYPE2 = 12;
      var TYPEDO2 = 13;
      var STORED2 = 14;
      var COPY_2 = 15;
      var COPY2 = 16;
      var TABLE2 = 17;
      var LENLENS2 = 18;
      var CODELENS2 = 19;
      var LEN_2 = 20;
      var LEN2 = 21;
      var LENEXT2 = 22;
      var DIST2 = 23;
      var DISTEXT2 = 24;
      var MATCH2 = 25;
      var LIT2 = 26;
      var CHECK2 = 27;
      var LENGTH2 = 28;
      var DONE2 = 29;
      var BAD2 = 30;
      var MEM2 = 31;
      var SYNC2 = 32;
      var ENOUGH_LENS2 = 852;
      var ENOUGH_DISTS2 = 592;
      var MAX_WBITS2 = 15;
      var DEF_WBITS2 = MAX_WBITS2;
      function zswap322(q) {
        return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
      }
      function InflateState2() {
        this.mode = 0;
        this.last = false;
        this.wrap = 0;
        this.havedict = false;
        this.flags = 0;
        this.dmax = 0;
        this.check = 0;
        this.total = 0;
        this.head = null;
        this.wbits = 0;
        this.wsize = 0;
        this.whave = 0;
        this.wnext = 0;
        this.window = null;
        this.hold = 0;
        this.bits = 0;
        this.length = 0;
        this.offset = 0;
        this.extra = 0;
        this.lencode = null;
        this.distcode = null;
        this.lenbits = 0;
        this.distbits = 0;
        this.ncode = 0;
        this.nlen = 0;
        this.ndist = 0;
        this.have = 0;
        this.next = null;
        this.lens = (0, common_js_1.Buf16)(320);
        this.work = (0, common_js_1.Buf16)(288);
        this.lendyn = null;
        this.distdyn = null;
        this.sane = 0;
        this.back = 0;
        this.was = 0;
      }
      function inflateResetKeep2(strm) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR2;
        }
        state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = "";
        if (state.wrap) {
          strm.adler = state.wrap & 1;
        }
        state.mode = HEAD2;
        state.last = 0;
        state.havedict = 0;
        state.dmax = 32768;
        state.head = null;
        state.hold = 0;
        state.bits = 0;
        state.lencode = state.lendyn = (0, common_js_1.Buf32)(ENOUGH_LENS2);
        state.distcode = state.distdyn = (0, common_js_1.Buf32)(ENOUGH_DISTS2);
        state.sane = 1;
        state.back = -1;
        return Z_OK2;
      }
      function inflateReset3(strm) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR2;
        }
        state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep2(strm);
      }
      function inflateReset22(strm, windowBits) {
        var wrap;
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR2;
        }
        state = strm.state;
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else {
          wrap = (windowBits >> 4) + 1;
          if (windowBits < 48) {
            windowBits &= 15;
          }
        }
        if (windowBits && (windowBits < 8 || windowBits > 15)) {
          return Z_STREAM_ERROR2;
        }
        if (state.window !== null && state.wbits !== windowBits) {
          state.window = null;
        }
        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset3(strm);
      }
      function inflateInit22(strm, windowBits) {
        var ret;
        var state;
        if (!strm) {
          return Z_STREAM_ERROR2;
        }
        state = new InflateState2();
        strm.state = state;
        state.window = null;
        ret = inflateReset22(strm, windowBits);
        if (ret !== Z_OK2) {
          strm.state = null;
        }
        return ret;
      }
      function inflateInit3(strm) {
        return inflateInit22(strm, DEF_WBITS2);
      }
      var virgin2 = true;
      var lenfix2;
      var distfix2;
      function fixedtables2(state) {
        if (virgin2) {
          var sym;
          lenfix2 = (0, common_js_1.Buf32)(512);
          distfix2 = (0, common_js_1.Buf32)(32);
          sym = 0;
          while (sym < 144) {
            state.lens[sym++] = 8;
          }
          while (sym < 256) {
            state.lens[sym++] = 9;
          }
          while (sym < 280) {
            state.lens[sym++] = 7;
          }
          while (sym < 288) {
            state.lens[sym++] = 8;
          }
          (0, inftrees_js_1.default)(LENS2, state.lens, 0, 288, lenfix2, 0, state.work, { bits: 9 });
          sym = 0;
          while (sym < 32) {
            state.lens[sym++] = 5;
          }
          (0, inftrees_js_1.default)(DISTS2, state.lens, 0, 32, distfix2, 0, state.work, {
            bits: 5
          });
          virgin2 = false;
        }
        state.lencode = lenfix2;
        state.lenbits = 9;
        state.distcode = distfix2;
        state.distbits = 5;
      }
      function updatewindow2(strm, src, end, copy4) {
        var dist;
        var state = strm.state;
        if (state.window === null) {
          state.wsize = 1 << state.wbits;
          state.wnext = 0;
          state.whave = 0;
          state.window = (0, common_js_1.Buf8)(state.wsize);
        }
        if (copy4 >= state.wsize) {
          (0, common_js_1.arraySet)(state.window, src, end - state.wsize, state.wsize, 0);
          state.wnext = 0;
          state.whave = state.wsize;
        } else {
          dist = state.wsize - state.wnext;
          if (dist > copy4) {
            dist = copy4;
          }
          (0, common_js_1.arraySet)(state.window, src, end - copy4, dist, state.wnext);
          copy4 -= dist;
          if (copy4) {
            (0, common_js_1.arraySet)(state.window, src, end - copy4, copy4, 0);
            state.wnext = copy4;
            state.whave = state.wsize;
          } else {
            state.wnext += dist;
            if (state.wnext === state.wsize) {
              state.wnext = 0;
            }
            if (state.whave < state.wsize) {
              state.whave += dist;
            }
          }
        }
        return 0;
      }
      function inflate2(strm, flush) {
        var state;
        var input, output;
        var next2;
        var put;
        var have, left;
        var hold;
        var bits;
        var _in, _out;
        var copy4;
        var from2;
        var from_source;
        var here = 0;
        var here_bits, here_op, here_val;
        var last_bits, last_op, last_val;
        var len2;
        var ret;
        var hbuf = (0, common_js_1.Buf8)(4);
        var opts;
        var n2;
        var order = (
          /* permutation of code lengths */
          [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
        );
        if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
          return Z_STREAM_ERROR2;
        }
        state = strm.state;
        if (state.mode === TYPE2) {
          state.mode = TYPEDO2;
        }
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next2 = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        _in = have;
        _out = left;
        ret = Z_OK2;
        inf_leave: for (; ; ) {
          switch (state.mode) {
            case HEAD2:
              if (state.wrap === 0) {
                state.mode = TYPEDO2;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = (0, crc32_js_1.default)(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS2;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD2;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED2) {
                strm.msg = "unknown compression method";
                state.mode = BAD2;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len2 = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len2;
              } else if (len2 > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD2;
                break;
              }
              state.dmax = 1 << len2;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID2 : TYPE2;
              hold = 0;
              bits = 0;
              break;
            case FLAGS2:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED2) {
                strm.msg = "unknown compression method";
                state.mode = BAD2;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD2;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = (0, crc32_js_1.default)(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME2;
            /* falls through */
            case TIME2:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = (0, crc32_js_1.default)(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS2;
            /* falls through */
            case OS2:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = (0, crc32_js_1.default)(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN2;
            /* falls through */
            case EXLEN2:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = (0, crc32_js_1.default)(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA2;
            /* falls through */
            case EXTRA2:
              if (state.flags & 1024) {
                copy4 = state.length;
                if (copy4 > have) {
                  copy4 = have;
                }
                if (copy4) {
                  if (state.head) {
                    len2 = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    (0, common_js_1.arraySet)(
                      state.head.extra,
                      input,
                      next2,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy4,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len2
                    );
                  }
                  if (state.flags & 512) {
                    state.check = (0, crc32_js_1.default)(state.check, input, copy4, next2);
                  }
                  have -= copy4;
                  next2 += copy4;
                  state.length -= copy4;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME2;
            /* falls through */
            case NAME2:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy4 = 0;
                do {
                  len2 = input[next2 + copy4++];
                  if (state.head && len2 && state.length < 65536) {
                    state.head.name += String.fromCharCode(len2);
                  }
                } while (len2 && copy4 < have);
                if (state.flags & 512) {
                  state.check = (0, crc32_js_1.default)(state.check, input, copy4, next2);
                }
                have -= copy4;
                next2 += copy4;
                if (len2) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT3;
            /* falls through */
            case COMMENT3:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy4 = 0;
                do {
                  len2 = input[next2 + copy4++];
                  if (state.head && len2 && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len2);
                  }
                } while (len2 && copy4 < have);
                if (state.flags & 512) {
                  state.check = (0, crc32_js_1.default)(state.check, input, copy4, next2);
                }
                have -= copy4;
                next2 += copy4;
                if (len2) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC2;
            /* falls through */
            case HCRC2:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD2;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE2;
              break;
            case DICTID2:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap322(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT2;
            /* falls through */
            case DICT2:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next2;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT2;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE2;
            /* falls through */
            case TYPE2:
              if (flush === Z_BLOCK2 || flush === Z_TREES2) {
                break inf_leave;
              }
            /* falls through */
            case TYPEDO2:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK2;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED2;
                  break;
                case 1:
                  fixedtables2(state);
                  state.mode = LEN_2;
                  if (flush === Z_TREES2) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE2;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD2;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED2:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD2;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_2;
              if (flush === Z_TREES2) {
                break inf_leave;
              }
            /* falls through */
            case COPY_2:
              state.mode = COPY2;
            /* falls through */
            case COPY2:
              copy4 = state.length;
              if (copy4) {
                if (copy4 > have) {
                  copy4 = have;
                }
                if (copy4 > left) {
                  copy4 = left;
                }
                if (copy4 === 0) {
                  break inf_leave;
                }
                (0, common_js_1.arraySet)(output, input, next2, copy4, put);
                have -= copy4;
                next2 += copy4;
                left -= copy4;
                put += copy4;
                state.length -= copy4;
                break;
              }
              state.mode = TYPE2;
              break;
            case TABLE2:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD2;
                break;
              }
              state.have = 0;
              state.mode = LENLENS2;
            /* falls through */
            case LENLENS2:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = (0, inftrees_js_1.default)(CODES2, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD2;
                break;
              }
              state.have = 0;
              state.mode = CODELENS2;
            /* falls through */
            case CODELENS2:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n2 = here_bits + 2;
                    while (bits < n2) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD2;
                      break;
                    }
                    len2 = state.lens[state.have - 1];
                    copy4 = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n2 = here_bits + 3;
                    while (bits < n2) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len2 = 0;
                    copy4 = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n2 = here_bits + 7;
                    while (bits < n2) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next2++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len2 = 0;
                    copy4 = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy4 > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD2;
                    break;
                  }
                  while (copy4--) {
                    state.lens[state.have++] = len2;
                  }
                }
              }
              if (state.mode === BAD2) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD2;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = (0, inftrees_js_1.default)(LENS2, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD2;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = (0, inftrees_js_1.default)(DISTS2, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD2;
                break;
              }
              state.mode = LEN_2;
              if (flush === Z_TREES2) {
                break inf_leave;
              }
            /* falls through */
            case LEN_2:
              state.mode = LEN2;
            /* falls through */
            case LEN2:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next2;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                (0, inffast_js_1.default)(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next2 = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE2) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT2;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE2;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD2;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT2;
            /* falls through */
            case LENEXT2:
              if (state.extra) {
                n2 = state.extra;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST2;
            /* falls through */
            case DIST2:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD2;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT2;
            /* falls through */
            case DISTEXT2:
              if (state.extra) {
                n2 = state.extra;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD2;
                break;
              }
              state.mode = MATCH2;
            /* falls through */
            case MATCH2:
              if (left === 0) {
                break inf_leave;
              }
              copy4 = _out - left;
              if (state.offset > copy4) {
                copy4 = state.offset - copy4;
                if (copy4 > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD2;
                    break;
                  }
                }
                if (copy4 > state.wnext) {
                  copy4 -= state.wnext;
                  from2 = state.wsize - copy4;
                } else {
                  from2 = state.wnext - copy4;
                }
                if (copy4 > state.length) {
                  copy4 = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from2 = put - state.offset;
                copy4 = state.length;
              }
              if (copy4 > left) {
                copy4 = left;
              }
              left -= copy4;
              state.length -= copy4;
              do {
                output[put++] = from_source[from2++];
              } while (--copy4);
              if (state.length === 0) {
                state.mode = LEN2;
              }
              break;
            case LIT2:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN2;
              break;
            case CHECK2:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next2++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? (0, crc32_js_1.default)(state.check, output, _out, put - _out) : (0, adler32_js_1.default)(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap322(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD2;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH2;
            /* falls through */
            case LENGTH2:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next2++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD2;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE2;
            /* falls through */
            case DONE2:
              ret = Z_STREAM_END2;
              break inf_leave;
            case BAD2:
              ret = Z_DATA_ERROR2;
              break inf_leave;
            case MEM2:
              return Z_MEM_ERROR2;
            case SYNC2:
            /* falls through */
            default:
              return Z_STREAM_ERROR2;
          }
        }
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next2;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        if (state.wsize || _out !== strm.avail_out && state.mode < BAD2 && (state.mode < CHECK2 || flush !== Z_FINISH2)) {
          if (updatewindow2(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
            state.mode = MEM2;
            return Z_MEM_ERROR2;
          }
        }
        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;
        if (state.wrap && _out) {
          strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
          state.flags ? (0, crc32_js_1.default)(state.check, output, _out, strm.next_out - _out) : (0, adler32_js_1.default)(state.check, output, _out, strm.next_out - _out);
        }
        strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE2 ? 128 : 0) + (state.mode === LEN_2 || state.mode === COPY_2 ? 256 : 0);
        if ((_in === 0 && _out === 0 || flush === Z_FINISH2) && ret === Z_OK2) {
          ret = Z_BUF_ERROR2;
        }
        return ret;
      }
      function inflateEnd2(strm) {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR2;
        }
        var state = strm.state;
        if (state.window) {
          state.window = null;
        }
        strm.state = null;
        return Z_OK2;
      }
      function inflateGetHeader2(strm, head) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR2;
        }
        state = strm.state;
        if ((state.wrap & 2) === 0) {
          return Z_STREAM_ERROR2;
        }
        state.head = head;
        head.done = false;
        return Z_OK2;
      }
      function inflateSetDictionary2(strm, dictionary) {
        var dictLength = dictionary.length;
        var state;
        var dictid;
        var ret;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR2;
        }
        state = strm.state;
        if (state.wrap !== 0 && state.mode !== DICT2) {
          return Z_STREAM_ERROR2;
        }
        if (state.mode === DICT2) {
          dictid = 1;
          dictid = (0, adler32_js_1.default)(dictid, dictionary, dictLength, 0);
          if (dictid !== state.check) {
            return Z_DATA_ERROR2;
          }
        }
        ret = updatewindow2(strm, dictionary, dictLength, dictLength);
        if (ret) {
          state.mode = MEM2;
          return Z_MEM_ERROR2;
        }
        state.havedict = 1;
        return Z_OK2;
      }
      exports.inflateInfo = "pako inflate (from Nodeca project)";
    }
  });

  // node_modules/pako-esm2/dist/zlib/messages.js
  var require_messages = __commonJS({
    "node_modules/pako-esm2/dist/zlib/messages.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = {
        2: "need dictionary",
        1: "stream end",
        0: "",
        "-1": "file error",
        "-2": "stream error",
        "-3": "data error",
        "-4": "insufficient memory",
        "-5": "buffer error",
        "-6": "incompatible version"
      };
    }
  });

  // node_modules/pako-esm2/dist/zlib/zstream.js
  var require_zstream = __commonJS({
    "node_modules/pako-esm2/dist/zlib/zstream.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = ZStream2;
      function ZStream2() {
        this.input = null;
        this.next_in = 0;
        this.avail_in = 0;
        this.total_in = 0;
        this.output = null;
        this.next_out = 0;
        this.avail_out = 0;
        this.total_out = 0;
        this.msg = "";
        this.state = null;
        this.data_type = 2;
        this.adler = 0;
      }
    }
  });

  // node_modules/pako-esm2/dist/inflate.js
  var require_inflate2 = __commonJS({
    "node_modules/pako-esm2/dist/inflate.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ungzip = exports.Inflate = void 0;
      exports.inflate = inflate2;
      exports.inflateRaw = inflateRaw2;
      var common_js_1 = require_common();
      var strings_js_1 = require_strings();
      var constants_js_1 = require_constants();
      var gzheader_js_1 = __importDefault(require_gzheader());
      var inflate_js_1 = require_inflate();
      var messages_js_1 = __importDefault(require_messages());
      var zstream_js_1 = __importDefault(require_zstream());
      var toString2 = Object.prototype.toString;
      var Inflate2 = class _Inflate {
        constructor(options) {
          if (!(this instanceof _Inflate))
            return new _Inflate(options);
          this.options = (0, common_js_1.assign)({
            chunkSize: 16384,
            windowBits: 0,
            to: ""
          }, options || {});
          var opt = this.options;
          if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
            opt.windowBits = -opt.windowBits;
            if (opt.windowBits === 0) {
              opt.windowBits = -15;
            }
          }
          if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
            opt.windowBits += 32;
          }
          if (opt.windowBits > 15 && opt.windowBits < 48) {
            if ((opt.windowBits & 15) === 0) {
              opt.windowBits |= 15;
            }
          }
          this.err = 0;
          this.msg = "";
          this.ended = false;
          this.chunks = [];
          this.strm = new zstream_js_1.default();
          this.strm.avail_out = 0;
          var status = (0, inflate_js_1.inflateInit2)(this.strm, opt.windowBits);
          if (status !== constants_js_1.Z_OK) {
            throw new Error(messages_js_1.default[status]);
          }
          this.header = new gzheader_js_1.default();
          (0, inflate_js_1.inflateGetHeader)(this.strm, this.header);
          if (opt.dictionary) {
            if (typeof opt.dictionary === "string") {
              opt.dictionary = (0, strings_js_1.string2buf)(opt.dictionary);
            } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
              opt.dictionary = new Uint8Array(opt.dictionary);
            }
            if (opt.raw) {
              status = (0, inflate_js_1.inflateSetDictionary)(this.strm, opt.dictionary);
              if (status !== constants_js_1.Z_OK) {
                throw new Error(messages_js_1.default[status]);
              }
            }
          }
        }
        /**
         * Inflate#push(data[, mode]) -> Boolean
         * - data (Uint8Array|Array|ArrayBuffer|String): input data
         * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
         *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
         *
         * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
         * new output chunks. Returns `true` on success. The last data block must have
         * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
         * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
         * can use mode Z_SYNC_FLUSH, keeping the decompression context.
         *
         * On fail call [[Inflate#onEnd]] with error code and return false.
         *
         * We strongly recommend to use `Uint8Array` on input for best speed (output
         * format is detected automatically). Also, don't skip last param and always
         * use the same type in your code (boolean or number). That will improve JS speed.
         *
         * For regular `Array`-s make sure all elements are [0..255].
         *
         * ##### Example
         *
         * ```javascript
         * push(chunk, false); // push one of data chunks
         * ...
         * push(chunk, true);  // push last chunk
         * ```
         **/
        push(data, mode) {
          var strm = this.strm;
          var chunkSize = this.options.chunkSize;
          var dictionary = this.options.dictionary;
          var status, _mode;
          var next_out_utf8, tail, utf8str;
          var dict;
          var allowBufError = false;
          if (this.ended) {
            return false;
          }
          _mode = mode === ~~mode ? mode : mode === true ? constants_js_1.Z_FINISH : constants_js_1.Z_NO_FLUSH;
          if (typeof data === "string") {
            strm.input = (0, strings_js_1.binstring2buf)(data);
          } else if (toString2.call(data) === "[object ArrayBuffer]") {
            strm.input = new Uint8Array(data);
          } else {
            strm.input = data;
          }
          strm.next_in = 0;
          strm.avail_in = strm.input.length;
          do {
            if (strm.avail_out === 0) {
              strm.output = (0, common_js_1.Buf8)(chunkSize);
              strm.next_out = 0;
              strm.avail_out = chunkSize;
            }
            status = (0, inflate_js_1.inflate)(strm, constants_js_1.Z_NO_FLUSH);
            if (status === constants_js_1.Z_NEED_DICT && dictionary) {
              if (typeof dictionary === "string") {
                dict = (0, strings_js_1.string2buf)(dictionary);
              } else if (toString2.call(dictionary) === "[object ArrayBuffer]") {
                dict = new Uint8Array(dictionary);
              } else {
                dict = dictionary;
              }
              status = (0, inflate_js_1.inflateSetDictionary)(this.strm, dict);
            }
            if (status === constants_js_1.Z_BUF_ERROR && allowBufError === true) {
              status = constants_js_1.Z_OK;
              allowBufError = false;
            }
            if (status !== constants_js_1.Z_STREAM_END && status !== constants_js_1.Z_OK) {
              this.onEnd(status);
              this.ended = true;
              return false;
            }
            if (strm.next_out) {
              if (strm.avail_out === 0 || status === constants_js_1.Z_STREAM_END || strm.avail_in === 0 && (_mode === constants_js_1.Z_FINISH || _mode === constants_js_1.Z_SYNC_FLUSH)) {
                if (this.options.to === "string") {
                  next_out_utf8 = (0, strings_js_1.utf8border)(strm.output, strm.next_out);
                  tail = strm.next_out - next_out_utf8;
                  utf8str = (0, strings_js_1.buf2string)(strm.output, next_out_utf8);
                  strm.next_out = tail;
                  strm.avail_out = chunkSize - tail;
                  if (tail) {
                    (0, common_js_1.arraySet)(strm.output, strm.output, next_out_utf8, tail, 0);
                  }
                  this.onData(utf8str);
                } else {
                  this.onData((0, common_js_1.shrinkBuf)(strm.output, strm.next_out));
                }
              }
            }
            if (strm.avail_in === 0 && strm.avail_out === 0) {
              allowBufError = true;
            }
          } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== constants_js_1.Z_STREAM_END);
          if (status === constants_js_1.Z_STREAM_END) {
            _mode = constants_js_1.Z_FINISH;
          }
          if (_mode === constants_js_1.Z_FINISH) {
            status = (0, inflate_js_1.inflateEnd)(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === constants_js_1.Z_OK;
          }
          if (_mode === constants_js_1.Z_SYNC_FLUSH) {
            this.onEnd(constants_js_1.Z_OK);
            strm.avail_out = 0;
            return true;
          }
          return true;
        }
        /**
         * Inflate#onData(chunk) -> Void
         * - chunk (Uint8Array|Array|String): output data. Type of array depends
         *   on js engine support. When string output requested, each chunk
         *   will be string.
         *
         * By default, stores data blocks in `chunks[]` property and glue
         * those in `onEnd`. Override this handler, if you need another behaviour.
         **/
        onData(chunk) {
          this.chunks.push(chunk);
        }
        /**
         * Inflate#onEnd(status) -> Void
         * - status (Number): inflate status. 0 (Z_OK) on success,
         *   other if not.
         *
         * Called either after you tell inflate that the input stream is
         * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
         * or if an error happened. By default - join collected chunks,
         * free memory and fill `results` / `err` properties.
         **/
        onEnd(status) {
          if (status === constants_js_1.Z_OK) {
            if (this.options.to === "string") {
              this.result = this.chunks.join("");
            } else {
              this.result = (0, common_js_1.flattenChunks)(this.chunks);
            }
          }
          this.chunks = [];
          this.err = status;
          this.msg = this.strm.msg;
        }
      };
      exports.Inflate = Inflate2;
      function inflate2(input, options) {
        var inflator = new Inflate2(options);
        inflator.push(input, true);
        if (inflator.err) {
          throw inflator.msg || messages_js_1.default[inflator.err];
        }
        return inflator.result;
      }
      function inflateRaw2(input, options) {
        options = options || {};
        options.raw = true;
        return inflate2(input, options);
      }
      exports.ungzip = inflate2;
    }
  });

  // node_modules/pako-esm2/dist/zlib/trees.js
  var require_trees = __commonJS({
    "node_modules/pako-esm2/dist/zlib/trees.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports._tr_init = _tr_init2;
      exports._tr_stored_block = _tr_stored_block2;
      exports._tr_align = _tr_align2;
      exports._tr_flush_block = _tr_flush_block2;
      exports._tr_tally = _tr_tally2;
      var constants_js_1 = require_constants();
      var common_js_1 = require_common();
      function zero2(buf) {
        var len2 = buf.length;
        while (--len2 >= 0) {
          buf[len2] = 0;
        }
      }
      var STORED_BLOCK2 = 0;
      var STATIC_TREES2 = 1;
      var DYN_TREES2 = 2;
      var MIN_MATCH2 = 3;
      var MAX_MATCH2 = 258;
      var LENGTH_CODES2 = 29;
      var LITERALS2 = 256;
      var L_CODES2 = LITERALS2 + 1 + LENGTH_CODES2;
      var D_CODES2 = 30;
      var BL_CODES2 = 19;
      var HEAP_SIZE2 = 2 * L_CODES2 + 1;
      var MAX_BITS2 = 15;
      var Buf_size2 = 16;
      var MAX_BL_BITS2 = 7;
      var END_BLOCK2 = 256;
      var REP_3_62 = 16;
      var REPZ_3_102 = 17;
      var REPZ_11_1382 = 18;
      var extra_lbits2 = (
        /* extra bits for each length code */
        [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          1,
          1,
          1,
          2,
          2,
          2,
          2,
          3,
          3,
          3,
          3,
          4,
          4,
          4,
          4,
          5,
          5,
          5,
          5,
          0
        ]
      );
      var extra_dbits2 = (
        /* extra bits for each distance code */
        [
          0,
          0,
          0,
          0,
          1,
          1,
          2,
          2,
          3,
          3,
          4,
          4,
          5,
          5,
          6,
          6,
          7,
          7,
          8,
          8,
          9,
          9,
          10,
          10,
          11,
          11,
          12,
          12,
          13,
          13
        ]
      );
      var extra_blbits2 = (
        /* extra bits for each bit length code */
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
      );
      var bl_order2 = [
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15
      ];
      var DIST_CODE_LEN2 = 512;
      var static_ltree2;
      var static_dtree2;
      var _dist_code2;
      var _length_code2;
      var base_length2;
      var base_dist2;
      function StaticTreeDesc2(static_tree, extra_bits, extra_base, elems, max_length) {
        this.static_tree = static_tree;
        this.extra_bits = extra_bits;
        this.extra_base = extra_base;
        this.elems = elems;
        this.max_length = max_length;
        this.has_stree = static_tree && static_tree.length;
      }
      var static_l_desc2;
      var static_d_desc2;
      var static_bl_desc2;
      function TreeDesc2(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree;
        this.max_code = 0;
        this.stat_desc = stat_desc;
      }
      function d_code2(dist) {
        return dist < 256 ? _dist_code2[dist] : _dist_code2[256 + (dist >>> 7)];
      }
      function put_short2(s2, w2) {
        s2.pending_buf[s2.pending++] = w2 & 255;
        s2.pending_buf[s2.pending++] = w2 >>> 8 & 255;
      }
      function send_bits2(s2, value, length2) {
        if (s2.bi_valid > Buf_size2 - length2) {
          s2.bi_buf |= value << s2.bi_valid & 65535;
          put_short2(s2, s2.bi_buf);
          s2.bi_buf = value >> Buf_size2 - s2.bi_valid;
          s2.bi_valid += length2 - Buf_size2;
        } else {
          s2.bi_buf |= value << s2.bi_valid & 65535;
          s2.bi_valid += length2;
        }
      }
      function send_code2(s2, c2, tree) {
        send_bits2(
          s2,
          tree[c2 * 2],
          tree[c2 * 2 + 1]
          /*.Len*/
        );
      }
      function bi_reverse2(code, len2) {
        var res = 0;
        do {
          res |= code & 1;
          code >>>= 1;
          res <<= 1;
        } while (--len2 > 0);
        return res >>> 1;
      }
      function bi_flush2(s2) {
        if (s2.bi_valid === 16) {
          put_short2(s2, s2.bi_buf);
          s2.bi_buf = 0;
          s2.bi_valid = 0;
        } else if (s2.bi_valid >= 8) {
          s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
          s2.bi_buf >>= 8;
          s2.bi_valid -= 8;
        }
      }
      function gen_bitlen2(s2, desc) {
        var tree = desc.dyn_tree;
        var max_code = desc.max_code;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var extra = desc.stat_desc.extra_bits;
        var base4 = desc.stat_desc.extra_base;
        var max_length = desc.stat_desc.max_length;
        var h2;
        var n2, m2;
        var bits;
        var xbits;
        var f2;
        var overflow = 0;
        for (bits = 0; bits <= MAX_BITS2; bits++) {
          s2.bl_count[bits] = 0;
        }
        tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
        for (h2 = s2.heap_max + 1; h2 < HEAP_SIZE2; h2++) {
          n2 = s2.heap[h2];
          bits = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
          if (bits > max_length) {
            bits = max_length;
            overflow++;
          }
          tree[n2 * 2 + 1] = bits;
          if (n2 > max_code) {
            continue;
          }
          s2.bl_count[bits]++;
          xbits = 0;
          if (n2 >= base4) {
            xbits = extra[n2 - base4];
          }
          f2 = tree[n2 * 2];
          s2.opt_len += f2 * (bits + xbits);
          if (has_stree) {
            s2.static_len += f2 * (stree[n2 * 2 + 1] + xbits);
          }
        }
        if (overflow === 0) {
          return;
        }
        do {
          bits = max_length - 1;
          while (s2.bl_count[bits] === 0) {
            bits--;
          }
          s2.bl_count[bits]--;
          s2.bl_count[bits + 1] += 2;
          s2.bl_count[max_length]--;
          overflow -= 2;
        } while (overflow > 0);
        for (bits = max_length; bits !== 0; bits--) {
          n2 = s2.bl_count[bits];
          while (n2 !== 0) {
            m2 = s2.heap[--h2];
            if (m2 > max_code) {
              continue;
            }
            if (tree[m2 * 2 + 1] !== bits) {
              s2.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2];
              tree[m2 * 2 + 1] = bits;
            }
            n2--;
          }
        }
      }
      function gen_codes2(tree, max_code, bl_count) {
        var next_code = new Array(MAX_BITS2 + 1);
        var code = 0;
        var bits;
        var n2;
        for (bits = 1; bits <= MAX_BITS2; bits++) {
          next_code[bits] = code = code + bl_count[bits - 1] << 1;
        }
        for (n2 = 0; n2 <= max_code; n2++) {
          var len2 = tree[n2 * 2 + 1];
          if (len2 === 0) {
            continue;
          }
          tree[n2 * 2] = bi_reverse2(next_code[len2]++, len2);
        }
      }
      function tr_static_init2() {
        var n2;
        var bits;
        var length2;
        var code;
        var dist;
        var bl_count = new Array(MAX_BITS2 + 1);
        static_ltree2 = new Array((L_CODES2 + 2) * 2);
        zero2(static_ltree2);
        static_dtree2 = new Array(D_CODES2 * 2);
        zero2(static_dtree2);
        _dist_code2 = new Array(DIST_CODE_LEN2);
        zero2(_dist_code2);
        _length_code2 = new Array(MAX_MATCH2 - MIN_MATCH2 + 1);
        zero2(_length_code2);
        base_length2 = new Array(LENGTH_CODES2);
        zero2(base_length2);
        base_dist2 = new Array(D_CODES2);
        zero2(base_dist2);
        length2 = 0;
        for (code = 0; code < LENGTH_CODES2 - 1; code++) {
          base_length2[code] = length2;
          for (n2 = 0; n2 < 1 << extra_lbits2[code]; n2++) {
            _length_code2[length2++] = code;
          }
        }
        _length_code2[length2 - 1] = code;
        dist = 0;
        for (code = 0; code < 16; code++) {
          base_dist2[code] = dist;
          for (n2 = 0; n2 < 1 << extra_dbits2[code]; n2++) {
            _dist_code2[dist++] = code;
          }
        }
        dist >>= 7;
        for (; code < D_CODES2; code++) {
          base_dist2[code] = dist << 7;
          for (n2 = 0; n2 < 1 << extra_dbits2[code] - 7; n2++) {
            _dist_code2[256 + dist++] = code;
          }
        }
        for (bits = 0; bits <= MAX_BITS2; bits++) {
          bl_count[bits] = 0;
        }
        n2 = 0;
        while (n2 <= 143) {
          static_ltree2[n2 * 2 + 1] = 8;
          n2++;
          bl_count[8]++;
        }
        while (n2 <= 255) {
          static_ltree2[n2 * 2 + 1] = 9;
          n2++;
          bl_count[9]++;
        }
        while (n2 <= 279) {
          static_ltree2[n2 * 2 + 1] = 7;
          n2++;
          bl_count[7]++;
        }
        while (n2 <= 287) {
          static_ltree2[n2 * 2 + 1] = 8;
          n2++;
          bl_count[8]++;
        }
        gen_codes2(static_ltree2, L_CODES2 + 1, bl_count);
        for (n2 = 0; n2 < D_CODES2; n2++) {
          static_dtree2[n2 * 2 + 1] = 5;
          static_dtree2[n2 * 2] = bi_reverse2(n2, 5);
        }
        static_l_desc2 = new StaticTreeDesc2(static_ltree2, extra_lbits2, LITERALS2 + 1, L_CODES2, MAX_BITS2);
        static_d_desc2 = new StaticTreeDesc2(static_dtree2, extra_dbits2, 0, D_CODES2, MAX_BITS2);
        static_bl_desc2 = new StaticTreeDesc2(new Array(0), extra_blbits2, 0, BL_CODES2, MAX_BL_BITS2);
      }
      function init_block2(s2) {
        var n2;
        for (n2 = 0; n2 < L_CODES2; n2++) {
          s2.dyn_ltree[n2 * 2] = 0;
        }
        for (n2 = 0; n2 < D_CODES2; n2++) {
          s2.dyn_dtree[n2 * 2] = 0;
        }
        for (n2 = 0; n2 < BL_CODES2; n2++) {
          s2.bl_tree[n2 * 2] = 0;
        }
        s2.dyn_ltree[END_BLOCK2 * 2] = 1;
        s2.opt_len = s2.static_len = 0;
        s2.last_lit = s2.matches = 0;
      }
      function bi_windup2(s2) {
        if (s2.bi_valid > 8) {
          put_short2(s2, s2.bi_buf);
        } else if (s2.bi_valid > 0) {
          s2.pending_buf[s2.pending++] = s2.bi_buf;
        }
        s2.bi_buf = 0;
        s2.bi_valid = 0;
      }
      function copy_block(s2, buf, len2, header) {
        bi_windup2(s2);
        if (header) {
          put_short2(s2, len2);
          put_short2(s2, ~len2);
        }
        (0, common_js_1.arraySet)(s2.pending_buf, s2.window, buf, len2, s2.pending);
        s2.pending += len2;
      }
      function smaller2(tree, n2, m2, depth) {
        var _n2 = n2 * 2;
        var _m2 = m2 * 2;
        return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m2];
      }
      function pqdownheap2(s2, tree, k2) {
        var v2 = s2.heap[k2];
        var j2 = k2 << 1;
        while (j2 <= s2.heap_len) {
          if (j2 < s2.heap_len && smaller2(tree, s2.heap[j2 + 1], s2.heap[j2], s2.depth)) {
            j2++;
          }
          if (smaller2(tree, v2, s2.heap[j2], s2.depth)) {
            break;
          }
          s2.heap[k2] = s2.heap[j2];
          k2 = j2;
          j2 <<= 1;
        }
        s2.heap[k2] = v2;
      }
      function compress_block2(s2, ltree, dtree) {
        var dist;
        var lc;
        var lx = 0;
        var code;
        var extra;
        if (s2.last_lit !== 0) {
          do {
            dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
            lc = s2.pending_buf[s2.l_buf + lx];
            lx++;
            if (dist === 0) {
              send_code2(s2, lc, ltree);
            } else {
              code = _length_code2[lc];
              send_code2(s2, code + LITERALS2 + 1, ltree);
              extra = extra_lbits2[code];
              if (extra !== 0) {
                lc -= base_length2[code];
                send_bits2(s2, lc, extra);
              }
              dist--;
              code = d_code2(dist);
              send_code2(s2, code, dtree);
              extra = extra_dbits2[code];
              if (extra !== 0) {
                dist -= base_dist2[code];
                send_bits2(s2, dist, extra);
              }
            }
          } while (lx < s2.last_lit);
        }
        send_code2(s2, END_BLOCK2, ltree);
      }
      function build_tree2(s2, desc) {
        var tree = desc.dyn_tree;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var elems = desc.stat_desc.elems;
        var n2, m2;
        var max_code = -1;
        var node2;
        s2.heap_len = 0;
        s2.heap_max = HEAP_SIZE2;
        for (n2 = 0; n2 < elems; n2++) {
          if (tree[n2 * 2] !== 0) {
            s2.heap[++s2.heap_len] = max_code = n2;
            s2.depth[n2] = 0;
          } else {
            tree[n2 * 2 + 1] = 0;
          }
        }
        while (s2.heap_len < 2) {
          node2 = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
          tree[node2 * 2] = 1;
          s2.depth[node2] = 0;
          s2.opt_len--;
          if (has_stree) {
            s2.static_len -= stree[node2 * 2 + 1];
          }
        }
        desc.max_code = max_code;
        for (n2 = s2.heap_len >> 1; n2 >= 1; n2--) {
          pqdownheap2(s2, tree, n2);
        }
        node2 = elems;
        do {
          n2 = s2.heap[
            1
            /*SMALLEST*/
          ];
          s2.heap[
            1
            /*SMALLEST*/
          ] = s2.heap[s2.heap_len--];
          pqdownheap2(
            s2,
            tree,
            1
            /*SMALLEST*/
          );
          m2 = s2.heap[
            1
            /*SMALLEST*/
          ];
          s2.heap[--s2.heap_max] = n2;
          s2.heap[--s2.heap_max] = m2;
          tree[node2 * 2] = tree[n2 * 2] + tree[m2 * 2];
          s2.depth[node2] = (s2.depth[n2] >= s2.depth[m2] ? s2.depth[n2] : s2.depth[m2]) + 1;
          tree[n2 * 2 + 1] = tree[m2 * 2 + 1] = node2;
          s2.heap[
            1
            /*SMALLEST*/
          ] = node2++;
          pqdownheap2(
            s2,
            tree,
            1
            /*SMALLEST*/
          );
        } while (s2.heap_len >= 2);
        s2.heap[--s2.heap_max] = s2.heap[
          1
          /*SMALLEST*/
        ];
        gen_bitlen2(s2, desc);
        gen_codes2(tree, max_code, s2.bl_count);
      }
      function scan_tree2(s2, tree, max_code) {
        var n2;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count3 = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        tree[(max_code + 1) * 2 + 1] = 65535;
        for (n2 = 0; n2 <= max_code; n2++) {
          curlen = nextlen;
          nextlen = tree[(n2 + 1) * 2 + 1];
          if (++count3 < max_count && curlen === nextlen) {
            continue;
          } else if (count3 < min_count) {
            s2.bl_tree[curlen * 2] += count3;
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              s2.bl_tree[curlen * 2]++;
            }
            s2.bl_tree[REP_3_62 * 2]++;
          } else if (count3 <= 10) {
            s2.bl_tree[REPZ_3_102 * 2]++;
          } else {
            s2.bl_tree[REPZ_11_1382 * 2]++;
          }
          count3 = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      }
      function send_tree2(s2, tree, max_code) {
        var n2;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count3 = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        for (n2 = 0; n2 <= max_code; n2++) {
          curlen = nextlen;
          nextlen = tree[(n2 + 1) * 2 + 1];
          if (++count3 < max_count && curlen === nextlen) {
            continue;
          } else if (count3 < min_count) {
            do {
              send_code2(s2, curlen, s2.bl_tree);
            } while (--count3 !== 0);
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              send_code2(s2, curlen, s2.bl_tree);
              count3--;
            }
            send_code2(s2, REP_3_62, s2.bl_tree);
            send_bits2(s2, count3 - 3, 2);
          } else if (count3 <= 10) {
            send_code2(s2, REPZ_3_102, s2.bl_tree);
            send_bits2(s2, count3 - 3, 3);
          } else {
            send_code2(s2, REPZ_11_1382, s2.bl_tree);
            send_bits2(s2, count3 - 11, 7);
          }
          count3 = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      }
      function build_bl_tree2(s2) {
        var max_blindex;
        scan_tree2(s2, s2.dyn_ltree, s2.l_desc.max_code);
        scan_tree2(s2, s2.dyn_dtree, s2.d_desc.max_code);
        build_tree2(s2, s2.bl_desc);
        for (max_blindex = BL_CODES2 - 1; max_blindex >= 3; max_blindex--) {
          if (s2.bl_tree[bl_order2[max_blindex] * 2 + 1] !== 0) {
            break;
          }
        }
        s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        return max_blindex;
      }
      function send_all_trees2(s2, lcodes, dcodes, blcodes) {
        var rank2;
        send_bits2(s2, lcodes - 257, 5);
        send_bits2(s2, dcodes - 1, 5);
        send_bits2(s2, blcodes - 4, 4);
        for (rank2 = 0; rank2 < blcodes; rank2++) {
          send_bits2(s2, s2.bl_tree[bl_order2[rank2] * 2 + 1], 3);
        }
        send_tree2(s2, s2.dyn_ltree, lcodes - 1);
        send_tree2(s2, s2.dyn_dtree, dcodes - 1);
      }
      function detect_data_type2(s2) {
        var black_mask = 4093624447;
        var n2;
        for (n2 = 0; n2 <= 31; n2++, black_mask >>>= 1) {
          if (black_mask & 1 && s2.dyn_ltree[n2 * 2] !== 0) {
            return constants_js_1.Z_BINARY;
          }
        }
        if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
          return constants_js_1.Z_TEXT;
        }
        for (n2 = 32; n2 < LITERALS2; n2++) {
          if (s2.dyn_ltree[n2 * 2] !== 0) {
            return constants_js_1.Z_TEXT;
          }
        }
        return constants_js_1.Z_BINARY;
      }
      var static_init_done2 = false;
      function _tr_init2(s2) {
        if (!static_init_done2) {
          tr_static_init2();
          static_init_done2 = true;
        }
        s2.l_desc = new TreeDesc2(s2.dyn_ltree, static_l_desc2);
        s2.d_desc = new TreeDesc2(s2.dyn_dtree, static_d_desc2);
        s2.bl_desc = new TreeDesc2(s2.bl_tree, static_bl_desc2);
        s2.bi_buf = 0;
        s2.bi_valid = 0;
        init_block2(s2);
      }
      function _tr_stored_block2(s2, buf, stored_len, last) {
        send_bits2(s2, (STORED_BLOCK2 << 1) + (last ? 1 : 0), 3);
        copy_block(s2, buf, stored_len, true);
      }
      function _tr_align2(s2) {
        send_bits2(s2, STATIC_TREES2 << 1, 3);
        send_code2(s2, END_BLOCK2, static_ltree2);
        bi_flush2(s2);
      }
      function _tr_flush_block2(s2, buf, stored_len, last) {
        var opt_lenb, static_lenb;
        var max_blindex = 0;
        if (s2.level > 0) {
          if (s2.strm.data_type === constants_js_1.Z_UNKNOWN) {
            s2.strm.data_type = detect_data_type2(s2);
          }
          build_tree2(s2, s2.l_desc);
          build_tree2(s2, s2.d_desc);
          max_blindex = build_bl_tree2(s2);
          opt_lenb = s2.opt_len + 3 + 7 >>> 3;
          static_lenb = s2.static_len + 3 + 7 >>> 3;
          if (static_lenb <= opt_lenb) {
            opt_lenb = static_lenb;
          }
        } else {
          opt_lenb = static_lenb = stored_len + 5;
        }
        if (stored_len + 4 <= opt_lenb && buf !== -1) {
          _tr_stored_block2(s2, buf, stored_len, last);
        } else if (s2.strategy === constants_js_1.Z_FIXED || static_lenb === opt_lenb) {
          send_bits2(s2, (STATIC_TREES2 << 1) + (last ? 1 : 0), 3);
          compress_block2(s2, static_ltree2, static_dtree2);
        } else {
          send_bits2(s2, (DYN_TREES2 << 1) + (last ? 1 : 0), 3);
          send_all_trees2(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
          compress_block2(s2, s2.dyn_ltree, s2.dyn_dtree);
        }
        init_block2(s2);
        if (last) {
          bi_windup2(s2);
        }
      }
      function _tr_tally2(s2, dist, lc) {
        s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
        s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
        s2.pending_buf[s2.l_buf + s2.last_lit] = lc & 255;
        s2.last_lit++;
        if (dist === 0) {
          s2.dyn_ltree[lc * 2]++;
        } else {
          s2.matches++;
          dist--;
          s2.dyn_ltree[(_length_code2[lc] + LITERALS2 + 1) * 2]++;
          s2.dyn_dtree[d_code2(dist) * 2]++;
        }
        return s2.last_lit === s2.lit_bufsize - 1;
      }
    }
  });

  // node_modules/pako-esm2/dist/zlib/deflate.js
  var require_deflate = __commonJS({
    "node_modules/pako-esm2/dist/zlib/deflate.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.deflateInfo = void 0;
      exports.deflateResetKeep = deflateResetKeep2;
      exports.deflateReset = deflateReset2;
      exports.deflateSetHeader = deflateSetHeader2;
      exports.deflateInit2 = deflateInit22;
      exports.deflateInit = deflateInit3;
      exports.deflate = deflate2;
      exports.deflateEnd = deflateEnd2;
      exports.deflateSetDictionary = deflateSetDictionary2;
      var adler32_js_1 = __importDefault(require_adler32());
      var constants_js_1 = require_constants();
      var crc32_js_1 = __importDefault(require_crc32());
      var messages_js_1 = __importDefault(require_messages());
      var trees_js_1 = require_trees();
      var common_js_1 = require_common();
      var MAX_MEM_LEVEL2 = 9;
      var MAX_WBITS2 = 15;
      var DEF_MEM_LEVEL2 = 8;
      var LENGTH_CODES2 = 29;
      var LITERALS2 = 256;
      var L_CODES2 = LITERALS2 + 1 + LENGTH_CODES2;
      var D_CODES2 = 30;
      var BL_CODES2 = 19;
      var HEAP_SIZE2 = 2 * L_CODES2 + 1;
      var MAX_BITS2 = 15;
      var MIN_MATCH2 = 3;
      var MAX_MATCH2 = 258;
      var MIN_LOOKAHEAD2 = MAX_MATCH2 + MIN_MATCH2 + 1;
      var PRESET_DICT2 = 32;
      var INIT_STATE2 = 42;
      var EXTRA_STATE2 = 69;
      var NAME_STATE2 = 73;
      var COMMENT_STATE2 = 91;
      var HCRC_STATE2 = 103;
      var BUSY_STATE2 = 113;
      var FINISH_STATE2 = 666;
      var BS_NEED_MORE2 = 1;
      var BS_BLOCK_DONE2 = 2;
      var BS_FINISH_STARTED2 = 3;
      var BS_FINISH_DONE2 = 4;
      var OS_CODE2 = 3;
      function err2(strm, errorCode) {
        strm.msg = messages_js_1.default[errorCode];
        return errorCode;
      }
      function rank2(f2) {
        return (f2 << 1) - (f2 > 4 ? 9 : 0);
      }
      function zero2(buf) {
        var len2 = buf.length;
        while (--len2 >= 0) {
          buf[len2] = 0;
        }
      }
      function flush_pending2(strm) {
        var s2 = strm.state;
        var len2 = s2.pending;
        if (len2 > strm.avail_out) {
          len2 = strm.avail_out;
        }
        if (len2 === 0) {
          return;
        }
        (0, common_js_1.arraySet)(strm.output, s2.pending_buf, s2.pending_out, len2, strm.next_out);
        strm.next_out += len2;
        s2.pending_out += len2;
        strm.total_out += len2;
        strm.avail_out -= len2;
        s2.pending -= len2;
        if (s2.pending === 0) {
          s2.pending_out = 0;
        }
      }
      function flush_block_only2(s2, last) {
        (0, trees_js_1._tr_flush_block)(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last);
        s2.block_start = s2.strstart;
        flush_pending2(s2.strm);
      }
      function put_byte2(s2, b2) {
        s2.pending_buf[s2.pending++] = b2;
      }
      function putShortMSB2(s2, b2) {
        s2.pending_buf[s2.pending++] = b2 >>> 8 & 255;
        s2.pending_buf[s2.pending++] = b2 & 255;
      }
      function read_buf2(strm, buf, start, size4) {
        var len2 = strm.avail_in;
        if (len2 > size4) {
          len2 = size4;
        }
        if (len2 === 0) {
          return 0;
        }
        strm.avail_in -= len2;
        (0, common_js_1.arraySet)(buf, strm.input, strm.next_in, len2, start);
        if (strm.state.wrap === 1) {
          strm.adler = (0, adler32_js_1.default)(strm.adler, buf, len2, start);
        } else if (strm.state.wrap === 2) {
          strm.adler = (0, crc32_js_1.default)(strm.adler, buf, len2, start);
        }
        strm.next_in += len2;
        strm.total_in += len2;
        return len2;
      }
      function longest_match2(s2, cur_match) {
        var chain_length = s2.max_chain_length;
        var scan = s2.strstart;
        var match2;
        var len2;
        var best_len = s2.prev_length;
        var nice_match = s2.nice_match;
        var limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD2 ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD2) : 0;
        var _win = s2.window;
        var wmask = s2.w_mask;
        var prev2 = s2.prev;
        var strend = s2.strstart + MAX_MATCH2;
        var scan_end1 = _win[scan + best_len - 1];
        var scan_end = _win[scan + best_len];
        if (s2.prev_length >= s2.good_match) {
          chain_length >>= 2;
        }
        if (nice_match > s2.lookahead) {
          nice_match = s2.lookahead;
        }
        do {
          match2 = cur_match;
          if (_win[match2 + best_len] !== scan_end || _win[match2 + best_len - 1] !== scan_end1 || _win[match2] !== _win[scan] || _win[++match2] !== _win[scan + 1]) {
            continue;
          }
          scan += 2;
          match2++;
          do {
          } while (_win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && scan < strend);
          len2 = MAX_MATCH2 - (strend - scan);
          scan = strend - MAX_MATCH2;
          if (len2 > best_len) {
            s2.match_start = cur_match;
            best_len = len2;
            if (len2 >= nice_match) {
              break;
            }
            scan_end1 = _win[scan + best_len - 1];
            scan_end = _win[scan + best_len];
          }
        } while ((cur_match = prev2[cur_match & wmask]) > limit && --chain_length !== 0);
        if (best_len <= s2.lookahead) {
          return best_len;
        }
        return s2.lookahead;
      }
      function fill_window2(s2) {
        var _w_size = s2.w_size;
        var p2, n2, m2, more, str;
        do {
          more = s2.window_size - s2.lookahead - s2.strstart;
          if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD2)) {
            (0, common_js_1.arraySet)(s2.window, s2.window, _w_size, _w_size, 0);
            s2.match_start -= _w_size;
            s2.strstart -= _w_size;
            s2.block_start -= _w_size;
            n2 = s2.hash_size;
            p2 = n2;
            do {
              m2 = s2.head[--p2];
              s2.head[p2] = m2 >= _w_size ? m2 - _w_size : 0;
            } while (--n2);
            n2 = _w_size;
            p2 = n2;
            do {
              m2 = s2.prev[--p2];
              s2.prev[p2] = m2 >= _w_size ? m2 - _w_size : 0;
            } while (--n2);
            more += _w_size;
          }
          if (s2.strm.avail_in === 0) {
            break;
          }
          n2 = read_buf2(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
          s2.lookahead += n2;
          if (s2.lookahead + s2.insert >= MIN_MATCH2) {
            str = s2.strstart - s2.insert;
            s2.ins_h = s2.window[str];
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + 1]) & s2.hash_mask;
            while (s2.insert) {
              s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH2 - 1]) & s2.hash_mask;
              s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = str;
              str++;
              s2.insert--;
              if (s2.lookahead + s2.insert < MIN_MATCH2) {
                break;
              }
            }
          }
        } while (s2.lookahead < MIN_LOOKAHEAD2 && s2.strm.avail_in !== 0);
      }
      function deflate_stored2(s2, flush) {
        var max_block_size = 65535;
        if (max_block_size > s2.pending_buf_size - 5) {
          max_block_size = s2.pending_buf_size - 5;
        }
        for (; ; ) {
          if (s2.lookahead <= 1) {
            fill_window2(s2);
            if (s2.lookahead === 0 && flush === constants_js_1.Z_NO_FLUSH) {
              return BS_NEED_MORE2;
            }
            if (s2.lookahead === 0) {
              break;
            }
          }
          s2.strstart += s2.lookahead;
          s2.lookahead = 0;
          var max_start = s2.block_start + max_block_size;
          if (s2.strstart === 0 || s2.strstart >= max_start) {
            s2.lookahead = s2.strstart - max_start;
            s2.strstart = max_start;
            flush_block_only2(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE2;
            }
          }
          if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD2) {
            flush_block_only2(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE2;
            }
          }
        }
        s2.insert = 0;
        if (flush === constants_js_1.Z_FINISH) {
          flush_block_only2(s2, true);
          if (s2.strm.avail_out === 0) {
            return BS_FINISH_STARTED2;
          }
          return BS_FINISH_DONE2;
        }
        if (s2.strstart > s2.block_start) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
        return BS_NEED_MORE2;
      }
      function deflate_fast2(s2, flush) {
        var hash_head;
        var bflush;
        for (; ; ) {
          if (s2.lookahead < MIN_LOOKAHEAD2) {
            fill_window2(s2);
            if (s2.lookahead < MIN_LOOKAHEAD2 && flush === constants_js_1.Z_NO_FLUSH) {
              return BS_NEED_MORE2;
            }
            if (s2.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s2.lookahead >= MIN_MATCH2) {
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH2 - 1]) & s2.hash_mask;
            hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = s2.strstart;
          }
          if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD2) {
            s2.match_length = longest_match2(s2, hash_head);
          }
          if (s2.match_length >= MIN_MATCH2) {
            bflush = (0, trees_js_1._tr_tally)(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH2);
            s2.lookahead -= s2.match_length;
            if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH2) {
              s2.match_length--;
              do {
                s2.strstart++;
                s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH2 - 1]) & s2.hash_mask;
                hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
                s2.head[s2.ins_h] = s2.strstart;
              } while (--s2.match_length !== 0);
              s2.strstart++;
            } else {
              s2.strstart += s2.match_length;
              s2.match_length = 0;
              s2.ins_h = s2.window[s2.strstart];
              s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + 1]) & s2.hash_mask;
            }
          } else {
            bflush = (0, trees_js_1._tr_tally)(s2, 0, s2.window[s2.strstart]);
            s2.lookahead--;
            s2.strstart++;
          }
          if (bflush) {
            flush_block_only2(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE2;
            }
          }
        }
        s2.insert = s2.strstart < MIN_MATCH2 - 1 ? s2.strstart : MIN_MATCH2 - 1;
        if (flush === constants_js_1.Z_FINISH) {
          flush_block_only2(s2, true);
          if (s2.strm.avail_out === 0) {
            return BS_FINISH_STARTED2;
          }
          return BS_FINISH_DONE2;
        }
        if (s2.last_lit) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
        return BS_BLOCK_DONE2;
      }
      function deflate_slow2(s2, flush) {
        var hash_head;
        var bflush;
        var max_insert;
        for (; ; ) {
          if (s2.lookahead < MIN_LOOKAHEAD2) {
            fill_window2(s2);
            if (s2.lookahead < MIN_LOOKAHEAD2 && flush === constants_js_1.Z_NO_FLUSH) {
              return BS_NEED_MORE2;
            }
            if (s2.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s2.lookahead >= MIN_MATCH2) {
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH2 - 1]) & s2.hash_mask;
            hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = s2.strstart;
          }
          s2.prev_length = s2.match_length;
          s2.prev_match = s2.match_start;
          s2.match_length = MIN_MATCH2 - 1;
          if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD2) {
            s2.match_length = longest_match2(s2, hash_head);
            if (s2.match_length <= 5 && (s2.strategy === constants_js_1.Z_FILTERED || s2.match_length === MIN_MATCH2 && s2.strstart - s2.match_start > 4096)) {
              s2.match_length = MIN_MATCH2 - 1;
            }
          }
          if (s2.prev_length >= MIN_MATCH2 && s2.match_length <= s2.prev_length) {
            max_insert = s2.strstart + s2.lookahead - MIN_MATCH2;
            bflush = (0, trees_js_1._tr_tally)(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH2);
            s2.lookahead -= s2.prev_length - 1;
            s2.prev_length -= 2;
            do {
              if (++s2.strstart <= max_insert) {
                s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[s2.strstart + MIN_MATCH2 - 1]) & s2.hash_mask;
                hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
                s2.head[s2.ins_h] = s2.strstart;
              }
            } while (--s2.prev_length !== 0);
            s2.match_available = 0;
            s2.match_length = MIN_MATCH2 - 1;
            s2.strstart++;
            if (bflush) {
              flush_block_only2(s2, false);
              if (s2.strm.avail_out === 0) {
                return BS_NEED_MORE2;
              }
            }
          } else if (s2.match_available) {
            bflush = (0, trees_js_1._tr_tally)(s2, 0, s2.window[s2.strstart - 1]);
            if (bflush) {
              flush_block_only2(s2, false);
            }
            s2.strstart++;
            s2.lookahead--;
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE2;
            }
          } else {
            s2.match_available = 1;
            s2.strstart++;
            s2.lookahead--;
          }
        }
        if (s2.match_available) {
          bflush = (0, trees_js_1._tr_tally)(s2, 0, s2.window[s2.strstart - 1]);
          s2.match_available = 0;
        }
        s2.insert = s2.strstart < MIN_MATCH2 - 1 ? s2.strstart : MIN_MATCH2 - 1;
        if (flush === constants_js_1.Z_FINISH) {
          flush_block_only2(s2, true);
          if (s2.strm.avail_out === 0) {
            return BS_FINISH_STARTED2;
          }
          return BS_FINISH_DONE2;
        }
        if (s2.last_lit) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
        return BS_BLOCK_DONE2;
      }
      function deflate_rle2(s2, flush) {
        var bflush;
        var prev2;
        var scan, strend;
        var _win = s2.window;
        for (; ; ) {
          if (s2.lookahead <= MAX_MATCH2) {
            fill_window2(s2);
            if (s2.lookahead <= MAX_MATCH2 && flush === constants_js_1.Z_NO_FLUSH) {
              return BS_NEED_MORE2;
            }
            if (s2.lookahead === 0) {
              break;
            }
          }
          s2.match_length = 0;
          if (s2.lookahead >= MIN_MATCH2 && s2.strstart > 0) {
            scan = s2.strstart - 1;
            prev2 = _win[scan];
            if (prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan]) {
              strend = s2.strstart + MAX_MATCH2;
              do {
              } while (prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && scan < strend);
              s2.match_length = MAX_MATCH2 - (strend - scan);
              if (s2.match_length > s2.lookahead) {
                s2.match_length = s2.lookahead;
              }
            }
          }
          if (s2.match_length >= MIN_MATCH2) {
            bflush = (0, trees_js_1._tr_tally)(s2, 1, s2.match_length - MIN_MATCH2);
            s2.lookahead -= s2.match_length;
            s2.strstart += s2.match_length;
            s2.match_length = 0;
          } else {
            bflush = (0, trees_js_1._tr_tally)(s2, 0, s2.window[s2.strstart]);
            s2.lookahead--;
            s2.strstart++;
          }
          if (bflush) {
            flush_block_only2(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE2;
            }
          }
        }
        s2.insert = 0;
        if (flush === constants_js_1.Z_FINISH) {
          flush_block_only2(s2, true);
          if (s2.strm.avail_out === 0) {
            return BS_FINISH_STARTED2;
          }
          return BS_FINISH_DONE2;
        }
        if (s2.last_lit) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
        return BS_BLOCK_DONE2;
      }
      function deflate_huff2(s2, flush) {
        var bflush;
        for (; ; ) {
          if (s2.lookahead === 0) {
            fill_window2(s2);
            if (s2.lookahead === 0) {
              if (flush === constants_js_1.Z_NO_FLUSH) {
                return BS_NEED_MORE2;
              }
              break;
            }
          }
          s2.match_length = 0;
          bflush = (0, trees_js_1._tr_tally)(s2, 0, s2.window[s2.strstart]);
          s2.lookahead--;
          s2.strstart++;
          if (bflush) {
            flush_block_only2(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE2;
            }
          }
        }
        s2.insert = 0;
        if (flush === constants_js_1.Z_FINISH) {
          flush_block_only2(s2, true);
          if (s2.strm.avail_out === 0) {
            return BS_FINISH_STARTED2;
          }
          return BS_FINISH_DONE2;
        }
        if (s2.last_lit) {
          flush_block_only2(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE2;
          }
        }
        return BS_BLOCK_DONE2;
      }
      function Config2(good_length, max_lazy, nice_length, max_chain, func) {
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func;
      }
      var configurationTable = function() {
        const table2 = [
          /*      good lazy nice chain */
          new Config2(0, 0, 0, 0, deflate_stored2),
          new Config2(4, 4, 8, 4, deflate_fast2),
          new Config2(4, 5, 16, 8, deflate_fast2),
          new Config2(4, 6, 32, 32, deflate_fast2),
          new Config2(4, 4, 16, 16, deflate_slow2),
          new Config2(8, 16, 32, 32, deflate_slow2),
          new Config2(8, 16, 128, 128, deflate_slow2),
          new Config2(8, 32, 128, 256, deflate_slow2),
          new Config2(32, 128, 258, 1024, deflate_slow2),
          new Config2(32, 258, 258, 4096, deflate_slow2)
        ];
        configurationTable = () => table2;
        return table2;
      };
      function lm_init2(s2) {
        s2.window_size = 2 * s2.w_size;
        zero2(s2.head);
        const table2 = configurationTable();
        s2.max_lazy_match = table2[s2.level].max_lazy;
        s2.good_match = table2[s2.level].good_length;
        s2.nice_match = table2[s2.level].nice_length;
        s2.max_chain_length = table2[s2.level].max_chain;
        s2.strstart = 0;
        s2.block_start = 0;
        s2.lookahead = 0;
        s2.insert = 0;
        s2.match_length = s2.prev_length = MIN_MATCH2 - 1;
        s2.match_available = 0;
        s2.ins_h = 0;
      }
      function DeflateState2() {
        this.strm = null;
        this.status = 0;
        this.pending_buf = null;
        this.pending_buf_size = 0;
        this.pending_out = 0;
        this.pending = 0;
        this.wrap = 0;
        this.gzhead = null;
        this.gzindex = 0;
        this.method = constants_js_1.Z_DEFLATED;
        this.last_flush = -1;
        this.w_size = 0;
        this.w_bits = 0;
        this.w_mask = 0;
        this.window = null;
        this.window_size = 0;
        this.prev = null;
        this.head = null;
        this.ins_h = 0;
        this.hash_size = 0;
        this.hash_bits = 0;
        this.hash_mask = 0;
        this.hash_shift = 0;
        this.block_start = 0;
        this.match_length = 0;
        this.prev_match = 0;
        this.match_available = 0;
        this.strstart = 0;
        this.match_start = 0;
        this.lookahead = 0;
        this.prev_length = 0;
        this.max_chain_length = 0;
        this.max_lazy_match = 0;
        this.level = 0;
        this.strategy = 0;
        this.good_match = 0;
        this.nice_match = 0;
        this.dyn_ltree = (0, common_js_1.Buf16)(HEAP_SIZE2 * 2);
        this.dyn_dtree = (0, common_js_1.Buf16)((2 * D_CODES2 + 1) * 2);
        this.bl_tree = (0, common_js_1.Buf16)((2 * BL_CODES2 + 1) * 2);
        zero2(this.dyn_ltree);
        zero2(this.dyn_dtree);
        zero2(this.bl_tree);
        this.l_desc = null;
        this.d_desc = null;
        this.bl_desc = null;
        this.bl_count = (0, common_js_1.Buf16)(MAX_BITS2 + 1);
        this.heap = (0, common_js_1.Buf16)(2 * L_CODES2 + 1);
        zero2(this.heap);
        this.heap_len = 0;
        this.heap_max = 0;
        this.depth = (0, common_js_1.Buf16)(2 * L_CODES2 + 1);
        zero2(this.depth);
        this.l_buf = 0;
        this.lit_bufsize = 0;
        this.last_lit = 0;
        this.d_buf = 0;
        this.opt_len = 0;
        this.static_len = 0;
        this.matches = 0;
        this.insert = 0;
        this.bi_buf = 0;
        this.bi_valid = 0;
      }
      function deflateResetKeep2(strm) {
        var s2;
        if (!strm || !strm.state) {
          return err2(strm, constants_js_1.Z_STREAM_ERROR);
        }
        strm.total_in = strm.total_out = 0;
        strm.data_type = constants_js_1.Z_UNKNOWN;
        s2 = strm.state;
        s2.pending = 0;
        s2.pending_out = 0;
        if (s2.wrap < 0) {
          s2.wrap = -s2.wrap;
        }
        s2.status = s2.wrap ? INIT_STATE2 : BUSY_STATE2;
        strm.adler = s2.wrap === 2 ? 0 : 1;
        s2.last_flush = constants_js_1.Z_NO_FLUSH;
        (0, trees_js_1._tr_init)(s2);
        return constants_js_1.Z_OK;
      }
      function deflateReset2(strm) {
        var ret = deflateResetKeep2(strm);
        if (ret === constants_js_1.Z_OK) {
          lm_init2(strm.state);
        }
        return ret;
      }
      function deflateSetHeader2(strm, head) {
        if (!strm || !strm.state) {
          return constants_js_1.Z_STREAM_ERROR;
        }
        if (strm.state.wrap !== 2) {
          return constants_js_1.Z_STREAM_ERROR;
        }
        strm.state.gzhead = head;
        return constants_js_1.Z_OK;
      }
      function deflateInit22(strm, level, method, windowBits, memLevel, strategy) {
        if (!strm) {
          return constants_js_1.Z_STREAM_ERROR;
        }
        var wrap = 1;
        if (level === constants_js_1.Z_DEFAULT_COMPRESSION) {
          level = 6;
        }
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else if (windowBits > 15) {
          wrap = 2;
          windowBits -= 16;
        }
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL2 || method !== constants_js_1.Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > constants_js_1.Z_FIXED) {
          return err2(strm, constants_js_1.Z_STREAM_ERROR);
        }
        if (windowBits === 8) {
          windowBits = 9;
        }
        var s2 = new DeflateState2();
        strm.state = s2;
        s2.strm = strm;
        s2.wrap = wrap;
        s2.gzhead = null;
        s2.w_bits = windowBits;
        s2.w_size = 1 << s2.w_bits;
        s2.w_mask = s2.w_size - 1;
        s2.hash_bits = memLevel + 7;
        s2.hash_size = 1 << s2.hash_bits;
        s2.hash_mask = s2.hash_size - 1;
        s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH2 - 1) / MIN_MATCH2);
        s2.window = (0, common_js_1.Buf8)(s2.w_size * 2);
        s2.head = (0, common_js_1.Buf16)(s2.hash_size);
        s2.prev = (0, common_js_1.Buf16)(s2.w_size);
        s2.lit_bufsize = 1 << memLevel + 6;
        s2.pending_buf_size = s2.lit_bufsize * 4;
        s2.pending_buf = (0, common_js_1.Buf8)(s2.pending_buf_size);
        s2.d_buf = 1 * s2.lit_bufsize;
        s2.l_buf = (1 + 2) * s2.lit_bufsize;
        s2.level = level;
        s2.strategy = strategy;
        s2.method = method;
        return deflateReset2(strm);
      }
      function deflateInit3(strm, level) {
        return deflateInit22(strm, level, constants_js_1.Z_DEFLATED, MAX_WBITS2, DEF_MEM_LEVEL2, constants_js_1.Z_DEFAULT_STRATEGY);
      }
      function deflate2(strm, flush) {
        var old_flush, s2;
        var beg, val;
        if (!strm || !strm.state || flush > constants_js_1.Z_BLOCK || flush < 0) {
          return strm ? err2(strm, constants_js_1.Z_STREAM_ERROR) : constants_js_1.Z_STREAM_ERROR;
        }
        s2 = strm.state;
        if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE2 && flush !== constants_js_1.Z_FINISH) {
          return err2(strm, strm.avail_out === 0 ? constants_js_1.Z_BUF_ERROR : constants_js_1.Z_STREAM_ERROR);
        }
        s2.strm = strm;
        old_flush = s2.last_flush;
        s2.last_flush = flush;
        if (s2.status === INIT_STATE2) {
          if (s2.wrap === 2) {
            strm.adler = 0;
            put_byte2(s2, 31);
            put_byte2(s2, 139);
            put_byte2(s2, 8);
            if (!s2.gzhead) {
              put_byte2(s2, 0);
              put_byte2(s2, 0);
              put_byte2(s2, 0);
              put_byte2(s2, 0);
              put_byte2(s2, 0);
              put_byte2(s2, s2.level === 9 ? 2 : s2.strategy >= constants_js_1.Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
              put_byte2(s2, OS_CODE2);
              s2.status = BUSY_STATE2;
            } else {
              put_byte2(s2, (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16));
              put_byte2(s2, s2.gzhead.time & 255);
              put_byte2(s2, s2.gzhead.time >> 8 & 255);
              put_byte2(s2, s2.gzhead.time >> 16 & 255);
              put_byte2(s2, s2.gzhead.time >> 24 & 255);
              put_byte2(s2, s2.level === 9 ? 2 : s2.strategy >= constants_js_1.Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
              put_byte2(s2, s2.gzhead.os & 255);
              if (s2.gzhead.extra && s2.gzhead.extra.length) {
                put_byte2(s2, s2.gzhead.extra.length & 255);
                put_byte2(s2, s2.gzhead.extra.length >> 8 & 255);
              }
              if (s2.gzhead.hcrc) {
                strm.adler = (0, crc32_js_1.default)(strm.adler, s2.pending_buf, s2.pending, 0);
              }
              s2.gzindex = 0;
              s2.status = EXTRA_STATE2;
            }
          } else {
            var header = constants_js_1.Z_DEFLATED + (s2.w_bits - 8 << 4) << 8;
            var level_flags = -1;
            if (s2.strategy >= constants_js_1.Z_HUFFMAN_ONLY || s2.level < 2) {
              level_flags = 0;
            } else if (s2.level < 6) {
              level_flags = 1;
            } else if (s2.level === 6) {
              level_flags = 2;
            } else {
              level_flags = 3;
            }
            header |= level_flags << 6;
            if (s2.strstart !== 0) {
              header |= PRESET_DICT2;
            }
            header += 31 - header % 31;
            s2.status = BUSY_STATE2;
            putShortMSB2(s2, header);
            if (s2.strstart !== 0) {
              putShortMSB2(s2, strm.adler >>> 16);
              putShortMSB2(s2, strm.adler & 65535);
            }
            strm.adler = 1;
          }
        }
        if (s2.status === EXTRA_STATE2) {
          if (s2.gzhead.extra) {
            beg = s2.pending;
            while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
              if (s2.pending === s2.pending_buf_size) {
                if (s2.gzhead.hcrc && s2.pending > beg) {
                  strm.adler = (0, crc32_js_1.default)(strm.adler, s2.pending_buf, s2.pending - beg, beg);
                }
                flush_pending2(strm);
                beg = s2.pending;
                if (s2.pending === s2.pending_buf_size) {
                  break;
                }
              }
              put_byte2(s2, s2.gzhead.extra[s2.gzindex] & 255);
              s2.gzindex++;
            }
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = (0, crc32_js_1.default)(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            if (s2.gzindex === s2.gzhead.extra.length) {
              s2.gzindex = 0;
              s2.status = NAME_STATE2;
            }
          } else {
            s2.status = NAME_STATE2;
          }
        }
        if (s2.status === NAME_STATE2) {
          if (s2.gzhead.name) {
            beg = s2.pending;
            do {
              if (s2.pending === s2.pending_buf_size) {
                if (s2.gzhead.hcrc && s2.pending > beg) {
                  strm.adler = (0, crc32_js_1.default)(strm.adler, s2.pending_buf, s2.pending - beg, beg);
                }
                flush_pending2(strm);
                beg = s2.pending;
                if (s2.pending === s2.pending_buf_size) {
                  val = 1;
                  break;
                }
              }
              if (s2.gzindex < s2.gzhead.name.length) {
                val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte2(s2, val);
            } while (val !== 0);
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = (0, crc32_js_1.default)(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            if (val === 0) {
              s2.gzindex = 0;
              s2.status = COMMENT_STATE2;
            }
          } else {
            s2.status = COMMENT_STATE2;
          }
        }
        if (s2.status === COMMENT_STATE2) {
          if (s2.gzhead.comment) {
            beg = s2.pending;
            do {
              if (s2.pending === s2.pending_buf_size) {
                if (s2.gzhead.hcrc && s2.pending > beg) {
                  strm.adler = (0, crc32_js_1.default)(strm.adler, s2.pending_buf, s2.pending - beg, beg);
                }
                flush_pending2(strm);
                beg = s2.pending;
                if (s2.pending === s2.pending_buf_size) {
                  val = 1;
                  break;
                }
              }
              if (s2.gzindex < s2.gzhead.comment.length) {
                val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte2(s2, val);
            } while (val !== 0);
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = (0, crc32_js_1.default)(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            if (val === 0) {
              s2.status = HCRC_STATE2;
            }
          } else {
            s2.status = HCRC_STATE2;
          }
        }
        if (s2.status === HCRC_STATE2) {
          if (s2.gzhead.hcrc) {
            if (s2.pending + 2 > s2.pending_buf_size) {
              flush_pending2(strm);
            }
            if (s2.pending + 2 <= s2.pending_buf_size) {
              put_byte2(s2, strm.adler & 255);
              put_byte2(s2, strm.adler >> 8 & 255);
              strm.adler = 0;
              s2.status = BUSY_STATE2;
            }
          } else {
            s2.status = BUSY_STATE2;
          }
        }
        if (s2.pending !== 0) {
          flush_pending2(strm);
          if (strm.avail_out === 0) {
            s2.last_flush = -1;
            return constants_js_1.Z_OK;
          }
        } else if (strm.avail_in === 0 && rank2(flush) <= rank2(old_flush) && flush !== constants_js_1.Z_FINISH) {
          return err2(strm, constants_js_1.Z_BUF_ERROR);
        }
        if (s2.status === FINISH_STATE2 && strm.avail_in !== 0) {
          return err2(strm, constants_js_1.Z_BUF_ERROR);
        }
        if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== constants_js_1.Z_NO_FLUSH && s2.status !== FINISH_STATE2) {
          var bstate = s2.strategy === constants_js_1.Z_HUFFMAN_ONLY ? deflate_huff2(s2, flush) : s2.strategy === constants_js_1.Z_RLE ? deflate_rle2(s2, flush) : configurationTable()[s2.level].func(s2, flush);
          if (bstate === BS_FINISH_STARTED2 || bstate === BS_FINISH_DONE2) {
            s2.status = FINISH_STATE2;
          }
          if (bstate === BS_NEED_MORE2 || bstate === BS_FINISH_STARTED2) {
            if (strm.avail_out === 0) {
              s2.last_flush = -1;
            }
            return constants_js_1.Z_OK;
          }
          if (bstate === BS_BLOCK_DONE2) {
            if (flush === constants_js_1.Z_PARTIAL_FLUSH) {
              (0, trees_js_1._tr_align)(s2);
            } else if (flush !== constants_js_1.Z_BLOCK) {
              (0, trees_js_1._tr_stored_block)(s2, 0, 0, false);
              if (flush === constants_js_1.Z_FULL_FLUSH) {
                zero2(s2.head);
                if (s2.lookahead === 0) {
                  s2.strstart = 0;
                  s2.block_start = 0;
                  s2.insert = 0;
                }
              }
            }
            flush_pending2(strm);
            if (strm.avail_out === 0) {
              s2.last_flush = -1;
              return constants_js_1.Z_OK;
            }
          }
        }
        if (flush !== constants_js_1.Z_FINISH) {
          return constants_js_1.Z_OK;
        }
        if (s2.wrap <= 0) {
          return constants_js_1.Z_STREAM_END;
        }
        if (s2.wrap === 2) {
          put_byte2(s2, strm.adler & 255);
          put_byte2(s2, strm.adler >> 8 & 255);
          put_byte2(s2, strm.adler >> 16 & 255);
          put_byte2(s2, strm.adler >> 24 & 255);
          put_byte2(s2, strm.total_in & 255);
          put_byte2(s2, strm.total_in >> 8 & 255);
          put_byte2(s2, strm.total_in >> 16 & 255);
          put_byte2(s2, strm.total_in >> 24 & 255);
        } else {
          putShortMSB2(s2, strm.adler >>> 16);
          putShortMSB2(s2, strm.adler & 65535);
        }
        flush_pending2(strm);
        if (s2.wrap > 0) {
          s2.wrap = -s2.wrap;
        }
        return s2.pending !== 0 ? constants_js_1.Z_OK : constants_js_1.Z_STREAM_END;
      }
      function deflateEnd2(strm) {
        var status;
        if (!strm || !strm.state) {
          return constants_js_1.Z_STREAM_ERROR;
        }
        status = strm.state.status;
        if (status !== INIT_STATE2 && status !== EXTRA_STATE2 && status !== NAME_STATE2 && status !== COMMENT_STATE2 && status !== HCRC_STATE2 && status !== BUSY_STATE2 && status !== FINISH_STATE2) {
          return err2(strm, constants_js_1.Z_STREAM_ERROR);
        }
        strm.state = null;
        return status === BUSY_STATE2 ? err2(strm, constants_js_1.Z_DATA_ERROR) : constants_js_1.Z_OK;
      }
      function deflateSetDictionary2(strm, dictionary) {
        var dictLength = dictionary.length;
        var s2;
        var str, n2;
        var wrap;
        var avail;
        var next2;
        var input;
        var tmpDict;
        if (!strm || !strm.state) {
          return constants_js_1.Z_STREAM_ERROR;
        }
        s2 = strm.state;
        wrap = s2.wrap;
        if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE2 || s2.lookahead) {
          return constants_js_1.Z_STREAM_ERROR;
        }
        if (wrap === 1) {
          strm.adler = (0, adler32_js_1.default)(strm.adler, dictionary, dictLength, 0);
        }
        s2.wrap = 0;
        if (dictLength >= s2.w_size) {
          if (wrap === 0) {
            zero2(s2.head);
            s2.strstart = 0;
            s2.block_start = 0;
            s2.insert = 0;
          }
          tmpDict = (0, common_js_1.Buf8)(s2.w_size);
          (0, common_js_1.arraySet)(tmpDict, dictionary, dictLength - s2.w_size, s2.w_size, 0);
          dictionary = tmpDict;
          dictLength = s2.w_size;
        }
        avail = strm.avail_in;
        next2 = strm.next_in;
        input = strm.input;
        strm.avail_in = dictLength;
        strm.next_in = 0;
        strm.input = dictionary;
        fill_window2(s2);
        while (s2.lookahead >= MIN_MATCH2) {
          str = s2.strstart;
          n2 = s2.lookahead - (MIN_MATCH2 - 1);
          do {
            s2.ins_h = (s2.ins_h << s2.hash_shift ^ s2.window[str + MIN_MATCH2 - 1]) & s2.hash_mask;
            s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = str;
            str++;
          } while (--n2);
          s2.strstart = str;
          s2.lookahead = MIN_MATCH2 - 1;
          fill_window2(s2);
        }
        s2.strstart += s2.lookahead;
        s2.block_start = s2.strstart;
        s2.insert = s2.lookahead;
        s2.lookahead = 0;
        s2.match_length = s2.prev_length = MIN_MATCH2 - 1;
        s2.match_available = 0;
        strm.next_in = next2;
        strm.input = input;
        strm.avail_in = avail;
        s2.wrap = wrap;
        return constants_js_1.Z_OK;
      }
      exports.deflateInfo = "pako deflate (from Nodeca project)";
    }
  });

  // node_modules/pako-esm2/dist/deflate.js
  var require_deflate2 = __commonJS({
    "node_modules/pako-esm2/dist/deflate.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Deflate = void 0;
      exports.deflate = deflate2;
      exports.deflateRaw = deflateRaw2;
      exports.gzip = gzip2;
      var common_js_1 = require_common();
      var strings_js_1 = require_strings();
      var constants_js_1 = require_constants();
      var deflate_js_1 = require_deflate();
      var messages_js_1 = __importDefault(require_messages());
      var zstream_js_1 = __importDefault(require_zstream());
      var toString2 = Object.prototype.toString;
      var Deflate2 = class {
        constructor(options) {
          this.options = (0, common_js_1.assign)({
            level: constants_js_1.Z_DEFAULT_COMPRESSION,
            method: constants_js_1.Z_DEFLATED,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: constants_js_1.Z_DEFAULT_STRATEGY,
            to: ""
          }, options || {});
          var opt = this.options;
          if (opt.raw && opt.windowBits > 0) {
            opt.windowBits = -opt.windowBits;
          } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
            opt.windowBits += 16;
          }
          this.err = 0;
          this.msg = "";
          this.ended = false;
          this.chunks = [];
          this.strm = new zstream_js_1.default();
          this.strm.avail_out = 0;
          var status = (0, deflate_js_1.deflateInit2)(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
          if (status !== constants_js_1.Z_OK) {
            throw new Error(messages_js_1.default[status]);
          }
          if (opt.header) {
            (0, deflate_js_1.deflateSetHeader)(this.strm, opt.header);
          }
          if (opt.dictionary) {
            var dict;
            if (typeof opt.dictionary === "string") {
              dict = (0, strings_js_1.string2buf)(opt.dictionary);
            } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
              dict = new Uint8Array(opt.dictionary);
            } else {
              dict = opt.dictionary;
            }
            status = (0, deflate_js_1.deflateSetDictionary)(this.strm, dict);
            if (status !== constants_js_1.Z_OK) {
              throw new Error(messages_js_1.default[status]);
            }
            this._dict_set = true;
          }
        }
        /**
         * Deflate#push(data[, mode]) -> Boolean
         * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
         *   converted to utf8 byte sequence.
         * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
         *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
         *
         * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
         * new compressed chunks. Returns `true` on success. The last data block must have
         * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
         * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
         * can use mode Z_SYNC_FLUSH, keeping the compression context.
         *
         * On fail call [[Deflate#onEnd]] with error code and return false.
         *
         * We strongly recommend to use `Uint8Array` on input for best speed (output
         * array format is detected automatically). Also, don't skip last param and always
         * use the same type in your code (boolean or number). That will improve JS speed.
         *
         * For regular `Array`-s make sure all elements are [0..255].
         *
         * ##### Example
         *
         * ```javascript
         * push(chunk, false); // push one of data chunks
         * ...
         * push(chunk, true);  // push last chunk
         * ```
         **/
        push(data, mode) {
          var strm = this.strm;
          var chunkSize = this.options.chunkSize;
          var status, _mode;
          if (this.ended) {
            return false;
          }
          _mode = mode === ~~mode ? mode : mode === true ? constants_js_1.Z_FINISH : constants_js_1.Z_NO_FLUSH;
          if (typeof data === "string") {
            strm.input = (0, strings_js_1.string2buf)(data);
          } else if (toString2.call(data) === "[object ArrayBuffer]") {
            strm.input = new Uint8Array(data);
          } else {
            strm.input = data;
          }
          strm.next_in = 0;
          strm.avail_in = strm.input.length;
          do {
            if (strm.avail_out === 0) {
              strm.output = (0, common_js_1.Buf8)(chunkSize);
              strm.next_out = 0;
              strm.avail_out = chunkSize;
            }
            status = (0, deflate_js_1.deflate)(strm, _mode);
            if (status !== constants_js_1.Z_STREAM_END && status !== constants_js_1.Z_OK) {
              this.onEnd(status);
              this.ended = true;
              return false;
            }
            if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === constants_js_1.Z_FINISH || _mode === constants_js_1.Z_SYNC_FLUSH)) {
              if (this.options.to === "string") {
                this.onData((0, strings_js_1.buf2binstring)((0, common_js_1.shrinkBuf)(strm.output, strm.next_out)));
              } else {
                this.onData((0, common_js_1.shrinkBuf)(strm.output, strm.next_out));
              }
            }
          } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== constants_js_1.Z_STREAM_END);
          if (_mode === constants_js_1.Z_FINISH) {
            status = (0, deflate_js_1.deflateEnd)(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === constants_js_1.Z_OK;
          }
          if (_mode === constants_js_1.Z_SYNC_FLUSH) {
            this.onEnd(constants_js_1.Z_OK);
            strm.avail_out = 0;
            return true;
          }
          return true;
        }
        /**
         * Deflate#onData(chunk) -> Void
         * - chunk (Uint8Array|Array|String): output data. Type of array depends
         *   on js engine support. When string output requested, each chunk
         *   will be string.
         *
         * By default, stores data blocks in `chunks[]` property and glue
         * those in `onEnd`. Override this handler, if you need another behaviour.
         **/
        onData(chunk) {
          this.chunks.push(chunk);
        }
        /**
         * Deflate#onEnd(status) -> Void
         * - status (Number): deflate status. 0 (Z_OK) on success,
         *   other if not.
         *
         * Called once after you tell deflate that the input stream is
         * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
         * or if an error happened. By default - join collected chunks,
         * free memory and fill `results` / `err` properties.
         **/
        onEnd(status) {
          if (status === constants_js_1.Z_OK) {
            if (this.options.to === "string") {
              this.result = this.chunks.join("");
            } else {
              this.result = (0, common_js_1.flattenChunks)(this.chunks);
            }
          }
          this.chunks = [];
          this.err = status;
          this.msg = this.strm.msg;
        }
      };
      exports.Deflate = Deflate2;
      function deflate2(input, options) {
        var deflator = new Deflate2(options);
        deflator.push(input, true);
        if (deflator.err) {
          throw deflator.msg || messages_js_1.default[deflator.err];
        }
        return deflator.result;
      }
      function deflateRaw2(input, options) {
        options = options || {};
        options.raw = true;
        return deflate2(input, options);
      }
      function gzip2(input, options) {
        options = options || {};
        options.gzip = true;
        return deflate2(input, options);
      }
    }
  });

  // node_modules/pako-esm2/dist/main.js
  var require_main = __commonJS({
    "node_modules/pako-esm2/dist/main.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o2, m2, k2, k22) {
        if (k22 === void 0) k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m2, k2);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k2];
          } };
        }
        Object.defineProperty(o2, k22, desc);
      }) : (function(o2, m2, k2, k22) {
        if (k22 === void 0) k22 = k2;
        o2[k22] = m2[k2];
      }));
      var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
        for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_constants(), exports);
      __exportStar(require_inflate2(), exports);
      __exportStar(require_deflate2(), exports);
    }
  });

  // node_modules/@gmod/bgzf-filehandle/dist/util.js
  var require_util2 = __commonJS({
    "node_modules/@gmod/bgzf-filehandle/dist/util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.concatUint8Array = concatUint8Array;
      function sum3(array) {
        let sum4 = 0;
        for (const entry of array) {
          sum4 += entry.length;
        }
        return sum4;
      }
      function concatUint8Array(args, totalLength) {
        const mergedArray = new Uint8Array(totalLength ?? sum3(args));
        let offset4 = 0;
        for (const entry of args) {
          mergedArray.set(entry, offset4);
          offset4 += entry.length;
        }
        return mergedArray;
      }
    }
  });

  // node_modules/@gmod/bgzf-filehandle/dist/unzip.js
  var require_unzip = __commonJS({
    "node_modules/@gmod/bgzf-filehandle/dist/unzip.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.unzip = unzip;
      exports.unzipChunkSlice = unzipChunkSlice;
      var pako_esm2_1 = require_main();
      var util_ts_1 = require_util2();
      async function unzip(inputData) {
        try {
          let strm;
          let pos = 0;
          let inflator;
          const blocks = [];
          let totalLength = 0;
          do {
            const remainingInput = inputData.subarray(pos);
            inflator = new pako_esm2_1.Inflate(void 0);
            ({ strm } = inflator);
            inflator.push(remainingInput, pako_esm2_1.Z_SYNC_FLUSH);
            if (inflator.err) {
              throw new Error(inflator.msg);
            }
            pos += strm.next_in;
            const result = inflator.result;
            blocks.push(result);
            totalLength += result.length;
          } while (strm.avail_in);
          return (0, util_ts_1.concatUint8Array)(blocks, totalLength);
        } catch (e2) {
          if (/incorrect header check/.exec(`${e2}`)) {
            throw new Error("problem decompressing block: incorrect gzip header check");
          }
          throw e2;
        }
      }
      async function unzipChunkSlice(inputData, chunk, blockCache) {
        try {
          let strm;
          const { minv, maxv } = chunk;
          let cpos = minv.blockPosition;
          let dpos = minv.dataPosition;
          const chunks = [];
          const cpositions = [];
          const dpositions = [];
          let i2 = 0;
          let wasFromCache = false;
          let totalLength = 0;
          do {
            const remainingInput = inputData.subarray(cpos - minv.blockPosition);
            const cacheKey = cpos.toString();
            let buffer;
            let nextIn;
            const cached = blockCache?.get(cacheKey);
            if (cached) {
              buffer = cached.buffer;
              nextIn = cached.nextIn;
              wasFromCache = true;
            } else {
              const inflator = new pako_esm2_1.Inflate(void 0);
              ({ strm } = inflator);
              inflator.push(remainingInput, pako_esm2_1.Z_SYNC_FLUSH);
              if (inflator.err) {
                throw new Error(inflator.msg);
              }
              buffer = inflator.result;
              nextIn = strm.next_in;
              wasFromCache = false;
              blockCache?.set(cacheKey, { buffer, nextIn });
            }
            chunks.push(buffer);
            let len2 = buffer.length;
            cpositions.push(cpos);
            dpositions.push(dpos);
            if (chunks.length === 1 && minv.dataPosition) {
              chunks[0] = chunks[0].subarray(minv.dataPosition);
              len2 = chunks[0].length;
            }
            const origCpos = cpos;
            cpos += nextIn;
            dpos += len2;
            if (origCpos >= maxv.blockPosition) {
              chunks[i2] = chunks[i2].subarray(0, maxv.blockPosition === minv.blockPosition ? maxv.dataPosition - minv.dataPosition + 1 : maxv.dataPosition + 1);
              totalLength += chunks[i2].length;
              cpositions.push(cpos);
              dpositions.push(dpos);
              break;
            }
            totalLength += len2;
            i2++;
          } while (wasFromCache ? cpos < inputData.length + minv.blockPosition : (
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
            strm.avail_in
          ));
          return {
            buffer: (0, util_ts_1.concatUint8Array)(chunks, totalLength),
            cpositions,
            dpositions
          };
        } catch (e2) {
          if (/incorrect header check/.exec(`${e2}`)) {
            throw new Error("problem decompressing block: incorrect gzip header check");
          }
          throw e2;
        }
      }
    }
  });

  // node_modules/@gmod/bgzf-filehandle/dist/bgzFilehandle.js
  var require_bgzFilehandle = __commonJS({
    "node_modules/@gmod/bgzf-filehandle/dist/bgzFilehandle.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var gziIndex_ts_1 = __importDefault(require_gziIndex());
      var unzip_ts_1 = require_unzip();
      var util_ts_1 = require_util2();
      var BgzFilehandle = class {
        constructor({ filehandle, gziFilehandle }) {
          this.filehandle = filehandle;
          this.gzi = new gziIndex_ts_1.default({
            filehandle: gziFilehandle
          });
        }
        async _readAndUncompressBlock(compressedPosition, nextCompressedPosition) {
          let next2 = nextCompressedPosition;
          if (!next2) {
            next2 = (await this.filehandle.stat()).size;
          }
          const blockCompressedLength = next2 - compressedPosition;
          const blockBuffer = await this.filehandle.read(blockCompressedLength, compressedPosition);
          return (0, unzip_ts_1.unzip)(blockBuffer);
        }
        async read(length2, position2) {
          const blockPositions = await this.gzi.getRelevantBlocksForRead(length2, position2);
          const blocks = [];
          for (let blockNum = 0; blockNum < blockPositions.length - 1; blockNum += 1) {
            const uncompressedBuffer = await this._readAndUncompressBlock(blockPositions[blockNum][0], blockPositions[blockNum + 1][0]);
            const [, uncompressedPosition] = blockPositions[blockNum];
            const sourceOffset = uncompressedPosition >= position2 ? 0 : position2 - uncompressedPosition;
            const sourceEnd = Math.min(position2 + length2, uncompressedPosition + uncompressedBuffer.length) - uncompressedPosition;
            if (sourceOffset >= 0 && sourceOffset < uncompressedBuffer.length) {
              blocks.push(uncompressedBuffer.subarray(sourceOffset, sourceEnd));
            }
          }
          return (0, util_ts_1.concatUint8Array)(blocks);
        }
      };
      exports.default = BgzFilehandle;
    }
  });

  // node_modules/@gmod/bgzf-filehandle/dist/index.js
  var require_dist = __commonJS({
    "node_modules/@gmod/bgzf-filehandle/dist/index.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.unzipChunkSlice = exports.unzip = exports.BgzfFilehandle = void 0;
      var bgzFilehandle_ts_1 = require_bgzFilehandle();
      Object.defineProperty(exports, "BgzfFilehandle", { enumerable: true, get: function() {
        return __importDefault(bgzFilehandle_ts_1).default;
      } });
      var unzip_ts_1 = require_unzip();
      Object.defineProperty(exports, "unzip", { enumerable: true, get: function() {
        return unzip_ts_1.unzip;
      } });
      Object.defineProperty(exports, "unzipChunkSlice", { enumerable: true, get: function() {
        return unzip_ts_1.unzipChunkSlice;
      } });
    }
  });

  // node_modules/@jbrowse/core/util/useMeasure.js
  var require_useMeasure = __commonJS({
    "node_modules/@jbrowse/core/util/useMeasure.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = useMeasure2;
      var react_1 = require_react();
      function useMeasure2() {
        const ref = (0, react_1.useRef)(null);
        const [dims, setDims] = (0, react_1.useState)({
          width: void 0,
          height: void 0
        });
        (0, react_1.useEffect)(() => {
          if (!ref.current) {
            return;
          }
          const RS = typeof window !== "undefined" && "ResizeObserver" in window ? window.ResizeObserver : void 0;
          if (!RS) {
            return;
          }
          const observer50 = new RS((entries) => {
            setDims({
              width: entries[0].contentRect.width,
              height: entries[0].contentRect.height
            });
          });
          observer50.observe(ref.current);
          return () => {
            observer50.disconnect();
          };
        }, []);
        return [ref, dims];
      }
    }
  });

  // global-externals:react-dom
  var require_react_dom = __commonJS({
    "global-externals:react-dom"(exports, module) {
      module.exports = JBrowseExports["react-dom"];
    }
  });

  // global-externals:react-dom/client
  var require_client = __commonJS({
    "global-externals:react-dom/client"(exports, module) {
      module.exports = JBrowseExports["react-dom/client"];
    }
  });

  // node_modules/colord/index.js
  var require_colord = __commonJS({
    "node_modules/colord/index.js"(exports) {
      Object.defineProperty(exports, "__esModule", { value: true });
      var r2 = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
      var t2 = function(r3) {
        return "string" == typeof r3 ? r3.length > 0 : "number" == typeof r3;
      };
      var n2 = function(r3, t3, n3) {
        return void 0 === t3 && (t3 = 0), void 0 === n3 && (n3 = Math.pow(10, t3)), Math.round(n3 * r3) / n3 + 0;
      };
      var e2 = function(r3, t3, n3) {
        return void 0 === t3 && (t3 = 0), void 0 === n3 && (n3 = 1), r3 > n3 ? n3 : r3 > t3 ? r3 : t3;
      };
      var u2 = function(r3) {
        return (r3 = isFinite(r3) ? r3 % 360 : 0) > 0 ? r3 : r3 + 360;
      };
      var o2 = function(r3) {
        return { r: e2(r3.r, 0, 255), g: e2(r3.g, 0, 255), b: e2(r3.b, 0, 255), a: e2(r3.a) };
      };
      var a2 = function(r3) {
        return { r: n2(r3.r), g: n2(r3.g), b: n2(r3.b), a: n2(r3.a, 3) };
      };
      var s2 = /^#([0-9a-f]{3,8})$/i;
      var i2 = function(r3) {
        var t3 = r3.toString(16);
        return t3.length < 2 ? "0" + t3 : t3;
      };
      var h2 = function(r3) {
        var t3 = r3.r, n3 = r3.g, e3 = r3.b, u3 = r3.a, o3 = Math.max(t3, n3, e3), a3 = o3 - Math.min(t3, n3, e3), s3 = a3 ? o3 === t3 ? (n3 - e3) / a3 : o3 === n3 ? 2 + (e3 - t3) / a3 : 4 + (t3 - n3) / a3 : 0;
        return { h: 60 * (s3 < 0 ? s3 + 6 : s3), s: o3 ? a3 / o3 * 100 : 0, v: o3 / 255 * 100, a: u3 };
      };
      var b2 = function(r3) {
        var t3 = r3.h, n3 = r3.s, e3 = r3.v, u3 = r3.a;
        t3 = t3 / 360 * 6, n3 /= 100, e3 /= 100;
        var o3 = Math.floor(t3), a3 = e3 * (1 - n3), s3 = e3 * (1 - (t3 - o3) * n3), i3 = e3 * (1 - (1 - t3 + o3) * n3), h3 = o3 % 6;
        return { r: 255 * [e3, s3, a3, a3, i3, e3][h3], g: 255 * [i3, e3, e3, s3, a3, a3][h3], b: 255 * [a3, a3, i3, e3, e3, s3][h3], a: u3 };
      };
      var d3 = function(r3) {
        return { h: u2(r3.h), s: e2(r3.s, 0, 100), l: e2(r3.l, 0, 100), a: e2(r3.a) };
      };
      var g2 = function(r3) {
        return { h: n2(r3.h), s: n2(r3.s), l: n2(r3.l), a: n2(r3.a, 3) };
      };
      var f2 = function(r3) {
        return b2((n3 = (t3 = r3).s, { h: t3.h, s: (n3 *= ((e3 = t3.l) < 50 ? e3 : 100 - e3) / 100) > 0 ? 2 * n3 / (e3 + n3) * 100 : 0, v: e3 + n3, a: t3.a }));
        var t3, n3, e3;
      };
      var p2 = function(r3) {
        return { h: (t3 = h2(r3)).h, s: (u3 = (200 - (n3 = t3.s)) * (e3 = t3.v) / 100) > 0 && u3 < 200 ? n3 * e3 / 100 / (u3 <= 100 ? u3 : 200 - u3) * 100 : 0, l: u3 / 2, a: t3.a };
        var t3, n3, e3, u3;
      };
      var l2 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      var c2 = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      var v2 = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      var m2 = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      var y2 = { string: [[function(r3) {
        var t3 = s2.exec(r3);
        return t3 ? (r3 = t3[1]).length <= 4 ? { r: parseInt(r3[0] + r3[0], 16), g: parseInt(r3[1] + r3[1], 16), b: parseInt(r3[2] + r3[2], 16), a: 4 === r3.length ? n2(parseInt(r3[3] + r3[3], 16) / 255, 2) : 1 } : 6 === r3.length || 8 === r3.length ? { r: parseInt(r3.substr(0, 2), 16), g: parseInt(r3.substr(2, 2), 16), b: parseInt(r3.substr(4, 2), 16), a: 8 === r3.length ? n2(parseInt(r3.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
      }, "hex"], [function(r3) {
        var t3 = v2.exec(r3) || m2.exec(r3);
        return t3 ? t3[2] !== t3[4] || t3[4] !== t3[6] ? null : o2({ r: Number(t3[1]) / (t3[2] ? 100 / 255 : 1), g: Number(t3[3]) / (t3[4] ? 100 / 255 : 1), b: Number(t3[5]) / (t3[6] ? 100 / 255 : 1), a: void 0 === t3[7] ? 1 : Number(t3[7]) / (t3[8] ? 100 : 1) }) : null;
      }, "rgb"], [function(t3) {
        var n3 = l2.exec(t3) || c2.exec(t3);
        if (!n3) return null;
        var e3, u3, o3 = d3({ h: (e3 = n3[1], u3 = n3[2], void 0 === u3 && (u3 = "deg"), Number(e3) * (r2[u3] || 1)), s: Number(n3[3]), l: Number(n3[4]), a: void 0 === n3[5] ? 1 : Number(n3[5]) / (n3[6] ? 100 : 1) });
        return f2(o3);
      }, "hsl"]], object: [[function(r3) {
        var n3 = r3.r, e3 = r3.g, u3 = r3.b, a3 = r3.a, s3 = void 0 === a3 ? 1 : a3;
        return t2(n3) && t2(e3) && t2(u3) ? o2({ r: Number(n3), g: Number(e3), b: Number(u3), a: Number(s3) }) : null;
      }, "rgb"], [function(r3) {
        var n3 = r3.h, e3 = r3.s, u3 = r3.l, o3 = r3.a, a3 = void 0 === o3 ? 1 : o3;
        if (!t2(n3) || !t2(e3) || !t2(u3)) return null;
        var s3 = d3({ h: Number(n3), s: Number(e3), l: Number(u3), a: Number(a3) });
        return f2(s3);
      }, "hsl"], [function(r3) {
        var n3 = r3.h, o3 = r3.s, a3 = r3.v, s3 = r3.a, i3 = void 0 === s3 ? 1 : s3;
        if (!t2(n3) || !t2(o3) || !t2(a3)) return null;
        var h3 = (function(r4) {
          return { h: u2(r4.h), s: e2(r4.s, 0, 100), v: e2(r4.v, 0, 100), a: e2(r4.a) };
        })({ h: Number(n3), s: Number(o3), v: Number(a3), a: Number(i3) });
        return b2(h3);
      }, "hsv"]] };
      var N2 = function(r3, t3) {
        for (var n3 = 0; n3 < t3.length; n3++) {
          var e3 = t3[n3][0](r3);
          if (e3) return [e3, t3[n3][1]];
        }
        return [null, void 0];
      };
      var x2 = function(r3) {
        return "string" == typeof r3 ? N2(r3.trim(), y2.string) : "object" == typeof r3 && null !== r3 ? N2(r3, y2.object) : [null, void 0];
      };
      var M2 = function(r3, t3) {
        var n3 = p2(r3);
        return { h: n3.h, s: e2(n3.s + 100 * t3, 0, 100), l: n3.l, a: n3.a };
      };
      var I = function(r3) {
        return (299 * r3.r + 587 * r3.g + 114 * r3.b) / 1e3 / 255;
      };
      var H2 = function(r3, t3) {
        var n3 = p2(r3);
        return { h: n3.h, s: n3.s, l: e2(n3.l + 100 * t3, 0, 100), a: n3.a };
      };
      var $2 = (function() {
        function r3(r4) {
          this.parsed = x2(r4)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
        }
        return r3.prototype.isValid = function() {
          return null !== this.parsed;
        }, r3.prototype.brightness = function() {
          return n2(I(this.rgba), 2);
        }, r3.prototype.isDark = function() {
          return I(this.rgba) < 0.5;
        }, r3.prototype.isLight = function() {
          return I(this.rgba) >= 0.5;
        }, r3.prototype.toHex = function() {
          return r4 = a2(this.rgba), t3 = r4.r, e3 = r4.g, u3 = r4.b, s3 = (o3 = r4.a) < 1 ? i2(n2(255 * o3)) : "", "#" + i2(t3) + i2(e3) + i2(u3) + s3;
          var r4, t3, e3, u3, o3, s3;
        }, r3.prototype.toRgb = function() {
          return a2(this.rgba);
        }, r3.prototype.toRgbString = function() {
          return r4 = a2(this.rgba), t3 = r4.r, n3 = r4.g, e3 = r4.b, (u3 = r4.a) < 1 ? "rgba(" + t3 + ", " + n3 + ", " + e3 + ", " + u3 + ")" : "rgb(" + t3 + ", " + n3 + ", " + e3 + ")";
          var r4, t3, n3, e3, u3;
        }, r3.prototype.toHsl = function() {
          return g2(p2(this.rgba));
        }, r3.prototype.toHslString = function() {
          return r4 = g2(p2(this.rgba)), t3 = r4.h, n3 = r4.s, e3 = r4.l, (u3 = r4.a) < 1 ? "hsla(" + t3 + ", " + n3 + "%, " + e3 + "%, " + u3 + ")" : "hsl(" + t3 + ", " + n3 + "%, " + e3 + "%)";
          var r4, t3, n3, e3, u3;
        }, r3.prototype.toHsv = function() {
          return r4 = h2(this.rgba), { h: n2(r4.h), s: n2(r4.s), v: n2(r4.v), a: n2(r4.a, 3) };
          var r4;
        }, r3.prototype.invert = function() {
          return j2({ r: 255 - (r4 = this.rgba).r, g: 255 - r4.g, b: 255 - r4.b, a: r4.a });
          var r4;
        }, r3.prototype.saturate = function(r4) {
          return void 0 === r4 && (r4 = 0.1), j2(M2(this.rgba, r4));
        }, r3.prototype.desaturate = function(r4) {
          return void 0 === r4 && (r4 = 0.1), j2(M2(this.rgba, -r4));
        }, r3.prototype.grayscale = function() {
          return j2(M2(this.rgba, -1));
        }, r3.prototype.lighten = function(r4) {
          return void 0 === r4 && (r4 = 0.1), j2(H2(this.rgba, r4));
        }, r3.prototype.darken = function(r4) {
          return void 0 === r4 && (r4 = 0.1), j2(H2(this.rgba, -r4));
        }, r3.prototype.rotate = function(r4) {
          return void 0 === r4 && (r4 = 15), this.hue(this.hue() + r4);
        }, r3.prototype.alpha = function(r4) {
          return "number" == typeof r4 ? j2({ r: (t3 = this.rgba).r, g: t3.g, b: t3.b, a: r4 }) : n2(this.rgba.a, 3);
          var t3;
        }, r3.prototype.hue = function(r4) {
          var t3 = p2(this.rgba);
          return "number" == typeof r4 ? j2({ h: r4, s: t3.s, l: t3.l, a: t3.a }) : n2(t3.h);
        }, r3.prototype.isEqual = function(r4) {
          return this.toHex() === j2(r4).toHex();
        }, r3;
      })();
      var j2 = function(r3) {
        return r3 instanceof $2 ? r3 : new $2(r3);
      };
      var w2 = [];
      exports.Colord = $2, exports.colord = j2, exports.extend = function(r3) {
        r3.forEach(function(r4) {
          w2.indexOf(r4) < 0 && (r4($2, y2), w2.push(r4));
        });
      }, exports.getFormat = function(r3) {
        return x2(r3)[1];
      }, exports.random = function() {
        return new $2({ r: 255 * Math.random(), g: 255 * Math.random(), b: 255 * Math.random() });
      };
    }
  });

  // node_modules/colord/plugins/mix.js
  var require_mix = __commonJS({
    "node_modules/colord/plugins/mix.js"(exports, module) {
      var t2 = function(t3, a3, n3) {
        return void 0 === a3 && (a3 = 0), void 0 === n3 && (n3 = 1), t3 > n3 ? n3 : t3 > a3 ? t3 : a3;
      };
      var a2 = function(t3) {
        var a3 = t3 / 255;
        return a3 < 0.04045 ? a3 / 12.92 : Math.pow((a3 + 0.055) / 1.055, 2.4);
      };
      var n2 = function(t3) {
        return 255 * (t3 > 31308e-7 ? 1.055 * Math.pow(t3, 1 / 2.4) - 0.055 : 12.92 * t3);
      };
      var r2 = 96.422;
      var o2 = 100;
      var u2 = 82.521;
      var e2 = function(a3) {
        var r3, o3, u3 = { x: 0.9555766 * (r3 = a3).x + -0.0230393 * r3.y + 0.0631636 * r3.z, y: -0.0282895 * r3.x + 1.0099416 * r3.y + 0.0210077 * r3.z, z: 0.0122982 * r3.x + -0.020483 * r3.y + 1.3299098 * r3.z };
        return o3 = { r: n2(0.032404542 * u3.x - 0.015371385 * u3.y - 4985314e-9 * u3.z), g: n2(-969266e-8 * u3.x + 0.018760108 * u3.y + 41556e-8 * u3.z), b: n2(556434e-9 * u3.x - 2040259e-9 * u3.y + 0.010572252 * u3.z), a: a3.a }, { r: t2(o3.r, 0, 255), g: t2(o3.g, 0, 255), b: t2(o3.b, 0, 255), a: t2(o3.a) };
      };
      var i2 = function(n3) {
        var e3 = a2(n3.r), i3 = a2(n3.g), p3 = a2(n3.b);
        return (function(a3) {
          return { x: t2(a3.x, 0, r2), y: t2(a3.y, 0, o2), z: t2(a3.z, 0, u2), a: t2(a3.a) };
        })((function(t3) {
          return { x: 1.0478112 * t3.x + 0.0228866 * t3.y + -0.050127 * t3.z, y: 0.0295424 * t3.x + 0.9904844 * t3.y + -0.0170491 * t3.z, z: -92345e-7 * t3.x + 0.0150436 * t3.y + 0.7521316 * t3.z, a: t3.a };
        })({ x: 100 * (0.4124564 * e3 + 0.3575761 * i3 + 0.1804375 * p3), y: 100 * (0.2126729 * e3 + 0.7151522 * i3 + 0.072175 * p3), z: 100 * (0.0193339 * e3 + 0.119192 * i3 + 0.9503041 * p3), a: n3.a }));
      };
      var p2 = 216 / 24389;
      var h2 = 24389 / 27;
      var f2 = function(t3) {
        var a3 = i2(t3), n3 = a3.x / r2, e3 = a3.y / o2, f3 = a3.z / u2;
        return n3 = n3 > p2 ? Math.cbrt(n3) : (h2 * n3 + 16) / 116, { l: 116 * (e3 = e3 > p2 ? Math.cbrt(e3) : (h2 * e3 + 16) / 116) - 16, a: 500 * (n3 - e3), b: 200 * (e3 - (f3 = f3 > p2 ? Math.cbrt(f3) : (h2 * f3 + 16) / 116)), alpha: a3.a };
      };
      var c2 = function(a3, n3, i3) {
        var c3, y2 = f2(a3), x2 = f2(n3);
        return (function(t3) {
          var a4 = (t3.l + 16) / 116, n4 = t3.a / 500 + a4, i4 = a4 - t3.b / 200;
          return e2({ x: (Math.pow(n4, 3) > p2 ? Math.pow(n4, 3) : (116 * n4 - 16) / h2) * r2, y: (t3.l > 8 ? Math.pow((t3.l + 16) / 116, 3) : t3.l / h2) * o2, z: (Math.pow(i4, 3) > p2 ? Math.pow(i4, 3) : (116 * i4 - 16) / h2) * u2, a: t3.alpha });
        })({ l: t2((c3 = { l: y2.l * (1 - i3) + x2.l * i3, a: y2.a * (1 - i3) + x2.a * i3, b: y2.b * (1 - i3) + x2.b * i3, alpha: y2.alpha * (1 - i3) + x2.alpha * i3 }).l, 0, 400), a: c3.a, b: c3.b, alpha: t2(c3.alpha) });
      };
      module.exports = function(t3) {
        function a3(t4, a4, n3) {
          void 0 === n3 && (n3 = 5);
          for (var r3 = [], o3 = 1 / (n3 - 1), u3 = 0; u3 <= n3 - 1; u3++) r3.push(t4.mix(a4, o3 * u3));
          return r3;
        }
        t3.prototype.mix = function(a4, n3) {
          void 0 === n3 && (n3 = 0.5);
          var r3 = a4 instanceof t3 ? a4 : new t3(a4), o3 = c2(this.toRgb(), r3.toRgb(), n3);
          return new t3(o3);
        }, t3.prototype.tints = function(t4) {
          return a3(this, "#fff", t4);
        }, t3.prototype.shades = function(t4) {
          return a3(this, "#000", t4);
        }, t3.prototype.tones = function(t4) {
          return a3(this, "#808080", t4);
        };
      };
    }
  });

  // node_modules/colord/plugins/names.js
  var require_names = __commonJS({
    "node_modules/colord/plugins/names.js"(exports, module) {
      module.exports = function(e2, f2) {
        var a2 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r2 = {};
        for (var d3 in a2) r2[a2[d3]] = d3;
        var l2 = {};
        e2.prototype.toName = function(f3) {
          if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
          var d4, i2, o2 = r2[this.toHex()];
          if (o2) return o2;
          if (null == f3 ? void 0 : f3.closest) {
            var n2 = this.toRgb(), t2 = 1 / 0, b2 = "black";
            if (!l2.length) for (var c2 in a2) l2[c2] = new e2(a2[c2]).toRgb();
            for (var g2 in a2) {
              var u2 = (d4 = n2, i2 = l2[g2], Math.pow(d4.r - i2.r, 2) + Math.pow(d4.g - i2.g, 2) + Math.pow(d4.b - i2.b, 2));
              u2 < t2 && (t2 = u2, b2 = g2);
            }
            return b2;
          }
        };
        f2.string.push([function(f3) {
          var r3 = f3.toLowerCase(), d4 = "transparent" === r3 ? "#0000" : a2[r3];
          return d4 ? new e2(d4).toRgb() : null;
        }, "name"]);
      };
    }
  });

  // node_modules/@jbrowse/core/util/colord.js
  var require_colord2 = __commonJS({
    "node_modules/@jbrowse/core/util/colord.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.colord = exports.Colord = void 0;
      var colord_1 = require_colord();
      var mix_1 = __importDefault(require_mix());
      var names_1 = __importDefault(require_names());
      (0, colord_1.extend)([mix_1.default, names_1.default]);
      var colord_2 = require_colord();
      Object.defineProperty(exports, "Colord", { enumerable: true, get: function() {
        return colord_2.Colord;
      } });
      Object.defineProperty(exports, "colord", { enumerable: true, get: function() {
        return colord_2.colord;
      } });
    }
  });

  // node_modules/@jbrowse/core/util/stopToken.js
  var require_stopToken = __commonJS({
    "node_modules/@jbrowse/core/util/stopToken.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createStopToken = createStopToken;
      exports.stopStopToken = stopStopToken;
      exports.checkStopToken = checkStopToken;
      function isWebWorker() {
        return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
      }
      function createStopToken() {
        var _a;
        return ((_a = URL.createObjectURL) === null || _a === void 0 ? void 0 : _a.call(URL, new Blob())) || `${Math.random()}`;
      }
      function stopStopToken(stopToken) {
        var _a;
        (_a = URL.revokeObjectURL) === null || _a === void 0 ? void 0 : _a.call(URL, stopToken);
      }
      function checkStopToken(stopToken) {
        if (typeof jest === "undefined" && stopToken !== void 0 && isWebWorker()) {
          const xhr = new XMLHttpRequest();
          xhr.open("GET", stopToken, false);
          try {
            xhr.send(null);
          } catch (e2) {
            throw new Error("aborted");
          }
        }
      }
    }
  });

  // node_modules/@jbrowse/core/util/types/util.js
  var require_util3 = __commonJS({
    "node_modules/@jbrowse/core/util/types/util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/@leeoniya/ufuzzy/dist/uFuzzy.cjs
  var require_uFuzzy = __commonJS({
    "node_modules/@leeoniya/ufuzzy/dist/uFuzzy.cjs"(exports, module) {
      "use strict";
      var cmp = (a2, b2) => a2 > b2 ? 1 : a2 < b2 ? -1 : 0;
      var inf = Infinity;
      var escapeRegExp = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      var EXACT_HERE = "eexxaacctt";
      var PUNCT_RE = /\p{P}/gu;
      var LATIN_UPPER = "A-Z";
      var LATIN_LOWER = "a-z";
      var COLLATE_ARGS = ["en", { numeric: true, sensitivity: "base" }];
      var swapAlpha = (str, upper, lower) => str.replace(LATIN_UPPER, upper).replace(LATIN_LOWER, lower);
      var OPTS = {
        // whether regexps use a /u unicode flag
        unicode: false,
        alpha: null,
        // term segmentation & punct/whitespace merging
        interSplit: "[^A-Za-z\\d']+",
        intraSplit: "[a-z][A-Z]",
        // inter bounds that will be used to increase lft2/rgt2 info counters
        interBound: "[^A-Za-z\\d]",
        // intra bounds that will be used to increase lft1/rgt1 info counters
        intraBound: "[A-Za-z]\\d|\\d[A-Za-z]|[a-z][A-Z]",
        // inter-bounds mode
        // 2 = strict (will only match 'man' on whitepace and punct boundaries: Mega Man, Mega_Man, mega.man)
        // 1 = loose  (plus allowance for alpha-num and case-change boundaries: MegaMan, 0007man)
        // 0 = any    (will match 'man' as any substring: megamaniac)
        interLft: 0,
        interRgt: 0,
        // allowance between terms
        interChars: ".",
        interIns: inf,
        // allowance between chars in terms
        intraChars: "[a-z\\d']",
        // internally case-insensitive
        intraIns: null,
        intraContr: "'[a-z]{1,2}\\b",
        // multi-insert or single-error mode
        intraMode: 0,
        // single-error bounds for errors within terms, default requires exact first char
        intraSlice: [1, inf],
        // single-error tolerance toggles
        intraSub: null,
        intraTrn: null,
        intraDel: null,
        // can post-filter matches that are too far apart in distance or length
        // (since intraIns is between each char, it can accum to nonsense matches)
        intraFilt: (term, match2, index3) => true,
        // should this also accept WIP info?
        toUpper: (str) => str.toLocaleUpperCase(),
        toLower: (str) => str.toLocaleLowerCase(),
        compare: null,
        // final sorting fn
        sort: (info, haystack, needle, compare2 = cmp) => {
          let {
            idx,
            chars,
            terms,
            interLft2,
            interLft1,
            //	interRgt2,
            //	interRgt1,
            start,
            intraIns,
            interIns,
            cases
          } = info;
          return idx.map((v2, i2) => i2).sort((ia, ib) => (
            // most contig chars matched
            chars[ib] - chars[ia] || // least char intra-fuzz (most contiguous)
            intraIns[ia] - intraIns[ib] || // most prefix bounds, boosted by full term matches
            terms[ib] + interLft2[ib] + 0.5 * interLft1[ib] - (terms[ia] + interLft2[ia] + 0.5 * interLft1[ia]) || // highest density of match (least span)
            //	span[ia] - span[ib] ||
            // highest density of match (least term inter-fuzz)
            interIns[ia] - interIns[ib] || // earliest start of match
            start[ia] - start[ib] || // case match
            cases[ib] - cases[ia] || // alphabetic
            compare2(haystack[idx[ia]], haystack[idx[ib]])
          ));
        }
      };
      var lazyRepeat = (chars, limit) => limit == 0 ? "" : limit == 1 ? chars + "??" : limit == inf ? chars + "*?" : chars + `{0,${limit}}?`;
      var mode2Tpl = "(?:\\b|_)";
      function uFuzzy(opts) {
        opts = Object.assign({}, OPTS, opts);
        let {
          unicode,
          interLft,
          interRgt,
          intraMode,
          intraSlice,
          intraIns,
          intraSub,
          intraTrn,
          intraDel,
          intraContr,
          intraSplit: _intraSplit,
          interSplit: _interSplit,
          intraBound: _intraBound,
          interBound: _interBound,
          intraChars,
          toUpper,
          toLower,
          compare: compare2
        } = opts;
        intraIns ??= intraMode;
        intraSub ??= intraMode;
        intraTrn ??= intraMode;
        intraDel ??= intraMode;
        compare2 ??= typeof Intl == "undefined" ? cmp : new Intl.Collator(...COLLATE_ARGS).compare;
        let alpha = opts.letters ?? opts.alpha;
        if (alpha != null) {
          let upper = toUpper(alpha);
          let lower = toLower(alpha);
          _interSplit = swapAlpha(_interSplit, upper, lower);
          _intraSplit = swapAlpha(_intraSplit, upper, lower);
          _interBound = swapAlpha(_interBound, upper, lower);
          _intraBound = swapAlpha(_intraBound, upper, lower);
          intraChars = swapAlpha(intraChars, upper, lower);
          intraContr = swapAlpha(intraContr, upper, lower);
        }
        let uFlag = unicode ? "u" : "";
        const quotedAny = '".+?"';
        const EXACTS_RE = new RegExp(quotedAny, "gi" + uFlag);
        const NEGS_RE = new RegExp(`(?:\\s+|^)-(?:${intraChars}+|${quotedAny})`, "gi" + uFlag);
        let { intraRules } = opts;
        if (intraRules == null) {
          intraRules = (p2) => {
            let _intraSlice = OPTS.intraSlice, _intraIns = 0, _intraSub = 0, _intraTrn = 0, _intraDel = 0;
            if (/[^\d]/.test(p2)) {
              let plen = p2.length;
              if (plen <= 4) {
                if (plen >= 3) {
                  _intraTrn = Math.min(intraTrn, 1);
                  if (plen == 4)
                    _intraIns = Math.min(intraIns, 1);
                }
              } else {
                _intraSlice = intraSlice;
                _intraIns = intraIns, _intraSub = intraSub, _intraTrn = intraTrn, _intraDel = intraDel;
              }
            }
            return {
              intraSlice: _intraSlice,
              intraIns: _intraIns,
              intraSub: _intraSub,
              intraTrn: _intraTrn,
              intraDel: _intraDel
            };
          };
        }
        let withIntraSplit = !!_intraSplit;
        let intraSplit = new RegExp(_intraSplit, "g" + uFlag);
        let interSplit = new RegExp(_interSplit, "g" + uFlag);
        let trimRe = new RegExp("^" + _interSplit + "|" + _interSplit + "$", "g" + uFlag);
        let contrsRe = new RegExp(intraContr, "gi" + uFlag);
        const split = (needle, keepCase = false) => {
          let exacts = [];
          needle = needle.replace(EXACTS_RE, (m2) => {
            exacts.push(m2);
            return EXACT_HERE;
          });
          needle = needle.replace(trimRe, "");
          if (!keepCase)
            needle = toLower(needle);
          if (withIntraSplit)
            needle = needle.replace(intraSplit, (m2) => m2[0] + " " + m2[1]);
          let j2 = 0;
          return needle.split(interSplit).filter((t2) => t2 != "").map((v2) => v2 === EXACT_HERE ? exacts[j2++] : v2);
        };
        const NUM_OR_ALPHA_RE = /[^\d]+|\d+/g;
        const prepQuery = (needle, capt = 0, interOR = false) => {
          let parts = split(needle);
          if (parts.length == 0)
            return [];
          let contrs = Array(parts.length).fill("");
          parts = parts.map((p2, pi) => p2.replace(contrsRe, (m2) => {
            contrs[pi] = m2;
            return "";
          }));
          let reTpl;
          if (intraMode == 1) {
            reTpl = parts.map((p2, pi) => {
              if (p2[0] === '"')
                return escapeRegExp(p2.slice(1, -1));
              let reTpl2 = "";
              for (let m2 of p2.matchAll(NUM_OR_ALPHA_RE)) {
                let p3 = m2[0];
                let {
                  intraSlice: intraSlice2,
                  intraIns: intraIns2,
                  intraSub: intraSub2,
                  intraTrn: intraTrn2,
                  intraDel: intraDel2
                } = intraRules(p3);
                if (intraIns2 + intraSub2 + intraTrn2 + intraDel2 == 0)
                  reTpl2 += p3 + contrs[pi];
                else {
                  let [lftIdx, rgtIdx] = intraSlice2;
                  let lftChar = p3.slice(0, lftIdx);
                  let rgtChar = p3.slice(rgtIdx);
                  let chars = p3.slice(lftIdx, rgtIdx);
                  if (intraIns2 == 1 && lftChar.length == 1 && lftChar != chars[0])
                    lftChar += "(?!" + lftChar + ")";
                  let numChars = chars.length;
                  let variants = [p3];
                  if (intraSub2) {
                    for (let i2 = 0; i2 < numChars; i2++)
                      variants.push(lftChar + chars.slice(0, i2) + intraChars + chars.slice(i2 + 1) + rgtChar);
                  }
                  if (intraTrn2) {
                    for (let i2 = 0; i2 < numChars - 1; i2++) {
                      if (chars[i2] != chars[i2 + 1])
                        variants.push(lftChar + chars.slice(0, i2) + chars[i2 + 1] + chars[i2] + chars.slice(i2 + 2) + rgtChar);
                    }
                  }
                  if (intraDel2) {
                    for (let i2 = 0; i2 < numChars; i2++)
                      variants.push(lftChar + chars.slice(0, i2 + 1) + "?" + chars.slice(i2 + 1) + rgtChar);
                  }
                  if (intraIns2) {
                    let intraInsTpl = lazyRepeat(intraChars, 1);
                    for (let i2 = 0; i2 < numChars; i2++)
                      variants.push(lftChar + chars.slice(0, i2) + intraInsTpl + chars.slice(i2) + rgtChar);
                  }
                  reTpl2 += "(?:" + variants.join("|") + ")" + contrs[pi];
                }
              }
              return reTpl2;
            });
          } else {
            let intraInsTpl = lazyRepeat(intraChars, intraIns);
            if (capt == 2 && intraIns > 0) {
              intraInsTpl = ")(" + intraInsTpl + ")(";
            }
            reTpl = parts.map((p2, pi) => p2[0] === '"' ? escapeRegExp(p2.slice(1, -1)) : p2.split("").map((c2, i2, chars) => {
              if (intraIns == 1 && i2 == 0 && chars.length > 1 && c2 != chars[i2 + 1])
                c2 += "(?!" + c2 + ")";
              return c2;
            }).join(intraInsTpl) + contrs[pi]);
          }
          let preTpl = interLft == 2 ? mode2Tpl : "";
          let sufTpl = interRgt == 2 ? mode2Tpl : "";
          let interCharsTpl = sufTpl + lazyRepeat(opts.interChars, opts.interIns) + preTpl;
          if (capt > 0) {
            if (interOR) {
              reTpl = preTpl + "(" + reTpl.join(")" + sufTpl + "|" + preTpl + "(") + ")" + sufTpl;
            } else {
              reTpl = "(" + reTpl.join(")(" + interCharsTpl + ")(") + ")";
              reTpl = "(.??" + preTpl + ")" + reTpl + "(" + sufTpl + ".*)";
            }
          } else {
            reTpl = reTpl.join(interCharsTpl);
            reTpl = preTpl + reTpl + sufTpl;
          }
          return [new RegExp(reTpl, "i" + uFlag), parts, contrs];
        };
        const filter = (haystack, needle, idxs) => {
          let [query] = prepQuery(needle);
          if (query == null)
            return null;
          let out = [];
          if (idxs != null) {
            for (let i2 = 0; i2 < idxs.length; i2++) {
              let idx = idxs[i2];
              query.test(haystack[idx]) && out.push(idx);
            }
          } else {
            for (let i2 = 0; i2 < haystack.length; i2++)
              query.test(haystack[i2]) && out.push(i2);
          }
          return out;
        };
        let withIntraBound = !!_intraBound;
        let interBound = new RegExp(_interBound, uFlag);
        let intraBound = new RegExp(_intraBound, uFlag);
        const info = (idxs, haystack, needle) => {
          let [query, parts, contrs] = prepQuery(needle, 1);
          let partsCased = split(needle, true);
          let [queryR] = prepQuery(needle, 2);
          let partsLen = parts.length;
          let _terms = Array(partsLen);
          let _termsCased = Array(partsLen);
          for (let j2 = 0; j2 < partsLen; j2++) {
            let part = parts[j2];
            let partCased = partsCased[j2];
            let term = part[0] == '"' ? part.slice(1, -1) : part + contrs[j2];
            let termCased = partCased[0] == '"' ? partCased.slice(1, -1) : partCased + contrs[j2];
            _terms[j2] = term;
            _termsCased[j2] = termCased;
          }
          let len2 = idxs.length;
          let field = Array(len2).fill(0);
          let info2 = {
            // idx in haystack
            idx: Array(len2),
            // start of match
            start: field.slice(),
            // length of match
            //	span: field.slice(),
            // contiguous chars matched
            chars: field.slice(),
            // case matched in term (via term.includes(match))
            cases: field.slice(),
            // contiguous (no fuzz) and bounded terms (intra=0, lft2/1, rgt2/1)
            // excludes terms that are contiguous but have < 2 bounds (substrings)
            terms: field.slice(),
            // cumulative length of unmatched chars (fuzz) within span
            interIns: field.slice(),
            // between terms
            intraIns: field.slice(),
            // within terms
            // interLft/interRgt counters
            interLft2: field.slice(),
            interRgt2: field.slice(),
            interLft1: field.slice(),
            interRgt1: field.slice(),
            ranges: Array(len2)
          };
          let mayDiscard = interLft == 1 || interRgt == 1;
          let ii = 0;
          for (let i2 = 0; i2 < idxs.length; i2++) {
            let mhstr = haystack[idxs[i2]];
            let m2 = mhstr.match(query);
            let start = m2.index + m2[1].length;
            let idxAcc = start;
            let disc = false;
            let lft2 = 0;
            let lft1 = 0;
            let rgt2 = 0;
            let rgt1 = 0;
            let chars = 0;
            let terms = 0;
            let cases = 0;
            let inter = 0;
            let intra = 0;
            let refine = [];
            for (let j2 = 0, k2 = 2; j2 < partsLen; j2++, k2 += 2) {
              let group = toLower(m2[k2]);
              let term = _terms[j2];
              let termCased = _termsCased[j2];
              let termLen = term.length;
              let groupLen = group.length;
              let fullMatch = group == term;
              if (m2[k2] == termCased)
                cases++;
              if (!fullMatch && m2[k2 + 1].length >= termLen) {
                let idxOf = toLower(m2[k2 + 1]).indexOf(term);
                if (idxOf > -1) {
                  refine.push(idxAcc, groupLen, idxOf, termLen);
                  idxAcc += refineMatch(m2, k2, idxOf, termLen);
                  group = term;
                  groupLen = termLen;
                  fullMatch = true;
                  if (j2 == 0)
                    start = idxAcc;
                }
              }
              if (mayDiscard || fullMatch) {
                let lftCharIdx = idxAcc - 1;
                let rgtCharIdx = idxAcc + groupLen;
                let isPre = false;
                let isSuf = false;
                if (lftCharIdx == -1 || interBound.test(mhstr[lftCharIdx])) {
                  fullMatch && lft2++;
                  isPre = true;
                } else {
                  if (interLft == 2) {
                    disc = true;
                    break;
                  }
                  if (withIntraBound && intraBound.test(mhstr[lftCharIdx] + mhstr[lftCharIdx + 1])) {
                    fullMatch && lft1++;
                    isPre = true;
                  } else {
                    if (interLft == 1) {
                      let junk = m2[k2 + 1];
                      let junkIdx = idxAcc + groupLen;
                      if (junk.length >= termLen) {
                        let idxOf = 0;
                        let found = false;
                        let re = new RegExp(term, "ig" + uFlag);
                        let m22;
                        while (m22 = re.exec(junk)) {
                          idxOf = m22.index;
                          let charIdx = junkIdx + idxOf;
                          let lftCharIdx2 = charIdx - 1;
                          if (lftCharIdx2 == -1 || interBound.test(mhstr[lftCharIdx2])) {
                            lft2++;
                            found = true;
                            break;
                          } else if (intraBound.test(mhstr[lftCharIdx2] + mhstr[charIdx])) {
                            lft1++;
                            found = true;
                            break;
                          }
                        }
                        if (found) {
                          isPre = true;
                          refine.push(idxAcc, groupLen, idxOf, termLen);
                          idxAcc += refineMatch(m2, k2, idxOf, termLen);
                          group = term;
                          groupLen = termLen;
                          fullMatch = true;
                          if (j2 == 0)
                            start = idxAcc;
                        }
                      }
                      if (!isPre) {
                        disc = true;
                        break;
                      }
                    }
                  }
                }
                if (rgtCharIdx == mhstr.length || interBound.test(mhstr[rgtCharIdx])) {
                  fullMatch && rgt2++;
                  isSuf = true;
                } else {
                  if (interRgt == 2) {
                    disc = true;
                    break;
                  }
                  if (withIntraBound && intraBound.test(mhstr[rgtCharIdx - 1] + mhstr[rgtCharIdx])) {
                    fullMatch && rgt1++;
                    isSuf = true;
                  } else {
                    if (interRgt == 1) {
                      disc = true;
                      break;
                    }
                  }
                }
                if (fullMatch) {
                  chars += termLen;
                  if (isPre && isSuf)
                    terms++;
                }
              }
              if (groupLen > termLen)
                intra += groupLen - termLen;
              if (j2 > 0)
                inter += m2[k2 - 1].length;
              if (!opts.intraFilt(term, group, idxAcc)) {
                disc = true;
                break;
              }
              if (j2 < partsLen - 1)
                idxAcc += groupLen + m2[k2 + 1].length;
            }
            if (!disc) {
              info2.idx[ii] = idxs[i2];
              info2.interLft2[ii] = lft2;
              info2.interLft1[ii] = lft1;
              info2.interRgt2[ii] = rgt2;
              info2.interRgt1[ii] = rgt1;
              info2.chars[ii] = chars;
              info2.terms[ii] = terms;
              info2.cases[ii] = cases;
              info2.interIns[ii] = inter;
              info2.intraIns[ii] = intra;
              info2.start[ii] = start;
              let m3 = mhstr.match(queryR);
              let idxAcc2 = m3.index + m3[1].length;
              let refLen = refine.length;
              let ri = refLen > 0 ? 0 : Infinity;
              let lastRi = refLen - 4;
              for (let i3 = 2; i3 < m3.length; ) {
                let len3 = m3[i3].length;
                if (ri <= lastRi && refine[ri] == idxAcc2) {
                  let groupLen = refine[ri + 1];
                  let idxOf = refine[ri + 2];
                  let termLen = refine[ri + 3];
                  let j2 = i3;
                  let v2 = "";
                  for (let _len = 0; _len < groupLen; j2++) {
                    v2 += m3[j2];
                    _len += m3[j2].length;
                  }
                  m3.splice(i3, j2 - i3, v2);
                  idxAcc2 += refineMatch(m3, i3, idxOf, termLen);
                  ri += 4;
                } else {
                  idxAcc2 += len3;
                  i3++;
                }
              }
              idxAcc2 = m3.index + m3[1].length;
              let ranges = info2.ranges[ii] = [];
              let from2 = idxAcc2;
              let to = idxAcc2;
              for (let i3 = 2; i3 < m3.length; i3++) {
                let len3 = m3[i3].length;
                idxAcc2 += len3;
                if (i3 % 2 == 0)
                  to = idxAcc2;
                else if (len3 > 0) {
                  ranges.push(from2, to);
                  from2 = to = idxAcc2;
                }
              }
              if (to > from2)
                ranges.push(from2, to);
              ii++;
            }
          }
          if (ii < idxs.length) {
            for (let k2 in info2)
              info2[k2] = info2[k2].slice(0, ii);
          }
          return info2;
        };
        const refineMatch = (m2, k2, idxInNext, termLen) => {
          let prepend = m2[k2] + m2[k2 + 1].slice(0, idxInNext);
          m2[k2 - 1] += prepend;
          m2[k2] = m2[k2 + 1].slice(idxInNext, idxInNext + termLen);
          m2[k2 + 1] = m2[k2 + 1].slice(idxInNext + termLen);
          return prepend.length;
        };
        const OOO_TERMS_LIMIT = 5;
        const _search = (haystack, needle, outOfOrder, infoThresh = 1e3, preFiltered) => {
          outOfOrder = !outOfOrder ? 0 : outOfOrder === true ? OOO_TERMS_LIMIT : outOfOrder;
          let needles = null;
          let matches2 = null;
          let negs = [];
          needle = needle.replace(NEGS_RE, (m2) => {
            let neg = m2.trim().slice(1);
            neg = neg[0] === '"' ? escapeRegExp(neg.slice(1, -1)) : neg.replace(PUNCT_RE, "");
            if (neg != "")
              negs.push(neg);
            return "";
          });
          let terms = split(needle);
          let negsRe;
          if (negs.length > 0) {
            negsRe = new RegExp(negs.join("|"), "i" + uFlag);
            if (terms.length == 0) {
              let idxs = [];
              for (let i2 = 0; i2 < haystack.length; i2++) {
                if (!negsRe.test(haystack[i2]))
                  idxs.push(i2);
              }
              return [idxs, null, null];
            }
          } else {
            if (terms.length == 0)
              return [null, null, null];
          }
          if (outOfOrder > 0) {
            let terms2 = split(needle);
            if (terms2.length > 1) {
              let terms22 = terms2.slice().sort((a2, b2) => b2.length - a2.length);
              for (let ti = 0; ti < terms22.length; ti++) {
                if (preFiltered?.length == 0)
                  return [[], null, null];
                preFiltered = filter(haystack, terms22[ti], preFiltered);
              }
              if (terms2.length > outOfOrder)
                return [preFiltered, null, null];
              needles = permute(terms2).map((perm) => perm.join(" "));
              matches2 = [];
              let matchedIdxs = /* @__PURE__ */ new Set();
              for (let ni = 0; ni < needles.length; ni++) {
                if (matchedIdxs.size < preFiltered.length) {
                  let preFiltered2 = preFiltered.filter((idx) => !matchedIdxs.has(idx));
                  let matched = filter(haystack, needles[ni], preFiltered2);
                  for (let j2 = 0; j2 < matched.length; j2++)
                    matchedIdxs.add(matched[j2]);
                  matches2.push(matched);
                } else
                  matches2.push([]);
              }
            }
          }
          if (needles == null) {
            needles = [needle];
            matches2 = [preFiltered?.length > 0 ? preFiltered : filter(haystack, needle)];
          }
          let retInfo = null;
          let retOrder = null;
          if (negs.length > 0)
            matches2 = matches2.map((idxs) => idxs.filter((idx) => !negsRe.test(haystack[idx])));
          let matchCount = matches2.reduce((acc, idxs) => acc + idxs.length, 0);
          if (matchCount <= infoThresh) {
            retInfo = {};
            retOrder = [];
            for (let ni = 0; ni < matches2.length; ni++) {
              let idxs = matches2[ni];
              if (idxs == null || idxs.length == 0)
                continue;
              let needle2 = needles[ni];
              let _info = info(idxs, haystack, needle2);
              let order = opts.sort(_info, haystack, needle2, compare2);
              if (ni > 0) {
                for (let i2 = 0; i2 < order.length; i2++)
                  order[i2] += retOrder.length;
              }
              for (let k2 in _info)
                retInfo[k2] = (retInfo[k2] ?? []).concat(_info[k2]);
              retOrder = retOrder.concat(order);
            }
          }
          return [
            [].concat(...matches2),
            retInfo,
            retOrder
          ];
        };
        return {
          search: (...args) => {
            let out = _search(...args);
            return out;
          },
          split,
          filter,
          info,
          sort: opts.sort
        };
      }
      var latinize = (() => {
        let accents = {
          A: "\xC1\xC0\xC3\xC2\xC4\u0104\u0102\xC5",
          a: "\xE1\xE0\xE3\xE2\xE4\u0105\u0103\xE5",
          E: "\xC9\xC8\xCA\xCB\u0116\u011A",
          e: "\xE9\xE8\xEA\xEB\u0119\u011B",
          I: "\xCD\xCC\xCE\xCF\u012E\u0130",
          i: "\xED\xEC\xEE\xEF\u012F\u0131",
          O: "\xD3\xD2\xD4\xD5\xD6",
          o: "\xF3\xF2\xF4\xF5\xF6",
          U: "\xDA\xD9\xDB\xDC\u016A\u0172\u016E\u0170",
          u: "\xFA\xF9\xFB\xFC\u016B\u0173\u016F\u0171",
          C: "\xC7\u010C\u0106",
          c: "\xE7\u010D\u0107",
          D: "\u010E",
          d: "\u010F",
          G: "\u011E",
          g: "\u011F",
          L: "\u0141",
          l: "\u0142",
          N: "\xD1\u0143\u0147",
          n: "\xF1\u0144\u0148",
          S: "\u0160\u015A\u0218\u015E",
          s: "\u0161\u015B\u0219\u015F",
          T: "\u0162\u021A\u0164",
          t: "\u0163\u021B\u0165",
          Y: "\xDD",
          y: "\xFD",
          Z: "\u017B\u0179\u017D",
          z: "\u017C\u017A\u017E"
        };
        let accentsMap = {};
        let accentsTpl = "";
        for (let r2 in accents) {
          accents[r2].split("").forEach((a2) => {
            accentsTpl += a2;
            accentsMap[a2] = r2;
          });
        }
        let accentsRe = new RegExp(`[${accentsTpl}]`, "g");
        let replacer = (m2) => accentsMap[m2];
        return (strings2) => {
          if (typeof strings2 == "string")
            return strings2.replace(accentsRe, replacer);
          let out = Array(strings2.length);
          for (let i2 = 0; i2 < strings2.length; i2++)
            out[i2] = strings2[i2].replace(accentsRe, replacer);
          return out;
        };
      })();
      function permute(arr) {
        arr = arr.slice();
        let length2 = arr.length, result = [arr.slice()], c2 = new Array(length2).fill(0), i2 = 1, k2, p2;
        while (i2 < length2) {
          if (c2[i2] < i2) {
            k2 = i2 % 2 && c2[i2];
            p2 = arr[i2];
            arr[i2] = arr[k2];
            arr[k2] = p2;
            ++c2[i2];
            i2 = 1;
            result.push(arr.slice());
          } else {
            c2[i2] = 0;
            ++i2;
          }
        }
        return result;
      }
      var _mark = (part, matched) => matched ? `<mark>${part}</mark>` : part;
      var _append = (acc, part) => acc + part;
      function highlight(str, ranges, mark = _mark, accum = "", append2 = _append) {
        accum = append2(accum, mark(str.substring(0, ranges[0]), false)) ?? accum;
        for (let i2 = 0; i2 < ranges.length; i2 += 2) {
          let fr = ranges[i2];
          let to = ranges[i2 + 1];
          accum = append2(accum, mark(str.substring(fr, to), true)) ?? accum;
          if (i2 < ranges.length - 3)
            accum = append2(accum, mark(str.substring(ranges[i2 + 1], ranges[i2 + 2]), false)) ?? accum;
        }
        accum = append2(accum, mark(str.substring(ranges[ranges.length - 1]), false)) ?? accum;
        return accum;
      }
      uFuzzy.latinize = latinize;
      uFuzzy.permute = (arr) => {
        let idxs = permute([...Array(arr.length).keys()]).sort((a2, b2) => {
          for (let i2 = 0; i2 < a2.length; i2++) {
            if (a2[i2] != b2[i2])
              return a2[i2] - b2[i2];
          }
          return 0;
        });
        return idxs.map((pi) => pi.map((i2) => arr[i2]));
      };
      uFuzzy.highlight = highlight;
      module.exports = uFuzzy;
    }
  });

  // node_modules/@babel/runtime/helpers/interopRequireDefault.js
  var require_interopRequireDefault = __commonJS({
    "node_modules/@babel/runtime/helpers/interopRequireDefault.js"(exports, module) {
      function _interopRequireDefault(e2) {
        return e2 && e2.__esModule ? e2 : {
          "default": e2
        };
      }
      module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/typeof.js
  var require_typeof = __commonJS({
    "node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
      function _typeof(o2) {
        "@babel/helpers - typeof";
        return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
          return typeof o3;
        } : function(o3) {
          return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o2);
      }
      module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/toPrimitive.js
  var require_toPrimitive = __commonJS({
    "node_modules/@babel/runtime/helpers/toPrimitive.js"(exports, module) {
      var _typeof = require_typeof()["default"];
      function toPrimitive(t2, r2) {
        if ("object" != _typeof(t2) || !t2) return t2;
        var e2 = t2[Symbol.toPrimitive];
        if (void 0 !== e2) {
          var i2 = e2.call(t2, r2 || "default");
          if ("object" != _typeof(i2)) return i2;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === r2 ? String : Number)(t2);
      }
      module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/toPropertyKey.js
  var require_toPropertyKey = __commonJS({
    "node_modules/@babel/runtime/helpers/toPropertyKey.js"(exports, module) {
      var _typeof = require_typeof()["default"];
      var toPrimitive = require_toPrimitive();
      function toPropertyKey(t2) {
        var i2 = toPrimitive(t2, "string");
        return "symbol" == _typeof(i2) ? i2 : i2 + "";
      }
      module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/defineProperty.js
  var require_defineProperty = __commonJS({
    "node_modules/@babel/runtime/helpers/defineProperty.js"(exports, module) {
      var toPropertyKey = require_toPropertyKey();
      function _defineProperty(e2, r2, t2) {
        return (r2 = toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, {
          value: t2,
          enumerable: true,
          configurable: true,
          writable: true
        }) : e2[r2] = t2, e2;
      }
      module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/classCallCheck.js
  var require_classCallCheck = __commonJS({
    "node_modules/@babel/runtime/helpers/classCallCheck.js"(exports, module) {
      function _classCallCheck(a2, n2) {
        if (!(a2 instanceof n2)) throw new TypeError("Cannot call a class as a function");
      }
      module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/createClass.js
  var require_createClass = __commonJS({
    "node_modules/@babel/runtime/helpers/createClass.js"(exports, module) {
      var toPropertyKey = require_toPropertyKey();
      function _defineProperties(e2, r2) {
        for (var t2 = 0; t2 < r2.length; t2++) {
          var o2 = r2[t2];
          o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, toPropertyKey(o2.key), o2);
        }
      }
      function _createClass(e2, r2, t2) {
        return r2 && _defineProperties(e2.prototype, r2), t2 && _defineProperties(e2, t2), Object.defineProperty(e2, "prototype", {
          writable: false
        }), e2;
      }
      module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/arrayLikeToArray.js
  var require_arrayLikeToArray = __commonJS({
    "node_modules/@babel/runtime/helpers/arrayLikeToArray.js"(exports, module) {
      function _arrayLikeToArray(r2, a2) {
        (null == a2 || a2 > r2.length) && (a2 = r2.length);
        for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
        return n2;
      }
      module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/arrayWithoutHoles.js
  var require_arrayWithoutHoles = __commonJS({
    "node_modules/@babel/runtime/helpers/arrayWithoutHoles.js"(exports, module) {
      var arrayLikeToArray = require_arrayLikeToArray();
      function _arrayWithoutHoles(r2) {
        if (Array.isArray(r2)) return arrayLikeToArray(r2);
      }
      module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/iterableToArray.js
  var require_iterableToArray = __commonJS({
    "node_modules/@babel/runtime/helpers/iterableToArray.js"(exports, module) {
      function _iterableToArray(r2) {
        if ("undefined" != typeof Symbol && null != r2[Symbol.iterator] || null != r2["@@iterator"]) return Array.from(r2);
      }
      module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js
  var require_unsupportedIterableToArray = __commonJS({
    "node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"(exports, module) {
      var arrayLikeToArray = require_arrayLikeToArray();
      function _unsupportedIterableToArray(r2, a2) {
        if (r2) {
          if ("string" == typeof r2) return arrayLikeToArray(r2, a2);
          var t2 = {}.toString.call(r2).slice(8, -1);
          return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? arrayLikeToArray(r2, a2) : void 0;
        }
      }
      module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/nonIterableSpread.js
  var require_nonIterableSpread = __commonJS({
    "node_modules/@babel/runtime/helpers/nonIterableSpread.js"(exports, module) {
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/@babel/runtime/helpers/toConsumableArray.js
  var require_toConsumableArray = __commonJS({
    "node_modules/@babel/runtime/helpers/toConsumableArray.js"(exports, module) {
      var arrayWithoutHoles = require_arrayWithoutHoles();
      var iterableToArray = require_iterableToArray();
      var unsupportedIterableToArray = require_unsupportedIterableToArray();
      var nonIterableSpread = require_nonIterableSpread();
      function _toConsumableArray(r2) {
        return arrayWithoutHoles(r2) || iterableToArray(r2) || unsupportedIterableToArray(r2) || nonIterableSpread();
      }
      module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/jexl/dist/evaluator/handlers.js
  var require_handlers = __commonJS({
    "node_modules/jexl/dist/evaluator/handlers.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      var _toConsumableArray2 = _interopRequireDefault(require_toConsumableArray());
      var poolNames = {
        functions: "Jexl Function",
        transforms: "Transform"
      };
      exports.ArrayLiteral = function(ast) {
        return this.evalArray(ast.value);
      };
      exports.BinaryExpression = function(ast) {
        var _this = this;
        var grammarOp = this._grammar.elements[ast.operator];
        if (grammarOp.evalOnDemand) {
          var wrap = function wrap2(subAst) {
            return {
              eval: function _eval() {
                return _this.eval(subAst);
              }
            };
          };
          return grammarOp.evalOnDemand(wrap(ast.left), wrap(ast.right));
        }
        return this.Promise.all([this.eval(ast.left), this.eval(ast.right)]).then(function(arr) {
          return grammarOp.eval(arr[0], arr[1]);
        });
      };
      exports.ConditionalExpression = function(ast) {
        var _this2 = this;
        return this.eval(ast.test).then(function(res) {
          if (res) {
            if (ast.consequent) {
              return _this2.eval(ast.consequent);
            }
            return res;
          }
          return _this2.eval(ast.alternate);
        });
      };
      exports.FilterExpression = function(ast) {
        var _this3 = this;
        return this.eval(ast.subject).then(function(subject) {
          if (ast.relative) {
            return _this3._filterRelative(subject, ast.expr);
          }
          return _this3._filterStatic(subject, ast.expr);
        });
      };
      exports.Identifier = function(ast) {
        if (!ast.from) {
          return ast.relative ? this._relContext[ast.value] : this._context[ast.value];
        }
        return this.eval(ast.from).then(function(context2) {
          if (context2 === void 0 || context2 === null) {
            return void 0;
          }
          if (Array.isArray(context2)) {
            context2 = context2[0];
          }
          return context2[ast.value];
        });
      };
      exports.Literal = function(ast) {
        return ast.value;
      };
      exports.ObjectLiteral = function(ast) {
        return this.evalMap(ast.value);
      };
      exports.FunctionCall = function(ast) {
        var poolName = poolNames[ast.pool];
        if (!poolName) {
          throw new Error("Corrupt AST: Pool '".concat(ast.pool, "' not found"));
        }
        var pool = this._grammar[ast.pool];
        var func = pool[ast.name];
        if (!func) {
          throw new Error("".concat(poolName, " ").concat(ast.name, " is not defined."));
        }
        return this.evalArray(ast.args || []).then(function(args) {
          return func.apply(void 0, (0, _toConsumableArray2.default)(args));
        });
      };
      exports.UnaryExpression = function(ast) {
        var _this4 = this;
        return this.eval(ast.right).then(function(right) {
          return _this4._grammar.elements[ast.operator].eval(right);
        });
      };
    }
  });

  // node_modules/jexl/dist/evaluator/Evaluator.js
  var require_Evaluator = __commonJS({
    "node_modules/jexl/dist/evaluator/Evaluator.js"(exports, module) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var handlers = require_handlers();
      var Evaluator = /* @__PURE__ */ (function() {
        function Evaluator2(grammar, context2, relativeContext) {
          var promise = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Promise;
          (0, _classCallCheck2.default)(this, Evaluator2);
          this._grammar = grammar;
          this._context = context2 || {};
          this._relContext = relativeContext || this._context;
          this.Promise = promise;
        }
        (0, _createClass2.default)(Evaluator2, [{
          key: "eval",
          value: function _eval(ast) {
            var _this = this;
            return this.Promise.resolve().then(function() {
              return handlers[ast.type].call(_this, ast);
            });
          }
          /**
           * Simultaneously evaluates each expression within an array, and delivers the
           * response as an array with the resulting values at the same indexes as their
           * originating expressions.
           * @param {Array<string>} arr An array of expression strings to be evaluated
           * @returns {Promise<Array<{}>>} resolves with the result array
           */
        }, {
          key: "evalArray",
          value: function evalArray(arr) {
            var _this2 = this;
            return this.Promise.all(arr.map(function(elem) {
              return _this2.eval(elem);
            }));
          }
          /**
           * Simultaneously evaluates each expression within a map, and delivers the
           * response as a map with the same keys, but with the evaluated result for each
           * as their value.
           * @param {{}} map A map of expression names to expression trees to be
           *      evaluated
           * @returns {Promise<{}>} resolves with the result map.
           */
        }, {
          key: "evalMap",
          value: function evalMap(map) {
            var _this3 = this;
            var keys = Object.keys(map);
            var result = {};
            var asts = keys.map(function(key) {
              return _this3.eval(map[key]);
            });
            return this.Promise.all(asts).then(function(vals) {
              vals.forEach(function(val, idx) {
                result[keys[idx]] = val;
              });
              return result;
            });
          }
          /**
           * Applies a filter expression with relative identifier elements to a subject.
           * The intent is for the subject to be an array of subjects that will be
           * individually used as the relative context against the provided expression
           * tree. Only the elements whose expressions result in a truthy value will be
           * included in the resulting array.
           *
           * If the subject is not an array of values, it will be converted to a single-
           * element array before running the filter.
           * @param {*} subject The value to be filtered usually an array. If this value is
           *      not an array, it will be converted to an array with this value as the
           *      only element.
           * @param {{}} expr The expression tree to run against each subject. If the
           *      tree evaluates to a truthy result, then the value will be included in
           *      the returned array otherwise, it will be eliminated.
           * @returns {Promise<Array>} resolves with an array of values that passed the
           *      expression filter.
           * @private
           */
        }, {
          key: "_filterRelative",
          value: function _filterRelative(subject, expr) {
            var _this4 = this;
            var promises = [];
            if (!Array.isArray(subject)) {
              subject = subject === void 0 ? [] : [subject];
            }
            subject.forEach(function(elem) {
              var evalInst = new Evaluator2(_this4._grammar, _this4._context, elem, _this4.Promise);
              promises.push(evalInst.eval(expr));
            });
            return this.Promise.all(promises).then(function(values) {
              var results = [];
              values.forEach(function(value, idx) {
                if (value) {
                  results.push(subject[idx]);
                }
              });
              return results;
            });
          }
          /**
           * Applies a static filter expression to a subject value.  If the filter
           * expression evaluates to boolean true, the subject is returned if false,
           * undefined.
           *
           * For any other resulting value of the expression, this function will attempt
           * to respond with the property at that name or index of the subject.
           * @param {*} subject The value to be filtered.  Usually an Array (for which
           *      the expression would generally resolve to a numeric index) or an
           *      Object (for which the expression would generally resolve to a string
           *      indicating a property name)
           * @param {{}} expr The expression tree to run against the subject
           * @returns {Promise<*>} resolves with the value of the drill-down.
           * @private
           */
        }, {
          key: "_filterStatic",
          value: function _filterStatic(subject, expr) {
            return this.eval(expr).then(function(res) {
              if (typeof res === "boolean") {
                return res ? subject : void 0;
              }
              return subject[res];
            });
          }
        }]);
        return Evaluator2;
      })();
      module.exports = Evaluator;
    }
  });

  // node_modules/jexl/dist/Lexer.js
  var require_Lexer = __commonJS({
    "node_modules/jexl/dist/Lexer.js"(exports, module) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var numericRegex = /^-?(?:(?:[0-9]*\.[0-9]+)|[0-9]+)$/;
      var identRegex = /^[a-zA-Z--_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$][a-zA-Z--0-9_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$]*$/;
      var escEscRegex = /\\\\/;
      var whitespaceRegex = /^\s*$/;
      var preOpRegexElems = [
        // Strings
        "'(?:(?:\\\\')|[^'])*'",
        '"(?:(?:\\\\")|[^"])*"',
        // Whitespace
        "\\s+",
        // Booleans
        "\\btrue\\b",
        "\\bfalse\\b"
      ];
      var postOpRegexElems = [
        // Identifiers
        "[a-zA-Z\u0430-\u044F\u0410-\u042F_\xC0-\xD6\xD8-\xF6\xF8-\xFF\\$][a-zA-Z0-9\u0430-\u044F\u0410-\u042F_\xC0-\xD6\xD8-\xF6\xF8-\xFF\\$]*",
        // Numerics (without negative symbol)
        "(?:(?:[0-9]*\\.[0-9]+)|[0-9]+)"
      ];
      var minusNegatesAfter = ["binaryOp", "unaryOp", "openParen", "openBracket", "question", "colon"];
      var Lexer = /* @__PURE__ */ (function() {
        function Lexer2(grammar) {
          (0, _classCallCheck2.default)(this, Lexer2);
          this._grammar = grammar;
        }
        (0, _createClass2.default)(Lexer2, [{
          key: "getElements",
          value: function getElements(str) {
            var regex = this._getSplitRegex();
            return str.split(regex).filter(function(elem) {
              return elem;
            });
          }
          /**
           * Converts an array of expression elements into an array of tokens.  Note that
           * the resulting array may not equal the element array in length, as any
           * elements that consist only of whitespace get appended to the previous
           * token's "raw" property.  For the structure of a token object, please see
           * {@link Lexer#tokenize}.
           * @param {Array<string>} elements An array of Jexl expression elements to be
           *      converted to tokens
           * @returns {Array<{type, value, raw}>} an array of token objects.
           */
        }, {
          key: "getTokens",
          value: function getTokens(elements) {
            var tokens = [];
            var negate = false;
            for (var i2 = 0; i2 < elements.length; i2++) {
              if (this._isWhitespace(elements[i2])) {
                if (tokens.length) {
                  tokens[tokens.length - 1].raw += elements[i2];
                }
              } else if (elements[i2] === "-" && this._isNegative(tokens)) {
                negate = true;
              } else {
                if (negate) {
                  elements[i2] = "-" + elements[i2];
                  negate = false;
                }
                tokens.push(this._createToken(elements[i2]));
              }
            }
            if (negate) {
              tokens.push(this._createToken("-"));
            }
            return tokens;
          }
          /**
           * Converts a Jexl string into an array of tokens.  Each token is an object
           * in the following format:
           *
           *     {
           *         type: <string>,
           *         [name]: <string>,
           *         value: <boolean|number|string>,
           *         raw: <string>
           *     }
           *
           * Type is one of the following:
           *
           *      literal, identifier, binaryOp, unaryOp
           *
           * OR, if the token is a control character its type is the name of the element
           * defined in the Grammar.
           *
           * Name appears only if the token is a control string found in
           * {@link grammar#elements}, and is set to the name of the element.
           *
           * Value is the value of the token in the correct type (boolean or numeric as
           * appropriate). Raw is the string representation of this value taken directly
           * from the expression string, including any trailing spaces.
           * @param {string} str The Jexl string to be tokenized
           * @returns {Array<{type, value, raw}>} an array of token objects.
           * @throws {Error} if the provided string contains an invalid token.
           */
        }, {
          key: "tokenize",
          value: function tokenize(str) {
            var elements = this.getElements(str);
            return this.getTokens(elements);
          }
          /**
           * Creates a new token object from an element of a Jexl string. See
           * {@link Lexer#tokenize} for a description of the token object.
           * @param {string} element The element from which a token should be made
           * @returns {{value: number|boolean|string, [name]: string, type: string,
           *      raw: string}} a token object describing the provided element.
           * @throws {Error} if the provided string is not a valid expression element.
           * @private
           */
        }, {
          key: "_createToken",
          value: function _createToken(element) {
            var token2 = {
              type: "literal",
              value: element,
              raw: element
            };
            if (element[0] === '"' || element[0] === "'") {
              token2.value = this._unquote(element);
            } else if (element.match(numericRegex)) {
              token2.value = parseFloat(element);
            } else if (element === "true" || element === "false") {
              token2.value = element === "true";
            } else if (this._grammar.elements[element]) {
              token2.type = this._grammar.elements[element].type;
            } else if (element.match(identRegex)) {
              token2.type = "identifier";
            } else {
              throw new Error("Invalid expression token: ".concat(element));
            }
            return token2;
          }
          /**
           * Escapes a string so that it can be treated as a string literal within a
           * regular expression.
           * @param {string} str The string to be escaped
           * @returns {string} the RegExp-escaped string.
           * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions
           * @private
           */
        }, {
          key: "_escapeRegExp",
          value: function _escapeRegExp(str) {
            str = str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            if (str.match(identRegex)) {
              str = "\\b" + str + "\\b";
            }
            return str;
          }
          /**
           * Gets a RegEx object appropriate for splitting a Jexl string into its core
           * elements.
           * @returns {RegExp} An element-splitting RegExp object
           * @private
           */
        }, {
          key: "_getSplitRegex",
          value: function _getSplitRegex() {
            var _this = this;
            if (!this._splitRegex) {
              var elemArray = Object.keys(this._grammar.elements).sort(function(a2, b2) {
                return b2.length - a2.length;
              }).map(function(elem) {
                return _this._escapeRegExp(elem);
              }, this);
              this._splitRegex = new RegExp("(" + [preOpRegexElems.join("|"), elemArray.join("|"), postOpRegexElems.join("|")].join("|") + ")");
            }
            return this._splitRegex;
          }
          /**
           * Determines whether the addition of a '-' token should be interpreted as a
           * negative symbol for an upcoming number, given an array of tokens already
           * processed.
           * @param {Array<Object>} tokens An array of tokens already processed
           * @returns {boolean} true if adding a '-' should be considered a negative
           *      symbol; false otherwise
           * @private
           */
        }, {
          key: "_isNegative",
          value: function _isNegative(tokens) {
            if (!tokens.length) return true;
            return minusNegatesAfter.some(function(type) {
              return type === tokens[tokens.length - 1].type;
            });
          }
          /**
           * A utility function to determine if a string consists of only space
           * characters.
           * @param {string} str A string to be tested
           * @returns {boolean} true if the string is empty or consists of only spaces;
           *      false otherwise.
           * @private
           */
        }, {
          key: "_isWhitespace",
          value: function _isWhitespace(str) {
            return !!str.match(whitespaceRegex);
          }
          /**
           * Removes the beginning and trailing quotes from a string, unescapes any
           * escaped quotes on its interior, and unescapes any escaped escape
           * characters. Note that this function is not defensive; it assumes that the
           * provided string is not empty, and that its first and last characters are
           * actually quotes.
           * @param {string} str A string whose first and last characters are quotes
           * @returns {string} a string with the surrounding quotes stripped and escapes
           *      properly processed.
           * @private
           */
        }, {
          key: "_unquote",
          value: function _unquote(str) {
            var quote = str[0];
            var escQuoteRegex = new RegExp("\\\\" + quote, "g");
            return str.substr(1, str.length - 2).replace(escQuoteRegex, quote).replace(escEscRegex, "\\");
          }
        }]);
        return Lexer2;
      })();
      module.exports = Lexer;
    }
  });

  // node_modules/jexl/dist/parser/handlers.js
  var require_handlers2 = __commonJS({
    "node_modules/jexl/dist/parser/handlers.js"(exports) {
      "use strict";
      exports.argVal = function(ast) {
        if (ast) this._cursor.args.push(ast);
      };
      exports.arrayStart = function() {
        this._placeAtCursor({
          type: "ArrayLiteral",
          value: []
        });
      };
      exports.arrayVal = function(ast) {
        if (ast) {
          this._cursor.value.push(ast);
        }
      };
      exports.binaryOp = function(token2) {
        var precedence = this._grammar.elements[token2.value].precedence || 0;
        var parent = this._cursor._parent;
        while (parent && parent.operator && this._grammar.elements[parent.operator].precedence >= precedence) {
          this._cursor = parent;
          parent = parent._parent;
        }
        var node2 = {
          type: "BinaryExpression",
          operator: token2.value,
          left: this._cursor
        };
        this._setParent(this._cursor, node2);
        this._cursor = parent;
        this._placeAtCursor(node2);
      };
      exports.dot = function() {
        this._nextIdentEncapsulate = this._cursor && this._cursor.type !== "UnaryExpression" && (this._cursor.type !== "BinaryExpression" || this._cursor.type === "BinaryExpression" && this._cursor.right);
        this._nextIdentRelative = !this._cursor || this._cursor && !this._nextIdentEncapsulate;
        if (this._nextIdentRelative) {
          this._relative = true;
        }
      };
      exports.filter = function(ast) {
        this._placeBeforeCursor({
          type: "FilterExpression",
          expr: ast,
          relative: this._subParser.isRelative(),
          subject: this._cursor
        });
      };
      exports.functionCall = function() {
        this._placeBeforeCursor({
          type: "FunctionCall",
          name: this._cursor.value,
          args: [],
          pool: "functions"
        });
      };
      exports.identifier = function(token2) {
        var node2 = {
          type: "Identifier",
          value: token2.value
        };
        if (this._nextIdentEncapsulate) {
          node2.from = this._cursor;
          this._placeBeforeCursor(node2);
          this._nextIdentEncapsulate = false;
        } else {
          if (this._nextIdentRelative) {
            node2.relative = true;
            this._nextIdentRelative = false;
          }
          this._placeAtCursor(node2);
        }
      };
      exports.literal = function(token2) {
        this._placeAtCursor({
          type: "Literal",
          value: token2.value
        });
      };
      exports.objKey = function(token2) {
        this._curObjKey = token2.value;
      };
      exports.objStart = function() {
        this._placeAtCursor({
          type: "ObjectLiteral",
          value: {}
        });
      };
      exports.objVal = function(ast) {
        this._cursor.value[this._curObjKey] = ast;
      };
      exports.subExpression = function(ast) {
        this._placeAtCursor(ast);
      };
      exports.ternaryEnd = function(ast) {
        this._cursor.alternate = ast;
      };
      exports.ternaryMid = function(ast) {
        this._cursor.consequent = ast;
      };
      exports.ternaryStart = function() {
        this._tree = {
          type: "ConditionalExpression",
          test: this._tree
        };
        this._cursor = this._tree;
      };
      exports.transform = function(token2) {
        this._placeBeforeCursor({
          type: "FunctionCall",
          name: token2.value,
          args: [this._cursor],
          pool: "transforms"
        });
      };
      exports.unaryOp = function(token2) {
        this._placeAtCursor({
          type: "UnaryExpression",
          operator: token2.value
        });
      };
    }
  });

  // node_modules/jexl/dist/parser/states.js
  var require_states = __commonJS({
    "node_modules/jexl/dist/parser/states.js"(exports) {
      "use strict";
      var h2 = require_handlers2();
      exports.states = {
        expectOperand: {
          tokenTypes: {
            literal: {
              toState: "expectBinOp"
            },
            identifier: {
              toState: "identifier"
            },
            unaryOp: {},
            openParen: {
              toState: "subExpression"
            },
            openCurl: {
              toState: "expectObjKey",
              handler: h2.objStart
            },
            dot: {
              toState: "traverse"
            },
            openBracket: {
              toState: "arrayVal",
              handler: h2.arrayStart
            }
          }
        },
        expectBinOp: {
          tokenTypes: {
            binaryOp: {
              toState: "expectOperand"
            },
            pipe: {
              toState: "expectTransform"
            },
            dot: {
              toState: "traverse"
            },
            question: {
              toState: "ternaryMid",
              handler: h2.ternaryStart
            }
          },
          completable: true
        },
        expectTransform: {
          tokenTypes: {
            identifier: {
              toState: "postTransform",
              handler: h2.transform
            }
          }
        },
        expectObjKey: {
          tokenTypes: {
            identifier: {
              toState: "expectKeyValSep",
              handler: h2.objKey
            },
            closeCurl: {
              toState: "expectBinOp"
            }
          }
        },
        expectKeyValSep: {
          tokenTypes: {
            colon: {
              toState: "objVal"
            }
          }
        },
        postTransform: {
          tokenTypes: {
            openParen: {
              toState: "argVal"
            },
            binaryOp: {
              toState: "expectOperand"
            },
            dot: {
              toState: "traverse"
            },
            openBracket: {
              toState: "filter"
            },
            pipe: {
              toState: "expectTransform"
            }
          },
          completable: true
        },
        postArgs: {
          tokenTypes: {
            binaryOp: {
              toState: "expectOperand"
            },
            dot: {
              toState: "traverse"
            },
            openBracket: {
              toState: "filter"
            },
            pipe: {
              toState: "expectTransform"
            }
          },
          completable: true
        },
        identifier: {
          tokenTypes: {
            binaryOp: {
              toState: "expectOperand"
            },
            dot: {
              toState: "traverse"
            },
            openBracket: {
              toState: "filter"
            },
            openParen: {
              toState: "argVal",
              handler: h2.functionCall
            },
            pipe: {
              toState: "expectTransform"
            },
            question: {
              toState: "ternaryMid",
              handler: h2.ternaryStart
            }
          },
          completable: true
        },
        traverse: {
          tokenTypes: {
            identifier: {
              toState: "identifier"
            }
          }
        },
        filter: {
          subHandler: h2.filter,
          endStates: {
            closeBracket: "identifier"
          }
        },
        subExpression: {
          subHandler: h2.subExpression,
          endStates: {
            closeParen: "expectBinOp"
          }
        },
        argVal: {
          subHandler: h2.argVal,
          endStates: {
            comma: "argVal",
            closeParen: "postArgs"
          }
        },
        objVal: {
          subHandler: h2.objVal,
          endStates: {
            comma: "expectObjKey",
            closeCurl: "expectBinOp"
          }
        },
        arrayVal: {
          subHandler: h2.arrayVal,
          endStates: {
            comma: "arrayVal",
            closeBracket: "expectBinOp"
          }
        },
        ternaryMid: {
          subHandler: h2.ternaryMid,
          endStates: {
            colon: "ternaryEnd"
          }
        },
        ternaryEnd: {
          subHandler: h2.ternaryEnd,
          completable: true
        }
      };
    }
  });

  // node_modules/jexl/dist/parser/Parser.js
  var require_Parser = __commonJS({
    "node_modules/jexl/dist/parser/Parser.js"(exports, module) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var handlers = require_handlers2();
      var states = require_states().states;
      var Parser = /* @__PURE__ */ (function() {
        function Parser2(grammar, prefix2, stopMap) {
          (0, _classCallCheck2.default)(this, Parser2);
          this._grammar = grammar;
          this._state = "expectOperand";
          this._tree = null;
          this._exprStr = prefix2 || "";
          this._relative = false;
          this._stopMap = stopMap || {};
        }
        (0, _createClass2.default)(Parser2, [{
          key: "addToken",
          value: function addToken(token2) {
            if (this._state === "complete") {
              throw new Error("Cannot add a new token to a completed Parser");
            }
            var state = states[this._state];
            var startExpr = this._exprStr;
            this._exprStr += token2.raw;
            if (state.subHandler) {
              if (!this._subParser) {
                this._startSubExpression(startExpr);
              }
              var stopState = this._subParser.addToken(token2);
              if (stopState) {
                this._endSubExpression();
                if (this._parentStop) return stopState;
                this._state = stopState;
              }
            } else if (state.tokenTypes[token2.type]) {
              var typeOpts = state.tokenTypes[token2.type];
              var handleFunc = handlers[token2.type];
              if (typeOpts.handler) {
                handleFunc = typeOpts.handler;
              }
              if (handleFunc) {
                handleFunc.call(this, token2);
              }
              if (typeOpts.toState) {
                this._state = typeOpts.toState;
              }
            } else if (this._stopMap[token2.type]) {
              return this._stopMap[token2.type];
            } else {
              throw new Error("Token ".concat(token2.raw, " (").concat(token2.type, ") unexpected in expression: ").concat(this._exprStr));
            }
            return false;
          }
          /**
           * Processes an array of tokens iteratively through the {@link #addToken}
           * function.
           * @param {Array<{type: <string>}>} tokens An array of tokens, as provided by
           *      the {@link Lexer#tokenize} function.
           */
        }, {
          key: "addTokens",
          value: function addTokens(tokens) {
            tokens.forEach(this.addToken, this);
          }
          /**
           * Marks this Parser instance as completed and retrieves the full AST.
           * @returns {{}|null} a full expression tree, ready for evaluation by the
           *      {@link Evaluator#eval} function, or null if no tokens were passed to
           *      the parser before complete was called
           * @throws {Error} if the parser is not in a state where it's legal to end
           *      the expression, indicating that the expression is incomplete
           */
        }, {
          key: "complete",
          value: function complete() {
            if (this._cursor && !states[this._state].completable) {
              throw new Error("Unexpected end of expression: ".concat(this._exprStr));
            }
            if (this._subParser) {
              this._endSubExpression();
            }
            this._state = "complete";
            return this._cursor ? this._tree : null;
          }
          /**
           * Indicates whether the expression tree contains a relative path identifier.
           * @returns {boolean} true if a relative identifier exists false otherwise.
           */
        }, {
          key: "isRelative",
          value: function isRelative() {
            return this._relative;
          }
          /**
           * Ends a subexpression by completing the subParser and passing its result
           * to the subHandler configured in the current state.
           * @private
           */
        }, {
          key: "_endSubExpression",
          value: function _endSubExpression() {
            states[this._state].subHandler.call(this, this._subParser.complete());
            this._subParser = null;
          }
          /**
           * Places a new tree node at the current position of the cursor (to the 'right'
           * property) and then advances the cursor to the new node. This function also
           * handles setting the parent of the new node.
           * @param {{type: <string>}} node A node to be added to the AST
           * @private
           */
        }, {
          key: "_placeAtCursor",
          value: function _placeAtCursor(node2) {
            if (!this._cursor) {
              this._tree = node2;
            } else {
              this._cursor.right = node2;
              this._setParent(node2, this._cursor);
            }
            this._cursor = node2;
          }
          /**
           * Places a tree node before the current position of the cursor, replacing
           * the node that the cursor currently points to. This should only be called in
           * cases where the cursor is known to exist, and the provided node already
           * contains a pointer to what's at the cursor currently.
           * @param {{type: <string>}} node A node to be added to the AST
           * @private
           */
        }, {
          key: "_placeBeforeCursor",
          value: function _placeBeforeCursor(node2) {
            this._cursor = this._cursor._parent;
            this._placeAtCursor(node2);
          }
          /**
           * Sets the parent of a node by creating a non-enumerable _parent property
           * that points to the supplied parent argument.
           * @param {{type: <string>}} node A node of the AST on which to set a new
           *      parent
           * @param {{type: <string>}} parent An existing node of the AST to serve as the
           *      parent of the new node
           * @private
           */
        }, {
          key: "_setParent",
          value: function _setParent(node2, parent) {
            Object.defineProperty(node2, "_parent", {
              value: parent,
              writable: true
            });
          }
          /**
           * Prepares the Parser to accept a subexpression by (re)instantiating the
           * subParser.
           * @param {string} [exprStr] The expression string to prefix to the new Parser
           * @private
           */
        }, {
          key: "_startSubExpression",
          value: function _startSubExpression(exprStr) {
            var endStates = states[this._state].endStates;
            if (!endStates) {
              this._parentStop = true;
              endStates = this._stopMap;
            }
            this._subParser = new Parser2(this._grammar, exprStr, endStates);
          }
        }]);
        return Parser2;
      })();
      module.exports = Parser;
    }
  });

  // node_modules/jexl/dist/PromiseSync.js
  var require_PromiseSync = __commonJS({
    "node_modules/jexl/dist/PromiseSync.js"(exports, module) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var PromiseSync = /* @__PURE__ */ (function() {
        function PromiseSync2(fn) {
          (0, _classCallCheck2.default)(this, PromiseSync2);
          fn(this._resolve.bind(this), this._reject.bind(this));
        }
        (0, _createClass2.default)(PromiseSync2, [{
          key: "catch",
          value: function _catch(rejected) {
            if (this.error) {
              try {
                this._resolve(rejected(this.error));
              } catch (e2) {
                this._reject(e2);
              }
            }
            return this;
          }
        }, {
          key: "then",
          value: function then(resolved, rejected) {
            if (!this.error) {
              try {
                this._resolve(resolved(this.value));
              } catch (e2) {
                this._reject(e2);
              }
            }
            if (rejected) this.catch(rejected);
            return this;
          }
        }, {
          key: "_reject",
          value: function _reject(error2) {
            this.value = void 0;
            this.error = error2;
          }
        }, {
          key: "_resolve",
          value: function _resolve(val) {
            if (val instanceof PromiseSync2) {
              if (val.error) {
                this._reject(val.error);
              } else {
                this._resolve(val.value);
              }
            } else {
              this.value = val;
              this.error = void 0;
            }
          }
        }]);
        return PromiseSync2;
      })();
      PromiseSync.all = function(vals) {
        return new PromiseSync(function(resolve) {
          var resolved = vals.map(function(val) {
            while (val instanceof PromiseSync) {
              if (val.error) throw Error(val.error);
              val = val.value;
            }
            return val;
          });
          resolve(resolved);
        });
      };
      PromiseSync.resolve = function(val) {
        return new PromiseSync(function(resolve) {
          return resolve(val);
        });
      };
      PromiseSync.reject = function(error2) {
        return new PromiseSync(function(resolve, reject) {
          return reject(error2);
        });
      };
      module.exports = PromiseSync;
    }
  });

  // node_modules/jexl/dist/Expression.js
  var require_Expression = __commonJS({
    "node_modules/jexl/dist/Expression.js"(exports, module) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var Evaluator = require_Evaluator();
      var Lexer = require_Lexer();
      var Parser = require_Parser();
      var PromiseSync = require_PromiseSync();
      var Expression = /* @__PURE__ */ (function() {
        function Expression2(grammar, exprStr) {
          (0, _classCallCheck2.default)(this, Expression2);
          this._grammar = grammar;
          this._exprStr = exprStr;
          this._ast = null;
        }
        (0, _createClass2.default)(Expression2, [{
          key: "compile",
          value: function compile2() {
            var lexer = new Lexer(this._grammar);
            var parser = new Parser(this._grammar);
            var tokens = lexer.tokenize(this._exprStr);
            parser.addTokens(tokens);
            this._ast = parser.complete();
            return this;
          }
          /**
           * Asynchronously evaluates the expression within an optional context.
           * @param {Object} [context] A mapping of variables to values, which will be
           *      made accessible to the Jexl expression when evaluating it
           * @returns {Promise<*>} resolves with the result of the evaluation.
           */
        }, {
          key: "eval",
          value: function _eval() {
            var context2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            return this._eval(context2, Promise);
          }
          /**
           * Synchronously evaluates the expression within an optional context.
           * @param {Object} [context] A mapping of variables to values, which will be
           *      made accessible to the Jexl expression when evaluating it
           * @returns {*} the result of the evaluation.
           * @throws {*} on error
           */
        }, {
          key: "evalSync",
          value: function evalSync() {
            var context2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            var res = this._eval(context2, PromiseSync);
            if (res.error) throw res.error;
            return res.value;
          }
        }, {
          key: "_eval",
          value: function _eval(context2, promise) {
            var _this = this;
            return promise.resolve().then(function() {
              var ast = _this._getAst();
              var evaluator = new Evaluator(_this._grammar, context2, void 0, promise);
              return evaluator.eval(ast);
            });
          }
        }, {
          key: "_getAst",
          value: function _getAst() {
            if (!this._ast) this.compile();
            return this._ast;
          }
        }]);
        return Expression2;
      })();
      module.exports = Expression;
    }
  });

  // node_modules/jexl/dist/grammar.js
  var require_grammar = __commonJS({
    "node_modules/jexl/dist/grammar.js"(exports) {
      "use strict";
      exports.getGrammar = function() {
        return {
          /**
           * A map of all expression elements to their properties. Note that changes
           * here may require changes in the Lexer or Parser.
           * @type {{}}
           */
          elements: {
            ".": {
              type: "dot"
            },
            "[": {
              type: "openBracket"
            },
            "]": {
              type: "closeBracket"
            },
            "|": {
              type: "pipe"
            },
            "{": {
              type: "openCurl"
            },
            "}": {
              type: "closeCurl"
            },
            ":": {
              type: "colon"
            },
            ",": {
              type: "comma"
            },
            "(": {
              type: "openParen"
            },
            ")": {
              type: "closeParen"
            },
            "?": {
              type: "question"
            },
            "+": {
              type: "binaryOp",
              precedence: 30,
              eval: function _eval(left, right) {
                return left + right;
              }
            },
            "-": {
              type: "binaryOp",
              precedence: 30,
              eval: function _eval(left, right) {
                return left - right;
              }
            },
            "*": {
              type: "binaryOp",
              precedence: 40,
              eval: function _eval(left, right) {
                return left * right;
              }
            },
            "/": {
              type: "binaryOp",
              precedence: 40,
              eval: function _eval(left, right) {
                return left / right;
              }
            },
            "//": {
              type: "binaryOp",
              precedence: 40,
              eval: function _eval(left, right) {
                return Math.floor(left / right);
              }
            },
            "%": {
              type: "binaryOp",
              precedence: 50,
              eval: function _eval(left, right) {
                return left % right;
              }
            },
            "^": {
              type: "binaryOp",
              precedence: 50,
              eval: function _eval(left, right) {
                return Math.pow(left, right);
              }
            },
            "==": {
              type: "binaryOp",
              precedence: 20,
              eval: function _eval(left, right) {
                return left == right;
              }
            },
            "!=": {
              type: "binaryOp",
              precedence: 20,
              eval: function _eval(left, right) {
                return left != right;
              }
            },
            ">": {
              type: "binaryOp",
              precedence: 20,
              eval: function _eval(left, right) {
                return left > right;
              }
            },
            ">=": {
              type: "binaryOp",
              precedence: 20,
              eval: function _eval(left, right) {
                return left >= right;
              }
            },
            "<": {
              type: "binaryOp",
              precedence: 20,
              eval: function _eval(left, right) {
                return left < right;
              }
            },
            "<=": {
              type: "binaryOp",
              precedence: 20,
              eval: function _eval(left, right) {
                return left <= right;
              }
            },
            "&&": {
              type: "binaryOp",
              precedence: 10,
              evalOnDemand: function evalOnDemand(left, right) {
                return left.eval().then(function(leftVal) {
                  if (!leftVal) return leftVal;
                  return right.eval();
                });
              }
            },
            "||": {
              type: "binaryOp",
              precedence: 10,
              evalOnDemand: function evalOnDemand(left, right) {
                return left.eval().then(function(leftVal) {
                  if (leftVal) return leftVal;
                  return right.eval();
                });
              }
            },
            in: {
              type: "binaryOp",
              precedence: 20,
              eval: function _eval(left, right) {
                if (typeof right === "string") {
                  return right.indexOf(left) !== -1;
                }
                if (Array.isArray(right)) {
                  return right.some(function(elem) {
                    return elem === left;
                  });
                }
                return false;
              }
            },
            "!": {
              type: "unaryOp",
              precedence: Infinity,
              eval: function _eval(right) {
                return !right;
              }
            }
          },
          /**
           * A map of function names to javascript functions. A Jexl function
           * takes zero ore more arguemnts:
           *
           *     - {*} ...args: A variable number of arguments passed to this function.
           *       All of these are pre-evaluated to their actual values before calling
           *       the function.
           *
           * The Jexl function should return either the transformed value, or
           * a Promises/A+ Promise object that resolves with the value and rejects
           * or throws only when an unrecoverable error occurs. Functions should
           * generally return undefined when they don't make sense to be used on the
           * given value type, rather than throw/reject. An error is only
           * appropriate when the function would normally return a value, but
           * cannot due to some other failure.
           */
          functions: {},
          /**
           * A map of transform names to transform functions. A transform function
           * takes one ore more arguemnts:
           *
           *     - {*} val: A value to be transformed
           *     - {*} ...args: A variable number of arguments passed to this transform.
           *       All of these are pre-evaluated to their actual values before calling
           *       the function.
           *
           * The transform function should return either the transformed value, or
           * a Promises/A+ Promise object that resolves with the value and rejects
           * or throws only when an unrecoverable error occurs. Transforms should
           * generally return undefined when they don't make sense to be used on the
           * given value type, rather than throw/reject. An error is only
           * appropriate when the transform would normally return a value, but
           * cannot due to some other failure.
           */
          transforms: {}
        };
      };
    }
  });

  // node_modules/jexl/dist/Jexl.js
  var require_Jexl = __commonJS({
    "node_modules/jexl/dist/Jexl.js"(exports, module) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault();
      var _defineProperty2 = _interopRequireDefault(require_defineProperty());
      var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
      var _createClass2 = _interopRequireDefault(require_createClass());
      var Expression = require_Expression();
      var _require = require_grammar();
      var getGrammar = _require.getGrammar;
      var Jexl = /* @__PURE__ */ (function() {
        function Jexl2() {
          (0, _classCallCheck2.default)(this, Jexl2);
          this.expr = this.expr.bind(this);
          this._grammar = getGrammar();
        }
        (0, _createClass2.default)(Jexl2, [{
          key: "addBinaryOp",
          value: function addBinaryOp(operator, precedence, fn, manualEval) {
            this._addGrammarElement(operator, (0, _defineProperty2.default)({
              type: "binaryOp",
              precedence
            }, manualEval ? "evalOnDemand" : "eval", fn));
          }
          /**
           * Adds or replaces an expression function in this Jexl instance.
           * @param {string} name The name of the expression function, as it will be
           *      used within Jexl expressions
           * @param {function} fn The javascript function to be executed when this
           *      expression function is invoked. It will be provided with each argument
           *      supplied in the expression, in the same order.
           */
        }, {
          key: "addFunction",
          value: function addFunction(name, fn) {
            this._grammar.functions[name] = fn;
          }
          /**
           * Syntactic sugar for calling {@link #addFunction} repeatedly. This function
           * accepts a map of one or more expression function names to their javascript
           * function counterpart.
           * @param {{}} map A map of expression function names to javascript functions
           */
        }, {
          key: "addFunctions",
          value: function addFunctions(map) {
            for (var key in map) {
              this._grammar.functions[key] = map[key];
            }
          }
          /**
           * Adds a unary operator to Jexl. Unary operators are currently only supported
           * on the left side of the value on which it will operate.
           * @param {string} operator The operator string to be added
           * @param {function} fn A function to run to calculate the result. The function
           *      will be called with one argument: the literal value to the right of the
           *      operator. It should return either the resulting value, or a Promise
           *      that resolves with the resulting value.
           */
        }, {
          key: "addUnaryOp",
          value: function addUnaryOp(operator, fn) {
            this._addGrammarElement(operator, {
              type: "unaryOp",
              weight: Infinity,
              eval: fn
            });
          }
          /**
           * Adds or replaces a transform function in this Jexl instance.
           * @param {string} name The name of the transform function, as it will be used
           *      within Jexl expressions
           * @param {function} fn The function to be executed when this transform is
           *      invoked. It will be provided with at least one argument:
           *          - {*} value: The value to be transformed
           *          - {...*} args: The arguments for this transform
           */
        }, {
          key: "addTransform",
          value: function addTransform(name, fn) {
            this._grammar.transforms[name] = fn;
          }
          /**
           * Syntactic sugar for calling {@link #addTransform} repeatedly.  This function
           * accepts a map of one or more transform names to their transform function.
           * @param {{}} map A map of transform names to transform functions
           */
        }, {
          key: "addTransforms",
          value: function addTransforms(map) {
            for (var key in map) {
              this._grammar.transforms[key] = map[key];
            }
          }
          /**
           * Creates an Expression object from the given Jexl expression string, and
           * immediately compiles it. The returned Expression object can then be
           * evaluated multiple times with new contexts, without generating any
           * additional string processing overhead.
           * @param {string} expression The Jexl expression to be compiled
           * @returns {Expression} The compiled Expression object
           */
        }, {
          key: "compile",
          value: function compile2(expression) {
            var exprObj = this.createExpression(expression);
            return exprObj.compile();
          }
          /**
           * Constructs an Expression object from a Jexl expression string.
           * @param {string} expression The Jexl expression to be wrapped in an
           *    Expression object
           * @returns {Expression} The Expression object representing the given string
           */
        }, {
          key: "createExpression",
          value: function createExpression(expression) {
            return new Expression(this._grammar, expression);
          }
          /**
           * Retrieves a previously set expression function.
           * @param {string} name The name of the expression function
           * @returns {function} The expression function
           */
        }, {
          key: "getFunction",
          value: function getFunction(name) {
            return this._grammar.functions[name];
          }
          /**
           * Retrieves a previously set transform function.
           * @param {string} name The name of the transform function
           * @returns {function} The transform function
           */
        }, {
          key: "getTransform",
          value: function getTransform(name) {
            return this._grammar.transforms[name];
          }
          /**
           * Asynchronously evaluates a Jexl string within an optional context.
           * @param {string} expression The Jexl expression to be evaluated
           * @param {Object} [context] A mapping of variables to values, which will be
           *      made accessible to the Jexl expression when evaluating it
           * @returns {Promise<*>} resolves with the result of the evaluation.
           */
        }, {
          key: "eval",
          value: function _eval(expression) {
            var context2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var exprObj = this.createExpression(expression);
            return exprObj.eval(context2);
          }
          /**
           * Synchronously evaluates a Jexl string within an optional context.
           * @param {string} expression The Jexl expression to be evaluated
           * @param {Object} [context] A mapping of variables to values, which will be
           *      made accessible to the Jexl expression when evaluating it
           * @returns {*} the result of the evaluation.
           * @throws {*} on error
           */
        }, {
          key: "evalSync",
          value: function evalSync(expression) {
            var context2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var exprObj = this.createExpression(expression);
            return exprObj.evalSync(context2);
          }
          /**
           * A JavaScript template literal to allow expressions to be defined by the
           * syntax: expr`40 + 2`
           * @param {Array<string>} strs
           * @param  {...any} args
           */
        }, {
          key: "expr",
          value: function expr(strs) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            var exprStr = strs.reduce(function(acc, str, idx) {
              var arg = idx < args.length ? args[idx] : "";
              acc += str + arg;
              return acc;
            }, "");
            return this.createExpression(exprStr);
          }
          /**
           * Removes a binary or unary operator from the Jexl grammar.
           * @param {string} operator The operator string to be removed
           */
        }, {
          key: "removeOp",
          value: function removeOp(operator) {
            if (this._grammar.elements[operator] && (this._grammar.elements[operator].type === "binaryOp" || this._grammar.elements[operator].type === "unaryOp")) {
              delete this._grammar.elements[operator];
            }
          }
          /**
           * Adds an element to the grammar map used by this Jexl instance.
           * @param {string} str The key string to be added
           * @param {{type: <string>}} obj A map of configuration options for this
           *      grammar element
           * @private
           */
        }, {
          key: "_addGrammarElement",
          value: function _addGrammarElement(str, obj) {
            this._grammar.elements[str] = obj;
          }
        }]);
        return Jexl2;
      })();
      module.exports = new Jexl();
      module.exports.Jexl = Jexl;
    }
  });

  // node_modules/@jbrowse/core/util/jexl.js
  var require_jexl = __commonJS({
    "node_modules/@jbrowse/core/util/jexl.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = JexlF;
      var jexl_1 = __importDefault(require_Jexl());
      function JexlF() {
        const j2 = new jexl_1.default.Jexl();
        j2.addFunction("get", (feature, data) => feature.get(data));
        j2.addFunction("parent", (feature) => feature.parent());
        j2.addFunction("id", (feature) => feature.id());
        j2.addFunction("cast", (arg) => arg);
        j2.addFunction("log", (thing) => {
          console.log(thing);
          return thing;
        });
        j2.addFunction("max", Math.max);
        j2.addFunction("min", Math.min);
        j2.addFunction("sqrt", Math.sqrt);
        j2.addFunction("ceil", Math.ceil);
        j2.addFunction("floor", Math.floor);
        j2.addFunction("round", Math.round);
        j2.addFunction("abs", Math.abs);
        j2.addFunction("log10", Math.log10);
        j2.addFunction("parseInt", Number.parseInt);
        j2.addFunction("parseFloat", Number.parseFloat);
        j2.addFunction("split", (s2, char2) => s2.split(char2));
        j2.addFunction("join", (k2, ...args) => [...args].filter((f2) => !!f2).join(k2));
        j2.addFunction("charAt", (s2, index3) => s2.charAt(index3));
        j2.addFunction("charCodeAt", (s2, index3) => s2.charCodeAt(index3));
        j2.addFunction("codePointAt", (s2, pos) => s2.codePointAt(pos));
        j2.addFunction("startsWith", (s2, search, len2) => s2.startsWith(search, len2));
        j2.addFunction("endsWith", (s2, search, len2) => s2.endsWith(search, len2));
        j2.addFunction("padEnd", (s2, len2, pad) => s2.padEnd(len2, pad));
        j2.addFunction("padStart", (s2, len2, fill) => s2.padStart(len2, fill));
        j2.addFunction("repeat", (s2, count3) => s2.repeat(count3));
        j2.addFunction("replace", (s2, match2, sub) => s2.replace(match2, sub));
        j2.addFunction("replaceAll", (s2, match2, sub) => s2.replaceAll(match2, sub));
        j2.addFunction("slice", (s2, start, end) => s2.slice(start, end));
        j2.addFunction("startsWith", (s2, search, pos) => s2.startsWith(search, pos));
        j2.addFunction("substring", (s2, start, end) => s2.substring(start, end));
        j2.addFunction("toLowerCase", (s2) => s2.toLowerCase());
        j2.addFunction("toUpperCase", (s2) => s2.toUpperCase());
        j2.addFunction("jsonParse", (s2) => JSON.parse(s2));
        j2.addFunction("trim", (s2) => s2.trim());
        j2.addFunction("trimEnd", (s2) => s2.trimEnd());
        j2.addFunction("trimStart", (s2) => s2.trimStart());
        j2.addFunction("getTag", (feature, s2) => {
          const tags = feature.get("tags");
          return tags ? tags[s2] : feature.get(s2);
        });
        j2.addBinaryOp("&", 15, (a2, b2) => a2 & b2);
        return j2;
      }
    }
  });

  // node_modules/@jbrowse/core/util/jexlStrings.js
  var require_jexlStrings = __commonJS({
    "node_modules/@jbrowse/core/util/jexlStrings.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.stringToJexlExpression = stringToJexlExpression;
      var jexl_1 = __importDefault(require_jexl());
      var compilationCache = {};
      function stringToJexlExpression(str, jexl) {
        const cacheKey = `nosig|${str}`;
        if (!compilationCache[cacheKey]) {
          const match2 = str.startsWith("jexl:");
          if (!match2) {
            throw new Error("string does not appear to be in jexl format");
          }
          const code = str.split("jexl:")[1];
          const compiled = jexl ? jexl.compile(code) : (0, jexl_1.default)().compile(code);
          compilationCache[cacheKey] = compiled;
        }
        return compilationCache[cacheKey];
      }
    }
  });

  // node_modules/@jbrowse/core/util/nanoid.js
  var require_nanoid = __commonJS({
    "node_modules/@jbrowse/core/util/nanoid.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.nanoid = exports.customAlphabet = exports.customRandom = exports.random = exports.urlAlphabet = void 0;
      exports.urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
      var random = (bytes) => crypto.getRandomValues(new Uint8Array(bytes));
      exports.random = random;
      var customRandom = (alphabet, defaultSize, getRandom) => {
        const mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
        const step = -~(1.6 * mask * defaultSize / alphabet.length);
        return (size4 = defaultSize) => {
          let id = "";
          while (true) {
            const bytes = getRandom(step);
            let j2 = step;
            while (j2--) {
              id += alphabet[bytes[j2] & mask] || "";
              if (id.length === size4) {
                return id;
              }
            }
          }
        };
      };
      exports.customRandom = customRandom;
      var customAlphabet = (alphabet, size4 = 21) => (0, exports.customRandom)(alphabet, size4, exports.random);
      exports.customAlphabet = customAlphabet;
      var nanoid = (size4 = 21) => crypto.getRandomValues(new Uint8Array(size4)).reduce((id, byte) => {
        byte &= 63;
        if (byte < 36) {
          id += byte.toString(36);
        } else if (byte < 62) {
          id += (byte - 26).toString(36).toUpperCase();
        } else if (byte > 62) {
          id += "-";
        } else {
          id += "_";
        }
        return id;
      }, "");
      exports.nanoid = nanoid;
    }
  });

  // node_modules/@jbrowse/core/util/types/mst.js
  var require_mst = __commonJS({
    "node_modules/@jbrowse/core/util/types/mst.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FileLocation = exports.UriLocation = exports.UriLocationRaw = exports.BlobLocation = exports.LocalPathLocation = exports.Region = exports.NoAssemblyRegion = exports.ElementId = void 0;
      var mobx_state_tree_1 = require_mobx_state_tree();
      var nanoid_1 = require_nanoid();
      exports.ElementId = mobx_state_tree_1.types.optional(mobx_state_tree_1.types.identifier, () => (0, nanoid_1.nanoid)());
      exports.NoAssemblyRegion = mobx_state_tree_1.types.model("NoAssemblyRegion", {
        refName: mobx_state_tree_1.types.string,
        start: mobx_state_tree_1.types.number,
        end: mobx_state_tree_1.types.number,
        reversed: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.boolean, false)
      }).actions((self2) => ({
        setRefName(newRefName) {
          self2.refName = newRefName;
        }
      }));
      exports.Region = mobx_state_tree_1.types.compose("Region", exports.NoAssemblyRegion, mobx_state_tree_1.types.model({
        assemblyName: mobx_state_tree_1.types.string
      }));
      exports.LocalPathLocation = mobx_state_tree_1.types.model("LocalPathLocation", {
        locationType: mobx_state_tree_1.types.literal("LocalPathLocation"),
        localPath: mobx_state_tree_1.types.string
      });
      exports.BlobLocation = mobx_state_tree_1.types.model("BlobLocation", {
        locationType: mobx_state_tree_1.types.literal("BlobLocation"),
        name: mobx_state_tree_1.types.string,
        blobId: mobx_state_tree_1.types.string
      });
      exports.UriLocationRaw = mobx_state_tree_1.types.model("UriLocation", {
        locationType: mobx_state_tree_1.types.literal("UriLocation"),
        uri: mobx_state_tree_1.types.string,
        baseUri: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.string),
        internetAccountId: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.string),
        internetAccountPreAuthorization: mobx_state_tree_1.types.maybe(mobx_state_tree_1.types.model("InternetAccountPreAuthorization", {
          internetAccountType: mobx_state_tree_1.types.string,
          authInfo: mobx_state_tree_1.types.frozen()
        }))
      });
      exports.UriLocation = mobx_state_tree_1.types.snapshotProcessor(exports.UriLocationRaw, {
        postProcessor: (snap) => {
          const { baseUri, ...rest } = snap;
          if (!baseUri) {
            return rest;
          }
          return snap;
        }
      });
      exports.FileLocation = mobx_state_tree_1.types.snapshotProcessor(mobx_state_tree_1.types.union(exports.LocalPathLocation, exports.UriLocation, exports.BlobLocation), {
        preProcessor(snap) {
          if (!snap) {
            return void 0;
          }
          const { locationType, ...rest } = snap;
          if (!locationType) {
            const { uri, localPath, blob } = rest;
            let locationType2 = "";
            if (uri !== void 0) {
              locationType2 = "UriLocation";
            } else if (localPath !== void 0) {
              locationType2 = "LocalPathLocation";
            } else if (blob !== void 0) {
              locationType2 = "BlobLocation";
            }
            return { ...rest, locationType: locationType2 };
          }
          return snap;
        }
      });
    }
  });

  // node_modules/@jbrowse/core/configuration/configurationSlot.js
  var require_configurationSlot = __commonJS({
    "node_modules/@jbrowse/core/configuration/configurationSlot.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = ConfigSlot;
      var mobx_state_tree_1 = require_mobx_state_tree();
      var util_1 = require_util5();
      var jexlStrings_1 = require_jexlStrings();
      var mst_1 = require_mst();
      function isValidColorString() {
        return true;
      }
      var typeModels = {
        stringArray: mobx_state_tree_1.types.array(mobx_state_tree_1.types.string),
        stringArrayMap: mobx_state_tree_1.types.map(mobx_state_tree_1.types.array(mobx_state_tree_1.types.string)),
        numberMap: mobx_state_tree_1.types.map(mobx_state_tree_1.types.number),
        boolean: mobx_state_tree_1.types.boolean,
        color: mobx_state_tree_1.types.refinement("Color", mobx_state_tree_1.types.string, isValidColorString),
        integer: mobx_state_tree_1.types.integer,
        number: mobx_state_tree_1.types.number,
        string: mobx_state_tree_1.types.string,
        text: mobx_state_tree_1.types.string,
        fileLocation: mst_1.FileLocation,
        frozen: mobx_state_tree_1.types.frozen()
      };
      var fallbackDefaults = {
        stringArray: [],
        stringArrayMap: {},
        numberMap: {},
        boolean: true,
        color: "black",
        integer: 1,
        number: 1,
        string: "",
        text: "",
        fileLocation: { uri: "/path/to/resource.txt", locationType: "UriLocation" },
        frozen: {}
      };
      var literalJSON = (self2) => ({
        views: {
          get valueJSON() {
            return self2.value;
          }
        }
      });
      var objectJSON = (self2) => ({
        views: {
          get valueJSON() {
            return JSON.stringify(self2.value);
          }
        }
      });
      var typeModelExtensions = {
        fileLocation: objectJSON,
        number: literalJSON,
        integer: literalJSON,
        boolean: literalJSON,
        frozen: objectJSON,
        stringArray: (self2) => ({
          views: {
            get valueJSON() {
              return JSON.stringify(self2.value);
            }
          },
          actions: {
            add(val) {
              self2.value.push(val);
            },
            removeAtIndex(idx) {
              self2.value.splice(idx, 1);
            },
            setAtIndex(idx, val) {
              self2.value[idx] = val;
            }
          }
        }),
        stringArrayMap: (self2) => ({
          views: {
            get valueJSON() {
              return JSON.stringify(self2.value);
            }
          },
          actions: {
            add(key, val) {
              self2.value.set(key, val);
            },
            remove(key) {
              self2.value.delete(key);
            },
            addToKey(key, val) {
              const ar = self2.value.get(key);
              if (!ar) {
                throw new Error(`${key} not found`);
              }
              ar.push(val);
            },
            removeAtKeyIndex(key, idx) {
              const ar = self2.value.get(key);
              if (!ar) {
                throw new Error(`${key} not found`);
              }
              ar.splice(idx, 1);
            },
            setAtKeyIndex(key, idx, val) {
              const ar = self2.value.get(key);
              if (!ar) {
                throw new Error(`${key} not found`);
              }
              ar[idx] = val;
            }
          }
        }),
        numberMap: (self2) => ({
          views: {
            get valueJSON() {
              return JSON.stringify(self2.value);
            }
          },
          actions: {
            add(key, val) {
              self2.value.set(key, val);
            },
            remove(key) {
              self2.value.delete(key);
            }
          }
        })
      };
      var JexlStringType = mobx_state_tree_1.types.refinement("JexlString", mobx_state_tree_1.types.string, (str) => str.startsWith("jexl:"));
      function json(value) {
        return (value === null || value === void 0 ? void 0 : value.toJSON) ? value.toJSON() : `"${value}"`;
      }
      function ConfigSlot(slotName, { description = "", model, type, defaultValue, contextVariable = [] }) {
        if (!type) {
          throw new Error("type name required");
        }
        if (!model) {
          model = typeModels[type];
        }
        if (!model) {
          throw new Error(`no builtin config slot type "${type}", and no 'model' param provided`);
        }
        if (defaultValue === void 0) {
          throw new Error("no 'defaultValue' provided");
        }
        const configSlotModelName = `${slotName.charAt(0).toUpperCase()}${slotName.slice(1)}ConfigSlot`;
        let slot = mobx_state_tree_1.types.model(configSlotModelName, {
          name: mobx_state_tree_1.types.literal(slotName),
          description: mobx_state_tree_1.types.literal(description),
          type: mobx_state_tree_1.types.literal(type),
          value: mobx_state_tree_1.types.optional(mobx_state_tree_1.types.union(JexlStringType, model), defaultValue)
        }).volatile(() => ({
          contextVariable
        })).views((self2) => ({
          get isCallback() {
            return String(self2.value).startsWith("jexl:");
          }
        })).views((self2) => ({
          get expr() {
            if (self2.isCallback) {
              const { pluginManager } = (0, util_1.getEnv)(self2);
              if (!pluginManager && typeof jest === "undefined") {
                console.warn("no pluginManager detected on config env (if you dynamically instantiate a config, for example in renderProps for your display model, check that you add the env argument)");
              }
              return (0, jexlStrings_1.stringToJexlExpression)(String(self2.value), pluginManager === null || pluginManager === void 0 ? void 0 : pluginManager.jexl);
            }
            return { evalSync: () => self2.value };
          },
          get valueJSON() {
            if (self2.isCallback) {
              return void 0;
            }
            return json(self2.value);
          }
        })).preProcessSnapshot((val) => typeof val === "object" && val.name === slotName ? val : {
          name: slotName,
          description,
          type,
          value: val
        }).postProcessSnapshot((snap) => {
          if (typeof snap.value === "object") {
            return JSON.stringify(snap.value) !== JSON.stringify(defaultValue) ? snap.value : void 0;
          }
          return snap.value !== defaultValue ? snap.value : void 0;
        }).actions((self2) => ({
          set(newVal) {
            self2.value = newVal;
          },
          reset() {
            self2.value = defaultValue;
          },
          convertToCallback() {
            if (self2.isCallback) {
              return;
            }
            self2.value = `jexl:${self2.valueJSON || "''"}`;
          },
          convertToValue() {
            if (!self2.isCallback) {
              return;
            }
            try {
              const funcResult = self2.expr.evalSync();
              if (funcResult !== void 0) {
                self2.value = funcResult;
                return;
              }
            } catch (e2) {
            }
            self2.value = defaultValue;
            if (!(type in fallbackDefaults)) {
              throw new Error(`no fallbackDefault defined for type ${type}`);
            }
            self2.value = fallbackDefaults[type];
          }
        }));
        if (typeModelExtensions[type]) {
          slot = slot.extend(typeModelExtensions[type]);
        }
        const completeModel = mobx_state_tree_1.types.optional(slot, {
          name: slotName,
          type,
          description,
          value: defaultValue
        });
        const m2 = completeModel;
        Object.defineProperty(m2, "isJBrowseConfigurationSlot", { value: true });
        return m2;
      }
    }
  });

  // node_modules/@jbrowse/core/util/mst-reflection.js
  var require_mst_reflection = __commonJS({
    "node_modules/@jbrowse/core/util/mst-reflection.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getSubType = getSubType;
      exports.getUnionSubTypes = getUnionSubTypes;
      exports.getPropertyType = getPropertyType;
      exports.getDefaultValue = getDefaultValue;
      exports.getEnumerationValues = getEnumerationValues;
      exports.resolveLateType = resolveLateType;
      var mobx_state_tree_1 = require_mobx_state_tree();
      function getSubType(type) {
        let t2;
        if ((0, mobx_state_tree_1.isOptionalType)(type)) {
          t2 = type._subtype || type.type;
        } else if ((0, mobx_state_tree_1.isArrayType)(type) || (0, mobx_state_tree_1.isMapType)(type)) {
          t2 = type._subtype || type._subType || type.subType;
        } else if (typeof type.getSubType === "function") {
          return type.getSubType();
        } else {
          throw new TypeError("unsupported mst type");
        }
        if (!t2) {
          throw new Error("failed to get subtype");
        }
        return t2;
      }
      function getUnionSubTypes(unionType) {
        if (!(0, mobx_state_tree_1.isUnionType)(unionType)) {
          throw new TypeError("not an MST union type");
        }
        const t2 = unionType._types || unionType.types || getSubType(unionType)._types || getSubType(unionType).types;
        if (!t2) {
          throw new Error("failed to extract subtypes from mst union");
        }
        return t2;
      }
      function getPropertyType(type, propertyName) {
        return type.properties[propertyName];
      }
      function getDefaultValue(type) {
        if (!(0, mobx_state_tree_1.isOptionalType)(type)) {
          throw new TypeError("type must be an optional type");
        }
        return type._defaultValue || type.defaultValue;
      }
      function getEnumerationValues(type) {
        const subtypes = getUnionSubTypes(type);
        return subtypes.map((t2) => t2.value);
      }
      function resolveLateType(maybeLate) {
        if (!(0, mobx_state_tree_1.isUnionType)(maybeLate) && !(0, mobx_state_tree_1.isArrayType)(maybeLate) && (0, mobx_state_tree_1.isLateType)(maybeLate)) {
          return maybeLate.getSubType();
        }
        return maybeLate;
      }
    }
  });

  // node_modules/@jbrowse/core/configuration/util.js
  var require_util4 = __commonJS({
    "node_modules/@jbrowse/core/configuration/util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.readConfObject = readConfObject3;
      exports.getConf = getConf2;
      exports.getTypeNamesFromExplicitlyTypedUnion = getTypeNamesFromExplicitlyTypedUnion;
      exports.isBareConfigurationSchemaType = isBareConfigurationSchemaType;
      exports.isConfigurationSchemaType = isConfigurationSchemaType;
      exports.isConfigurationModel = isConfigurationModel;
      exports.isConfigurationSlotType = isConfigurationSlotType;
      var mobx_state_tree_1 = require_mobx_state_tree();
      var mst_reflection_1 = require_mst_reflection();
      function readConfObject3(confObject, slotPath, args = {}) {
        if (!slotPath) {
          return structuredClone((0, mobx_state_tree_1.getSnapshot)(confObject));
        } else if (typeof slotPath === "string") {
          let slot = confObject[slotPath];
          if (!slot && (0, mobx_state_tree_1.isStateTreeNode)(confObject) && (0, mobx_state_tree_1.isMapType)((0, mobx_state_tree_1.getType)(confObject))) {
            slot = confObject.get(slotPath);
          }
          if (!slot) {
            return void 0;
          } else {
            const val = slot.expr ? slot.expr.evalSync(args) : slot;
            return (0, mobx_state_tree_1.isStateTreeNode)(val) ? JSON.parse(JSON.stringify((0, mobx_state_tree_1.getSnapshot)(val))) : val;
          }
        } else if (Array.isArray(slotPath)) {
          const slotName = slotPath[0];
          if (slotPath.length > 1) {
            const newPath = slotPath.slice(1);
            let subConf = confObject[slotName];
            if (!subConf && (0, mobx_state_tree_1.isStateTreeNode)(confObject) && (0, mobx_state_tree_1.isMapType)((0, mobx_state_tree_1.getType)(confObject))) {
              subConf = confObject.get(slotName);
            }
            return subConf ? readConfObject3(subConf, newPath, args) : void 0;
          }
          return readConfObject3(confObject, slotName, args);
        }
        throw new TypeError("slotPath must be a string or array");
      }
      function getConf2(model, slotPath, args) {
        const { configuration } = model;
        if (isConfigurationModel(configuration)) {
          return readConfObject3(configuration, slotPath, args);
        }
        throw new TypeError("cannot getConf on this model, it has no configuration");
      }
      function getTypeNamesFromExplicitlyTypedUnion(maybeUnionType) {
        if ((0, mobx_state_tree_1.isType)(maybeUnionType)) {
          maybeUnionType = (0, mst_reflection_1.resolveLateType)(maybeUnionType);
          if ((0, mobx_state_tree_1.isUnionType)(maybeUnionType)) {
            const typeNames = [];
            for (let type of (0, mst_reflection_1.getUnionSubTypes)(maybeUnionType)) {
              type = (0, mst_reflection_1.resolveLateType)(type);
              let typeName = getTypeNamesFromExplicitlyTypedUnion(type);
              if (!typeName.length) {
                const def = (0, mst_reflection_1.getDefaultValue)(type);
                typeName = [def.type];
              }
              if (!typeName[0]) {
                throw new Error(`invalid config schema type ${type}`);
              }
              typeNames.push(...typeName);
            }
            return typeNames;
          }
        }
        return [];
      }
      function isBareConfigurationSchemaType(thing) {
        if ((0, mobx_state_tree_1.isType)(thing)) {
          if ((0, mobx_state_tree_1.isModelType)(thing) && ("isJBrowseConfigurationSchema" in thing || thing.name.includes("ConfigurationSchema"))) {
            return true;
          }
          if ((0, mobx_state_tree_1.isLateType)(thing)) {
            return true;
          }
        }
        return false;
      }
      function isConfigurationSchemaType(thing) {
        if (!(0, mobx_state_tree_1.isType)(thing)) {
          return false;
        } else if (isBareConfigurationSchemaType(thing)) {
          return true;
        } else if ((0, mobx_state_tree_1.isUnionType)(thing)) {
          return (0, mst_reflection_1.getUnionSubTypes)(thing).every((t2) => isConfigurationSchemaType(t2) || t2.name === "undefined");
        } else if ((0, mobx_state_tree_1.isOptionalType)(thing) && isConfigurationSchemaType((0, mst_reflection_1.getSubType)(thing))) {
          return true;
        } else if ((0, mobx_state_tree_1.isArrayType)(thing) && isConfigurationSchemaType((0, mst_reflection_1.getSubType)(thing))) {
          return true;
        } else if ((0, mobx_state_tree_1.isMapType)(thing) && isConfigurationSchemaType((0, mst_reflection_1.getSubType)(thing))) {
          return true;
        } else {
          return false;
        }
      }
      function isConfigurationModel(thing) {
        return (0, mobx_state_tree_1.isStateTreeNode)(thing) && isConfigurationSchemaType((0, mobx_state_tree_1.getType)(thing));
      }
      function isConfigurationSlotType(thing) {
        return typeof thing === "object" && thing !== null && "isJBrowseConfigurationSlot" in thing;
      }
    }
  });

  // node_modules/@jbrowse/core/configuration/configurationSchema.js
  var require_configurationSchema = __commonJS({
    "node_modules/@jbrowse/core/configuration/configurationSchema.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ConfigurationSchema = ConfigurationSchema3;
      exports.ConfigurationReference = ConfigurationReference;
      var mobx_state_tree_1 = require_mobx_state_tree();
      var configurationSlot_1 = __importDefault(require_configurationSlot());
      var util_1 = require_util4();
      var mst_1 = require_mst();
      function isEmptyObject(thing) {
        return typeof thing === "object" && !Array.isArray(thing) && thing !== null && Object.keys(thing).length === 0;
      }
      function isEmptyArray(thing) {
        return Array.isArray(thing) && thing.length === 0;
      }
      function preprocessConfigurationSchemaArguments(modelName, inputSchemaDefinition, inputOptions = {}) {
        var _a;
        if (typeof modelName !== "string") {
          throw new Error("first arg must be string name of the model that this config schema goes with");
        }
        let schemaDefinition = inputSchemaDefinition;
        let options = inputOptions;
        if ((_a = inputOptions.baseConfiguration) === null || _a === void 0 ? void 0 : _a.jbrowseSchemaDefinition) {
          schemaDefinition = {
            ...inputOptions.baseConfiguration.jbrowseSchemaDefinition,
            ...schemaDefinition
          };
          options = {
            ...inputOptions.baseConfiguration.jbrowseSchemaOptions,
            ...inputOptions,
            baseConfiguration: void 0
          };
        }
        return { schemaDefinition, options };
      }
      function makeConfigurationSchemaModel(modelName, schemaDefinition, options) {
        const modelDefinition = {};
        let identifier2;
        if (options.explicitlyTyped) {
          modelDefinition.type = mobx_state_tree_1.types.optional(mobx_state_tree_1.types.literal(modelName), modelName);
        }
        if (options.explicitIdentifier && options.implicitIdentifier) {
          throw new Error(`Cannot have both explicit and implicit identifiers in ${modelName}`);
        }
        if (options.explicitIdentifier) {
          if (typeof options.explicitIdentifier === "string") {
            modelDefinition[options.explicitIdentifier] = mobx_state_tree_1.types.identifier;
            identifier2 = options.explicitIdentifier;
          } else {
            modelDefinition.id = mobx_state_tree_1.types.identifier;
            identifier2 = "id";
          }
        } else if (options.implicitIdentifier) {
          if (typeof options.implicitIdentifier === "string") {
            modelDefinition[options.implicitIdentifier] = mst_1.ElementId;
            identifier2 = options.implicitIdentifier;
          } else {
            modelDefinition.id = mst_1.ElementId;
            identifier2 = "id";
          }
        }
        const volatileConstants = {
          isJBrowseConfigurationSchema: true,
          jbrowseSchema: {
            modelName,
            definition: schemaDefinition,
            options
          }
        };
        for (const [slotName, slotDefinition] of Object.entries(schemaDefinition)) {
          if ((0, mobx_state_tree_1.isType)(slotDefinition) && (0, mobx_state_tree_1.isLateType)(slotDefinition) || (0, util_1.isConfigurationSchemaType)(slotDefinition)) {
            modelDefinition[slotName] = slotDefinition;
          } else if (typeof slotDefinition === "string" || typeof slotDefinition === "number") {
            volatileConstants[slotName] = slotDefinition;
          } else if (typeof slotDefinition === "object") {
            if (!slotDefinition.type) {
              throw new Error(`no type set for config slot ${modelName}.${slotName}`);
            }
            try {
              modelDefinition[slotName] = (0, configurationSlot_1.default)(slotName, slotDefinition);
            } catch (e2) {
              throw new Error(`invalid config slot definition for ${modelName}.${slotName}: ${e2}`);
            }
          } else {
            throw new Error(`invalid configuration schema definition, "${slotName}" must be either a valid configuration slot definition, a constant, or a nested configuration schema`);
          }
        }
        let completeModel = mobx_state_tree_1.types.model(`${modelName}ConfigurationSchema`, modelDefinition).actions((self2) => ({
          setSubschema(slotName, data) {
            if (!(0, util_1.isConfigurationSchemaType)(modelDefinition[slotName])) {
              throw new Error(`${slotName} is not a subschema, cannot replace`);
            }
            const newSchema = (0, mobx_state_tree_1.isStateTreeNode)(data) ? data : modelDefinition[slotName].create(data);
            self2[slotName] = newSchema;
            return newSchema;
          }
        }));
        if (Object.keys(volatileConstants).length) {
          completeModel = completeModel.volatile(() => volatileConstants);
        }
        if (options.actions) {
          completeModel = completeModel.actions(options.actions);
        }
        if (options.views) {
          completeModel = completeModel.views(options.views);
        }
        if (options.extend) {
          completeModel = completeModel.extend(options.extend);
        }
        const identifierDefault = identifier2 ? { [identifier2]: "placeholderId" } : {};
        const modelDefault = options.explicitlyTyped ? { type: modelName, ...identifierDefault } : identifierDefault;
        const defaultSnap = (0, mobx_state_tree_1.getSnapshot)(completeModel.create(modelDefault));
        completeModel = completeModel.postProcessSnapshot((snap) => {
          const newSnap = {};
          let matchesDefault = true;
          for (const [key, value] of Object.entries(snap)) {
            if (matchesDefault) {
              if (typeof defaultSnap[key] === "object" && typeof value === "object") {
                if (JSON.stringify(defaultSnap[key]) !== JSON.stringify(value)) {
                  matchesDefault = false;
                }
              } else if (defaultSnap[key] !== value) {
                matchesDefault = false;
              }
            }
            if (value !== void 0 && volatileConstants[key] === void 0 && !isEmptyObject(value) && !isEmptyArray(value)) {
              newSnap[key] = value;
            }
          }
          if (matchesDefault) {
            return {};
          }
          return newSnap;
        });
        if (options.preProcessSnapshot) {
          completeModel = completeModel.preProcessSnapshot(options.preProcessSnapshot);
        }
        return mobx_state_tree_1.types.optional(completeModel, modelDefault);
      }
      function ConfigurationSchema3(modelName, inputSchemaDefinition, inputOptions) {
        const { schemaDefinition, options } = preprocessConfigurationSchemaArguments(modelName, inputSchemaDefinition, inputOptions);
        const schemaType = makeConfigurationSchemaModel(modelName, schemaDefinition, options);
        schemaType.isJBrowseConfigurationSchema = true;
        schemaType.jbrowseSchemaDefinition = schemaDefinition;
        schemaType.jbrowseSchemaOptions = options;
        return schemaType;
      }
      function ConfigurationReference(schemaType) {
        return mobx_state_tree_1.types.union(mobx_state_tree_1.types.reference(schemaType), schemaType);
      }
    }
  });

  // node_modules/@jbrowse/core/configuration/index.js
  var require_configuration2 = __commonJS({
    "node_modules/@jbrowse/core/configuration/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o2, m2, k2, k22) {
        if (k22 === void 0) k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m2, k2);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k2];
          } };
        }
        Object.defineProperty(o2, k22, desc);
      }) : (function(o2, m2, k2, k22) {
        if (k22 === void 0) k22 = k2;
        o2[k22] = m2[k2];
      }));
      var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
        for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ConfigurationSchema = exports.ConfigurationReference = void 0;
      var configurationSchema_1 = require_configurationSchema();
      Object.defineProperty(exports, "ConfigurationReference", { enumerable: true, get: function() {
        return configurationSchema_1.ConfigurationReference;
      } });
      Object.defineProperty(exports, "ConfigurationSchema", { enumerable: true, get: function() {
        return configurationSchema_1.ConfigurationSchema;
      } });
      __exportStar(require_util4(), exports);
    }
  });

  // node_modules/@jbrowse/core/util/QuickLRU.js
  var require_QuickLRU = __commonJS({
    "node_modules/@jbrowse/core/util/QuickLRU.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var QuickLRU = class extends Map {
        constructor(options = {}) {
          super();
          if (!(options.maxSize && options.maxSize > 0)) {
            throw new TypeError("`maxSize` must be a number greater than 0");
          }
          if (typeof options.maxAge === "number" && options.maxAge === 0) {
            throw new TypeError("`maxAge` must be a number greater than 0");
          }
          this.maxSize = options.maxSize;
          this.maxAge = options.maxAge || Number.POSITIVE_INFINITY;
          this.onEviction = options.onEviction;
          this.cache = /* @__PURE__ */ new Map();
          this.oldCache = /* @__PURE__ */ new Map();
          this._size = 0;
        }
        _emitEvictions(cache2) {
          if (typeof this.onEviction !== "function") {
            return;
          }
          for (const [key, item] of cache2) {
            this.onEviction(key, item.value);
          }
        }
        _deleteIfExpired(key, item) {
          if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
            if (typeof this.onEviction === "function") {
              this.onEviction(key, item.value);
            }
            return this.delete(key);
          }
          return false;
        }
        _getOrDeleteIfExpired(key, item) {
          const deleted = this._deleteIfExpired(key, item);
          if (!deleted) {
            return item.value;
          }
        }
        _getItemValue(key, item) {
          return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;
        }
        _peek(key, cache2) {
          const item = cache2.get(key);
          return this._getItemValue(key, item);
        }
        _set(key, value) {
          this.cache.set(key, value);
          this._size++;
          if (this._size >= this.maxSize) {
            this._size = 0;
            this._emitEvictions(this.oldCache);
            this.oldCache = this.cache;
            this.cache = /* @__PURE__ */ new Map();
          }
        }
        _moveToRecent(key, item) {
          this.oldCache.delete(key);
          this._set(key, item);
        }
        *_entriesAscending() {
          for (const item of this.oldCache) {
            const [key, value] = item;
            if (!this.cache.has(key)) {
              const deleted = this._deleteIfExpired(key, value);
              if (!deleted) {
                yield item;
              }
            }
          }
          for (const item of this.cache) {
            const [key, value] = item;
            const deleted = this._deleteIfExpired(key, value);
            if (!deleted) {
              yield item;
            }
          }
        }
        get(key) {
          if (this.cache.has(key)) {
            const item = this.cache.get(key);
            return this._getItemValue(key, item);
          }
          if (this.oldCache.has(key)) {
            const item = this.oldCache.get(key);
            if (!this._deleteIfExpired(key, item)) {
              this._moveToRecent(key, item);
              return item.value;
            }
          }
        }
        set(key, value, { maxAge = this.maxAge } = {}) {
          const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
          if (this.cache.has(key)) {
            this.cache.set(key, {
              value,
              expiry
            });
          } else {
            this._set(key, { value, expiry });
          }
        }
        has(key) {
          if (this.cache.has(key)) {
            return !this._deleteIfExpired(key, this.cache.get(key));
          }
          if (this.oldCache.has(key)) {
            return !this._deleteIfExpired(key, this.oldCache.get(key));
          }
          return false;
        }
        peek(key) {
          if (this.cache.has(key)) {
            return this._peek(key, this.cache);
          }
          if (this.oldCache.has(key)) {
            return this._peek(key, this.oldCache);
          }
        }
        delete(key) {
          const deleted = this.cache.delete(key);
          if (deleted) {
            this._size--;
          }
          return this.oldCache.delete(key) || deleted;
        }
        clear() {
          this.cache.clear();
          this.oldCache.clear();
          this._size = 0;
        }
        resize(newSize) {
          if (!(newSize && newSize > 0)) {
            throw new TypeError("`maxSize` must be a number greater than 0");
          }
          const items = [...this._entriesAscending()];
          const removeCount = items.length - newSize;
          if (removeCount < 0) {
            this.cache = new Map(items);
            this.oldCache = /* @__PURE__ */ new Map();
            this._size = items.length;
          } else {
            if (removeCount > 0) {
              this._emitEvictions(items.slice(0, removeCount));
            }
            this.oldCache = new Map(items.slice(removeCount));
            this.cache = /* @__PURE__ */ new Map();
            this._size = 0;
          }
          this.maxSize = newSize;
        }
        *keys() {
          for (const [key] of this) {
            yield key;
          }
        }
        *values() {
          for (const [, value] of this) {
            yield value;
          }
        }
        *[Symbol.iterator]() {
          for (const item of this.cache) {
            const [key, value] = item;
            const deleted = this._deleteIfExpired(key, value);
            if (!deleted) {
              yield [key, value.value];
            }
          }
          for (const item of this.oldCache) {
            const [key, value] = item;
            if (!this.cache.has(key)) {
              const deleted = this._deleteIfExpired(key, value);
              if (!deleted) {
                yield [key, value.value];
              }
            }
          }
        }
        *entriesDescending() {
          let items = [...this.cache];
          for (let i2 = items.length - 1; i2 >= 0; --i2) {
            const item = items[i2];
            const [key, value] = item;
            const deleted = this._deleteIfExpired(key, value);
            if (!deleted) {
              yield [key, value.value];
            }
          }
          items = [...this.oldCache];
          for (let i2 = items.length - 1; i2 >= 0; --i2) {
            const item = items[i2];
            const [key, value] = item;
            if (!this.cache.has(key)) {
              const deleted = this._deleteIfExpired(key, value);
              if (!deleted) {
                yield [key, value.value];
              }
            }
          }
        }
        *entriesAscending() {
          for (const [key, value] of this._entriesAscending()) {
            yield [key, value.value];
          }
        }
        get size() {
          if (!this._size) {
            return this.oldCache.size;
          }
          let oldCacheSize = 0;
          for (const key of this.oldCache.keys()) {
            if (!this.cache.has(key)) {
              oldCacheSize++;
            }
          }
          return Math.min(this._size + oldCacheSize, this.maxSize);
        }
        entries() {
          return this.entriesAscending();
        }
        forEach(callbackFunction, thisArgument = this) {
          for (const [key, value] of this.entriesAscending()) {
            callbackFunction.call(thisArgument, value, key, this);
          }
        }
        get [Symbol.toStringTag]() {
          return JSON.stringify([...this.entriesAscending()]);
        }
      };
      exports.default = QuickLRU;
    }
  });

  // node_modules/@jbrowse/core/TextSearch/TextSearchManager.js
  var require_TextSearchManager = __commonJS({
    "node_modules/@jbrowse/core/TextSearch/TextSearchManager.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var ufuzzy_1 = __importDefault(require_uFuzzy());
      var configuration_1 = require_configuration2();
      var QuickLRU_1 = __importDefault(require_QuickLRU());
      var TextSearchManager = class {
        constructor(pluginManager) {
          this.pluginManager = pluginManager;
          this.adapterCache = new QuickLRU_1.default({
            maxSize: 15
          });
        }
        loadTextSearchAdapters(searchScope) {
          return Promise.all(this.relevantAdapters(searchScope).map(async (conf) => {
            const adapterId = (0, configuration_1.readConfObject)(conf, "textSearchAdapterId");
            const r2 = this.adapterCache.get(adapterId);
            if (r2) {
              return r2;
            } else {
              const adapterType = this.pluginManager.getTextSearchAdapterType(conf.type);
              const AdapterClass = await adapterType.getAdapterClass();
              const adapterInstance = new AdapterClass(conf, void 0, this.pluginManager);
              this.adapterCache.set(adapterId, adapterInstance);
              return adapterInstance;
            }
          }));
        }
        relevantAdapters(searchScope) {
          const rootModel = this.pluginManager.rootModel;
          const { aggregateTextSearchAdapters } = rootModel === null || rootModel === void 0 ? void 0 : rootModel.jbrowse;
          const { tracks } = rootModel === null || rootModel === void 0 ? void 0 : rootModel.session;
          const { assemblyName } = searchScope;
          return [
            ...this.getAdaptersWithAssembly(assemblyName, aggregateTextSearchAdapters),
            ...this.getTrackAdaptersWithAssembly(assemblyName, tracks)
          ];
        }
        getAdaptersWithAssembly(assemblyName, confs) {
          return confs.filter((c2) => {
            var _a;
            return (_a = (0, configuration_1.readConfObject)(c2, "assemblyNames")) === null || _a === void 0 ? void 0 : _a.includes(assemblyName);
          });
        }
        getTrackAdaptersWithAssembly(assemblyName, confs) {
          return confs.filter((conf) => {
            var _a;
            return (_a = (0, configuration_1.readConfObject)(conf, [
              "textSearching",
              "textSearchAdapter",
              "assemblyNames"
            ])) === null || _a === void 0 ? void 0 : _a.includes(assemblyName);
          }).map((conf) => conf.textSearching.textSearchAdapter);
        }
        async search(args, searchScope, rankFn) {
          return this.search2({ args, searchScope, rankFn });
        }
        async search2({ args, searchScope, rankFn }) {
          const adapters = await this.loadTextSearchAdapters(searchScope);
          const results = await Promise.all(adapters.map((a2) => a2.searchIndex(args)));
          return this.sortResults2({
            args,
            results: results.flat(),
            rankFn
          });
        }
        sortResults2({ results, rankFn, args }) {
          const uf = new ufuzzy_1.default({});
          const haystack = results.map((r2) => r2.getDisplayString());
          const needle = args.queryString;
          const idxs = uf.filter(haystack, needle);
          const res = [];
          if (idxs != null && idxs.length > 0) {
            const info = uf.info(idxs, haystack, needle);
            const order = uf.sort(info, haystack, needle);
            for (const element of order) {
              res.push(results[info.idx[element]]);
            }
          }
          return rankFn(res);
        }
      };
      exports.default = TextSearchManager;
    }
  });

  // node_modules/@jbrowse/core/util/types/index.js
  var require_types = __commonJS({
    "node_modules/@jbrowse/core/util/types/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o2, m2, k2, k22) {
        if (k22 === void 0) k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m2, k2);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k2];
          } };
        }
        Object.defineProperty(o2, k22, desc);
      }) : (function(o2, m2, k2, k22) {
        if (k22 === void 0) k22 = k2;
        o2[k22] = m2[k2];
      }));
      var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
        for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TextSearchManager = exports.RetryError = exports.AuthNeededError = void 0;
      exports.isViewContainer = isViewContainer;
      exports.isSessionModel = isSessionModel;
      exports.isSessionModelWithConfigEditing = isSessionModelWithConfigEditing;
      exports.isSessionWithAddTracks = isSessionWithAddTracks;
      exports.isSessionWithShareURL = isSessionWithShareURL;
      exports.isSessionModelWithWidgets = isSessionModelWithWidgets;
      exports.isSessionModelWithConnections = isSessionModelWithConnections;
      exports.isSessionModelWithConnectionEditing = isSessionModelWithConnectionEditing;
      exports.isSessionWithSessionPlugins = isSessionWithSessionPlugins;
      exports.isSelectionContainer = isSelectionContainer;
      exports.isViewModel = isViewModel;
      exports.isTrackModel = isTrackModel;
      exports.isDisplayModel = isDisplayModel;
      exports.isTrackViewModel = isTrackViewModel;
      exports.isAppRootModel = isAppRootModel;
      exports.isRootModelWithInternetAccounts = isRootModelWithInternetAccounts;
      exports.isAbstractMenuManager = isAbstractMenuManager2;
      exports.isUriLocation = isUriLocation;
      exports.isLocalPathLocation = isLocalPathLocation;
      exports.isBlobLocation = isBlobLocation;
      exports.isAuthNeededException = isAuthNeededException;
      exports.isRetryException = isRetryException;
      var mobx_state_tree_1 = require_mobx_state_tree();
      __exportStar(require_util3(), exports);
      function isViewContainer(thing) {
        return (0, mobx_state_tree_1.isStateTreeNode)(thing) && "removeView" in thing && "addView" in thing && "views" in thing;
      }
      function isSessionModel(thing) {
        return typeof thing === "object" && thing !== null && "rpcManager" in thing && "configuration" in thing;
      }
      function isSessionModelWithConfigEditing(t2) {
        return isSessionModel(t2) && "editConfiguration" in t2;
      }
      function isSessionWithAddTracks(t2) {
        return isSessionModel(t2) && "addTrackConf" in t2 && !t2.disableAddTracks;
      }
      function isSessionWithShareURL(thing) {
        return isSessionModel(thing) && "shareURL" in thing && !!thing.shareURL;
      }
      function isSessionModelWithWidgets(thing) {
        return isSessionModel(thing) && "widgets" in thing;
      }
      function isSessionModelWithConnections(thing) {
        return isSessionModel(thing) && "makeConnection" in thing;
      }
      function isSessionModelWithConnectionEditing(thing) {
        return isSessionModel(thing) && "addConnectionConf" in thing;
      }
      function isSessionWithSessionPlugins(thing) {
        return isSessionModel(thing) && "sessionPlugins" in thing;
      }
      function isSelectionContainer(thing) {
        return typeof thing === "object" && thing !== null && "selection" in thing && "setSelection" in thing;
      }
      function isViewModel(thing) {
        return typeof thing === "object" && thing !== null && "width" in thing && "setWidth" in thing;
      }
      function isTrackModel(thing) {
        return typeof thing === "object" && thing !== null && "configuration" in thing && thing.configuration.trackId;
      }
      function isDisplayModel(thing) {
        return typeof thing === "object" && thing !== null && "configuration" in thing && thing.configuration.displayId;
      }
      function isTrackViewModel(thing) {
        return typeof thing === "object" && thing !== null && "showTrack" in thing && "hideTrack" in thing;
      }
      function isAppRootModel(thing) {
        return typeof thing === "object" && thing !== null && "findAppropriateInternetAccount" in thing;
      }
      function isRootModelWithInternetAccounts(thing) {
        return typeof thing === "object" && thing !== null && "internetAccounts" in thing && "findAppropriateInternetAccount" in thing;
      }
      function isAbstractMenuManager2(thing) {
        return typeof thing === "object" && thing !== null && "appendMenu" in thing && "appendToSubMenu" in thing;
      }
      function isUriLocation(location2) {
        return typeof location2 === "object" && location2 !== null && "uri" in location2 && !!location2.uri;
      }
      function isLocalPathLocation(location2) {
        return typeof location2 === "object" && location2 !== null && "localPath" in location2 && !!location2.localPath;
      }
      function isBlobLocation(location2) {
        return typeof location2 === "object" && location2 !== null && "blobId" in location2 && !!location2.blobId;
      }
      var AuthNeededError = class _AuthNeededError extends Error {
        constructor(message, url) {
          super(message);
          this.message = message;
          this.url = url;
          this.name = "AuthNeededError";
          Object.setPrototypeOf(this, _AuthNeededError.prototype);
        }
      };
      exports.AuthNeededError = AuthNeededError;
      var RetryError = class extends Error {
        constructor(message, internetAccountId) {
          super(message);
          this.message = message;
          this.internetAccountId = internetAccountId;
          this.name = "RetryError";
        }
      };
      exports.RetryError = RetryError;
      function isAuthNeededException(exception) {
        return exception instanceof Error && (exception.name === "AuthNeededError" || exception.url !== void 0);
      }
      function isRetryException(exception) {
        return exception.name === "RetryError" || exception.internetAccountId !== void 0;
      }
      var TextSearchManager_1 = require_TextSearchManager();
      Object.defineProperty(exports, "TextSearchManager", { enumerable: true, get: function() {
        return __importDefault(TextSearchManager_1).default;
      } });
    }
  });

  // global-externals:mobx
  var require_mobx = __commonJS({
    "global-externals:mobx"(exports, module) {
      module.exports = JBrowseExports["mobx"];
    }
  });

  // node_modules/@jbrowse/core/util/when.js
  var require_when = __commonJS({
    "node_modules/@jbrowse/core/util/when.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.when = void 0;
      var mobx_1 = require_mobx();
      Object.defineProperty(exports, "when", { enumerable: true, get: function() {
        return mobx_1.when;
      } });
    }
  });

  // node_modules/@jbrowse/core/util/range.js
  var require_range = __commonJS({
    "node_modules/@jbrowse/core/util/range.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.intersection2 = intersection2;
      exports.doesIntersect2 = doesIntersect2;
      exports.isContainedWithin = isContainedWithin;
      function intersection2(left1, right1, left2, right2) {
        if (right1 > left2 && left1 < right2 && right2 - left2 && right1 - left1) {
          if (left1 > left2) {
            if (right1 < right2) {
              return [left1, right1];
            }
            return [left1, right2];
          }
          if (right1 < right2) {
            return [left2, right1];
          }
          return [left2, right2];
        }
        return [];
      }
      function doesIntersect2(left1, right1, left2, right2) {
        return right1 > left2 && left1 < right2;
      }
      function isContainedWithin(left1, right1, left2, right2) {
        return left2 <= left1 && right2 >= right1;
      }
    }
  });

  // node_modules/@jbrowse/core/util/dedupe.js
  var require_dedupe = __commonJS({
    "node_modules/@jbrowse/core/util/dedupe.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.dedupe = dedupe2;
      function dedupe2(list, hasher = JSON.stringify) {
        const clone = [];
        const lookup = /* @__PURE__ */ new Set();
        for (const entry of list) {
          const hashed = hasher(entry);
          if (!lookup.has(hashed)) {
            clone.push(entry);
            lookup.add(hashed);
          }
        }
        return clone;
      }
    }
  });

  // node_modules/canvas-sequencer/dist/index.js
  var require_dist2 = __commonJS({
    "node_modules/canvas-sequencer/dist/index.js"(exports, module) {
      "use strict";
      var $663f930907ca9f24$exports = {};
      var $9a8fdc9f7382f5d6$exports = {};
      var $9a8fdc9f7382f5d6$var$TYPES = {
        /** @const */
        METHOD: "method",
        /** @const */
        PROPERTY: "property"
      };
      var $9a8fdc9f7382f5d6$var$Atom = class {
        constructor(inst, args) {
          this.inst = inst;
          this.args = args;
        }
      };
      var $9a8fdc9f7382f5d6$var$MethodCanvasAtom = class extends $9a8fdc9f7382f5d6$var$Atom {
        constructor(inst, args) {
          super(inst, args);
          this.type = $9a8fdc9f7382f5d6$var$TYPES.METHOD;
        }
        /**
        * Execute the atom on the given context.
        *
        * @param {CanvasRenderingContext2D} context
        */
        execute(context2) {
          context2[this.inst](...this.args);
        }
      };
      var $9a8fdc9f7382f5d6$var$PropertyCanvasAtom = class extends $9a8fdc9f7382f5d6$var$Atom {
        constructor(inst, args) {
          super(inst, args);
          this.type = $9a8fdc9f7382f5d6$var$TYPES.PROPERTY;
        }
        /**
        * Execute the atom on the given context.
        *
        * @param {CanvasRenderingContext2D} context
        */
        execute(context2) {
          context2[this.inst] = this.args[0];
        }
      };
      var $9a8fdc9f7382f5d6$var$atomOf = {
        [$9a8fdc9f7382f5d6$var$TYPES.METHOD]: $9a8fdc9f7382f5d6$var$MethodCanvasAtom,
        [$9a8fdc9f7382f5d6$var$TYPES.PROPERTY]: $9a8fdc9f7382f5d6$var$PropertyCanvasAtom
      };
      var $9a8fdc9f7382f5d6$var$CanvasAtom = class {
        constructor(type, inst, args) {
          return new $9a8fdc9f7382f5d6$var$atomOf[type](inst, args);
        }
      };
      Object.entries($9a8fdc9f7382f5d6$var$TYPES).forEach(([p2, v2]) => {
        Object.defineProperty($9a8fdc9f7382f5d6$var$CanvasAtom, p2, {
          value: v2,
          configurable: false,
          enumerable: true,
          writable: false
        });
      });
      $9a8fdc9f7382f5d6$exports = $9a8fdc9f7382f5d6$var$CanvasAtom;
      var $663f930907ca9f24$var$locals = Object.freeze({
        METHODS: [
          "addHitRegion",
          "arc",
          "arcTo",
          "beginPath",
          "bezierCurveTo",
          "clearHitRegions",
          "clearRect",
          "clip",
          "closePath",
          "drawFocusIfNeeded",
          "drawImage",
          "ellipse",
          "fill",
          "fillRect",
          "fillText",
          "lineTo",
          "moveTo",
          "putImageData",
          "quadraticCurveTo",
          "rect",
          "removeHitRegion",
          "resetTransform",
          "restore",
          "rotate",
          "save",
          "scale",
          "scrollPathIntoView",
          "setLineDash",
          "setTransform",
          "stroke",
          "strokeRect",
          "strokeText",
          "transform",
          "translate"
        ],
        PROPERTIES: [
          "direction",
          "fillStyle",
          "filter",
          "font",
          "globalAlpha",
          "globalCompositeOperation",
          "imageSmoothingEnabled",
          "imageSmoothingQuality",
          "lineCap",
          "lineDashOffset",
          "lineJoin",
          "lineWidth",
          "miterLimit",
          "shadowBlur",
          "shadowColor",
          "shadowOffsetX",
          "shadowOffsetY",
          "strokeStyle",
          "textAlign",
          "textBaseline"
        ]
      });
      var $663f930907ca9f24$var$symbols = Object.freeze({
        sequence: /* @__PURE__ */ Symbol.for("sequence"),
        push: /* @__PURE__ */ Symbol.for("push"),
        fromJSON: /* @__PURE__ */ Symbol.for("fromJSON")
      });
      var $663f930907ca9f24$var$CanvasSequence = class {
        constructor(data = null) {
          this[$663f930907ca9f24$var$symbols.sequence] = [];
          if (data) this[$663f930907ca9f24$var$symbols.fromJSON](data);
        }
        /**
        * Revive the sequence from transmitted JSON data.
        *
        * @private
        * @param {CanvasSequence} [data={}]
        */
        [$663f930907ca9f24$var$symbols.fromJSON](data = {
          sequence: []
        }) {
          data.sequence.forEach(({ type, inst, args }) => {
            this[$663f930907ca9f24$var$symbols.push](type, inst, args);
          });
        }
        /**
        * Push a new CanvasAtom onto the end of the sequence.
        *
        * @private
        * @param {string} type - The type of CanvasAtom to push.
        * @param {string} inst - The canvas context instruction.
        * @param {*[]} args - The arguments to the canvas context instruction.
        */
        [$663f930907ca9f24$var$symbols.push](type, inst, args) {
          this[$663f930907ca9f24$var$symbols.sequence].push(new $9a8fdc9f7382f5d6$exports(type, inst, args));
        }
        /**
        * Execute the sequence on the given context.
        *
        * @param {CanvasRenderingContext2D} context
        */
        execute(context2) {
          context2.save();
          this[$663f930907ca9f24$var$symbols.sequence].forEach(
            (a2) => a2.execute(context2)
          );
          context2.restore();
        }
        /**
        * Export a JSON serialized version of the sequence, ready for transmission.
        *
        * @return {CanvasSequence} In JSON serialized form.
        */
        toJSON() {
          return {
            sequence: this[$663f930907ca9f24$var$symbols.sequence]
          };
        }
      };
      $663f930907ca9f24$var$locals.METHODS.forEach((m2) => {
        Object.defineProperty($663f930907ca9f24$var$CanvasSequence.prototype, m2, {
          value: function pushMethodCall(...args) {
            this[$663f930907ca9f24$var$symbols.push]($9a8fdc9f7382f5d6$exports.METHOD, m2, args);
          },
          writable: false,
          enumerable: true,
          configurable: false
        });
      });
      $663f930907ca9f24$var$locals.PROPERTIES.forEach((p2) => {
        Object.defineProperty($663f930907ca9f24$var$CanvasSequence.prototype, p2, {
          get() {
            throw `Invalid canvas sequencer interaction, cannot get ${p2}.`;
          },
          set(v2) {
            this[$663f930907ca9f24$var$symbols.push]($9a8fdc9f7382f5d6$exports.PROPERTY, p2, [
              v2
            ]);
          },
          enumerable: true,
          configurable: false
        });
      });
      $663f930907ca9f24$exports = $663f930907ca9f24$var$CanvasSequence;
      var $4fabbdeef1f2d4ae$exports = {};
      var $4fabbdeef1f2d4ae$var$symbols = Object.freeze({
        sequence: /* @__PURE__ */ Symbol.for("sequence"),
        push: /* @__PURE__ */ Symbol.for("push")
      });
      function $4fabbdeef1f2d4ae$var$replaceTags(str, values) {
        const tag = str.replace(/^\{|\}$/gu, "");
        if (tag !== str) return values.hasOwnProperty(tag) ? values[tag] : tag;
        return str;
      }
      var $4fabbdeef1f2d4ae$var$CanvasBlueprint = class extends $663f930907ca9f24$exports {
        /**
        * Build the blueprint using the provided values.
        *
        * Rules:
        * - Strings not surrounded by curly braces {} will be returned.
        * - Strings surrounded by curly braces but not corresponding to a property on
        *   'values' will result in a string without the curly braces being returned.
        * - Strings surrounded by curly braces, with the inner string corresponding
        *   to a property on 'values' will result in the corresponding value being
        *   returned.
        *
        * @param {object} values - The values with which to construct the sequence.
        *
        * @return {CanvasSequence} The constructed sequence.
        */
        build(values = {}) {
          const seq = new $663f930907ca9f24$exports();
          this[$4fabbdeef1f2d4ae$var$symbols.sequence].forEach(({ type, inst, args }) => {
            const realArgs = args.map((v2) => {
              return typeof v2 === "string" ? $4fabbdeef1f2d4ae$var$replaceTags(v2, values) : v2;
            });
            seq[$4fabbdeef1f2d4ae$var$symbols.push](type, inst, realArgs);
          });
          return seq;
        }
        /**
        * CanvasBlueprints cannot be directly executed!
        *
        * @throws TypeError
        */
        execute() {
          throw new TypeError("Cannot execute a blueprint.");
        }
      };
      $4fabbdeef1f2d4ae$exports = $4fabbdeef1f2d4ae$var$CanvasBlueprint;
      module.exports = {
        CanvasSequence: $663f930907ca9f24$exports,
        CanvasBlueprint: $4fabbdeef1f2d4ae$exports
      };
    }
  });

  // node_modules/detect-node/browser.js
  var require_browser = __commonJS({
    "node_modules/detect-node/browser.js"(exports, module) {
      module.exports = false;
    }
  });

  // node_modules/@jbrowse/core/util/offscreenCanvasPonyfill.js
  var require_offscreenCanvasPonyfill = __commonJS({
    "node_modules/@jbrowse/core/util/offscreenCanvasPonyfill.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ImageBitmapType = exports.createImageBitmap = exports.createCanvas = void 0;
      exports.drawImageOntoCanvasContext = drawImageOntoCanvasContext;
      var canvas_sequencer_1 = require_dist2();
      var detect_node_1 = __importDefault(require_browser());
      function drawImageOntoCanvasContext(imageData, context2) {
        if (imageData.serializedCommands) {
          const seq = new canvas_sequencer_1.CanvasSequence(imageData.serializedCommands);
          seq.execute(context2);
        } else {
          context2.drawImage(imageData, 0, 0);
        }
      }
      var weHave = {
        realOffscreenCanvas: typeof OffscreenCanvas === "function",
        node: detect_node_1.default
      };
      if (weHave.realOffscreenCanvas) {
        exports.createCanvas = (width, height) => new OffscreenCanvas(width, height);
        exports.createImageBitmap = window.createImageBitmap || self.createImageBitmap;
        exports.ImageBitmapType = window.ImageBitmap || self.ImageBitmap;
      } else if (weHave.node) {
        exports.createCanvas = (...args) => {
          return nodeCreateCanvas(...args);
        };
        exports.createImageBitmap = async (canvas) => {
          const dataUri = canvas.toDataURL();
          const img = new nodeImage();
          return new Promise((resolve, reject) => {
            img.onload = () => {
              resolve(img);
            };
            img.onerror = reject;
            img.src = dataUri;
          });
        };
      } else {
        exports.createCanvas = (width, height) => {
          const context2 = new canvas_sequencer_1.CanvasSequence();
          return {
            width,
            height,
            getContext() {
              return context2;
            }
          };
        };
        exports.createImageBitmap = async (canvas) => {
          const ctx = canvas.getContext("2d");
          return {
            height: canvas.height,
            width: canvas.width,
            serializedCommands: ctx.toJSON(),
            containsNoTransferables: true
          };
        };
        exports.ImageBitmapType = String;
      }
    }
  });

  // node_modules/@jbrowse/core/util/blobToDataURL.js
  var require_blobToDataURL = __commonJS({
    "node_modules/@jbrowse/core/util/blobToDataURL.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.blobToDataURL = blobToDataURL;
      function blobToDataURL(blob) {
        const a2 = new FileReader();
        return new Promise((resolve, reject) => {
          a2.onload = (e2) => {
            if (e2.target) {
              resolve(e2.target.result);
            } else {
              reject(new Error("unknown result reading blob from canvas"));
            }
          };
          a2.readAsDataURL(blob);
        });
      }
    }
  });

  // node_modules/canvas2svg/canvas2svg.js
  var require_canvas2svg = __commonJS({
    "node_modules/canvas2svg/canvas2svg.js"(exports, module) {
      (function() {
        "use strict";
        var STYLES, ctx, CanvasGradient, CanvasPattern, namedEntities;
        function format(str, args) {
          var keys = Object.keys(args), i2;
          for (i2 = 0; i2 < keys.length; i2++) {
            str = str.replace(new RegExp("\\{" + keys[i2] + "\\}", "gi"), args[keys[i2]]);
          }
          return str;
        }
        function randomString(holder) {
          var chars, randomstring, i2;
          if (!holder) {
            throw new Error("cannot create a random attribute name for an undefined object");
          }
          chars = "ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
          randomstring = "";
          do {
            randomstring = "";
            for (i2 = 0; i2 < 12; i2++) {
              randomstring += chars[Math.floor(Math.random() * chars.length)];
            }
          } while (holder[randomstring]);
          return randomstring;
        }
        function createNamedToNumberedLookup(items, radix) {
          var i2, entity, lookup = {}, base10, base16;
          items = items.split(",");
          radix = radix || 10;
          for (i2 = 0; i2 < items.length; i2 += 2) {
            entity = "&" + items[i2 + 1] + ";";
            base10 = parseInt(items[i2], radix);
            lookup[entity] = "&#" + base10 + ";";
          }
          lookup["\\xa0"] = "&#160;";
          return lookup;
        }
        function getTextAnchor(textAlign) {
          var mapping = { "left": "start", "right": "end", "center": "middle", "start": "start", "end": "end" };
          return mapping[textAlign] || mapping.start;
        }
        function getDominantBaseline(textBaseline) {
          var mapping = { "alphabetic": "alphabetic", "hanging": "hanging", "top": "text-before-edge", "bottom": "text-after-edge", "middle": "central" };
          return mapping[textBaseline] || mapping.alphabetic;
        }
        namedEntities = createNamedToNumberedLookup(
          "50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro",
          32
        );
        STYLES = {
          "strokeStyle": {
            svgAttr: "stroke",
            //corresponding svg attribute
            canvas: "#000000",
            //canvas default
            svg: "none",
            //svg default
            apply: "stroke"
            //apply on stroke() or fill()
          },
          "fillStyle": {
            svgAttr: "fill",
            canvas: "#000000",
            svg: null,
            //svg default is black, but we need to special case this to handle canvas stroke without fill
            apply: "fill"
          },
          "lineCap": {
            svgAttr: "stroke-linecap",
            canvas: "butt",
            svg: "butt",
            apply: "stroke"
          },
          "lineJoin": {
            svgAttr: "stroke-linejoin",
            canvas: "miter",
            svg: "miter",
            apply: "stroke"
          },
          "miterLimit": {
            svgAttr: "stroke-miterlimit",
            canvas: 10,
            svg: 4,
            apply: "stroke"
          },
          "lineWidth": {
            svgAttr: "stroke-width",
            canvas: 1,
            svg: 1,
            apply: "stroke"
          },
          "globalAlpha": {
            svgAttr: "opacity",
            canvas: 1,
            svg: 1,
            apply: "fill stroke"
          },
          "font": {
            //font converts to multiple svg attributes, there is custom logic for this
            canvas: "10px sans-serif"
          },
          "shadowColor": {
            canvas: "#000000"
          },
          "shadowOffsetX": {
            canvas: 0
          },
          "shadowOffsetY": {
            canvas: 0
          },
          "shadowBlur": {
            canvas: 0
          },
          "textAlign": {
            canvas: "start"
          },
          "textBaseline": {
            canvas: "alphabetic"
          }
        };
        CanvasGradient = function(gradientNode, ctx2) {
          this.__root = gradientNode;
          this.__ctx = ctx2;
        };
        CanvasGradient.prototype.addColorStop = function(offset4, color) {
          var stop = this.__ctx.__createElement("stop"), regex, matches2;
          stop.setAttribute("offset", offset4);
          if (color.indexOf("rgba") !== -1) {
            regex = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
            matches2 = regex.exec(color);
            stop.setAttribute("stop-color", format("rgb({r},{g},{b})", { r: matches2[1], g: matches2[2], b: matches2[3] }));
            stop.setAttribute("stop-opacity", matches2[4]);
          } else {
            stop.setAttribute("stop-color", color);
          }
          this.__root.appendChild(stop);
        };
        CanvasPattern = function(pattern, ctx2) {
          this.__root = pattern;
          this.__ctx = ctx2;
        };
        ctx = function(o2) {
          var defaultOptions = { width: 500, height: 500, enableMirroring: false }, options;
          if (arguments.length > 1) {
            options = defaultOptions;
            options.width = arguments[0];
            options.height = arguments[1];
          } else if (!o2) {
            options = defaultOptions;
          } else {
            options = o2;
          }
          if (!(this instanceof ctx)) {
            return new ctx(options);
          }
          this.width = options.width || defaultOptions.width;
          this.height = options.height || defaultOptions.height;
          this.enableMirroring = options.enableMirroring !== void 0 ? options.enableMirroring : defaultOptions.enableMirroring;
          this.canvas = this;
          this.__document = options.document || document;
          this.__canvas = this.__document.createElement("canvas");
          this.__ctx = this.__canvas.getContext("2d");
          this.__setDefaultStyles();
          this.__stack = [this.__getStyleState()];
          this.__groupStack = [];
          this.__root = this.__document.createElementNS("http://www.w3.org/2000/svg", "svg");
          this.__root.setAttribute("version", 1.1);
          this.__root.setAttribute("xmlns", "http://www.w3.org/2000/svg");
          this.__root.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
          this.__root.setAttribute("width", this.width);
          this.__root.setAttribute("height", this.height);
          this.__ids = {};
          this.__defs = this.__document.createElementNS("http://www.w3.org/2000/svg", "defs");
          this.__root.appendChild(this.__defs);
          this.__currentElement = this.__document.createElementNS("http://www.w3.org/2000/svg", "g");
          this.__root.appendChild(this.__currentElement);
        };
        ctx.prototype.__createElement = function(elementName, properties, resetFill) {
          if (typeof properties === "undefined") {
            properties = {};
          }
          var element = this.__document.createElementNS("http://www.w3.org/2000/svg", elementName), keys = Object.keys(properties), i2, key;
          if (resetFill) {
            element.setAttribute("fill", "none");
            element.setAttribute("stroke", "none");
          }
          for (i2 = 0; i2 < keys.length; i2++) {
            key = keys[i2];
            element.setAttribute(key, properties[key]);
          }
          return element;
        };
        ctx.prototype.__setDefaultStyles = function() {
          var keys = Object.keys(STYLES), i2, key;
          for (i2 = 0; i2 < keys.length; i2++) {
            key = keys[i2];
            this[key] = STYLES[key].canvas;
          }
        };
        ctx.prototype.__applyStyleState = function(styleState) {
          var keys = Object.keys(styleState), i2, key;
          for (i2 = 0; i2 < keys.length; i2++) {
            key = keys[i2];
            this[key] = styleState[key];
          }
        };
        ctx.prototype.__getStyleState = function() {
          var i2, styleState = {}, keys = Object.keys(STYLES), key;
          for (i2 = 0; i2 < keys.length; i2++) {
            key = keys[i2];
            styleState[key] = this[key];
          }
          return styleState;
        };
        ctx.prototype.__applyStyleToCurrentElement = function(type) {
          var keys = Object.keys(STYLES), i2, style, value, id, regex, matches2;
          for (i2 = 0; i2 < keys.length; i2++) {
            style = STYLES[keys[i2]];
            value = this[keys[i2]];
            if (style.apply) {
              if (style.apply.indexOf("fill") !== -1 && value instanceof CanvasPattern) {
                if (value.__ctx) {
                  while (value.__ctx.__defs.childNodes.length) {
                    id = value.__ctx.__defs.childNodes[0].getAttribute("id");
                    this.__ids[id] = id;
                    this.__defs.appendChild(value.__ctx.__defs.childNodes[0]);
                  }
                }
                this.__currentElement.setAttribute("fill", format("url(#{id})", { id: value.__root.getAttribute("id") }));
              } else if (style.apply.indexOf("fill") !== -1 && value instanceof CanvasGradient) {
                this.__currentElement.setAttribute("fill", format("url(#{id})", { id: value.__root.getAttribute("id") }));
              } else if (style.apply.indexOf(type) !== -1 && style.svg !== value) {
                if ((style.svgAttr === "stroke" || style.svgAttr === "fill") && value.indexOf("rgba") !== -1) {
                  regex = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
                  matches2 = regex.exec(value);
                  this.__currentElement.setAttribute(style.svgAttr, format("rgb({r},{g},{b})", { r: matches2[1], g: matches2[2], b: matches2[3] }));
                  this.__currentElement.setAttribute(style.svgAttr + "-opacity", matches2[4]);
                } else {
                  this.__currentElement.setAttribute(style.svgAttr, value);
                }
              }
            }
          }
        };
        ctx.prototype.__closestGroupOrSvg = function(node2) {
          node2 = node2 || this.__currentElement;
          if (node2.nodeName === "g" || node2.nodeName === "svg") {
            return node2;
          } else {
            return this.__closestGroupOrSvg(node2.parentNode);
          }
        };
        ctx.prototype.getSerializedSvg = function(fixNamedEntities) {
          var serialized = new XMLSerializer().serializeToString(this.__root), keys, i2, key, value, regexp, xmlns;
          xmlns = /xmlns="http:\/\/www\.w3\.org\/2000\/svg".+xmlns="http:\/\/www\.w3\.org\/2000\/svg/gi;
          if (xmlns.test(serialized)) {
            serialized = serialized.replace('xmlns="http://www.w3.org/2000/svg', 'xmlns:xlink="http://www.w3.org/1999/xlink');
          }
          if (fixNamedEntities) {
            keys = Object.keys(namedEntities);
            for (i2 = 0; i2 < keys.length; i2++) {
              key = keys[i2];
              value = namedEntities[key];
              regexp = new RegExp(key, "gi");
              if (regexp.test(serialized)) {
                serialized = serialized.replace(regexp, value);
              }
            }
          }
          return serialized;
        };
        ctx.prototype.getSvg = function() {
          return this.__root;
        };
        ctx.prototype.save = function() {
          var group = this.__createElement("g"), parent = this.__closestGroupOrSvg();
          this.__groupStack.push(parent);
          parent.appendChild(group);
          this.__currentElement = group;
          this.__stack.push(this.__getStyleState());
        };
        ctx.prototype.restore = function() {
          this.__currentElement = this.__groupStack.pop();
          var state = this.__stack.pop();
          this.__applyStyleState(state);
        };
        ctx.prototype.__addTransform = function(t2) {
          var parent = this.__closestGroupOrSvg();
          if (parent.childNodes.length > 0) {
            var group = this.__createElement("g");
            parent.appendChild(group);
            this.__currentElement = group;
          }
          var transform2 = this.__currentElement.getAttribute("transform");
          if (transform2) {
            transform2 += " ";
          } else {
            transform2 = "";
          }
          transform2 += t2;
          this.__currentElement.setAttribute("transform", transform2);
        };
        ctx.prototype.scale = function(x2, y2) {
          if (y2 === void 0) {
            y2 = x2;
          }
          this.__addTransform(format("scale({x},{y})", { x: x2, y: y2 }));
        };
        ctx.prototype.rotate = function(angle) {
          var degrees = angle * 180 / Math.PI;
          this.__addTransform(format("rotate({angle},{cx},{cy})", { angle: degrees, cx: 0, cy: 0 }));
        };
        ctx.prototype.translate = function(x2, y2) {
          this.__addTransform(format("translate({x},{y})", { x: x2, y: y2 }));
        };
        ctx.prototype.transform = function(a2, b2, c2, d3, e2, f2) {
          this.__addTransform(format("matrix({a},{b},{c},{d},{e},{f})", { a: a2, b: b2, c: c2, d: d3, e: e2, f: f2 }));
        };
        ctx.prototype.beginPath = function() {
          var path, parent;
          this.__currentDefaultPath = "";
          this.__currentPosition = {};
          path = this.__createElement("path", {}, true);
          parent = this.__closestGroupOrSvg();
          parent.appendChild(path);
          this.__currentElement = path;
        };
        ctx.prototype.__applyCurrentDefaultPath = function() {
          if (this.__currentElement.nodeName === "path") {
            var d3 = this.__currentDefaultPath;
            this.__currentElement.setAttribute("d", d3);
          } else {
            throw new Error("Attempted to apply path command to node " + this.__currentElement.nodeName);
          }
        };
        ctx.prototype.__addPathCommand = function(command) {
          this.__currentDefaultPath += " ";
          this.__currentDefaultPath += command;
        };
        ctx.prototype.moveTo = function(x2, y2) {
          if (this.__currentElement.nodeName !== "path") {
            this.beginPath();
          }
          this.__currentPosition = { x: x2, y: y2 };
          this.__addPathCommand(format("M {x} {y}", { x: x2, y: y2 }));
        };
        ctx.prototype.closePath = function() {
          this.__addPathCommand("Z");
        };
        ctx.prototype.lineTo = function(x2, y2) {
          this.__currentPosition = { x: x2, y: y2 };
          if (this.__currentDefaultPath.indexOf("M") > -1) {
            this.__addPathCommand(format("L {x} {y}", { x: x2, y: y2 }));
          } else {
            this.__addPathCommand(format("M {x} {y}", { x: x2, y: y2 }));
          }
        };
        ctx.prototype.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x2, y2) {
          this.__currentPosition = { x: x2, y: y2 };
          this.__addPathCommand(format(
            "C {cp1x} {cp1y} {cp2x} {cp2y} {x} {y}",
            { cp1x, cp1y, cp2x, cp2y, x: x2, y: y2 }
          ));
        };
        ctx.prototype.quadraticCurveTo = function(cpx, cpy, x2, y2) {
          this.__currentPosition = { x: x2, y: y2 };
          this.__addPathCommand(format("Q {cpx} {cpy} {x} {y}", { cpx, cpy, x: x2, y: y2 }));
        };
        var normalize2 = function(vector) {
          var len2 = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);
          return [vector[0] / len2, vector[1] / len2];
        };
        ctx.prototype.arcTo = function(x1, y1, x2, y2, radius2) {
          var x0 = this.__currentPosition && this.__currentPosition.x;
          var y0 = this.__currentPosition && this.__currentPosition.y;
          if (typeof x0 == "undefined" || typeof y0 == "undefined") {
            return;
          }
          if (radius2 < 0) {
            throw new Error("IndexSizeError: The radius provided (" + radius2 + ") is negative.");
          }
          if (x0 === x1 && y0 === y1 || x1 === x2 && y1 === y2 || radius2 === 0) {
            this.lineTo(x1, y1);
            return;
          }
          var unit_vec_p1_p0 = normalize2([x0 - x1, y0 - y1]);
          var unit_vec_p1_p2 = normalize2([x2 - x1, y2 - y1]);
          if (unit_vec_p1_p0[0] * unit_vec_p1_p2[1] === unit_vec_p1_p0[1] * unit_vec_p1_p2[0]) {
            this.lineTo(x1, y1);
            return;
          }
          var cos = unit_vec_p1_p0[0] * unit_vec_p1_p2[0] + unit_vec_p1_p0[1] * unit_vec_p1_p2[1];
          var theta = Math.acos(Math.abs(cos));
          var unit_vec_p1_origin = normalize2([
            unit_vec_p1_p0[0] + unit_vec_p1_p2[0],
            unit_vec_p1_p0[1] + unit_vec_p1_p2[1]
          ]);
          var len_p1_origin = radius2 / Math.sin(theta / 2);
          var x3 = x1 + len_p1_origin * unit_vec_p1_origin[0];
          var y3 = y1 + len_p1_origin * unit_vec_p1_origin[1];
          var unit_vec_origin_start_tangent = [
            -unit_vec_p1_p0[1],
            unit_vec_p1_p0[0]
          ];
          var unit_vec_origin_end_tangent = [
            unit_vec_p1_p2[1],
            -unit_vec_p1_p2[0]
          ];
          var getAngle = function(vector) {
            var x4 = vector[0];
            var y4 = vector[1];
            if (y4 >= 0) {
              return Math.acos(x4);
            } else {
              return -Math.acos(x4);
            }
          };
          var startAngle = getAngle(unit_vec_origin_start_tangent);
          var endAngle = getAngle(unit_vec_origin_end_tangent);
          this.lineTo(
            x3 + unit_vec_origin_start_tangent[0] * radius2,
            y3 + unit_vec_origin_start_tangent[1] * radius2
          );
          this.arc(x3, y3, radius2, startAngle, endAngle);
        };
        ctx.prototype.stroke = function() {
          if (this.__currentElement.nodeName === "path") {
            this.__currentElement.setAttribute("paint-order", "fill stroke markers");
          }
          this.__applyCurrentDefaultPath();
          this.__applyStyleToCurrentElement("stroke");
        };
        ctx.prototype.fill = function() {
          if (this.__currentElement.nodeName === "path") {
            this.__currentElement.setAttribute("paint-order", "stroke fill markers");
          }
          this.__applyCurrentDefaultPath();
          this.__applyStyleToCurrentElement("fill");
        };
        ctx.prototype.rect = function(x2, y2, width, height) {
          if (this.__currentElement.nodeName !== "path") {
            this.beginPath();
          }
          this.moveTo(x2, y2);
          this.lineTo(x2 + width, y2);
          this.lineTo(x2 + width, y2 + height);
          this.lineTo(x2, y2 + height);
          this.lineTo(x2, y2);
          this.closePath();
        };
        ctx.prototype.fillRect = function(x2, y2, width, height) {
          var rect, parent;
          rect = this.__createElement("rect", {
            x: x2,
            y: y2,
            width,
            height
          }, true);
          parent = this.__closestGroupOrSvg();
          parent.appendChild(rect);
          this.__currentElement = rect;
          this.__applyStyleToCurrentElement("fill");
        };
        ctx.prototype.strokeRect = function(x2, y2, width, height) {
          var rect, parent;
          rect = this.__createElement("rect", {
            x: x2,
            y: y2,
            width,
            height
          }, true);
          parent = this.__closestGroupOrSvg();
          parent.appendChild(rect);
          this.__currentElement = rect;
          this.__applyStyleToCurrentElement("stroke");
        };
        ctx.prototype.clearRect = function(x2, y2, width, height) {
          var rect, parent = this.__closestGroupOrSvg();
          rect = this.__createElement("rect", {
            x: x2,
            y: y2,
            width,
            height,
            fill: "#FFFFFF"
          }, true);
          parent.appendChild(rect);
        };
        ctx.prototype.createLinearGradient = function(x1, y1, x2, y2) {
          var grad = this.__createElement("linearGradient", {
            id: randomString(this.__ids),
            x1: x1 + "px",
            x2: x2 + "px",
            y1: y1 + "px",
            y2: y2 + "px",
            "gradientUnits": "userSpaceOnUse"
          }, false);
          this.__defs.appendChild(grad);
          return new CanvasGradient(grad, this);
        };
        ctx.prototype.createRadialGradient = function(x0, y0, r0, x1, y1, r1) {
          var grad = this.__createElement("radialGradient", {
            id: randomString(this.__ids),
            cx: x1 + "px",
            cy: y1 + "px",
            r: r1 + "px",
            fx: x0 + "px",
            fy: y0 + "px",
            "gradientUnits": "userSpaceOnUse"
          }, false);
          this.__defs.appendChild(grad);
          return new CanvasGradient(grad, this);
        };
        ctx.prototype.__parseFont = function() {
          var regex = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-,\"\sa-z]+?)\s*$/i;
          var fontPart = regex.exec(this.font);
          var data = {
            style: fontPart[1] || "normal",
            size: fontPart[4] || "10px",
            family: fontPart[6] || "sans-serif",
            weight: fontPart[3] || "normal",
            decoration: fontPart[2] || "normal",
            href: null
          };
          if (this.__fontUnderline === "underline") {
            data.decoration = "underline";
          }
          if (this.__fontHref) {
            data.href = this.__fontHref;
          }
          return data;
        };
        ctx.prototype.__wrapTextLink = function(font, element) {
          if (font.href) {
            var a2 = this.__createElement("a");
            a2.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", font.href);
            a2.appendChild(element);
            return a2;
          }
          return element;
        };
        ctx.prototype.__applyText = function(text, x2, y2, action) {
          var font = this.__parseFont(), parent = this.__closestGroupOrSvg(), textElement = this.__createElement("text", {
            "font-family": font.family,
            "font-size": font.size,
            "font-style": font.style,
            "font-weight": font.weight,
            "text-decoration": font.decoration,
            "x": x2,
            "y": y2,
            "text-anchor": getTextAnchor(this.textAlign),
            "dominant-baseline": getDominantBaseline(this.textBaseline)
          }, true);
          textElement.appendChild(this.__document.createTextNode(text));
          this.__currentElement = textElement;
          this.__applyStyleToCurrentElement(action);
          parent.appendChild(this.__wrapTextLink(font, textElement));
        };
        ctx.prototype.fillText = function(text, x2, y2) {
          this.__applyText(text, x2, y2, "fill");
        };
        ctx.prototype.strokeText = function(text, x2, y2) {
          this.__applyText(text, x2, y2, "stroke");
        };
        ctx.prototype.measureText = function(text) {
          this.__ctx.font = this.font;
          return this.__ctx.measureText(text);
        };
        ctx.prototype.arc = function(x2, y2, radius2, startAngle, endAngle, counterClockwise) {
          if (startAngle === endAngle) {
            return;
          }
          startAngle = startAngle % (2 * Math.PI);
          endAngle = endAngle % (2 * Math.PI);
          if (startAngle === endAngle) {
            endAngle = (endAngle + 2 * Math.PI - 1e-3 * (counterClockwise ? -1 : 1)) % (2 * Math.PI);
          }
          var endX = x2 + radius2 * Math.cos(endAngle), endY = y2 + radius2 * Math.sin(endAngle), startX = x2 + radius2 * Math.cos(startAngle), startY = y2 + radius2 * Math.sin(startAngle), sweepFlag = counterClockwise ? 0 : 1, largeArcFlag = 0, diff = endAngle - startAngle;
          if (diff < 0) {
            diff += 2 * Math.PI;
          }
          if (counterClockwise) {
            largeArcFlag = diff > Math.PI ? 0 : 1;
          } else {
            largeArcFlag = diff > Math.PI ? 1 : 0;
          }
          this.lineTo(startX, startY);
          this.__addPathCommand(format(
            "A {rx} {ry} {xAxisRotation} {largeArcFlag} {sweepFlag} {endX} {endY}",
            { rx: radius2, ry: radius2, xAxisRotation: 0, largeArcFlag, sweepFlag, endX, endY }
          ));
          this.__currentPosition = { x: endX, y: endY };
        };
        ctx.prototype.clip = function() {
          var group = this.__closestGroupOrSvg(), clipPath = this.__createElement("clipPath"), id = randomString(this.__ids), newGroup = this.__createElement("g");
          group.removeChild(this.__currentElement);
          clipPath.setAttribute("id", id);
          clipPath.appendChild(this.__currentElement);
          this.__defs.appendChild(clipPath);
          group.setAttribute("clip-path", format("url(#{id})", { id }));
          group.appendChild(newGroup);
          this.__currentElement = newGroup;
        };
        ctx.prototype.drawImage = function() {
          var args = Array.prototype.slice.call(arguments), image = args[0], dx, dy, dw, dh, sx = 0, sy = 0, sw, sh, parent, svg, defs, group, currentElement, svgImage, canvas, context2, id;
          if (args.length === 3) {
            dx = args[1];
            dy = args[2];
            sw = image.width;
            sh = image.height;
            dw = sw;
            dh = sh;
          } else if (args.length === 5) {
            dx = args[1];
            dy = args[2];
            dw = args[3];
            dh = args[4];
            sw = image.width;
            sh = image.height;
          } else if (args.length === 9) {
            sx = args[1];
            sy = args[2];
            sw = args[3];
            sh = args[4];
            dx = args[5];
            dy = args[6];
            dw = args[7];
            dh = args[8];
          } else {
            throw new Error("Inavlid number of arguments passed to drawImage: " + arguments.length);
          }
          parent = this.__closestGroupOrSvg();
          currentElement = this.__currentElement;
          if (image instanceof ctx) {
            svg = image.getSvg();
            defs = svg.childNodes[0];
            while (defs.childNodes.length) {
              id = defs.childNodes[0].getAttribute("id");
              this.__ids[id] = id;
              this.__defs.appendChild(defs.childNodes[0]);
            }
            group = svg.childNodes[1];
            parent.appendChild(group);
            this.__currentElement = group;
            this.translate(dx, dy);
            this.__currentElement = currentElement;
          } else if (image.nodeName === "CANVAS" || image.nodeName === "IMG") {
            svgImage = this.__createElement("image");
            svgImage.setAttribute("width", dw);
            svgImage.setAttribute("height", dh);
            svgImage.setAttribute("preserveAspectRatio", "none");
            if (sx || sy || sw !== image.width || sh !== image.height) {
              canvas = this.__document.createElement("canvas");
              canvas.width = dw;
              canvas.height = dh;
              context2 = canvas.getContext("2d");
              context2.drawImage(image, sx, sy, sw, sh, 0, 0, dw, dh);
              image = canvas;
            }
            svgImage.setAttributeNS(
              "http://www.w3.org/1999/xlink",
              "xlink:href",
              image.nodeName === "CANVAS" ? image.toDataURL() : image.getAttribute("src")
            );
            parent.appendChild(svgImage);
            this.__currentElement = svgImage;
            this.translate(dx, dy);
            this.__currentElement = currentElement;
          }
        };
        ctx.prototype.createPattern = function(image, repetition) {
          var pattern = this.__document.createElementNS("http://www.w3.org/2000/svg", "pattern"), id = randomString(this.__ids), img;
          pattern.setAttribute("id", id);
          pattern.setAttribute("width", image.width);
          pattern.setAttribute("height", image.height);
          if (image.nodeName === "CANVAS" || image.nodeName === "IMG") {
            img = this.__document.createElementNS("http://www.w3.org/2000/svg", "image");
            img.setAttribute("width", image.width);
            img.setAttribute("height", image.height);
            img.setAttributeNS(
              "http://www.w3.org/1999/xlink",
              "xlink:href",
              image.nodeName === "CANVAS" ? image.toDataURL() : image.getAttribute("src")
            );
            pattern.appendChild(img);
            this.__defs.appendChild(pattern);
          } else if (image instanceof ctx) {
            pattern.appendChild(image.__root.childNodes[1]);
            this.__defs.appendChild(pattern);
          }
          return new CanvasPattern(pattern, this);
        };
        ctx.prototype.drawFocusRing = function() {
        };
        ctx.prototype.createImageData = function() {
        };
        ctx.prototype.getImageData = function() {
        };
        ctx.prototype.putImageData = function() {
        };
        ctx.prototype.globalCompositeOperation = function() {
        };
        ctx.prototype.setTransform = function() {
        };
        if (typeof window === "object") {
          window.C2S = ctx;
        }
        if (typeof module === "object" && typeof module.exports === "object") {
          module.exports = ctx;
        }
      })();
    }
  });

  // node_modules/@jbrowse/core/util/offscreenCanvasUtils.js
  var require_offscreenCanvasUtils = __commonJS({
    "node_modules/@jbrowse/core/util/offscreenCanvasUtils.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o2, m2, k2, k22) {
        if (k22 === void 0) k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m2, k2);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k2];
          } };
        }
        Object.defineProperty(o2, k22, desc);
      }) : (function(o2, m2, k2, k22) {
        if (k22 === void 0) k22 = k2;
        o2[k22] = m2[k2];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v2) {
        Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
      }) : function(o2, v2) {
        o2["default"] = v2;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o2) {
          ownKeys = Object.getOwnPropertyNames || function(o3) {
            var ar = [];
            for (var k2 in o3) if (Object.prototype.hasOwnProperty.call(o3, k2)) ar[ar.length] = k2;
            return ar;
          };
          return ownKeys(o2);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k2 = ownKeys(mod), i2 = 0; i2 < k2.length; i2++) if (k2[i2] !== "default") __createBinding(result, mod, k2[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.renderToAbstractCanvas = renderToAbstractCanvas;
      exports.getSerializedSvg = getSerializedSvg;
      exports.ReactRendering = ReactRendering;
      var jsx_runtime_1 = require_jsx_runtime();
      var react_1 = require_react();
      var canvas_sequencer_1 = require_dist2();
      var blobToDataURL_1 = require_blobToDataURL();
      var offscreenCanvasPonyfill_1 = require_offscreenCanvasPonyfill();
      async function renderToAbstractCanvas(width, height, opts, cb) {
        const { exportSVG, highResolutionScaling = 1 } = opts;
        if (exportSVG) {
          if (!exportSVG.rasterizeLayers) {
            const fakeCtx = new canvas_sequencer_1.CanvasSequence();
            const callbackResult = await cb(fakeCtx);
            return {
              ...callbackResult,
              canvasRecordedData: fakeCtx.toJSON()
            };
          } else {
            const s2 = exportSVG.scale || highResolutionScaling;
            const canvas = (0, offscreenCanvasPonyfill_1.createCanvas)(Math.ceil(width * s2), height * s2);
            const ctx = canvas.getContext("2d");
            if (!ctx) {
              throw new Error("2d canvas rendering not supported on this platform");
            }
            ctx.scale(s2, s2);
            const callbackResult = await cb(ctx);
            return {
              ...callbackResult,
              reactElement: (0, jsx_runtime_1.jsx)("image", { width, height, xlinkHref: "convertToBlob" in canvas ? await (0, blobToDataURL_1.blobToDataURL)(await canvas.convertToBlob({
                type: "image/png"
              })) : canvas.toDataURL("image/png") })
            };
          }
        } else {
          const s2 = highResolutionScaling;
          const canvas = (0, offscreenCanvasPonyfill_1.createCanvas)(Math.ceil(width * s2), height * s2);
          const ctx = canvas.getContext("2d");
          if (!ctx) {
            throw new Error("2d canvas rendering not supported on this platform");
          }
          ctx.scale(s2, s2);
          const callbackResult = await cb(ctx);
          return {
            ...callbackResult,
            imageData: await (0, offscreenCanvasPonyfill_1.createImageBitmap)(canvas)
          };
        }
      }
      async function getSerializedSvg(results) {
        const { width, height, canvasRecordedData } = results;
        const C2S = await Promise.resolve().then(() => __importStar(require_canvas2svg()));
        const ctx = new C2S.default(width, height);
        const seq = new canvas_sequencer_1.CanvasSequence(canvasRecordedData);
        seq.execute(ctx);
        return ctx.getSvg().innerHTML;
      }
      function ReactRendering({ rendering }) {
        return (0, react_1.isValidElement)(rendering.reactElement) ? rendering.reactElement : (0, jsx_runtime_1.jsx)("g", { dangerouslySetInnerHTML: { __html: rendering.html || "" } });
      }
    }
  });

  // node_modules/@jbrowse/core/util/simpleFeature.js
  var require_simpleFeature = __commonJS({
    "node_modules/@jbrowse/core/util/simpleFeature.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isFeature = isFeature;
      function isFeature(thing) {
        return typeof thing === "object" && thing !== null && typeof thing.get === "function" && typeof thing.id === "function";
      }
      function isSimpleFeatureSerialized(args) {
        return "uniqueId" in args && typeof args.data !== "object";
      }
      var SimpleFeature = class _SimpleFeature {
        constructor(args) {
          var _a;
          if (isSimpleFeatureSerialized(args)) {
            this.data = args;
          } else {
            this.data = args.data;
            this.parentHandle = args.parent;
          }
          const id = isSimpleFeatureSerialized(args) ? args.uniqueId : args.id;
          if (id === void 0 || id === null) {
            throw new Error("SimpleFeature requires a unique `id` or `data.uniqueId` attribute");
          }
          this.uniqueId = String(id);
          if (!(this.data.aliases || this.data.end - this.data.start >= 0)) {
            throw new Error(`invalid feature data, end less than start. end: ${this.data.end} start: ${this.data.start}`);
          }
          if (this.data.subfeatures) {
            this.subfeatures = (_a = this.data.subfeatures) === null || _a === void 0 ? void 0 : _a.map((f2, i2) => typeof f2.get !== "function" ? new _SimpleFeature({
              id: f2.uniqueId || `${id}-${i2}`,
              data: {
                strand: this.data.strand,
                ...f2
              },
              parent: this
            }) : f2);
          }
        }
        get(name) {
          return name === "subfeatures" ? this.subfeatures : name === "parent" ? this.parent() : this.data[name];
        }
        set(name, val) {
          this.data[name] = val;
        }
        tags() {
          return Object.keys(this.data);
        }
        id() {
          return this.uniqueId;
        }
        parent() {
          return this.parentHandle;
        }
        children() {
          return this.get("subfeatures");
        }
        toJSON() {
          const d3 = { ...this.data, uniqueId: this.id() };
          const p2 = this.parent();
          if (p2) {
            d3.parentId = p2.id();
          }
          const c2 = this.children();
          if (c2) {
            d3.subfeatures = c2.map((child) => child.toJSON());
          }
          return d3;
        }
        static fromJSON(json) {
          return new _SimpleFeature({ ...json });
        }
      };
      exports.default = SimpleFeature;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/isFunction.js
  var require_isFunction = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/isFunction.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isFunction = void 0;
      function isFunction3(value) {
        return typeof value === "function";
      }
      exports.isFunction = isFunction3;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js
  var require_createErrorClass = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/createErrorClass.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createErrorClass = void 0;
      function createErrorClass2(createImpl) {
        var _super = function(instance) {
          Error.call(instance);
          instance.stack = new Error().stack;
        };
        var ctorFunc = createImpl(_super);
        ctorFunc.prototype = Object.create(Error.prototype);
        ctorFunc.prototype.constructor = ctorFunc;
        return ctorFunc;
      }
      exports.createErrorClass = createErrorClass2;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js
  var require_UnsubscriptionError = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/UnsubscriptionError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.UnsubscriptionError = void 0;
      var createErrorClass_1 = require_createErrorClass();
      exports.UnsubscriptionError = createErrorClass_1.createErrorClass(function(_super) {
        return function UnsubscriptionErrorImpl(errors) {
          _super(this);
          this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err2, i2) {
            return i2 + 1 + ") " + err2.toString();
          }).join("\n  ") : "";
          this.name = "UnsubscriptionError";
          this.errors = errors;
        };
      });
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/arrRemove.js
  var require_arrRemove = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/arrRemove.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.arrRemove = void 0;
      function arrRemove2(arr, item) {
        if (arr) {
          var index3 = arr.indexOf(item);
          0 <= index3 && arr.splice(index3, 1);
        }
      }
      exports.arrRemove = arrRemove2;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/Subscription.js
  var require_Subscription = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/Subscription.js"(exports) {
      "use strict";
      var __values2 = exports && exports.__values || function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2) return m2.call(o2);
        if (o2 && typeof o2.length === "number") return {
          next: function() {
            if (o2 && i2 >= o2.length) o2 = void 0;
            return { value: o2 && o2[i2++], done: !o2 };
          }
        };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      var __read2 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2) return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
          } finally {
            if (e2) throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
        for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from2[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isSubscription = exports.EMPTY_SUBSCRIPTION = exports.Subscription = void 0;
      var isFunction_1 = require_isFunction();
      var UnsubscriptionError_1 = require_UnsubscriptionError();
      var arrRemove_1 = require_arrRemove();
      var Subscription2 = (function() {
        function Subscription3(initialTeardown) {
          this.initialTeardown = initialTeardown;
          this.closed = false;
          this._parentage = null;
          this._finalizers = null;
        }
        Subscription3.prototype.unsubscribe = function() {
          var e_1, _a, e_2, _b;
          var errors;
          if (!this.closed) {
            this.closed = true;
            var _parentage = this._parentage;
            if (_parentage) {
              this._parentage = null;
              if (Array.isArray(_parentage)) {
                try {
                  for (var _parentage_1 = __values2(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                    var parent_1 = _parentage_1_1.value;
                    parent_1.remove(this);
                  }
                } catch (e_1_1) {
                  e_1 = { error: e_1_1 };
                } finally {
                  try {
                    if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
                  } finally {
                    if (e_1) throw e_1.error;
                  }
                }
              } else {
                _parentage.remove(this);
              }
            }
            var initialFinalizer = this.initialTeardown;
            if (isFunction_1.isFunction(initialFinalizer)) {
              try {
                initialFinalizer();
              } catch (e2) {
                errors = e2 instanceof UnsubscriptionError_1.UnsubscriptionError ? e2.errors : [e2];
              }
            }
            var _finalizers = this._finalizers;
            if (_finalizers) {
              this._finalizers = null;
              try {
                for (var _finalizers_1 = __values2(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                  var finalizer = _finalizers_1_1.value;
                  try {
                    execFinalizer2(finalizer);
                  } catch (err2) {
                    errors = errors !== null && errors !== void 0 ? errors : [];
                    if (err2 instanceof UnsubscriptionError_1.UnsubscriptionError) {
                      errors = __spreadArray2(__spreadArray2([], __read2(errors)), __read2(err2.errors));
                    } else {
                      errors.push(err2);
                    }
                  }
                }
              } catch (e_2_1) {
                e_2 = { error: e_2_1 };
              } finally {
                try {
                  if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
                } finally {
                  if (e_2) throw e_2.error;
                }
              }
            }
            if (errors) {
              throw new UnsubscriptionError_1.UnsubscriptionError(errors);
            }
          }
        };
        Subscription3.prototype.add = function(teardown) {
          var _a;
          if (teardown && teardown !== this) {
            if (this.closed) {
              execFinalizer2(teardown);
            } else {
              if (teardown instanceof Subscription3) {
                if (teardown.closed || teardown._hasParent(this)) {
                  return;
                }
                teardown._addParent(this);
              }
              (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
            }
          }
        };
        Subscription3.prototype._hasParent = function(parent) {
          var _parentage = this._parentage;
          return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
        };
        Subscription3.prototype._addParent = function(parent) {
          var _parentage = this._parentage;
          this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
        };
        Subscription3.prototype._removeParent = function(parent) {
          var _parentage = this._parentage;
          if (_parentage === parent) {
            this._parentage = null;
          } else if (Array.isArray(_parentage)) {
            arrRemove_1.arrRemove(_parentage, parent);
          }
        };
        Subscription3.prototype.remove = function(teardown) {
          var _finalizers = this._finalizers;
          _finalizers && arrRemove_1.arrRemove(_finalizers, teardown);
          if (teardown instanceof Subscription3) {
            teardown._removeParent(this);
          }
        };
        Subscription3.EMPTY = (function() {
          var empty = new Subscription3();
          empty.closed = true;
          return empty;
        })();
        return Subscription3;
      })();
      exports.Subscription = Subscription2;
      exports.EMPTY_SUBSCRIPTION = Subscription2.EMPTY;
      function isSubscription2(value) {
        return value instanceof Subscription2 || value && "closed" in value && isFunction_1.isFunction(value.remove) && isFunction_1.isFunction(value.add) && isFunction_1.isFunction(value.unsubscribe);
      }
      exports.isSubscription = isSubscription2;
      function execFinalizer2(finalizer) {
        if (isFunction_1.isFunction(finalizer)) {
          finalizer();
        } else {
          finalizer.unsubscribe();
        }
      }
    }
  });

  // node_modules/rxjs/dist/cjs/internal/config.js
  var require_config = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/config.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.config = void 0;
      exports.config = {
        onUnhandledError: null,
        onStoppedNotification: null,
        Promise: void 0,
        useDeprecatedSynchronousErrorHandling: false,
        useDeprecatedNextContext: false
      };
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js
  var require_timeoutProvider = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduler/timeoutProvider.js"(exports) {
      "use strict";
      var __read2 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2) return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
          } finally {
            if (e2) throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
        for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from2[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.timeoutProvider = void 0;
      exports.timeoutProvider = {
        setTimeout: function(handler, timeout3) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var delegate = exports.timeoutProvider.delegate;
          if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
            return delegate.setTimeout.apply(delegate, __spreadArray2([handler, timeout3], __read2(args)));
          }
          return setTimeout.apply(void 0, __spreadArray2([handler, timeout3], __read2(args)));
        },
        clearTimeout: function(handle) {
          var delegate = exports.timeoutProvider.delegate;
          return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
        },
        delegate: void 0
      };
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js
  var require_reportUnhandledError = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/reportUnhandledError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.reportUnhandledError = void 0;
      var config_1 = require_config();
      var timeoutProvider_1 = require_timeoutProvider();
      function reportUnhandledError2(err2) {
        timeoutProvider_1.timeoutProvider.setTimeout(function() {
          var onUnhandledError = config_1.config.onUnhandledError;
          if (onUnhandledError) {
            onUnhandledError(err2);
          } else {
            throw err2;
          }
        });
      }
      exports.reportUnhandledError = reportUnhandledError2;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/noop.js
  var require_noop = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/noop.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.noop = void 0;
      function noop8() {
      }
      exports.noop = noop8;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/NotificationFactories.js
  var require_NotificationFactories = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/NotificationFactories.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createNotification = exports.nextNotification = exports.errorNotification = exports.COMPLETE_NOTIFICATION = void 0;
      exports.COMPLETE_NOTIFICATION = (function() {
        return createNotification2("C", void 0, void 0);
      })();
      function errorNotification2(error2) {
        return createNotification2("E", void 0, error2);
      }
      exports.errorNotification = errorNotification2;
      function nextNotification2(value) {
        return createNotification2("N", value, void 0);
      }
      exports.nextNotification = nextNotification2;
      function createNotification2(kind, value, error2) {
        return {
          kind,
          value,
          error: error2
        };
      }
      exports.createNotification = createNotification2;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/errorContext.js
  var require_errorContext = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/errorContext.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.captureError = exports.errorContext = void 0;
      var config_1 = require_config();
      var context2 = null;
      function errorContext(cb) {
        if (config_1.config.useDeprecatedSynchronousErrorHandling) {
          var isRoot = !context2;
          if (isRoot) {
            context2 = { errorThrown: false, error: null };
          }
          cb();
          if (isRoot) {
            var _a = context2, errorThrown = _a.errorThrown, error2 = _a.error;
            context2 = null;
            if (errorThrown) {
              throw error2;
            }
          }
        } else {
          cb();
        }
      }
      exports.errorContext = errorContext;
      function captureError2(err2) {
        if (config_1.config.useDeprecatedSynchronousErrorHandling && context2) {
          context2.errorThrown = true;
          context2.error = err2;
        }
      }
      exports.captureError = captureError2;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/Subscriber.js
  var require_Subscriber = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/Subscriber.js"(exports) {
      "use strict";
      var __extends2 = exports && exports.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d3, b2) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
          };
          return extendStatics2(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics2(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EMPTY_OBSERVER = exports.SafeSubscriber = exports.Subscriber = void 0;
      var isFunction_1 = require_isFunction();
      var Subscription_1 = require_Subscription();
      var config_1 = require_config();
      var reportUnhandledError_1 = require_reportUnhandledError();
      var noop_1 = require_noop();
      var NotificationFactories_1 = require_NotificationFactories();
      var timeoutProvider_1 = require_timeoutProvider();
      var errorContext_1 = require_errorContext();
      var Subscriber2 = (function(_super) {
        __extends2(Subscriber3, _super);
        function Subscriber3(destination) {
          var _this = _super.call(this) || this;
          _this.isStopped = false;
          if (destination) {
            _this.destination = destination;
            if (Subscription_1.isSubscription(destination)) {
              destination.add(_this);
            }
          } else {
            _this.destination = exports.EMPTY_OBSERVER;
          }
          return _this;
        }
        Subscriber3.create = function(next2, error2, complete) {
          return new SafeSubscriber2(next2, error2, complete);
        };
        Subscriber3.prototype.next = function(value) {
          if (this.isStopped) {
            handleStoppedNotification2(NotificationFactories_1.nextNotification(value), this);
          } else {
            this._next(value);
          }
        };
        Subscriber3.prototype.error = function(err2) {
          if (this.isStopped) {
            handleStoppedNotification2(NotificationFactories_1.errorNotification(err2), this);
          } else {
            this.isStopped = true;
            this._error(err2);
          }
        };
        Subscriber3.prototype.complete = function() {
          if (this.isStopped) {
            handleStoppedNotification2(NotificationFactories_1.COMPLETE_NOTIFICATION, this);
          } else {
            this.isStopped = true;
            this._complete();
          }
        };
        Subscriber3.prototype.unsubscribe = function() {
          if (!this.closed) {
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
            this.destination = null;
          }
        };
        Subscriber3.prototype._next = function(value) {
          this.destination.next(value);
        };
        Subscriber3.prototype._error = function(err2) {
          try {
            this.destination.error(err2);
          } finally {
            this.unsubscribe();
          }
        };
        Subscriber3.prototype._complete = function() {
          try {
            this.destination.complete();
          } finally {
            this.unsubscribe();
          }
        };
        return Subscriber3;
      })(Subscription_1.Subscription);
      exports.Subscriber = Subscriber2;
      var _bind2 = Function.prototype.bind;
      function bind2(fn, thisArg) {
        return _bind2.call(fn, thisArg);
      }
      var ConsumerObserver2 = (function() {
        function ConsumerObserver3(partialObserver) {
          this.partialObserver = partialObserver;
        }
        ConsumerObserver3.prototype.next = function(value) {
          var partialObserver = this.partialObserver;
          if (partialObserver.next) {
            try {
              partialObserver.next(value);
            } catch (error2) {
              handleUnhandledError2(error2);
            }
          }
        };
        ConsumerObserver3.prototype.error = function(err2) {
          var partialObserver = this.partialObserver;
          if (partialObserver.error) {
            try {
              partialObserver.error(err2);
            } catch (error2) {
              handleUnhandledError2(error2);
            }
          } else {
            handleUnhandledError2(err2);
          }
        };
        ConsumerObserver3.prototype.complete = function() {
          var partialObserver = this.partialObserver;
          if (partialObserver.complete) {
            try {
              partialObserver.complete();
            } catch (error2) {
              handleUnhandledError2(error2);
            }
          }
        };
        return ConsumerObserver3;
      })();
      var SafeSubscriber2 = (function(_super) {
        __extends2(SafeSubscriber3, _super);
        function SafeSubscriber3(observerOrNext, error2, complete) {
          var _this = _super.call(this) || this;
          var partialObserver;
          if (isFunction_1.isFunction(observerOrNext) || !observerOrNext) {
            partialObserver = {
              next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
              error: error2 !== null && error2 !== void 0 ? error2 : void 0,
              complete: complete !== null && complete !== void 0 ? complete : void 0
            };
          } else {
            var context_1;
            if (_this && config_1.config.useDeprecatedNextContext) {
              context_1 = Object.create(observerOrNext);
              context_1.unsubscribe = function() {
                return _this.unsubscribe();
              };
              partialObserver = {
                next: observerOrNext.next && bind2(observerOrNext.next, context_1),
                error: observerOrNext.error && bind2(observerOrNext.error, context_1),
                complete: observerOrNext.complete && bind2(observerOrNext.complete, context_1)
              };
            } else {
              partialObserver = observerOrNext;
            }
          }
          _this.destination = new ConsumerObserver2(partialObserver);
          return _this;
        }
        return SafeSubscriber3;
      })(Subscriber2);
      exports.SafeSubscriber = SafeSubscriber2;
      function handleUnhandledError2(error2) {
        if (config_1.config.useDeprecatedSynchronousErrorHandling) {
          errorContext_1.captureError(error2);
        } else {
          reportUnhandledError_1.reportUnhandledError(error2);
        }
      }
      function defaultErrorHandler2(err2) {
        throw err2;
      }
      function handleStoppedNotification2(notification, subscriber) {
        var onStoppedNotification = config_1.config.onStoppedNotification;
        onStoppedNotification && timeoutProvider_1.timeoutProvider.setTimeout(function() {
          return onStoppedNotification(notification, subscriber);
        });
      }
      exports.EMPTY_OBSERVER = {
        closed: true,
        next: noop_1.noop,
        error: defaultErrorHandler2,
        complete: noop_1.noop
      };
    }
  });

  // node_modules/rxjs/dist/cjs/internal/symbol/observable.js
  var require_observable = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/symbol/observable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.observable = void 0;
      exports.observable = (function() {
        return typeof Symbol === "function" && Symbol.observable || "@@observable";
      })();
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/identity.js
  var require_identity = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/identity.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.identity = void 0;
      function identity(x2) {
        return x2;
      }
      exports.identity = identity;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/pipe.js
  var require_pipe = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/pipe.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.pipeFromArray = exports.pipe = void 0;
      var identity_1 = require_identity();
      function pipe() {
        var fns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          fns[_i] = arguments[_i];
        }
        return pipeFromArray(fns);
      }
      exports.pipe = pipe;
      function pipeFromArray(fns) {
        if (fns.length === 0) {
          return identity_1.identity;
        }
        if (fns.length === 1) {
          return fns[0];
        }
        return function piped(input) {
          return fns.reduce(function(prev2, fn) {
            return fn(prev2);
          }, input);
        };
      }
      exports.pipeFromArray = pipeFromArray;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/Observable.js
  var require_Observable = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/Observable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Observable = void 0;
      var Subscriber_1 = require_Subscriber();
      var Subscription_1 = require_Subscription();
      var observable_1 = require_observable();
      var pipe_1 = require_pipe();
      var config_1 = require_config();
      var isFunction_1 = require_isFunction();
      var errorContext_1 = require_errorContext();
      var Observable = (function() {
        function Observable2(subscribe) {
          if (subscribe) {
            this._subscribe = subscribe;
          }
        }
        Observable2.prototype.lift = function(operator) {
          var observable = new Observable2();
          observable.source = this;
          observable.operator = operator;
          return observable;
        };
        Observable2.prototype.subscribe = function(observerOrNext, error2, complete) {
          var _this = this;
          var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new Subscriber_1.SafeSubscriber(observerOrNext, error2, complete);
          errorContext_1.errorContext(function() {
            var _a = _this, operator = _a.operator, source = _a.source;
            subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
          });
          return subscriber;
        };
        Observable2.prototype._trySubscribe = function(sink) {
          try {
            return this._subscribe(sink);
          } catch (err2) {
            sink.error(err2);
          }
        };
        Observable2.prototype.forEach = function(next2, promiseCtor) {
          var _this = this;
          promiseCtor = getPromiseCtor(promiseCtor);
          return new promiseCtor(function(resolve, reject) {
            var subscriber = new Subscriber_1.SafeSubscriber({
              next: function(value) {
                try {
                  next2(value);
                } catch (err2) {
                  reject(err2);
                  subscriber.unsubscribe();
                }
              },
              error: reject,
              complete: resolve
            });
            _this.subscribe(subscriber);
          });
        };
        Observable2.prototype._subscribe = function(subscriber) {
          var _a;
          return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
        };
        Observable2.prototype[observable_1.observable] = function() {
          return this;
        };
        Observable2.prototype.pipe = function() {
          var operations = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
          }
          return pipe_1.pipeFromArray(operations)(this);
        };
        Observable2.prototype.toPromise = function(promiseCtor) {
          var _this = this;
          promiseCtor = getPromiseCtor(promiseCtor);
          return new promiseCtor(function(resolve, reject) {
            var value;
            _this.subscribe(function(x2) {
              return value = x2;
            }, function(err2) {
              return reject(err2);
            }, function() {
              return resolve(value);
            });
          });
        };
        Observable2.create = function(subscribe) {
          return new Observable2(subscribe);
        };
        return Observable2;
      })();
      exports.Observable = Observable;
      function getPromiseCtor(promiseCtor) {
        var _a;
        return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config_1.config.Promise) !== null && _a !== void 0 ? _a : Promise;
      }
      function isObserver(value) {
        return value && isFunction_1.isFunction(value.next) && isFunction_1.isFunction(value.error) && isFunction_1.isFunction(value.complete);
      }
      function isSubscriber(value) {
        return value && value instanceof Subscriber_1.Subscriber || isObserver(value) && Subscription_1.isSubscription(value);
      }
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/lift.js
  var require_lift = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/lift.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.operate = exports.hasLift = void 0;
      var isFunction_1 = require_isFunction();
      function hasLift2(source) {
        return isFunction_1.isFunction(source === null || source === void 0 ? void 0 : source.lift);
      }
      exports.hasLift = hasLift2;
      function operate2(init) {
        return function(source) {
          if (hasLift2(source)) {
            return source.lift(function(liftedSource) {
              try {
                return init(liftedSource, this);
              } catch (err2) {
                this.error(err2);
              }
            });
          }
          throw new TypeError("Unable to lift unknown Observable type");
        };
      }
      exports.operate = operate2;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js
  var require_OperatorSubscriber = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/OperatorSubscriber.js"(exports) {
      "use strict";
      var __extends2 = exports && exports.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d3, b2) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
          };
          return extendStatics2(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics2(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.OperatorSubscriber = exports.createOperatorSubscriber = void 0;
      var Subscriber_1 = require_Subscriber();
      function createOperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize) {
        return new OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize);
      }
      exports.createOperatorSubscriber = createOperatorSubscriber2;
      var OperatorSubscriber2 = (function(_super) {
        __extends2(OperatorSubscriber3, _super);
        function OperatorSubscriber3(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
          var _this = _super.call(this, destination) || this;
          _this.onFinalize = onFinalize;
          _this.shouldUnsubscribe = shouldUnsubscribe;
          _this._next = onNext ? function(value) {
            try {
              onNext(value);
            } catch (err2) {
              destination.error(err2);
            }
          } : _super.prototype._next;
          _this._error = onError ? function(err2) {
            try {
              onError(err2);
            } catch (err3) {
              destination.error(err3);
            } finally {
              this.unsubscribe();
            }
          } : _super.prototype._error;
          _this._complete = onComplete ? function() {
            try {
              onComplete();
            } catch (err2) {
              destination.error(err2);
            } finally {
              this.unsubscribe();
            }
          } : _super.prototype._complete;
          return _this;
        }
        OperatorSubscriber3.prototype.unsubscribe = function() {
          var _a;
          if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
            var closed_1 = this.closed;
            _super.prototype.unsubscribe.call(this);
            !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
          }
        };
        return OperatorSubscriber3;
      })(Subscriber_1.Subscriber);
      exports.OperatorSubscriber = OperatorSubscriber2;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/refCount.js
  var require_refCount = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/refCount.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.refCount = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function refCount() {
        return lift_1.operate(function(source, subscriber) {
          var connection = null;
          source._refCount++;
          var refCounter = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
            if (!source || source._refCount <= 0 || 0 < --source._refCount) {
              connection = null;
              return;
            }
            var sharedConnection = source._connection;
            var conn = connection;
            connection = null;
            if (sharedConnection && (!conn || sharedConnection === conn)) {
              sharedConnection.unsubscribe();
            }
            subscriber.unsubscribe();
          });
          source.subscribe(refCounter);
          if (!refCounter.closed) {
            connection = source.connect();
          }
        });
      }
      exports.refCount = refCount;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js
  var require_ConnectableObservable = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/ConnectableObservable.js"(exports) {
      "use strict";
      var __extends2 = exports && exports.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d3, b2) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
          };
          return extendStatics2(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics2(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ConnectableObservable = void 0;
      var Observable_1 = require_Observable();
      var Subscription_1 = require_Subscription();
      var refCount_1 = require_refCount();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var lift_1 = require_lift();
      var ConnectableObservable = (function(_super) {
        __extends2(ConnectableObservable2, _super);
        function ConnectableObservable2(source, subjectFactory) {
          var _this = _super.call(this) || this;
          _this.source = source;
          _this.subjectFactory = subjectFactory;
          _this._subject = null;
          _this._refCount = 0;
          _this._connection = null;
          if (lift_1.hasLift(source)) {
            _this.lift = source.lift;
          }
          return _this;
        }
        ConnectableObservable2.prototype._subscribe = function(subscriber) {
          return this.getSubject().subscribe(subscriber);
        };
        ConnectableObservable2.prototype.getSubject = function() {
          var subject = this._subject;
          if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
          }
          return this._subject;
        };
        ConnectableObservable2.prototype._teardown = function() {
          this._refCount = 0;
          var _connection = this._connection;
          this._subject = this._connection = null;
          _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
        };
        ConnectableObservable2.prototype.connect = function() {
          var _this = this;
          var connection = this._connection;
          if (!connection) {
            connection = this._connection = new Subscription_1.Subscription();
            var subject_1 = this.getSubject();
            connection.add(this.source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subject_1, void 0, function() {
              _this._teardown();
              subject_1.complete();
            }, function(err2) {
              _this._teardown();
              subject_1.error(err2);
            }, function() {
              return _this._teardown();
            })));
            if (connection.closed) {
              this._connection = null;
              connection = Subscription_1.Subscription.EMPTY;
            }
          }
          return connection;
        };
        ConnectableObservable2.prototype.refCount = function() {
          return refCount_1.refCount()(this);
        };
        return ConnectableObservable2;
      })(Observable_1.Observable);
      exports.ConnectableObservable = ConnectableObservable;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js
  var require_performanceTimestampProvider = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduler/performanceTimestampProvider.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.performanceTimestampProvider = void 0;
      exports.performanceTimestampProvider = {
        now: function() {
          return (exports.performanceTimestampProvider.delegate || performance).now();
        },
        delegate: void 0
      };
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js
  var require_animationFrameProvider = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduler/animationFrameProvider.js"(exports) {
      "use strict";
      var __read2 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2) return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
          } finally {
            if (e2) throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
        for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from2[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.animationFrameProvider = void 0;
      var Subscription_1 = require_Subscription();
      exports.animationFrameProvider = {
        schedule: function(callback) {
          var request = requestAnimationFrame;
          var cancel = cancelAnimationFrame;
          var delegate = exports.animationFrameProvider.delegate;
          if (delegate) {
            request = delegate.requestAnimationFrame;
            cancel = delegate.cancelAnimationFrame;
          }
          var handle = request(function(timestamp) {
            cancel = void 0;
            callback(timestamp);
          });
          return new Subscription_1.Subscription(function() {
            return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
          });
        },
        requestAnimationFrame: function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var delegate = exports.animationFrameProvider.delegate;
          return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray2([], __read2(args)));
        },
        cancelAnimationFrame: function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var delegate = exports.animationFrameProvider.delegate;
          return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray2([], __read2(args)));
        },
        delegate: void 0
      };
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js
  var require_animationFrames = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/dom/animationFrames.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.animationFrames = void 0;
      var Observable_1 = require_Observable();
      var performanceTimestampProvider_1 = require_performanceTimestampProvider();
      var animationFrameProvider_1 = require_animationFrameProvider();
      function animationFrames(timestampProvider) {
        return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;
      }
      exports.animationFrames = animationFrames;
      function animationFramesFactory(timestampProvider) {
        return new Observable_1.Observable(function(subscriber) {
          var provider = timestampProvider || performanceTimestampProvider_1.performanceTimestampProvider;
          var start = provider.now();
          var id = 0;
          var run = function() {
            if (!subscriber.closed) {
              id = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function(timestamp) {
                id = 0;
                var now = provider.now();
                subscriber.next({
                  timestamp: timestampProvider ? now : timestamp,
                  elapsed: now - start
                });
                run();
              });
            }
          };
          run();
          return function() {
            if (id) {
              animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
            }
          };
        });
      }
      var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js
  var require_ObjectUnsubscribedError = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/ObjectUnsubscribedError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ObjectUnsubscribedError = void 0;
      var createErrorClass_1 = require_createErrorClass();
      exports.ObjectUnsubscribedError = createErrorClass_1.createErrorClass(function(_super) {
        return function ObjectUnsubscribedErrorImpl() {
          _super(this);
          this.name = "ObjectUnsubscribedError";
          this.message = "object unsubscribed";
        };
      });
    }
  });

  // node_modules/rxjs/dist/cjs/internal/Subject.js
  var require_Subject = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/Subject.js"(exports) {
      "use strict";
      var __extends2 = exports && exports.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d3, b2) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
          };
          return extendStatics2(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics2(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      var __values2 = exports && exports.__values || function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2) return m2.call(o2);
        if (o2 && typeof o2.length === "number") return {
          next: function() {
            if (o2 && i2 >= o2.length) o2 = void 0;
            return { value: o2 && o2[i2++], done: !o2 };
          }
        };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AnonymousSubject = exports.Subject = void 0;
      var Observable_1 = require_Observable();
      var Subscription_1 = require_Subscription();
      var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
      var arrRemove_1 = require_arrRemove();
      var errorContext_1 = require_errorContext();
      var Subject = (function(_super) {
        __extends2(Subject2, _super);
        function Subject2() {
          var _this = _super.call(this) || this;
          _this.closed = false;
          _this.currentObservers = null;
          _this.observers = [];
          _this.isStopped = false;
          _this.hasError = false;
          _this.thrownError = null;
          return _this;
        }
        Subject2.prototype.lift = function(operator) {
          var subject = new AnonymousSubject(this, this);
          subject.operator = operator;
          return subject;
        };
        Subject2.prototype._throwIfClosed = function() {
          if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
          }
        };
        Subject2.prototype.next = function(value) {
          var _this = this;
          errorContext_1.errorContext(function() {
            var e_1, _a;
            _this._throwIfClosed();
            if (!_this.isStopped) {
              if (!_this.currentObservers) {
                _this.currentObservers = Array.from(_this.observers);
              }
              try {
                for (var _b = __values2(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
                  var observer50 = _c.value;
                  observer50.next(value);
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                } finally {
                  if (e_1) throw e_1.error;
                }
              }
            }
          });
        };
        Subject2.prototype.error = function(err2) {
          var _this = this;
          errorContext_1.errorContext(function() {
            _this._throwIfClosed();
            if (!_this.isStopped) {
              _this.hasError = _this.isStopped = true;
              _this.thrownError = err2;
              var observers = _this.observers;
              while (observers.length) {
                observers.shift().error(err2);
              }
            }
          });
        };
        Subject2.prototype.complete = function() {
          var _this = this;
          errorContext_1.errorContext(function() {
            _this._throwIfClosed();
            if (!_this.isStopped) {
              _this.isStopped = true;
              var observers = _this.observers;
              while (observers.length) {
                observers.shift().complete();
              }
            }
          });
        };
        Subject2.prototype.unsubscribe = function() {
          this.isStopped = this.closed = true;
          this.observers = this.currentObservers = null;
        };
        Object.defineProperty(Subject2.prototype, "observed", {
          get: function() {
            var _a;
            return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
          },
          enumerable: false,
          configurable: true
        });
        Subject2.prototype._trySubscribe = function(subscriber) {
          this._throwIfClosed();
          return _super.prototype._trySubscribe.call(this, subscriber);
        };
        Subject2.prototype._subscribe = function(subscriber) {
          this._throwIfClosed();
          this._checkFinalizedStatuses(subscriber);
          return this._innerSubscribe(subscriber);
        };
        Subject2.prototype._innerSubscribe = function(subscriber) {
          var _this = this;
          var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
          if (hasError || isStopped) {
            return Subscription_1.EMPTY_SUBSCRIPTION;
          }
          this.currentObservers = null;
          observers.push(subscriber);
          return new Subscription_1.Subscription(function() {
            _this.currentObservers = null;
            arrRemove_1.arrRemove(observers, subscriber);
          });
        };
        Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
          var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
          if (hasError) {
            subscriber.error(thrownError);
          } else if (isStopped) {
            subscriber.complete();
          }
        };
        Subject2.prototype.asObservable = function() {
          var observable = new Observable_1.Observable();
          observable.source = this;
          return observable;
        };
        Subject2.create = function(destination, source) {
          return new AnonymousSubject(destination, source);
        };
        return Subject2;
      })(Observable_1.Observable);
      exports.Subject = Subject;
      var AnonymousSubject = (function(_super) {
        __extends2(AnonymousSubject2, _super);
        function AnonymousSubject2(destination, source) {
          var _this = _super.call(this) || this;
          _this.destination = destination;
          _this.source = source;
          return _this;
        }
        AnonymousSubject2.prototype.next = function(value) {
          var _a, _b;
          (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
        };
        AnonymousSubject2.prototype.error = function(err2) {
          var _a, _b;
          (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err2);
        };
        AnonymousSubject2.prototype.complete = function() {
          var _a, _b;
          (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        AnonymousSubject2.prototype._subscribe = function(subscriber) {
          var _a, _b;
          return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : Subscription_1.EMPTY_SUBSCRIPTION;
        };
        return AnonymousSubject2;
      })(Subject);
      exports.AnonymousSubject = AnonymousSubject;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js
  var require_BehaviorSubject = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/BehaviorSubject.js"(exports) {
      "use strict";
      var __extends2 = exports && exports.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d3, b2) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
          };
          return extendStatics2(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics2(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BehaviorSubject = void 0;
      var Subject_1 = require_Subject();
      var BehaviorSubject = (function(_super) {
        __extends2(BehaviorSubject2, _super);
        function BehaviorSubject2(_value) {
          var _this = _super.call(this) || this;
          _this._value = _value;
          return _this;
        }
        Object.defineProperty(BehaviorSubject2.prototype, "value", {
          get: function() {
            return this.getValue();
          },
          enumerable: false,
          configurable: true
        });
        BehaviorSubject2.prototype._subscribe = function(subscriber) {
          var subscription = _super.prototype._subscribe.call(this, subscriber);
          !subscription.closed && subscriber.next(this._value);
          return subscription;
        };
        BehaviorSubject2.prototype.getValue = function() {
          var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
          if (hasError) {
            throw thrownError;
          }
          this._throwIfClosed();
          return _value;
        };
        BehaviorSubject2.prototype.next = function(value) {
          _super.prototype.next.call(this, this._value = value);
        };
        return BehaviorSubject2;
      })(Subject_1.Subject);
      exports.BehaviorSubject = BehaviorSubject;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js
  var require_dateTimestampProvider = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduler/dateTimestampProvider.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.dateTimestampProvider = void 0;
      exports.dateTimestampProvider = {
        now: function() {
          return (exports.dateTimestampProvider.delegate || Date).now();
        },
        delegate: void 0
      };
    }
  });

  // node_modules/rxjs/dist/cjs/internal/ReplaySubject.js
  var require_ReplaySubject = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/ReplaySubject.js"(exports) {
      "use strict";
      var __extends2 = exports && exports.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d3, b2) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
          };
          return extendStatics2(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics2(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReplaySubject = void 0;
      var Subject_1 = require_Subject();
      var dateTimestampProvider_1 = require_dateTimestampProvider();
      var ReplaySubject = (function(_super) {
        __extends2(ReplaySubject2, _super);
        function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
          if (_bufferSize === void 0) {
            _bufferSize = Infinity;
          }
          if (_windowTime === void 0) {
            _windowTime = Infinity;
          }
          if (_timestampProvider === void 0) {
            _timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
          }
          var _this = _super.call(this) || this;
          _this._bufferSize = _bufferSize;
          _this._windowTime = _windowTime;
          _this._timestampProvider = _timestampProvider;
          _this._buffer = [];
          _this._infiniteTimeWindow = true;
          _this._infiniteTimeWindow = _windowTime === Infinity;
          _this._bufferSize = Math.max(1, _bufferSize);
          _this._windowTime = Math.max(1, _windowTime);
          return _this;
        }
        ReplaySubject2.prototype.next = function(value) {
          var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
          if (!isStopped) {
            _buffer.push(value);
            !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
          }
          this._trimBuffer();
          _super.prototype.next.call(this, value);
        };
        ReplaySubject2.prototype._subscribe = function(subscriber) {
          this._throwIfClosed();
          this._trimBuffer();
          var subscription = this._innerSubscribe(subscriber);
          var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
          var copy4 = _buffer.slice();
          for (var i2 = 0; i2 < copy4.length && !subscriber.closed; i2 += _infiniteTimeWindow ? 1 : 2) {
            subscriber.next(copy4[i2]);
          }
          this._checkFinalizedStatuses(subscriber);
          return subscription;
        };
        ReplaySubject2.prototype._trimBuffer = function() {
          var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
          var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
          _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
          if (!_infiniteTimeWindow) {
            var now = _timestampProvider.now();
            var last = 0;
            for (var i2 = 1; i2 < _buffer.length && _buffer[i2] <= now; i2 += 2) {
              last = i2;
            }
            last && _buffer.splice(0, last + 1);
          }
        };
        return ReplaySubject2;
      })(Subject_1.Subject);
      exports.ReplaySubject = ReplaySubject;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/AsyncSubject.js
  var require_AsyncSubject = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/AsyncSubject.js"(exports) {
      "use strict";
      var __extends2 = exports && exports.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d3, b2) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
          };
          return extendStatics2(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics2(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AsyncSubject = void 0;
      var Subject_1 = require_Subject();
      var AsyncSubject = (function(_super) {
        __extends2(AsyncSubject2, _super);
        function AsyncSubject2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this._value = null;
          _this._hasValue = false;
          _this._isComplete = false;
          return _this;
        }
        AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
          var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
          if (hasError) {
            subscriber.error(thrownError);
          } else if (isStopped || _isComplete) {
            _hasValue && subscriber.next(_value);
            subscriber.complete();
          }
        };
        AsyncSubject2.prototype.next = function(value) {
          if (!this.isStopped) {
            this._value = value;
            this._hasValue = true;
          }
        };
        AsyncSubject2.prototype.complete = function() {
          var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
          if (!_isComplete) {
            this._isComplete = true;
            _hasValue && _super.prototype.next.call(this, _value);
            _super.prototype.complete.call(this);
          }
        };
        return AsyncSubject2;
      })(Subject_1.Subject);
      exports.AsyncSubject = AsyncSubject;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduler/Action.js
  var require_Action = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduler/Action.js"(exports) {
      "use strict";
      var __extends2 = exports && exports.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d3, b2) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
          };
          return extendStatics2(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics2(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Action = void 0;
      var Subscription_1 = require_Subscription();
      var Action = (function(_super) {
        __extends2(Action2, _super);
        function Action2(scheduler, work) {
          return _super.call(this) || this;
        }
        Action2.prototype.schedule = function(state, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          return this;
        };
        return Action2;
      })(Subscription_1.Subscription);
      exports.Action = Action;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js
  var require_intervalProvider = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduler/intervalProvider.js"(exports) {
      "use strict";
      var __read2 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2) return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
          } finally {
            if (e2) throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
        for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from2[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.intervalProvider = void 0;
      exports.intervalProvider = {
        setInterval: function(handler, timeout3) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var delegate = exports.intervalProvider.delegate;
          if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
            return delegate.setInterval.apply(delegate, __spreadArray2([handler, timeout3], __read2(args)));
          }
          return setInterval.apply(void 0, __spreadArray2([handler, timeout3], __read2(args)));
        },
        clearInterval: function(handle) {
          var delegate = exports.intervalProvider.delegate;
          return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
        },
        delegate: void 0
      };
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js
  var require_AsyncAction = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduler/AsyncAction.js"(exports) {
      "use strict";
      var __extends2 = exports && exports.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d3, b2) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
          };
          return extendStatics2(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics2(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AsyncAction = void 0;
      var Action_1 = require_Action();
      var intervalProvider_1 = require_intervalProvider();
      var arrRemove_1 = require_arrRemove();
      var AsyncAction = (function(_super) {
        __extends2(AsyncAction2, _super);
        function AsyncAction2(scheduler, work) {
          var _this = _super.call(this, scheduler, work) || this;
          _this.scheduler = scheduler;
          _this.work = work;
          _this.pending = false;
          return _this;
        }
        AsyncAction2.prototype.schedule = function(state, delay) {
          var _a;
          if (delay === void 0) {
            delay = 0;
          }
          if (this.closed) {
            return this;
          }
          this.state = state;
          var id = this.id;
          var scheduler = this.scheduler;
          if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
          }
          this.pending = true;
          this.delay = delay;
          this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
          return this;
        };
        AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          return intervalProvider_1.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
        };
        AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          if (delay != null && this.delay === delay && this.pending === false) {
            return id;
          }
          if (id != null) {
            intervalProvider_1.intervalProvider.clearInterval(id);
          }
          return void 0;
        };
        AsyncAction2.prototype.execute = function(state, delay) {
          if (this.closed) {
            return new Error("executing a cancelled action");
          }
          this.pending = false;
          var error2 = this._execute(state, delay);
          if (error2) {
            return error2;
          } else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
          }
        };
        AsyncAction2.prototype._execute = function(state, _delay) {
          var errored = false;
          var errorValue;
          try {
            this.work(state);
          } catch (e2) {
            errored = true;
            errorValue = e2 ? e2 : new Error("Scheduled action threw falsy error");
          }
          if (errored) {
            this.unsubscribe();
            return errorValue;
          }
        };
        AsyncAction2.prototype.unsubscribe = function() {
          if (!this.closed) {
            var _a = this, id = _a.id, scheduler = _a.scheduler;
            var actions = scheduler.actions;
            this.work = this.state = this.scheduler = null;
            this.pending = false;
            arrRemove_1.arrRemove(actions, this);
            if (id != null) {
              this.id = this.recycleAsyncId(scheduler, id, null);
            }
            this.delay = null;
            _super.prototype.unsubscribe.call(this);
          }
        };
        return AsyncAction2;
      })(Action_1.Action);
      exports.AsyncAction = AsyncAction;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/Immediate.js
  var require_Immediate = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/Immediate.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TestTools = exports.Immediate = void 0;
      var nextHandle = 1;
      var resolved;
      var activeHandles = {};
      function findAndClearHandle(handle) {
        if (handle in activeHandles) {
          delete activeHandles[handle];
          return true;
        }
        return false;
      }
      exports.Immediate = {
        setImmediate: function(cb) {
          var handle = nextHandle++;
          activeHandles[handle] = true;
          if (!resolved) {
            resolved = Promise.resolve();
          }
          resolved.then(function() {
            return findAndClearHandle(handle) && cb();
          });
          return handle;
        },
        clearImmediate: function(handle) {
          findAndClearHandle(handle);
        }
      };
      exports.TestTools = {
        pending: function() {
          return Object.keys(activeHandles).length;
        }
      };
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js
  var require_immediateProvider = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduler/immediateProvider.js"(exports) {
      "use strict";
      var __read2 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2) return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
          } finally {
            if (e2) throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
        for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from2[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.immediateProvider = void 0;
      var Immediate_1 = require_Immediate();
      var setImmediate = Immediate_1.Immediate.setImmediate;
      var clearImmediate = Immediate_1.Immediate.clearImmediate;
      exports.immediateProvider = {
        setImmediate: function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var delegate = exports.immediateProvider.delegate;
          return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray2([], __read2(args)));
        },
        clearImmediate: function(handle) {
          var delegate = exports.immediateProvider.delegate;
          return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
        },
        delegate: void 0
      };
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js
  var require_AsapAction = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduler/AsapAction.js"(exports) {
      "use strict";
      var __extends2 = exports && exports.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d3, b2) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
          };
          return extendStatics2(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics2(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AsapAction = void 0;
      var AsyncAction_1 = require_AsyncAction();
      var immediateProvider_1 = require_immediateProvider();
      var AsapAction = (function(_super) {
        __extends2(AsapAction2, _super);
        function AsapAction2(scheduler, work) {
          var _this = _super.call(this, scheduler, work) || this;
          _this.scheduler = scheduler;
          _this.work = work;
          return _this;
        }
        AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
          }
          scheduler.actions.push(this);
          return scheduler._scheduled || (scheduler._scheduled = immediateProvider_1.immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
        };
        AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
          var _a;
          if (delay === void 0) {
            delay = 0;
          }
          if (delay != null ? delay > 0 : this.delay > 0) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
          }
          var actions = scheduler.actions;
          if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
            immediateProvider_1.immediateProvider.clearImmediate(id);
            if (scheduler._scheduled === id) {
              scheduler._scheduled = void 0;
            }
          }
          return void 0;
        };
        return AsapAction2;
      })(AsyncAction_1.AsyncAction);
      exports.AsapAction = AsapAction;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/Scheduler.js
  var require_Scheduler = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/Scheduler.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Scheduler = void 0;
      var dateTimestampProvider_1 = require_dateTimestampProvider();
      var Scheduler = (function() {
        function Scheduler2(schedulerActionCtor, now) {
          if (now === void 0) {
            now = Scheduler2.now;
          }
          this.schedulerActionCtor = schedulerActionCtor;
          this.now = now;
        }
        Scheduler2.prototype.schedule = function(work, delay, state) {
          if (delay === void 0) {
            delay = 0;
          }
          return new this.schedulerActionCtor(this, work).schedule(state, delay);
        };
        Scheduler2.now = dateTimestampProvider_1.dateTimestampProvider.now;
        return Scheduler2;
      })();
      exports.Scheduler = Scheduler;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js
  var require_AsyncScheduler = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduler/AsyncScheduler.js"(exports) {
      "use strict";
      var __extends2 = exports && exports.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d3, b2) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
          };
          return extendStatics2(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics2(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AsyncScheduler = void 0;
      var Scheduler_1 = require_Scheduler();
      var AsyncScheduler = (function(_super) {
        __extends2(AsyncScheduler2, _super);
        function AsyncScheduler2(SchedulerAction, now) {
          if (now === void 0) {
            now = Scheduler_1.Scheduler.now;
          }
          var _this = _super.call(this, SchedulerAction, now) || this;
          _this.actions = [];
          _this._active = false;
          return _this;
        }
        AsyncScheduler2.prototype.flush = function(action) {
          var actions = this.actions;
          if (this._active) {
            actions.push(action);
            return;
          }
          var error2;
          this._active = true;
          do {
            if (error2 = action.execute(action.state, action.delay)) {
              break;
            }
          } while (action = actions.shift());
          this._active = false;
          if (error2) {
            while (action = actions.shift()) {
              action.unsubscribe();
            }
            throw error2;
          }
        };
        return AsyncScheduler2;
      })(Scheduler_1.Scheduler);
      exports.AsyncScheduler = AsyncScheduler;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js
  var require_AsapScheduler = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduler/AsapScheduler.js"(exports) {
      "use strict";
      var __extends2 = exports && exports.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d3, b2) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
          };
          return extendStatics2(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics2(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AsapScheduler = void 0;
      var AsyncScheduler_1 = require_AsyncScheduler();
      var AsapScheduler = (function(_super) {
        __extends2(AsapScheduler2, _super);
        function AsapScheduler2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        AsapScheduler2.prototype.flush = function(action) {
          this._active = true;
          var flushId = this._scheduled;
          this._scheduled = void 0;
          var actions = this.actions;
          var error2;
          action = action || actions.shift();
          do {
            if (error2 = action.execute(action.state, action.delay)) {
              break;
            }
          } while ((action = actions[0]) && action.id === flushId && actions.shift());
          this._active = false;
          if (error2) {
            while ((action = actions[0]) && action.id === flushId && actions.shift()) {
              action.unsubscribe();
            }
            throw error2;
          }
        };
        return AsapScheduler2;
      })(AsyncScheduler_1.AsyncScheduler);
      exports.AsapScheduler = AsapScheduler;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduler/asap.js
  var require_asap = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduler/asap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.asap = exports.asapScheduler = void 0;
      var AsapAction_1 = require_AsapAction();
      var AsapScheduler_1 = require_AsapScheduler();
      exports.asapScheduler = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);
      exports.asap = exports.asapScheduler;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduler/async.js
  var require_async = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduler/async.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.async = exports.asyncScheduler = void 0;
      var AsyncAction_1 = require_AsyncAction();
      var AsyncScheduler_1 = require_AsyncScheduler();
      exports.asyncScheduler = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);
      exports.async = exports.asyncScheduler;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js
  var require_QueueAction = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduler/QueueAction.js"(exports) {
      "use strict";
      var __extends2 = exports && exports.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d3, b2) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
          };
          return extendStatics2(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics2(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.QueueAction = void 0;
      var AsyncAction_1 = require_AsyncAction();
      var QueueAction = (function(_super) {
        __extends2(QueueAction2, _super);
        function QueueAction2(scheduler, work) {
          var _this = _super.call(this, scheduler, work) || this;
          _this.scheduler = scheduler;
          _this.work = work;
          return _this;
        }
        QueueAction2.prototype.schedule = function(state, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
          }
          this.delay = delay;
          this.state = state;
          this.scheduler.flush(this);
          return this;
        };
        QueueAction2.prototype.execute = function(state, delay) {
          return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
        };
        QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          if (delay != null && delay > 0 || delay == null && this.delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
          }
          scheduler.flush(this);
          return 0;
        };
        return QueueAction2;
      })(AsyncAction_1.AsyncAction);
      exports.QueueAction = QueueAction;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js
  var require_QueueScheduler = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduler/QueueScheduler.js"(exports) {
      "use strict";
      var __extends2 = exports && exports.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d3, b2) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
          };
          return extendStatics2(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics2(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.QueueScheduler = void 0;
      var AsyncScheduler_1 = require_AsyncScheduler();
      var QueueScheduler = (function(_super) {
        __extends2(QueueScheduler2, _super);
        function QueueScheduler2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        return QueueScheduler2;
      })(AsyncScheduler_1.AsyncScheduler);
      exports.QueueScheduler = QueueScheduler;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduler/queue.js
  var require_queue = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduler/queue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.queue = exports.queueScheduler = void 0;
      var QueueAction_1 = require_QueueAction();
      var QueueScheduler_1 = require_QueueScheduler();
      exports.queueScheduler = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);
      exports.queue = exports.queueScheduler;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js
  var require_AnimationFrameAction = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameAction.js"(exports) {
      "use strict";
      var __extends2 = exports && exports.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d3, b2) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
          };
          return extendStatics2(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics2(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AnimationFrameAction = void 0;
      var AsyncAction_1 = require_AsyncAction();
      var animationFrameProvider_1 = require_animationFrameProvider();
      var AnimationFrameAction = (function(_super) {
        __extends2(AnimationFrameAction2, _super);
        function AnimationFrameAction2(scheduler, work) {
          var _this = _super.call(this, scheduler, work) || this;
          _this.scheduler = scheduler;
          _this.work = work;
          return _this;
        }
        AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
          }
          scheduler.actions.push(this);
          return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider_1.animationFrameProvider.requestAnimationFrame(function() {
            return scheduler.flush(void 0);
          }));
        };
        AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
          var _a;
          if (delay === void 0) {
            delay = 0;
          }
          if (delay != null ? delay > 0 : this.delay > 0) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
          }
          var actions = scheduler.actions;
          if (id != null && id === scheduler._scheduled && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
            animationFrameProvider_1.animationFrameProvider.cancelAnimationFrame(id);
            scheduler._scheduled = void 0;
          }
          return void 0;
        };
        return AnimationFrameAction2;
      })(AsyncAction_1.AsyncAction);
      exports.AnimationFrameAction = AnimationFrameAction;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js
  var require_AnimationFrameScheduler = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduler/AnimationFrameScheduler.js"(exports) {
      "use strict";
      var __extends2 = exports && exports.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d3, b2) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
          };
          return extendStatics2(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics2(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AnimationFrameScheduler = void 0;
      var AsyncScheduler_1 = require_AsyncScheduler();
      var AnimationFrameScheduler = (function(_super) {
        __extends2(AnimationFrameScheduler2, _super);
        function AnimationFrameScheduler2() {
          return _super !== null && _super.apply(this, arguments) || this;
        }
        AnimationFrameScheduler2.prototype.flush = function(action) {
          this._active = true;
          var flushId;
          if (action) {
            flushId = action.id;
          } else {
            flushId = this._scheduled;
            this._scheduled = void 0;
          }
          var actions = this.actions;
          var error2;
          action = action || actions.shift();
          do {
            if (error2 = action.execute(action.state, action.delay)) {
              break;
            }
          } while ((action = actions[0]) && action.id === flushId && actions.shift());
          this._active = false;
          if (error2) {
            while ((action = actions[0]) && action.id === flushId && actions.shift()) {
              action.unsubscribe();
            }
            throw error2;
          }
        };
        return AnimationFrameScheduler2;
      })(AsyncScheduler_1.AsyncScheduler);
      exports.AnimationFrameScheduler = AnimationFrameScheduler;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js
  var require_animationFrame = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduler/animationFrame.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.animationFrame = exports.animationFrameScheduler = void 0;
      var AnimationFrameAction_1 = require_AnimationFrameAction();
      var AnimationFrameScheduler_1 = require_AnimationFrameScheduler();
      exports.animationFrameScheduler = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);
      exports.animationFrame = exports.animationFrameScheduler;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js
  var require_VirtualTimeScheduler = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduler/VirtualTimeScheduler.js"(exports) {
      "use strict";
      var __extends2 = exports && exports.__extends || /* @__PURE__ */ (function() {
        var extendStatics2 = function(d3, b2) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d4[p2] = b3[p2];
          };
          return extendStatics2(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics2(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.VirtualAction = exports.VirtualTimeScheduler = void 0;
      var AsyncAction_1 = require_AsyncAction();
      var Subscription_1 = require_Subscription();
      var AsyncScheduler_1 = require_AsyncScheduler();
      var VirtualTimeScheduler = (function(_super) {
        __extends2(VirtualTimeScheduler2, _super);
        function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
          if (schedulerActionCtor === void 0) {
            schedulerActionCtor = VirtualAction;
          }
          if (maxFrames === void 0) {
            maxFrames = Infinity;
          }
          var _this = _super.call(this, schedulerActionCtor, function() {
            return _this.frame;
          }) || this;
          _this.maxFrames = maxFrames;
          _this.frame = 0;
          _this.index = -1;
          return _this;
        }
        VirtualTimeScheduler2.prototype.flush = function() {
          var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
          var error2;
          var action;
          while ((action = actions[0]) && action.delay <= maxFrames) {
            actions.shift();
            this.frame = action.delay;
            if (error2 = action.execute(action.state, action.delay)) {
              break;
            }
          }
          if (error2) {
            while (action = actions.shift()) {
              action.unsubscribe();
            }
            throw error2;
          }
        };
        VirtualTimeScheduler2.frameTimeFactor = 10;
        return VirtualTimeScheduler2;
      })(AsyncScheduler_1.AsyncScheduler);
      exports.VirtualTimeScheduler = VirtualTimeScheduler;
      var VirtualAction = (function(_super) {
        __extends2(VirtualAction2, _super);
        function VirtualAction2(scheduler, work, index3) {
          if (index3 === void 0) {
            index3 = scheduler.index += 1;
          }
          var _this = _super.call(this, scheduler, work) || this;
          _this.scheduler = scheduler;
          _this.work = work;
          _this.index = index3;
          _this.active = true;
          _this.index = scheduler.index = index3;
          return _this;
        }
        VirtualAction2.prototype.schedule = function(state, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          if (Number.isFinite(delay)) {
            if (!this.id) {
              return _super.prototype.schedule.call(this, state, delay);
            }
            this.active = false;
            var action = new VirtualAction2(this.scheduler, this.work);
            this.add(action);
            return action.schedule(state, delay);
          } else {
            return Subscription_1.Subscription.EMPTY;
          }
        };
        VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          this.delay = scheduler.frame + delay;
          var actions = scheduler.actions;
          actions.push(this);
          actions.sort(VirtualAction2.sortActions);
          return 1;
        };
        VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
          if (delay === void 0) {
            delay = 0;
          }
          return void 0;
        };
        VirtualAction2.prototype._execute = function(state, delay) {
          if (this.active === true) {
            return _super.prototype._execute.call(this, state, delay);
          }
        };
        VirtualAction2.sortActions = function(a2, b2) {
          if (a2.delay === b2.delay) {
            if (a2.index === b2.index) {
              return 0;
            } else if (a2.index > b2.index) {
              return 1;
            } else {
              return -1;
            }
          } else if (a2.delay > b2.delay) {
            return 1;
          } else {
            return -1;
          }
        };
        return VirtualAction2;
      })(AsyncAction_1.AsyncAction);
      exports.VirtualAction = VirtualAction;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/empty.js
  var require_empty = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/empty.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.empty = exports.EMPTY = void 0;
      var Observable_1 = require_Observable();
      exports.EMPTY = new Observable_1.Observable(function(subscriber) {
        return subscriber.complete();
      });
      function empty(scheduler) {
        return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
      }
      exports.empty = empty;
      function emptyScheduled(scheduler) {
        return new Observable_1.Observable(function(subscriber) {
          return scheduler.schedule(function() {
            return subscriber.complete();
          });
        });
      }
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/isScheduler.js
  var require_isScheduler = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/isScheduler.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isScheduler = void 0;
      var isFunction_1 = require_isFunction();
      function isScheduler(value) {
        return value && isFunction_1.isFunction(value.schedule);
      }
      exports.isScheduler = isScheduler;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/args.js
  var require_args = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/args.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.popNumber = exports.popScheduler = exports.popResultSelector = void 0;
      var isFunction_1 = require_isFunction();
      var isScheduler_1 = require_isScheduler();
      function last(arr) {
        return arr[arr.length - 1];
      }
      function popResultSelector(args) {
        return isFunction_1.isFunction(last(args)) ? args.pop() : void 0;
      }
      exports.popResultSelector = popResultSelector;
      function popScheduler(args) {
        return isScheduler_1.isScheduler(last(args)) ? args.pop() : void 0;
      }
      exports.popScheduler = popScheduler;
      function popNumber(args, defaultValue) {
        return typeof last(args) === "number" ? args.pop() : defaultValue;
      }
      exports.popNumber = popNumber;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js
  var require_isArrayLike = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/isArrayLike.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isArrayLike = void 0;
      exports.isArrayLike = (function(x2) {
        return x2 && typeof x2.length === "number" && typeof x2 !== "function";
      });
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/isPromise.js
  var require_isPromise = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/isPromise.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isPromise = void 0;
      var isFunction_1 = require_isFunction();
      function isPromise(value) {
        return isFunction_1.isFunction(value === null || value === void 0 ? void 0 : value.then);
      }
      exports.isPromise = isPromise;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js
  var require_isInteropObservable = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/isInteropObservable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isInteropObservable = void 0;
      var observable_1 = require_observable();
      var isFunction_1 = require_isFunction();
      function isInteropObservable(input) {
        return isFunction_1.isFunction(input[observable_1.observable]);
      }
      exports.isInteropObservable = isInteropObservable;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js
  var require_isAsyncIterable = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/isAsyncIterable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isAsyncIterable = void 0;
      var isFunction_1 = require_isFunction();
      function isAsyncIterable(obj) {
        return Symbol.asyncIterator && isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
      }
      exports.isAsyncIterable = isAsyncIterable;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js
  var require_throwUnobservableError = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/throwUnobservableError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createInvalidObservableTypeError = void 0;
      function createInvalidObservableTypeError(input) {
        return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
      }
      exports.createInvalidObservableTypeError = createInvalidObservableTypeError;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/symbol/iterator.js
  var require_iterator = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/symbol/iterator.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.iterator = exports.getSymbolIterator = void 0;
      function getSymbolIterator() {
        if (typeof Symbol !== "function" || !Symbol.iterator) {
          return "@@iterator";
        }
        return Symbol.iterator;
      }
      exports.getSymbolIterator = getSymbolIterator;
      exports.iterator = getSymbolIterator();
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/isIterable.js
  var require_isIterable = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/isIterable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isIterable = void 0;
      var iterator_1 = require_iterator();
      var isFunction_1 = require_isFunction();
      function isIterable(input) {
        return isFunction_1.isFunction(input === null || input === void 0 ? void 0 : input[iterator_1.iterator]);
      }
      exports.isIterable = isIterable;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js
  var require_isReadableStreamLike = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/isReadableStreamLike.js"(exports) {
      "use strict";
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1) throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f2, y2, t2, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f2) throw new TypeError("Generator is already executing.");
          while (_) try {
            if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
            if (y2 = 0, t2) op = [op[0] & 2, t2.value];
            switch (op[0]) {
              case 0:
              case 1:
                t2 = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y2 = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t2[1]) {
                  _.label = t2[1];
                  t2 = op;
                  break;
                }
                if (t2 && _.label < t2[2]) {
                  _.label = t2[2];
                  _.ops.push(op);
                  break;
                }
                if (t2[2]) _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e2) {
            op = [6, e2];
            y2 = 0;
          } finally {
            f2 = t2 = 0;
          }
          if (op[0] & 5) throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      var __await = exports && exports.__await || function(v2) {
        return this instanceof __await ? (this.v = v2, this) : new __await(v2);
      };
      var __asyncGenerator = exports && exports.__asyncGenerator || function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i2, q = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n2) {
          if (g2[n2]) i2[n2] = function(v2) {
            return new Promise(function(a2, b2) {
              q.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
            });
          };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e2) {
            settle(q[0][3], e2);
          }
        }
        function step(r2) {
          r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f2, v2) {
          if (f2(v2), q.shift(), q.length) resume(q[0][0], q[0][1]);
        }
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isReadableStreamLike = exports.readableStreamLikeToAsyncGenerator = void 0;
      var isFunction_1 = require_isFunction();
      function readableStreamLikeToAsyncGenerator(readableStream) {
        return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
          var reader, _a, value, done;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                reader = readableStream.getReader();
                _b.label = 1;
              case 1:
                _b.trys.push([1, , 9, 10]);
                _b.label = 2;
              case 2:
                if (false) return [3, 8];
                return [4, __await(reader.read())];
              case 3:
                _a = _b.sent(), value = _a.value, done = _a.done;
                if (!done) return [3, 5];
                return [4, __await(void 0)];
              case 4:
                return [2, _b.sent()];
              case 5:
                return [4, __await(value)];
              case 6:
                return [4, _b.sent()];
              case 7:
                _b.sent();
                return [3, 2];
              case 8:
                return [3, 10];
              case 9:
                reader.releaseLock();
                return [7];
              case 10:
                return [2];
            }
          });
        });
      }
      exports.readableStreamLikeToAsyncGenerator = readableStreamLikeToAsyncGenerator;
      function isReadableStreamLike(obj) {
        return isFunction_1.isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
      }
      exports.isReadableStreamLike = isReadableStreamLike;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js
  var require_innerFrom = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/innerFrom.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1) throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f2, y2, t2, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f2) throw new TypeError("Generator is already executing.");
          while (_) try {
            if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
            if (y2 = 0, t2) op = [op[0] & 2, t2.value];
            switch (op[0]) {
              case 0:
              case 1:
                t2 = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y2 = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t2[1]) {
                  _.label = t2[1];
                  t2 = op;
                  break;
                }
                if (t2 && _.label < t2[2]) {
                  _.label = t2[2];
                  _.ops.push(op);
                  break;
                }
                if (t2[2]) _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e2) {
            op = [6, e2];
            y2 = 0;
          } finally {
            f2 = t2 = 0;
          }
          if (op[0] & 5) throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      var __asyncValues = exports && exports.__asyncValues || function(o2) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o2[Symbol.asyncIterator], i2;
        return m2 ? m2.call(o2) : (o2 = typeof __values2 === "function" ? __values2(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n2) {
          i2[n2] = o2[n2] && function(v2) {
            return new Promise(function(resolve, reject) {
              v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve, reject, d3, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve({ value: v3, done: d3 });
          }, reject);
        }
      };
      var __values2 = exports && exports.__values || function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2) return m2.call(o2);
        if (o2 && typeof o2.length === "number") return {
          next: function() {
            if (o2 && i2 >= o2.length) o2 = void 0;
            return { value: o2 && o2[i2++], done: !o2 };
          }
        };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fromReadableStreamLike = exports.fromAsyncIterable = exports.fromIterable = exports.fromPromise = exports.fromArrayLike = exports.fromInteropObservable = exports.innerFrom = void 0;
      var isArrayLike_1 = require_isArrayLike();
      var isPromise_1 = require_isPromise();
      var Observable_1 = require_Observable();
      var isInteropObservable_1 = require_isInteropObservable();
      var isAsyncIterable_1 = require_isAsyncIterable();
      var throwUnobservableError_1 = require_throwUnobservableError();
      var isIterable_1 = require_isIterable();
      var isReadableStreamLike_1 = require_isReadableStreamLike();
      var isFunction_1 = require_isFunction();
      var reportUnhandledError_1 = require_reportUnhandledError();
      var observable_1 = require_observable();
      function innerFrom(input) {
        if (input instanceof Observable_1.Observable) {
          return input;
        }
        if (input != null) {
          if (isInteropObservable_1.isInteropObservable(input)) {
            return fromInteropObservable(input);
          }
          if (isArrayLike_1.isArrayLike(input)) {
            return fromArrayLike(input);
          }
          if (isPromise_1.isPromise(input)) {
            return fromPromise(input);
          }
          if (isAsyncIterable_1.isAsyncIterable(input)) {
            return fromAsyncIterable(input);
          }
          if (isIterable_1.isIterable(input)) {
            return fromIterable(input);
          }
          if (isReadableStreamLike_1.isReadableStreamLike(input)) {
            return fromReadableStreamLike(input);
          }
        }
        throw throwUnobservableError_1.createInvalidObservableTypeError(input);
      }
      exports.innerFrom = innerFrom;
      function fromInteropObservable(obj) {
        return new Observable_1.Observable(function(subscriber) {
          var obs = obj[observable_1.observable]();
          if (isFunction_1.isFunction(obs.subscribe)) {
            return obs.subscribe(subscriber);
          }
          throw new TypeError("Provided object does not correctly implement Symbol.observable");
        });
      }
      exports.fromInteropObservable = fromInteropObservable;
      function fromArrayLike(array) {
        return new Observable_1.Observable(function(subscriber) {
          for (var i2 = 0; i2 < array.length && !subscriber.closed; i2++) {
            subscriber.next(array[i2]);
          }
          subscriber.complete();
        });
      }
      exports.fromArrayLike = fromArrayLike;
      function fromPromise(promise) {
        return new Observable_1.Observable(function(subscriber) {
          promise.then(function(value) {
            if (!subscriber.closed) {
              subscriber.next(value);
              subscriber.complete();
            }
          }, function(err2) {
            return subscriber.error(err2);
          }).then(null, reportUnhandledError_1.reportUnhandledError);
        });
      }
      exports.fromPromise = fromPromise;
      function fromIterable(iterable) {
        return new Observable_1.Observable(function(subscriber) {
          var e_1, _a;
          try {
            for (var iterable_1 = __values2(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
              var value = iterable_1_1.value;
              subscriber.next(value);
              if (subscriber.closed) {
                return;
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          subscriber.complete();
        });
      }
      exports.fromIterable = fromIterable;
      function fromAsyncIterable(asyncIterable) {
        return new Observable_1.Observable(function(subscriber) {
          process2(asyncIterable, subscriber).catch(function(err2) {
            return subscriber.error(err2);
          });
        });
      }
      exports.fromAsyncIterable = fromAsyncIterable;
      function fromReadableStreamLike(readableStream) {
        return fromAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(readableStream));
      }
      exports.fromReadableStreamLike = fromReadableStreamLike;
      function process2(asyncIterable, subscriber) {
        var asyncIterable_1, asyncIterable_1_1;
        var e_2, _a;
        return __awaiter(this, void 0, void 0, function() {
          var value, e_2_1;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                _b.trys.push([0, 5, 6, 11]);
                asyncIterable_1 = __asyncValues(asyncIterable);
                _b.label = 1;
              case 1:
                return [4, asyncIterable_1.next()];
              case 2:
                if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
                value = asyncIterable_1_1.value;
                subscriber.next(value);
                if (subscriber.closed) {
                  return [2];
                }
                _b.label = 3;
              case 3:
                return [3, 1];
              case 4:
                return [3, 11];
              case 5:
                e_2_1 = _b.sent();
                e_2 = { error: e_2_1 };
                return [3, 11];
              case 6:
                _b.trys.push([6, , 9, 10]);
                if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
                return [4, _a.call(asyncIterable_1)];
              case 7:
                _b.sent();
                _b.label = 8;
              case 8:
                return [3, 10];
              case 9:
                if (e_2) throw e_2.error;
                return [7];
              case 10:
                return [7];
              case 11:
                subscriber.complete();
                return [2];
            }
          });
        });
      }
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js
  var require_executeSchedule = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/executeSchedule.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.executeSchedule = void 0;
      function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
        if (delay === void 0) {
          delay = 0;
        }
        if (repeat === void 0) {
          repeat = false;
        }
        var scheduleSubscription = scheduler.schedule(function() {
          work();
          if (repeat) {
            parentSubscription.add(this.schedule(null, delay));
          } else {
            this.unsubscribe();
          }
        }, delay);
        parentSubscription.add(scheduleSubscription);
        if (!repeat) {
          return scheduleSubscription;
        }
      }
      exports.executeSchedule = executeSchedule;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/observeOn.js
  var require_observeOn = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/observeOn.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.observeOn = void 0;
      var executeSchedule_1 = require_executeSchedule();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function observeOn(scheduler, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return lift_1.operate(function(source, subscriber) {
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
              return subscriber.next(value);
            }, delay);
          }, function() {
            return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
              return subscriber.complete();
            }, delay);
          }, function(err2) {
            return executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
              return subscriber.error(err2);
            }, delay);
          }));
        });
      }
      exports.observeOn = observeOn;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js
  var require_subscribeOn = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/subscribeOn.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.subscribeOn = void 0;
      var lift_1 = require_lift();
      function subscribeOn(scheduler, delay) {
        if (delay === void 0) {
          delay = 0;
        }
        return lift_1.operate(function(source, subscriber) {
          subscriber.add(scheduler.schedule(function() {
            return source.subscribe(subscriber);
          }, delay));
        });
      }
      exports.subscribeOn = subscribeOn;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js
  var require_scheduleObservable = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleObservable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.scheduleObservable = void 0;
      var innerFrom_1 = require_innerFrom();
      var observeOn_1 = require_observeOn();
      var subscribeOn_1 = require_subscribeOn();
      function scheduleObservable(input, scheduler) {
        return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
      }
      exports.scheduleObservable = scheduleObservable;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js
  var require_schedulePromise = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduled/schedulePromise.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.schedulePromise = void 0;
      var innerFrom_1 = require_innerFrom();
      var observeOn_1 = require_observeOn();
      var subscribeOn_1 = require_subscribeOn();
      function schedulePromise(input, scheduler) {
        return innerFrom_1.innerFrom(input).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
      }
      exports.schedulePromise = schedulePromise;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js
  var require_scheduleArray = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleArray.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.scheduleArray = void 0;
      var Observable_1 = require_Observable();
      function scheduleArray(input, scheduler) {
        return new Observable_1.Observable(function(subscriber) {
          var i2 = 0;
          return scheduler.schedule(function() {
            if (i2 === input.length) {
              subscriber.complete();
            } else {
              subscriber.next(input[i2++]);
              if (!subscriber.closed) {
                this.schedule();
              }
            }
          });
        });
      }
      exports.scheduleArray = scheduleArray;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js
  var require_scheduleIterable = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleIterable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.scheduleIterable = void 0;
      var Observable_1 = require_Observable();
      var iterator_1 = require_iterator();
      var isFunction_1 = require_isFunction();
      var executeSchedule_1 = require_executeSchedule();
      function scheduleIterable(input, scheduler) {
        return new Observable_1.Observable(function(subscriber) {
          var iterator;
          executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            iterator = input[iterator_1.iterator]();
            executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
              var _a;
              var value;
              var done;
              try {
                _a = iterator.next(), value = _a.value, done = _a.done;
              } catch (err2) {
                subscriber.error(err2);
                return;
              }
              if (done) {
                subscriber.complete();
              } else {
                subscriber.next(value);
              }
            }, 0, true);
          });
          return function() {
            return isFunction_1.isFunction(iterator === null || iterator === void 0 ? void 0 : iterator.return) && iterator.return();
          };
        });
      }
      exports.scheduleIterable = scheduleIterable;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js
  var require_scheduleAsyncIterable = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleAsyncIterable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.scheduleAsyncIterable = void 0;
      var Observable_1 = require_Observable();
      var executeSchedule_1 = require_executeSchedule();
      function scheduleAsyncIterable(input, scheduler) {
        if (!input) {
          throw new Error("Iterable cannot be null");
        }
        return new Observable_1.Observable(function(subscriber) {
          executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
            var iterator = input[Symbol.asyncIterator]();
            executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
              iterator.next().then(function(result) {
                if (result.done) {
                  subscriber.complete();
                } else {
                  subscriber.next(result.value);
                }
              });
            }, 0, true);
          });
        });
      }
      exports.scheduleAsyncIterable = scheduleAsyncIterable;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js
  var require_scheduleReadableStreamLike = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduled/scheduleReadableStreamLike.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.scheduleReadableStreamLike = void 0;
      var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
      var isReadableStreamLike_1 = require_isReadableStreamLike();
      function scheduleReadableStreamLike(input, scheduler) {
        return scheduleAsyncIterable_1.scheduleAsyncIterable(isReadableStreamLike_1.readableStreamLikeToAsyncGenerator(input), scheduler);
      }
      exports.scheduleReadableStreamLike = scheduleReadableStreamLike;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js
  var require_scheduled = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/scheduled/scheduled.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.scheduled = void 0;
      var scheduleObservable_1 = require_scheduleObservable();
      var schedulePromise_1 = require_schedulePromise();
      var scheduleArray_1 = require_scheduleArray();
      var scheduleIterable_1 = require_scheduleIterable();
      var scheduleAsyncIterable_1 = require_scheduleAsyncIterable();
      var isInteropObservable_1 = require_isInteropObservable();
      var isPromise_1 = require_isPromise();
      var isArrayLike_1 = require_isArrayLike();
      var isIterable_1 = require_isIterable();
      var isAsyncIterable_1 = require_isAsyncIterable();
      var throwUnobservableError_1 = require_throwUnobservableError();
      var isReadableStreamLike_1 = require_isReadableStreamLike();
      var scheduleReadableStreamLike_1 = require_scheduleReadableStreamLike();
      function scheduled(input, scheduler) {
        if (input != null) {
          if (isInteropObservable_1.isInteropObservable(input)) {
            return scheduleObservable_1.scheduleObservable(input, scheduler);
          }
          if (isArrayLike_1.isArrayLike(input)) {
            return scheduleArray_1.scheduleArray(input, scheduler);
          }
          if (isPromise_1.isPromise(input)) {
            return schedulePromise_1.schedulePromise(input, scheduler);
          }
          if (isAsyncIterable_1.isAsyncIterable(input)) {
            return scheduleAsyncIterable_1.scheduleAsyncIterable(input, scheduler);
          }
          if (isIterable_1.isIterable(input)) {
            return scheduleIterable_1.scheduleIterable(input, scheduler);
          }
          if (isReadableStreamLike_1.isReadableStreamLike(input)) {
            return scheduleReadableStreamLike_1.scheduleReadableStreamLike(input, scheduler);
          }
        }
        throw throwUnobservableError_1.createInvalidObservableTypeError(input);
      }
      exports.scheduled = scheduled;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/from.js
  var require_from = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/from.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.from = void 0;
      var scheduled_1 = require_scheduled();
      var innerFrom_1 = require_innerFrom();
      function from2(input, scheduler) {
        return scheduler ? scheduled_1.scheduled(input, scheduler) : innerFrom_1.innerFrom(input);
      }
      exports.from = from2;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/of.js
  var require_of = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/of.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.of = void 0;
      var args_1 = require_args();
      var from_1 = require_from();
      function of() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var scheduler = args_1.popScheduler(args);
        return from_1.from(args, scheduler);
      }
      exports.of = of;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/throwError.js
  var require_throwError = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/throwError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.throwError = void 0;
      var Observable_1 = require_Observable();
      var isFunction_1 = require_isFunction();
      function throwError(errorOrErrorFactory, scheduler) {
        var errorFactory = isFunction_1.isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
          return errorOrErrorFactory;
        };
        var init = function(subscriber) {
          return subscriber.error(errorFactory());
        };
        return new Observable_1.Observable(scheduler ? function(subscriber) {
          return scheduler.schedule(init, 0, subscriber);
        } : init);
      }
      exports.throwError = throwError;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/Notification.js
  var require_Notification = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/Notification.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.observeNotification = exports.Notification = exports.NotificationKind = void 0;
      var empty_1 = require_empty();
      var of_1 = require_of();
      var throwError_1 = require_throwError();
      var isFunction_1 = require_isFunction();
      var NotificationKind;
      (function(NotificationKind2) {
        NotificationKind2["NEXT"] = "N";
        NotificationKind2["ERROR"] = "E";
        NotificationKind2["COMPLETE"] = "C";
      })(NotificationKind = exports.NotificationKind || (exports.NotificationKind = {}));
      var Notification = (function() {
        function Notification2(kind, value, error2) {
          this.kind = kind;
          this.value = value;
          this.error = error2;
          this.hasValue = kind === "N";
        }
        Notification2.prototype.observe = function(observer50) {
          return observeNotification(this, observer50);
        };
        Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
          var _a = this, kind = _a.kind, value = _a.value, error2 = _a.error;
          return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error2) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
        };
        Notification2.prototype.accept = function(nextOrObserver, error2, complete) {
          var _a;
          return isFunction_1.isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error2, complete);
        };
        Notification2.prototype.toObservable = function() {
          var _a = this, kind = _a.kind, value = _a.value, error2 = _a.error;
          var result = kind === "N" ? of_1.of(value) : kind === "E" ? throwError_1.throwError(function() {
            return error2;
          }) : kind === "C" ? empty_1.EMPTY : 0;
          if (!result) {
            throw new TypeError("Unexpected notification kind " + kind);
          }
          return result;
        };
        Notification2.createNext = function(value) {
          return new Notification2("N", value);
        };
        Notification2.createError = function(err2) {
          return new Notification2("E", void 0, err2);
        };
        Notification2.createComplete = function() {
          return Notification2.completeNotification;
        };
        Notification2.completeNotification = new Notification2("C");
        return Notification2;
      })();
      exports.Notification = Notification;
      function observeNotification(notification, observer50) {
        var _a, _b, _c;
        var _d = notification, kind = _d.kind, value = _d.value, error2 = _d.error;
        if (typeof kind !== "string") {
          throw new TypeError('Invalid notification, missing "kind"');
        }
        kind === "N" ? (_a = observer50.next) === null || _a === void 0 ? void 0 : _a.call(observer50, value) : kind === "E" ? (_b = observer50.error) === null || _b === void 0 ? void 0 : _b.call(observer50, error2) : (_c = observer50.complete) === null || _c === void 0 ? void 0 : _c.call(observer50);
      }
      exports.observeNotification = observeNotification;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/isObservable.js
  var require_isObservable = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/isObservable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isObservable = void 0;
      var Observable_1 = require_Observable();
      var isFunction_1 = require_isFunction();
      function isObservable(obj) {
        return !!obj && (obj instanceof Observable_1.Observable || isFunction_1.isFunction(obj.lift) && isFunction_1.isFunction(obj.subscribe));
      }
      exports.isObservable = isObservable;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/EmptyError.js
  var require_EmptyError = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/EmptyError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EmptyError = void 0;
      var createErrorClass_1 = require_createErrorClass();
      exports.EmptyError = createErrorClass_1.createErrorClass(function(_super) {
        return function EmptyErrorImpl() {
          _super(this);
          this.name = "EmptyError";
          this.message = "no elements in sequence";
        };
      });
    }
  });

  // node_modules/rxjs/dist/cjs/internal/lastValueFrom.js
  var require_lastValueFrom = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/lastValueFrom.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.lastValueFrom = void 0;
      var EmptyError_1 = require_EmptyError();
      function lastValueFrom(source, config2) {
        var hasConfig = typeof config2 === "object";
        return new Promise(function(resolve, reject) {
          var _hasValue = false;
          var _value;
          source.subscribe({
            next: function(value) {
              _value = value;
              _hasValue = true;
            },
            error: reject,
            complete: function() {
              if (_hasValue) {
                resolve(_value);
              } else if (hasConfig) {
                resolve(config2.defaultValue);
              } else {
                reject(new EmptyError_1.EmptyError());
              }
            }
          });
        });
      }
      exports.lastValueFrom = lastValueFrom;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/firstValueFrom.js
  var require_firstValueFrom = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/firstValueFrom.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.firstValueFrom = void 0;
      var EmptyError_1 = require_EmptyError();
      var Subscriber_1 = require_Subscriber();
      function firstValueFrom2(source, config2) {
        var hasConfig = typeof config2 === "object";
        return new Promise(function(resolve, reject) {
          var subscriber = new Subscriber_1.SafeSubscriber({
            next: function(value) {
              resolve(value);
              subscriber.unsubscribe();
            },
            error: reject,
            complete: function() {
              if (hasConfig) {
                resolve(config2.defaultValue);
              } else {
                reject(new EmptyError_1.EmptyError());
              }
            }
          });
          source.subscribe(subscriber);
        });
      }
      exports.firstValueFrom = firstValueFrom2;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js
  var require_ArgumentOutOfRangeError = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/ArgumentOutOfRangeError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ArgumentOutOfRangeError = void 0;
      var createErrorClass_1 = require_createErrorClass();
      exports.ArgumentOutOfRangeError = createErrorClass_1.createErrorClass(function(_super) {
        return function ArgumentOutOfRangeErrorImpl() {
          _super(this);
          this.name = "ArgumentOutOfRangeError";
          this.message = "argument out of range";
        };
      });
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js
  var require_NotFoundError = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/NotFoundError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NotFoundError = void 0;
      var createErrorClass_1 = require_createErrorClass();
      exports.NotFoundError = createErrorClass_1.createErrorClass(function(_super) {
        return function NotFoundErrorImpl(message) {
          _super(this);
          this.name = "NotFoundError";
          this.message = message;
        };
      });
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/SequenceError.js
  var require_SequenceError = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/SequenceError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SequenceError = void 0;
      var createErrorClass_1 = require_createErrorClass();
      exports.SequenceError = createErrorClass_1.createErrorClass(function(_super) {
        return function SequenceErrorImpl(message) {
          _super(this);
          this.name = "SequenceError";
          this.message = message;
        };
      });
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/isDate.js
  var require_isDate = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/isDate.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isValidDate = void 0;
      function isValidDate(value) {
        return value instanceof Date && !isNaN(value);
      }
      exports.isValidDate = isValidDate;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/timeout.js
  var require_timeout = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/timeout.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.timeout = exports.TimeoutError = void 0;
      var async_1 = require_async();
      var isDate_1 = require_isDate();
      var lift_1 = require_lift();
      var innerFrom_1 = require_innerFrom();
      var createErrorClass_1 = require_createErrorClass();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var executeSchedule_1 = require_executeSchedule();
      exports.TimeoutError = createErrorClass_1.createErrorClass(function(_super) {
        return function TimeoutErrorImpl(info) {
          if (info === void 0) {
            info = null;
          }
          _super(this);
          this.message = "Timeout has occurred";
          this.name = "TimeoutError";
          this.info = info;
        };
      });
      function timeout3(config2, schedulerArg) {
        var _a = isDate_1.isValidDate(config2) ? { first: config2 } : typeof config2 === "number" ? { each: config2 } : config2, first = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : async_1.asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
        if (first == null && each == null) {
          throw new TypeError("No timeout provided.");
        }
        return lift_1.operate(function(source, subscriber) {
          var originalSourceSubscription;
          var timerSubscription;
          var lastValue = null;
          var seen = 0;
          var startTimer = function(delay) {
            timerSubscription = executeSchedule_1.executeSchedule(subscriber, scheduler, function() {
              try {
                originalSourceSubscription.unsubscribe();
                innerFrom_1.innerFrom(_with({
                  meta,
                  lastValue,
                  seen
                })).subscribe(subscriber);
              } catch (err2) {
                subscriber.error(err2);
              }
            }, delay);
          };
          originalSourceSubscription = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
            seen++;
            subscriber.next(lastValue = value);
            each > 0 && startTimer(each);
          }, void 0, void 0, function() {
            if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
              timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
            }
            lastValue = null;
          }));
          !seen && startTimer(first != null ? typeof first === "number" ? first : +first - scheduler.now() : each);
        });
      }
      exports.timeout = timeout3;
      function timeoutErrorFactory(info) {
        throw new exports.TimeoutError(info);
      }
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/map.js
  var require_map = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/map.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.map = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function map(project, thisArg) {
        return lift_1.operate(function(source, subscriber) {
          var index3 = 0;
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            subscriber.next(project.call(thisArg, value, index3++));
          }));
        });
      }
      exports.map = map;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js
  var require_mapOneOrManyArgs = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/mapOneOrManyArgs.js"(exports) {
      "use strict";
      var __read2 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2) return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
          } finally {
            if (e2) throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
        for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from2[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mapOneOrManyArgs = void 0;
      var map_1 = require_map();
      var isArray = Array.isArray;
      function callOrApply(fn, args) {
        return isArray(args) ? fn.apply(void 0, __spreadArray2([], __read2(args))) : fn(args);
      }
      function mapOneOrManyArgs(fn) {
        return map_1.map(function(args) {
          return callOrApply(fn, args);
        });
      }
      exports.mapOneOrManyArgs = mapOneOrManyArgs;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js
  var require_bindCallbackInternals = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/bindCallbackInternals.js"(exports) {
      "use strict";
      var __read2 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2) return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
          } finally {
            if (e2) throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
        for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from2[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bindCallbackInternals = void 0;
      var isScheduler_1 = require_isScheduler();
      var Observable_1 = require_Observable();
      var subscribeOn_1 = require_subscribeOn();
      var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
      var observeOn_1 = require_observeOn();
      var AsyncSubject_1 = require_AsyncSubject();
      function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {
        if (resultSelector) {
          if (isScheduler_1.isScheduler(resultSelector)) {
            scheduler = resultSelector;
          } else {
            return function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler).apply(this, args).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
            };
          }
        }
        if (scheduler) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return bindCallbackInternals(isNodeStyle, callbackFunc).apply(this, args).pipe(subscribeOn_1.subscribeOn(scheduler), observeOn_1.observeOn(scheduler));
          };
        }
        return function() {
          var _this = this;
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var subject = new AsyncSubject_1.AsyncSubject();
          var uninitialized = true;
          return new Observable_1.Observable(function(subscriber) {
            var subs = subject.subscribe(subscriber);
            if (uninitialized) {
              uninitialized = false;
              var isAsync_1 = false;
              var isComplete_1 = false;
              callbackFunc.apply(_this, __spreadArray2(__spreadArray2([], __read2(args)), [
                function() {
                  var results = [];
                  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
                    results[_i2] = arguments[_i2];
                  }
                  if (isNodeStyle) {
                    var err2 = results.shift();
                    if (err2 != null) {
                      subject.error(err2);
                      return;
                    }
                  }
                  subject.next(1 < results.length ? results : results[0]);
                  isComplete_1 = true;
                  if (isAsync_1) {
                    subject.complete();
                  }
                }
              ]));
              if (isComplete_1) {
                subject.complete();
              }
              isAsync_1 = true;
            }
            return subs;
          });
        };
      }
      exports.bindCallbackInternals = bindCallbackInternals;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js
  var require_bindCallback = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/bindCallback.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bindCallback = void 0;
      var bindCallbackInternals_1 = require_bindCallbackInternals();
      function bindCallback(callbackFunc, resultSelector, scheduler) {
        return bindCallbackInternals_1.bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);
      }
      exports.bindCallback = bindCallback;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js
  var require_bindNodeCallback = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/bindNodeCallback.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bindNodeCallback = void 0;
      var bindCallbackInternals_1 = require_bindCallbackInternals();
      function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
        return bindCallbackInternals_1.bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);
      }
      exports.bindNodeCallback = bindNodeCallback;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js
  var require_argsArgArrayOrObject = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/argsArgArrayOrObject.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.argsArgArrayOrObject = void 0;
      var isArray = Array.isArray;
      var getPrototypeOf = Object.getPrototypeOf;
      var objectProto = Object.prototype;
      var getKeys = Object.keys;
      function argsArgArrayOrObject(args) {
        if (args.length === 1) {
          var first_1 = args[0];
          if (isArray(first_1)) {
            return { args: first_1, keys: null };
          }
          if (isPOJO(first_1)) {
            var keys = getKeys(first_1);
            return {
              args: keys.map(function(key) {
                return first_1[key];
              }),
              keys
            };
          }
        }
        return { args, keys: null };
      }
      exports.argsArgArrayOrObject = argsArgArrayOrObject;
      function isPOJO(obj) {
        return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
      }
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/createObject.js
  var require_createObject = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/createObject.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createObject = void 0;
      function createObject(keys, values) {
        return keys.reduce(function(result, key, i2) {
          return result[key] = values[i2], result;
        }, {});
      }
      exports.createObject = createObject;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js
  var require_combineLatest = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/combineLatest.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.combineLatestInit = exports.combineLatest = void 0;
      var Observable_1 = require_Observable();
      var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
      var from_1 = require_from();
      var identity_1 = require_identity();
      var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
      var args_1 = require_args();
      var createObject_1 = require_createObject();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var executeSchedule_1 = require_executeSchedule();
      function combineLatest() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var scheduler = args_1.popScheduler(args);
        var resultSelector = args_1.popResultSelector(args);
        var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
        if (observables.length === 0) {
          return from_1.from([], scheduler);
        }
        var result = new Observable_1.Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
          return createObject_1.createObject(keys, values);
        } : identity_1.identity));
        return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
      }
      exports.combineLatest = combineLatest;
      function combineLatestInit(observables, scheduler, valueTransform) {
        if (valueTransform === void 0) {
          valueTransform = identity_1.identity;
        }
        return function(subscriber) {
          maybeSchedule(scheduler, function() {
            var length2 = observables.length;
            var values = new Array(length2);
            var active = length2;
            var remainingFirstValues = length2;
            var _loop_1 = function(i3) {
              maybeSchedule(scheduler, function() {
                var source = from_1.from(observables[i3], scheduler);
                var hasFirstValue = false;
                source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
                  values[i3] = value;
                  if (!hasFirstValue) {
                    hasFirstValue = true;
                    remainingFirstValues--;
                  }
                  if (!remainingFirstValues) {
                    subscriber.next(valueTransform(values.slice()));
                  }
                }, function() {
                  if (!--active) {
                    subscriber.complete();
                  }
                }));
              }, subscriber);
            };
            for (var i2 = 0; i2 < length2; i2++) {
              _loop_1(i2);
            }
          }, subscriber);
        };
      }
      exports.combineLatestInit = combineLatestInit;
      function maybeSchedule(scheduler, execute, subscription) {
        if (scheduler) {
          executeSchedule_1.executeSchedule(subscription, scheduler, execute);
        } else {
          execute();
        }
      }
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js
  var require_mergeInternals = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/mergeInternals.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mergeInternals = void 0;
      var innerFrom_1 = require_innerFrom();
      var executeSchedule_1 = require_executeSchedule();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
        var buffer = [];
        var active = 0;
        var index3 = 0;
        var isComplete = false;
        var checkComplete = function() {
          if (isComplete && !buffer.length && !active) {
            subscriber.complete();
          }
        };
        var outerNext = function(value) {
          return active < concurrent ? doInnerSub(value) : buffer.push(value);
        };
        var doInnerSub = function(value) {
          expand && subscriber.next(value);
          active++;
          var innerComplete = false;
          innerFrom_1.innerFrom(project(value, index3++)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
            onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
            if (expand) {
              outerNext(innerValue);
            } else {
              subscriber.next(innerValue);
            }
          }, function() {
            innerComplete = true;
          }, void 0, function() {
            if (innerComplete) {
              try {
                active--;
                var _loop_1 = function() {
                  var bufferedValue = buffer.shift();
                  if (innerSubScheduler) {
                    executeSchedule_1.executeSchedule(subscriber, innerSubScheduler, function() {
                      return doInnerSub(bufferedValue);
                    });
                  } else {
                    doInnerSub(bufferedValue);
                  }
                };
                while (buffer.length && active < concurrent) {
                  _loop_1();
                }
                checkComplete();
              } catch (err2) {
                subscriber.error(err2);
              }
            }
          }));
        };
        source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, outerNext, function() {
          isComplete = true;
          checkComplete();
        }));
        return function() {
          additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
        };
      }
      exports.mergeInternals = mergeInternals;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js
  var require_mergeMap = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/mergeMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mergeMap = void 0;
      var map_1 = require_map();
      var innerFrom_1 = require_innerFrom();
      var lift_1 = require_lift();
      var mergeInternals_1 = require_mergeInternals();
      var isFunction_1 = require_isFunction();
      function mergeMap(project, resultSelector, concurrent) {
        if (concurrent === void 0) {
          concurrent = Infinity;
        }
        if (isFunction_1.isFunction(resultSelector)) {
          return mergeMap(function(a2, i2) {
            return map_1.map(function(b2, ii) {
              return resultSelector(a2, b2, i2, ii);
            })(innerFrom_1.innerFrom(project(a2, i2)));
          }, concurrent);
        } else if (typeof resultSelector === "number") {
          concurrent = resultSelector;
        }
        return lift_1.operate(function(source, subscriber) {
          return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent);
        });
      }
      exports.mergeMap = mergeMap;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js
  var require_mergeAll = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/mergeAll.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mergeAll = void 0;
      var mergeMap_1 = require_mergeMap();
      var identity_1 = require_identity();
      function mergeAll(concurrent) {
        if (concurrent === void 0) {
          concurrent = Infinity;
        }
        return mergeMap_1.mergeMap(identity_1.identity, concurrent);
      }
      exports.mergeAll = mergeAll;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/concatAll.js
  var require_concatAll = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/concatAll.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.concatAll = void 0;
      var mergeAll_1 = require_mergeAll();
      function concatAll() {
        return mergeAll_1.mergeAll(1);
      }
      exports.concatAll = concatAll;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/concat.js
  var require_concat = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/concat.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.concat = void 0;
      var concatAll_1 = require_concatAll();
      var args_1 = require_args();
      var from_1 = require_from();
      function concat() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return concatAll_1.concatAll()(from_1.from(args, args_1.popScheduler(args)));
      }
      exports.concat = concat;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/defer.js
  var require_defer = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/defer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.defer = void 0;
      var Observable_1 = require_Observable();
      var innerFrom_1 = require_innerFrom();
      function defer(observableFactory) {
        return new Observable_1.Observable(function(subscriber) {
          innerFrom_1.innerFrom(observableFactory()).subscribe(subscriber);
        });
      }
      exports.defer = defer;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/connectable.js
  var require_connectable = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/connectable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.connectable = void 0;
      var Subject_1 = require_Subject();
      var Observable_1 = require_Observable();
      var defer_1 = require_defer();
      var DEFAULT_CONFIG = {
        connector: function() {
          return new Subject_1.Subject();
        },
        resetOnDisconnect: true
      };
      function connectable(source, config2) {
        if (config2 === void 0) {
          config2 = DEFAULT_CONFIG;
        }
        var connection = null;
        var connector = config2.connector, _a = config2.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;
        var subject = connector();
        var result = new Observable_1.Observable(function(subscriber) {
          return subject.subscribe(subscriber);
        });
        result.connect = function() {
          if (!connection || connection.closed) {
            connection = defer_1.defer(function() {
              return source;
            }).subscribe(subject);
            if (resetOnDisconnect) {
              connection.add(function() {
                return subject = connector();
              });
            }
          }
          return connection;
        };
        return result;
      }
      exports.connectable = connectable;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js
  var require_forkJoin = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/forkJoin.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.forkJoin = void 0;
      var Observable_1 = require_Observable();
      var argsArgArrayOrObject_1 = require_argsArgArrayOrObject();
      var innerFrom_1 = require_innerFrom();
      var args_1 = require_args();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
      var createObject_1 = require_createObject();
      function forkJoin() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var resultSelector = args_1.popResultSelector(args);
        var _a = argsArgArrayOrObject_1.argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;
        var result = new Observable_1.Observable(function(subscriber) {
          var length2 = sources.length;
          if (!length2) {
            subscriber.complete();
            return;
          }
          var values = new Array(length2);
          var remainingCompletions = length2;
          var remainingEmissions = length2;
          var _loop_1 = function(sourceIndex2) {
            var hasValue = false;
            innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
              if (!hasValue) {
                hasValue = true;
                remainingEmissions--;
              }
              values[sourceIndex2] = value;
            }, function() {
              return remainingCompletions--;
            }, void 0, function() {
              if (!remainingCompletions || !hasValue) {
                if (!remainingEmissions) {
                  subscriber.next(keys ? createObject_1.createObject(keys, values) : values);
                }
                subscriber.complete();
              }
            }));
          };
          for (var sourceIndex = 0; sourceIndex < length2; sourceIndex++) {
            _loop_1(sourceIndex);
          }
        });
        return resultSelector ? result.pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : result;
      }
      exports.forkJoin = forkJoin;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js
  var require_fromEvent = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/fromEvent.js"(exports) {
      "use strict";
      var __read2 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2) return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
          } finally {
            if (e2) throw e2.error;
          }
        }
        return ar;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fromEvent = void 0;
      var innerFrom_1 = require_innerFrom();
      var Observable_1 = require_Observable();
      var mergeMap_1 = require_mergeMap();
      var isArrayLike_1 = require_isArrayLike();
      var isFunction_1 = require_isFunction();
      var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
      var nodeEventEmitterMethods = ["addListener", "removeListener"];
      var eventTargetMethods = ["addEventListener", "removeEventListener"];
      var jqueryMethods = ["on", "off"];
      function fromEvent(target, eventName, options, resultSelector) {
        if (isFunction_1.isFunction(options)) {
          resultSelector = options;
          options = void 0;
        }
        if (resultSelector) {
          return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
        }
        var _a = __read2(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
          return function(handler) {
            return target[methodName](eventName, handler, options);
          };
        }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
        if (!add) {
          if (isArrayLike_1.isArrayLike(target)) {
            return mergeMap_1.mergeMap(function(subTarget) {
              return fromEvent(subTarget, eventName, options);
            })(innerFrom_1.innerFrom(target));
          }
        }
        if (!add) {
          throw new TypeError("Invalid event target");
        }
        return new Observable_1.Observable(function(subscriber) {
          var handler = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return subscriber.next(1 < args.length ? args : args[0]);
          };
          add(handler);
          return function() {
            return remove(handler);
          };
        });
      }
      exports.fromEvent = fromEvent;
      function toCommonHandlerRegistry(target, eventName) {
        return function(methodName) {
          return function(handler) {
            return target[methodName](eventName, handler);
          };
        };
      }
      function isNodeStyleEventEmitter(target) {
        return isFunction_1.isFunction(target.addListener) && isFunction_1.isFunction(target.removeListener);
      }
      function isJQueryStyleEventEmitter(target) {
        return isFunction_1.isFunction(target.on) && isFunction_1.isFunction(target.off);
      }
      function isEventTarget(target) {
        return isFunction_1.isFunction(target.addEventListener) && isFunction_1.isFunction(target.removeEventListener);
      }
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js
  var require_fromEventPattern = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/fromEventPattern.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fromEventPattern = void 0;
      var Observable_1 = require_Observable();
      var isFunction_1 = require_isFunction();
      var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
      function fromEventPattern(addHandler, removeHandler, resultSelector) {
        if (resultSelector) {
          return fromEventPattern(addHandler, removeHandler).pipe(mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector));
        }
        return new Observable_1.Observable(function(subscriber) {
          var handler = function() {
            var e2 = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              e2[_i] = arguments[_i];
            }
            return subscriber.next(e2.length === 1 ? e2[0] : e2);
          };
          var retValue = addHandler(handler);
          return isFunction_1.isFunction(removeHandler) ? function() {
            return removeHandler(handler, retValue);
          } : void 0;
        });
      }
      exports.fromEventPattern = fromEventPattern;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/generate.js
  var require_generate = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/generate.js"(exports) {
      "use strict";
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t2[0] & 1) throw t2[1];
          return t2[1];
        }, trys: [], ops: [] }, f2, y2, t2, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f2) throw new TypeError("Generator is already executing.");
          while (_) try {
            if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
            if (y2 = 0, t2) op = [op[0] & 2, t2.value];
            switch (op[0]) {
              case 0:
              case 1:
                t2 = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y2 = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t2[1]) {
                  _.label = t2[1];
                  t2 = op;
                  break;
                }
                if (t2 && _.label < t2[2]) {
                  _.label = t2[2];
                  _.ops.push(op);
                  break;
                }
                if (t2[2]) _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e2) {
            op = [6, e2];
            y2 = 0;
          } finally {
            f2 = t2 = 0;
          }
          if (op[0] & 5) throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.generate = void 0;
      var identity_1 = require_identity();
      var isScheduler_1 = require_isScheduler();
      var defer_1 = require_defer();
      var scheduleIterable_1 = require_scheduleIterable();
      function generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {
        var _a, _b;
        var resultSelector;
        var initialState;
        if (arguments.length === 1) {
          _a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity_1.identity : _b, scheduler = _a.scheduler;
        } else {
          initialState = initialStateOrOptions;
          if (!resultSelectorOrScheduler || isScheduler_1.isScheduler(resultSelectorOrScheduler)) {
            resultSelector = identity_1.identity;
            scheduler = resultSelectorOrScheduler;
          } else {
            resultSelector = resultSelectorOrScheduler;
          }
        }
        function gen() {
          var state;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                state = initialState;
                _a2.label = 1;
              case 1:
                if (!(!condition || condition(state))) return [3, 4];
                return [4, resultSelector(state)];
              case 2:
                _a2.sent();
                _a2.label = 3;
              case 3:
                state = iterate(state);
                return [3, 1];
              case 4:
                return [2];
            }
          });
        }
        return defer_1.defer(scheduler ? function() {
          return scheduleIterable_1.scheduleIterable(gen(), scheduler);
        } : gen);
      }
      exports.generate = generate;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/iif.js
  var require_iif = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/iif.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.iif = void 0;
      var defer_1 = require_defer();
      function iif(condition, trueResult, falseResult) {
        return defer_1.defer(function() {
          return condition() ? trueResult : falseResult;
        });
      }
      exports.iif = iif;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/timer.js
  var require_timer = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/timer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.timer = void 0;
      var Observable_1 = require_Observable();
      var async_1 = require_async();
      var isScheduler_1 = require_isScheduler();
      var isDate_1 = require_isDate();
      function timer(dueTime, intervalOrScheduler, scheduler) {
        if (dueTime === void 0) {
          dueTime = 0;
        }
        if (scheduler === void 0) {
          scheduler = async_1.async;
        }
        var intervalDuration = -1;
        if (intervalOrScheduler != null) {
          if (isScheduler_1.isScheduler(intervalOrScheduler)) {
            scheduler = intervalOrScheduler;
          } else {
            intervalDuration = intervalOrScheduler;
          }
        }
        return new Observable_1.Observable(function(subscriber) {
          var due = isDate_1.isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
          if (due < 0) {
            due = 0;
          }
          var n2 = 0;
          return scheduler.schedule(function() {
            if (!subscriber.closed) {
              subscriber.next(n2++);
              if (0 <= intervalDuration) {
                this.schedule(void 0, intervalDuration);
              } else {
                subscriber.complete();
              }
            }
          }, due);
        });
      }
      exports.timer = timer;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/interval.js
  var require_interval = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/interval.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.interval = void 0;
      var async_1 = require_async();
      var timer_1 = require_timer();
      function interval(period, scheduler) {
        if (period === void 0) {
          period = 0;
        }
        if (scheduler === void 0) {
          scheduler = async_1.asyncScheduler;
        }
        if (period < 0) {
          period = 0;
        }
        return timer_1.timer(period, period, scheduler);
      }
      exports.interval = interval;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/merge.js
  var require_merge = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/merge.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.merge = void 0;
      var mergeAll_1 = require_mergeAll();
      var innerFrom_1 = require_innerFrom();
      var empty_1 = require_empty();
      var args_1 = require_args();
      var from_1 = require_from();
      function merge() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var scheduler = args_1.popScheduler(args);
        var concurrent = args_1.popNumber(args, Infinity);
        var sources = args;
        return !sources.length ? empty_1.EMPTY : sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : mergeAll_1.mergeAll(concurrent)(from_1.from(sources, scheduler));
      }
      exports.merge = merge;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/never.js
  var require_never = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/never.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.never = exports.NEVER = void 0;
      var Observable_1 = require_Observable();
      var noop_1 = require_noop();
      exports.NEVER = new Observable_1.Observable(noop_1.noop);
      function never() {
        return exports.NEVER;
      }
      exports.never = never;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js
  var require_argsOrArgArray = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/argsOrArgArray.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.argsOrArgArray = void 0;
      var isArray = Array.isArray;
      function argsOrArgArray(args) {
        return args.length === 1 && isArray(args[0]) ? args[0] : args;
      }
      exports.argsOrArgArray = argsOrArgArray;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js
  var require_onErrorResumeNext = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/onErrorResumeNext.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.onErrorResumeNext = void 0;
      var Observable_1 = require_Observable();
      var argsOrArgArray_1 = require_argsOrArgArray();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var noop_1 = require_noop();
      var innerFrom_1 = require_innerFrom();
      function onErrorResumeNext() {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          sources[_i] = arguments[_i];
        }
        var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
        return new Observable_1.Observable(function(subscriber) {
          var sourceIndex = 0;
          var subscribeNext = function() {
            if (sourceIndex < nextSources.length) {
              var nextSource = void 0;
              try {
                nextSource = innerFrom_1.innerFrom(nextSources[sourceIndex++]);
              } catch (err2) {
                subscribeNext();
                return;
              }
              var innerSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, void 0, noop_1.noop, noop_1.noop);
              nextSource.subscribe(innerSubscriber);
              innerSubscriber.add(subscribeNext);
            } else {
              subscriber.complete();
            }
          };
          subscribeNext();
        });
      }
      exports.onErrorResumeNext = onErrorResumeNext;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/pairs.js
  var require_pairs = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/pairs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.pairs = void 0;
      var from_1 = require_from();
      function pairs(obj, scheduler) {
        return from_1.from(Object.entries(obj), scheduler);
      }
      exports.pairs = pairs;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/util/not.js
  var require_not = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/util/not.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.not = void 0;
      function not(pred, thisArg) {
        return function(value, index3) {
          return !pred.call(thisArg, value, index3);
        };
      }
      exports.not = not;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/filter.js
  var require_filter = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/filter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.filter = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function filter(predicate, thisArg) {
        return lift_1.operate(function(source, subscriber) {
          var index3 = 0;
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            return predicate.call(thisArg, value, index3++) && subscriber.next(value);
          }));
        });
      }
      exports.filter = filter;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/partition.js
  var require_partition = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/partition.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.partition = void 0;
      var not_1 = require_not();
      var filter_1 = require_filter();
      var innerFrom_1 = require_innerFrom();
      function partition(source, predicate, thisArg) {
        return [filter_1.filter(predicate, thisArg)(innerFrom_1.innerFrom(source)), filter_1.filter(not_1.not(predicate, thisArg))(innerFrom_1.innerFrom(source))];
      }
      exports.partition = partition;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/race.js
  var require_race = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/race.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.raceInit = exports.race = void 0;
      var Observable_1 = require_Observable();
      var innerFrom_1 = require_innerFrom();
      var argsOrArgArray_1 = require_argsOrArgArray();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function race() {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          sources[_i] = arguments[_i];
        }
        sources = argsOrArgArray_1.argsOrArgArray(sources);
        return sources.length === 1 ? innerFrom_1.innerFrom(sources[0]) : new Observable_1.Observable(raceInit(sources));
      }
      exports.race = race;
      function raceInit(sources) {
        return function(subscriber) {
          var subscriptions = [];
          var _loop_1 = function(i3) {
            subscriptions.push(innerFrom_1.innerFrom(sources[i3]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
              if (subscriptions) {
                for (var s2 = 0; s2 < subscriptions.length; s2++) {
                  s2 !== i3 && subscriptions[s2].unsubscribe();
                }
                subscriptions = null;
              }
              subscriber.next(value);
            })));
          };
          for (var i2 = 0; subscriptions && !subscriber.closed && i2 < sources.length; i2++) {
            _loop_1(i2);
          }
        };
      }
      exports.raceInit = raceInit;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/range.js
  var require_range2 = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/range.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.range = void 0;
      var Observable_1 = require_Observable();
      var empty_1 = require_empty();
      function range(start, count3, scheduler) {
        if (count3 == null) {
          count3 = start;
          start = 0;
        }
        if (count3 <= 0) {
          return empty_1.EMPTY;
        }
        var end = count3 + start;
        return new Observable_1.Observable(scheduler ? function(subscriber) {
          var n2 = start;
          return scheduler.schedule(function() {
            if (n2 < end) {
              subscriber.next(n2++);
              this.schedule();
            } else {
              subscriber.complete();
            }
          });
        } : function(subscriber) {
          var n2 = start;
          while (n2 < end && !subscriber.closed) {
            subscriber.next(n2++);
          }
          subscriber.complete();
        });
      }
      exports.range = range;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/using.js
  var require_using = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/using.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.using = void 0;
      var Observable_1 = require_Observable();
      var innerFrom_1 = require_innerFrom();
      var empty_1 = require_empty();
      function using(resourceFactory, observableFactory) {
        return new Observable_1.Observable(function(subscriber) {
          var resource = resourceFactory();
          var result = observableFactory(resource);
          var source = result ? innerFrom_1.innerFrom(result) : empty_1.EMPTY;
          source.subscribe(subscriber);
          return function() {
            if (resource) {
              resource.unsubscribe();
            }
          };
        });
      }
      exports.using = using;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/zip.js
  var require_zip = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/zip.js"(exports) {
      "use strict";
      var __read2 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2) return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
          } finally {
            if (e2) throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
        for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from2[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.zip = void 0;
      var Observable_1 = require_Observable();
      var innerFrom_1 = require_innerFrom();
      var argsOrArgArray_1 = require_argsOrArgArray();
      var empty_1 = require_empty();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var args_1 = require_args();
      function zip() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var resultSelector = args_1.popResultSelector(args);
        var sources = argsOrArgArray_1.argsOrArgArray(args);
        return sources.length ? new Observable_1.Observable(function(subscriber) {
          var buffers = sources.map(function() {
            return [];
          });
          var completed = sources.map(function() {
            return false;
          });
          subscriber.add(function() {
            buffers = completed = null;
          });
          var _loop_1 = function(sourceIndex2) {
            innerFrom_1.innerFrom(sources[sourceIndex2]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
              buffers[sourceIndex2].push(value);
              if (buffers.every(function(buffer) {
                return buffer.length;
              })) {
                var result = buffers.map(function(buffer) {
                  return buffer.shift();
                });
                subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray2([], __read2(result))) : result);
                if (buffers.some(function(buffer, i2) {
                  return !buffer.length && completed[i2];
                })) {
                  subscriber.complete();
                }
              }
            }, function() {
              completed[sourceIndex2] = true;
              !buffers[sourceIndex2].length && subscriber.complete();
            }));
          };
          for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
            _loop_1(sourceIndex);
          }
          return function() {
            buffers = completed = null;
          };
        }) : empty_1.EMPTY;
      }
      exports.zip = zip;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/types.js
  var require_types2 = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/audit.js
  var require_audit = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/audit.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.audit = void 0;
      var lift_1 = require_lift();
      var innerFrom_1 = require_innerFrom();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function audit(durationSelector) {
        return lift_1.operate(function(source, subscriber) {
          var hasValue = false;
          var lastValue = null;
          var durationSubscriber = null;
          var isComplete = false;
          var endDuration = function() {
            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
            durationSubscriber = null;
            if (hasValue) {
              hasValue = false;
              var value = lastValue;
              lastValue = null;
              subscriber.next(value);
            }
            isComplete && subscriber.complete();
          };
          var cleanupDuration = function() {
            durationSubscriber = null;
            isComplete && subscriber.complete();
          };
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            hasValue = true;
            lastValue = value;
            if (!durationSubscriber) {
              innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, endDuration, cleanupDuration));
            }
          }, function() {
            isComplete = true;
            (!hasValue || !durationSubscriber || durationSubscriber.closed) && subscriber.complete();
          }));
        });
      }
      exports.audit = audit;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/auditTime.js
  var require_auditTime = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/auditTime.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.auditTime = void 0;
      var async_1 = require_async();
      var audit_1 = require_audit();
      var timer_1 = require_timer();
      function auditTime(duration, scheduler) {
        if (scheduler === void 0) {
          scheduler = async_1.asyncScheduler;
        }
        return audit_1.audit(function() {
          return timer_1.timer(duration, scheduler);
        });
      }
      exports.auditTime = auditTime;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/buffer.js
  var require_buffer = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/buffer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.buffer = void 0;
      var lift_1 = require_lift();
      var noop_1 = require_noop();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var innerFrom_1 = require_innerFrom();
      function buffer(closingNotifier) {
        return lift_1.operate(function(source, subscriber) {
          var currentBuffer = [];
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            return currentBuffer.push(value);
          }, function() {
            subscriber.next(currentBuffer);
            subscriber.complete();
          }));
          innerFrom_1.innerFrom(closingNotifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            var b2 = currentBuffer;
            currentBuffer = [];
            subscriber.next(b2);
          }, noop_1.noop));
          return function() {
            currentBuffer = null;
          };
        });
      }
      exports.buffer = buffer;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js
  var require_bufferCount = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/bufferCount.js"(exports) {
      "use strict";
      var __values2 = exports && exports.__values || function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2) return m2.call(o2);
        if (o2 && typeof o2.length === "number") return {
          next: function() {
            if (o2 && i2 >= o2.length) o2 = void 0;
            return { value: o2 && o2[i2++], done: !o2 };
          }
        };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bufferCount = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var arrRemove_1 = require_arrRemove();
      function bufferCount(bufferSize, startBufferEvery) {
        if (startBufferEvery === void 0) {
          startBufferEvery = null;
        }
        startBufferEvery = startBufferEvery !== null && startBufferEvery !== void 0 ? startBufferEvery : bufferSize;
        return lift_1.operate(function(source, subscriber) {
          var buffers = [];
          var count3 = 0;
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var e_1, _a, e_2, _b;
            var toEmit = null;
            if (count3++ % startBufferEvery === 0) {
              buffers.push([]);
            }
            try {
              for (var buffers_1 = __values2(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
                var buffer = buffers_1_1.value;
                buffer.push(value);
                if (bufferSize <= buffer.length) {
                  toEmit = toEmit !== null && toEmit !== void 0 ? toEmit : [];
                  toEmit.push(buffer);
                }
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
            if (toEmit) {
              try {
                for (var toEmit_1 = __values2(toEmit), toEmit_1_1 = toEmit_1.next(); !toEmit_1_1.done; toEmit_1_1 = toEmit_1.next()) {
                  var buffer = toEmit_1_1.value;
                  arrRemove_1.arrRemove(buffers, buffer);
                  subscriber.next(buffer);
                }
              } catch (e_2_1) {
                e_2 = { error: e_2_1 };
              } finally {
                try {
                  if (toEmit_1_1 && !toEmit_1_1.done && (_b = toEmit_1.return)) _b.call(toEmit_1);
                } finally {
                  if (e_2) throw e_2.error;
                }
              }
            }
          }, function() {
            var e_3, _a;
            try {
              for (var buffers_2 = __values2(buffers), buffers_2_1 = buffers_2.next(); !buffers_2_1.done; buffers_2_1 = buffers_2.next()) {
                var buffer = buffers_2_1.value;
                subscriber.next(buffer);
              }
            } catch (e_3_1) {
              e_3 = { error: e_3_1 };
            } finally {
              try {
                if (buffers_2_1 && !buffers_2_1.done && (_a = buffers_2.return)) _a.call(buffers_2);
              } finally {
                if (e_3) throw e_3.error;
              }
            }
            subscriber.complete();
          }, void 0, function() {
            buffers = null;
          }));
        });
      }
      exports.bufferCount = bufferCount;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js
  var require_bufferTime = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/bufferTime.js"(exports) {
      "use strict";
      var __values2 = exports && exports.__values || function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2) return m2.call(o2);
        if (o2 && typeof o2.length === "number") return {
          next: function() {
            if (o2 && i2 >= o2.length) o2 = void 0;
            return { value: o2 && o2[i2++], done: !o2 };
          }
        };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bufferTime = void 0;
      var Subscription_1 = require_Subscription();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var arrRemove_1 = require_arrRemove();
      var async_1 = require_async();
      var args_1 = require_args();
      var executeSchedule_1 = require_executeSchedule();
      function bufferTime(bufferTimeSpan) {
        var _a, _b;
        var otherArgs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          otherArgs[_i - 1] = arguments[_i];
        }
        var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
        var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
        var maxBufferSize = otherArgs[1] || Infinity;
        return lift_1.operate(function(source, subscriber) {
          var bufferRecords = [];
          var restartOnEmit = false;
          var emit = function(record) {
            var buffer = record.buffer, subs = record.subs;
            subs.unsubscribe();
            arrRemove_1.arrRemove(bufferRecords, record);
            subscriber.next(buffer);
            restartOnEmit && startBuffer();
          };
          var startBuffer = function() {
            if (bufferRecords) {
              var subs = new Subscription_1.Subscription();
              subscriber.add(subs);
              var buffer = [];
              var record_1 = {
                buffer,
                subs
              };
              bufferRecords.push(record_1);
              executeSchedule_1.executeSchedule(subs, scheduler, function() {
                return emit(record_1);
              }, bufferTimeSpan);
            }
          };
          if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
            executeSchedule_1.executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
          } else {
            restartOnEmit = true;
          }
          startBuffer();
          var bufferTimeSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var e_1, _a2;
            var recordsCopy = bufferRecords.slice();
            try {
              for (var recordsCopy_1 = __values2(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
                var record = recordsCopy_1_1.value;
                var buffer = record.buffer;
                buffer.push(value);
                maxBufferSize <= buffer.length && emit(record);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a2 = recordsCopy_1.return)) _a2.call(recordsCopy_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          }, function() {
            while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
              subscriber.next(bufferRecords.shift().buffer);
            }
            bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
            subscriber.complete();
            subscriber.unsubscribe();
          }, void 0, function() {
            return bufferRecords = null;
          });
          source.subscribe(bufferTimeSubscriber);
        });
      }
      exports.bufferTime = bufferTime;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js
  var require_bufferToggle = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/bufferToggle.js"(exports) {
      "use strict";
      var __values2 = exports && exports.__values || function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2) return m2.call(o2);
        if (o2 && typeof o2.length === "number") return {
          next: function() {
            if (o2 && i2 >= o2.length) o2 = void 0;
            return { value: o2 && o2[i2++], done: !o2 };
          }
        };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bufferToggle = void 0;
      var Subscription_1 = require_Subscription();
      var lift_1 = require_lift();
      var innerFrom_1 = require_innerFrom();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var noop_1 = require_noop();
      var arrRemove_1 = require_arrRemove();
      function bufferToggle(openings, closingSelector) {
        return lift_1.operate(function(source, subscriber) {
          var buffers = [];
          innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
            var buffer = [];
            buffers.push(buffer);
            var closingSubscription = new Subscription_1.Subscription();
            var emitBuffer = function() {
              arrRemove_1.arrRemove(buffers, buffer);
              subscriber.next(buffer);
              closingSubscription.unsubscribe();
            };
            closingSubscription.add(innerFrom_1.innerFrom(closingSelector(openValue)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, emitBuffer, noop_1.noop)));
          }, noop_1.noop));
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var e_1, _a;
            try {
              for (var buffers_1 = __values2(buffers), buffers_1_1 = buffers_1.next(); !buffers_1_1.done; buffers_1_1 = buffers_1.next()) {
                var buffer = buffers_1_1.value;
                buffer.push(value);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (buffers_1_1 && !buffers_1_1.done && (_a = buffers_1.return)) _a.call(buffers_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          }, function() {
            while (buffers.length > 0) {
              subscriber.next(buffers.shift());
            }
            subscriber.complete();
          }));
        });
      }
      exports.bufferToggle = bufferToggle;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js
  var require_bufferWhen = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/bufferWhen.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bufferWhen = void 0;
      var lift_1 = require_lift();
      var noop_1 = require_noop();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var innerFrom_1 = require_innerFrom();
      function bufferWhen(closingSelector) {
        return lift_1.operate(function(source, subscriber) {
          var buffer = null;
          var closingSubscriber = null;
          var openBuffer = function() {
            closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
            var b2 = buffer;
            buffer = [];
            b2 && subscriber.next(b2);
            innerFrom_1.innerFrom(closingSelector()).subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openBuffer, noop_1.noop));
          };
          openBuffer();
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            return buffer === null || buffer === void 0 ? void 0 : buffer.push(value);
          }, function() {
            buffer && subscriber.next(buffer);
            subscriber.complete();
          }, void 0, function() {
            return buffer = closingSubscriber = null;
          }));
        });
      }
      exports.bufferWhen = bufferWhen;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/catchError.js
  var require_catchError = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/catchError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.catchError = void 0;
      var innerFrom_1 = require_innerFrom();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var lift_1 = require_lift();
      function catchError(selector) {
        return lift_1.operate(function(source, subscriber) {
          var innerSub = null;
          var syncUnsub = false;
          var handledResult;
          innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err2) {
            handledResult = innerFrom_1.innerFrom(selector(err2, catchError(selector)(source)));
            if (innerSub) {
              innerSub.unsubscribe();
              innerSub = null;
              handledResult.subscribe(subscriber);
            } else {
              syncUnsub = true;
            }
          }));
          if (syncUnsub) {
            innerSub.unsubscribe();
            innerSub = null;
            handledResult.subscribe(subscriber);
          }
        });
      }
      exports.catchError = catchError;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js
  var require_scanInternals = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/scanInternals.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.scanInternals = void 0;
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function scanInternals2(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
        return function(source, subscriber) {
          var hasState = hasSeed;
          var state = seed;
          var index3 = 0;
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var i2 = index3++;
            state = hasState ? accumulator(state, value, i2) : (hasState = true, value);
            emitOnNext && subscriber.next(state);
          }, emitBeforeComplete && (function() {
            hasState && subscriber.next(state);
            subscriber.complete();
          })));
        };
      }
      exports.scanInternals = scanInternals2;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/reduce.js
  var require_reduce = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/reduce.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.reduce = void 0;
      var scanInternals_1 = require_scanInternals();
      var lift_1 = require_lift();
      function reduce2(accumulator, seed) {
        return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, false, true));
      }
      exports.reduce = reduce2;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/toArray.js
  var require_toArray = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/toArray.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toArray = void 0;
      var reduce_1 = require_reduce();
      var lift_1 = require_lift();
      var arrReducer2 = function(arr, value) {
        return arr.push(value), arr;
      };
      function toArray2() {
        return lift_1.operate(function(source, subscriber) {
          reduce_1.reduce(arrReducer2, [])(source).subscribe(subscriber);
        });
      }
      exports.toArray = toArray2;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js
  var require_joinAllInternals = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/joinAllInternals.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.joinAllInternals = void 0;
      var identity_1 = require_identity();
      var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
      var pipe_1 = require_pipe();
      var mergeMap_1 = require_mergeMap();
      var toArray_1 = require_toArray();
      function joinAllInternals(joinFn, project) {
        return pipe_1.pipe(toArray_1.toArray(), mergeMap_1.mergeMap(function(sources) {
          return joinFn(sources);
        }), project ? mapOneOrManyArgs_1.mapOneOrManyArgs(project) : identity_1.identity);
      }
      exports.joinAllInternals = joinAllInternals;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js
  var require_combineLatestAll = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/combineLatestAll.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.combineLatestAll = void 0;
      var combineLatest_1 = require_combineLatest();
      var joinAllInternals_1 = require_joinAllInternals();
      function combineLatestAll(project) {
        return joinAllInternals_1.joinAllInternals(combineLatest_1.combineLatest, project);
      }
      exports.combineLatestAll = combineLatestAll;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/combineAll.js
  var require_combineAll = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/combineAll.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.combineAll = void 0;
      var combineLatestAll_1 = require_combineLatestAll();
      exports.combineAll = combineLatestAll_1.combineLatestAll;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js
  var require_combineLatest2 = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/combineLatest.js"(exports) {
      "use strict";
      var __read2 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2) return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
          } finally {
            if (e2) throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
        for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from2[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.combineLatest = void 0;
      var combineLatest_1 = require_combineLatest();
      var lift_1 = require_lift();
      var argsOrArgArray_1 = require_argsOrArgArray();
      var mapOneOrManyArgs_1 = require_mapOneOrManyArgs();
      var pipe_1 = require_pipe();
      var args_1 = require_args();
      function combineLatest() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var resultSelector = args_1.popResultSelector(args);
        return resultSelector ? pipe_1.pipe(combineLatest.apply(void 0, __spreadArray2([], __read2(args))), mapOneOrManyArgs_1.mapOneOrManyArgs(resultSelector)) : lift_1.operate(function(source, subscriber) {
          combineLatest_1.combineLatestInit(__spreadArray2([source], __read2(argsOrArgArray_1.argsOrArgArray(args))))(subscriber);
        });
      }
      exports.combineLatest = combineLatest;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js
  var require_combineLatestWith = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/combineLatestWith.js"(exports) {
      "use strict";
      var __read2 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2) return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
          } finally {
            if (e2) throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
        for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from2[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.combineLatestWith = void 0;
      var combineLatest_1 = require_combineLatest2();
      function combineLatestWith() {
        var otherSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          otherSources[_i] = arguments[_i];
        }
        return combineLatest_1.combineLatest.apply(void 0, __spreadArray2([], __read2(otherSources)));
      }
      exports.combineLatestWith = combineLatestWith;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/concatMap.js
  var require_concatMap = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/concatMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.concatMap = void 0;
      var mergeMap_1 = require_mergeMap();
      var isFunction_1 = require_isFunction();
      function concatMap(project, resultSelector) {
        return isFunction_1.isFunction(resultSelector) ? mergeMap_1.mergeMap(project, resultSelector, 1) : mergeMap_1.mergeMap(project, 1);
      }
      exports.concatMap = concatMap;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js
  var require_concatMapTo = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/concatMapTo.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.concatMapTo = void 0;
      var concatMap_1 = require_concatMap();
      var isFunction_1 = require_isFunction();
      function concatMapTo(innerObservable, resultSelector) {
        return isFunction_1.isFunction(resultSelector) ? concatMap_1.concatMap(function() {
          return innerObservable;
        }, resultSelector) : concatMap_1.concatMap(function() {
          return innerObservable;
        });
      }
      exports.concatMapTo = concatMapTo;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/concat.js
  var require_concat2 = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/concat.js"(exports) {
      "use strict";
      var __read2 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2) return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
          } finally {
            if (e2) throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
        for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from2[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.concat = void 0;
      var lift_1 = require_lift();
      var concatAll_1 = require_concatAll();
      var args_1 = require_args();
      var from_1 = require_from();
      function concat() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var scheduler = args_1.popScheduler(args);
        return lift_1.operate(function(source, subscriber) {
          concatAll_1.concatAll()(from_1.from(__spreadArray2([source], __read2(args)), scheduler)).subscribe(subscriber);
        });
      }
      exports.concat = concat;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/concatWith.js
  var require_concatWith = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/concatWith.js"(exports) {
      "use strict";
      var __read2 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2) return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
          } finally {
            if (e2) throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
        for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from2[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.concatWith = void 0;
      var concat_1 = require_concat2();
      function concatWith() {
        var otherSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          otherSources[_i] = arguments[_i];
        }
        return concat_1.concat.apply(void 0, __spreadArray2([], __read2(otherSources)));
      }
      exports.concatWith = concatWith;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js
  var require_fromSubscribable = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/observable/fromSubscribable.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fromSubscribable = void 0;
      var Observable_1 = require_Observable();
      function fromSubscribable(subscribable) {
        return new Observable_1.Observable(function(subscriber) {
          return subscribable.subscribe(subscriber);
        });
      }
      exports.fromSubscribable = fromSubscribable;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/connect.js
  var require_connect = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/connect.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.connect = void 0;
      var Subject_1 = require_Subject();
      var innerFrom_1 = require_innerFrom();
      var lift_1 = require_lift();
      var fromSubscribable_1 = require_fromSubscribable();
      var DEFAULT_CONFIG = {
        connector: function() {
          return new Subject_1.Subject();
        }
      };
      function connect(selector, config2) {
        if (config2 === void 0) {
          config2 = DEFAULT_CONFIG;
        }
        var connector = config2.connector;
        return lift_1.operate(function(source, subscriber) {
          var subject = connector();
          innerFrom_1.innerFrom(selector(fromSubscribable_1.fromSubscribable(subject))).subscribe(subscriber);
          subscriber.add(source.subscribe(subject));
        });
      }
      exports.connect = connect;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/count.js
  var require_count = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/count.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.count = void 0;
      var reduce_1 = require_reduce();
      function count3(predicate) {
        return reduce_1.reduce(function(total, value, i2) {
          return !predicate || predicate(value, i2) ? total + 1 : total;
        }, 0);
      }
      exports.count = count3;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/debounce.js
  var require_debounce = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/debounce.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.debounce = void 0;
      var lift_1 = require_lift();
      var noop_1 = require_noop();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var innerFrom_1 = require_innerFrom();
      function debounce(durationSelector) {
        return lift_1.operate(function(source, subscriber) {
          var hasValue = false;
          var lastValue = null;
          var durationSubscriber = null;
          var emit = function() {
            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
            durationSubscriber = null;
            if (hasValue) {
              hasValue = false;
              var value = lastValue;
              lastValue = null;
              subscriber.next(value);
            }
          };
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            durationSubscriber === null || durationSubscriber === void 0 ? void 0 : durationSubscriber.unsubscribe();
            hasValue = true;
            lastValue = value;
            durationSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, emit, noop_1.noop);
            innerFrom_1.innerFrom(durationSelector(value)).subscribe(durationSubscriber);
          }, function() {
            emit();
            subscriber.complete();
          }, void 0, function() {
            lastValue = durationSubscriber = null;
          }));
        });
      }
      exports.debounce = debounce;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js
  var require_debounceTime = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/debounceTime.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.debounceTime = void 0;
      var async_1 = require_async();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function debounceTime(dueTime, scheduler) {
        if (scheduler === void 0) {
          scheduler = async_1.asyncScheduler;
        }
        return lift_1.operate(function(source, subscriber) {
          var activeTask = null;
          var lastValue = null;
          var lastTime = null;
          var emit = function() {
            if (activeTask) {
              activeTask.unsubscribe();
              activeTask = null;
              var value = lastValue;
              lastValue = null;
              subscriber.next(value);
            }
          };
          function emitWhenIdle() {
            var targetTime = lastTime + dueTime;
            var now = scheduler.now();
            if (now < targetTime) {
              activeTask = this.schedule(void 0, targetTime - now);
              subscriber.add(activeTask);
              return;
            }
            emit();
          }
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            lastValue = value;
            lastTime = scheduler.now();
            if (!activeTask) {
              activeTask = scheduler.schedule(emitWhenIdle, dueTime);
              subscriber.add(activeTask);
            }
          }, function() {
            emit();
            subscriber.complete();
          }, void 0, function() {
            lastValue = activeTask = null;
          }));
        });
      }
      exports.debounceTime = debounceTime;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js
  var require_defaultIfEmpty = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/defaultIfEmpty.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.defaultIfEmpty = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function defaultIfEmpty(defaultValue) {
        return lift_1.operate(function(source, subscriber) {
          var hasValue = false;
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            hasValue = true;
            subscriber.next(value);
          }, function() {
            if (!hasValue) {
              subscriber.next(defaultValue);
            }
            subscriber.complete();
          }));
        });
      }
      exports.defaultIfEmpty = defaultIfEmpty;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/take.js
  var require_take = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/take.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.take = void 0;
      var empty_1 = require_empty();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function take(count3) {
        return count3 <= 0 ? function() {
          return empty_1.EMPTY;
        } : lift_1.operate(function(source, subscriber) {
          var seen = 0;
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (++seen <= count3) {
              subscriber.next(value);
              if (count3 <= seen) {
                subscriber.complete();
              }
            }
          }));
        });
      }
      exports.take = take;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js
  var require_ignoreElements = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/ignoreElements.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ignoreElements = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var noop_1 = require_noop();
      function ignoreElements() {
        return lift_1.operate(function(source, subscriber) {
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, noop_1.noop));
        });
      }
      exports.ignoreElements = ignoreElements;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/mapTo.js
  var require_mapTo = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/mapTo.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mapTo = void 0;
      var map_1 = require_map();
      function mapTo(value) {
        return map_1.map(function() {
          return value;
        });
      }
      exports.mapTo = mapTo;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js
  var require_delayWhen = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/delayWhen.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.delayWhen = void 0;
      var concat_1 = require_concat();
      var take_1 = require_take();
      var ignoreElements_1 = require_ignoreElements();
      var mapTo_1 = require_mapTo();
      var mergeMap_1 = require_mergeMap();
      var innerFrom_1 = require_innerFrom();
      function delayWhen(delayDurationSelector, subscriptionDelay) {
        if (subscriptionDelay) {
          return function(source) {
            return concat_1.concat(subscriptionDelay.pipe(take_1.take(1), ignoreElements_1.ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
          };
        }
        return mergeMap_1.mergeMap(function(value, index3) {
          return innerFrom_1.innerFrom(delayDurationSelector(value, index3)).pipe(take_1.take(1), mapTo_1.mapTo(value));
        });
      }
      exports.delayWhen = delayWhen;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/delay.js
  var require_delay = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/delay.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.delay = void 0;
      var async_1 = require_async();
      var delayWhen_1 = require_delayWhen();
      var timer_1 = require_timer();
      function delay(due, scheduler) {
        if (scheduler === void 0) {
          scheduler = async_1.asyncScheduler;
        }
        var duration = timer_1.timer(due, scheduler);
        return delayWhen_1.delayWhen(function() {
          return duration;
        });
      }
      exports.delay = delay;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js
  var require_dematerialize = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/dematerialize.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.dematerialize = void 0;
      var Notification_1 = require_Notification();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function dematerialize() {
        return lift_1.operate(function(source, subscriber) {
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(notification) {
            return Notification_1.observeNotification(notification, subscriber);
          }));
        });
      }
      exports.dematerialize = dematerialize;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/distinct.js
  var require_distinct = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/distinct.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.distinct = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var noop_1 = require_noop();
      var innerFrom_1 = require_innerFrom();
      function distinct(keySelector, flushes) {
        return lift_1.operate(function(source, subscriber) {
          var distinctKeys = /* @__PURE__ */ new Set();
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var key = keySelector ? keySelector(value) : value;
            if (!distinctKeys.has(key)) {
              distinctKeys.add(key);
              subscriber.next(value);
            }
          }));
          flushes && innerFrom_1.innerFrom(flushes).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            return distinctKeys.clear();
          }, noop_1.noop));
        });
      }
      exports.distinct = distinct;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js
  var require_distinctUntilChanged = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/distinctUntilChanged.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.distinctUntilChanged = void 0;
      var identity_1 = require_identity();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function distinctUntilChanged(comparator, keySelector) {
        if (keySelector === void 0) {
          keySelector = identity_1.identity;
        }
        comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
        return lift_1.operate(function(source, subscriber) {
          var previousKey;
          var first = true;
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var currentKey = keySelector(value);
            if (first || !comparator(previousKey, currentKey)) {
              first = false;
              previousKey = currentKey;
              subscriber.next(value);
            }
          }));
        });
      }
      exports.distinctUntilChanged = distinctUntilChanged;
      function defaultCompare(a2, b2) {
        return a2 === b2;
      }
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js
  var require_distinctUntilKeyChanged = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/distinctUntilKeyChanged.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.distinctUntilKeyChanged = void 0;
      var distinctUntilChanged_1 = require_distinctUntilChanged();
      function distinctUntilKeyChanged(key, compare2) {
        return distinctUntilChanged_1.distinctUntilChanged(function(x2, y2) {
          return compare2 ? compare2(x2[key], y2[key]) : x2[key] === y2[key];
        });
      }
      exports.distinctUntilKeyChanged = distinctUntilKeyChanged;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js
  var require_throwIfEmpty = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/throwIfEmpty.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.throwIfEmpty = void 0;
      var EmptyError_1 = require_EmptyError();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function throwIfEmpty(errorFactory) {
        if (errorFactory === void 0) {
          errorFactory = defaultErrorFactory;
        }
        return lift_1.operate(function(source, subscriber) {
          var hasValue = false;
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            hasValue = true;
            subscriber.next(value);
          }, function() {
            return hasValue ? subscriber.complete() : subscriber.error(errorFactory());
          }));
        });
      }
      exports.throwIfEmpty = throwIfEmpty;
      function defaultErrorFactory() {
        return new EmptyError_1.EmptyError();
      }
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/elementAt.js
  var require_elementAt = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/elementAt.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.elementAt = void 0;
      var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
      var filter_1 = require_filter();
      var throwIfEmpty_1 = require_throwIfEmpty();
      var defaultIfEmpty_1 = require_defaultIfEmpty();
      var take_1 = require_take();
      function elementAt(index3, defaultValue) {
        if (index3 < 0) {
          throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
        }
        var hasDefaultValue = arguments.length >= 2;
        return function(source) {
          return source.pipe(filter_1.filter(function(v2, i2) {
            return i2 === index3;
          }), take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
            return new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
          }));
        };
      }
      exports.elementAt = elementAt;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/endWith.js
  var require_endWith = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/endWith.js"(exports) {
      "use strict";
      var __read2 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2) return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
          } finally {
            if (e2) throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
        for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from2[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.endWith = void 0;
      var concat_1 = require_concat();
      var of_1 = require_of();
      function endWith() {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          values[_i] = arguments[_i];
        }
        return function(source) {
          return concat_1.concat(source, of_1.of.apply(void 0, __spreadArray2([], __read2(values))));
        };
      }
      exports.endWith = endWith;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/every.js
  var require_every = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/every.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.every = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function every(predicate, thisArg) {
        return lift_1.operate(function(source, subscriber) {
          var index3 = 0;
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (!predicate.call(thisArg, value, index3++, source)) {
              subscriber.next(false);
              subscriber.complete();
            }
          }, function() {
            subscriber.next(true);
            subscriber.complete();
          }));
        });
      }
      exports.every = every;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js
  var require_exhaustMap = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/exhaustMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.exhaustMap = void 0;
      var map_1 = require_map();
      var innerFrom_1 = require_innerFrom();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function exhaustMap(project, resultSelector) {
        if (resultSelector) {
          return function(source) {
            return source.pipe(exhaustMap(function(a2, i2) {
              return innerFrom_1.innerFrom(project(a2, i2)).pipe(map_1.map(function(b2, ii) {
                return resultSelector(a2, b2, i2, ii);
              }));
            }));
          };
        }
        return lift_1.operate(function(source, subscriber) {
          var index3 = 0;
          var innerSub = null;
          var isComplete = false;
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(outerValue) {
            if (!innerSub) {
              innerSub = OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
                innerSub = null;
                isComplete && subscriber.complete();
              });
              innerFrom_1.innerFrom(project(outerValue, index3++)).subscribe(innerSub);
            }
          }, function() {
            isComplete = true;
            !innerSub && subscriber.complete();
          }));
        });
      }
      exports.exhaustMap = exhaustMap;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js
  var require_exhaustAll = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/exhaustAll.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.exhaustAll = void 0;
      var exhaustMap_1 = require_exhaustMap();
      var identity_1 = require_identity();
      function exhaustAll() {
        return exhaustMap_1.exhaustMap(identity_1.identity);
      }
      exports.exhaustAll = exhaustAll;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/exhaust.js
  var require_exhaust = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/exhaust.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.exhaust = void 0;
      var exhaustAll_1 = require_exhaustAll();
      exports.exhaust = exhaustAll_1.exhaustAll;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/expand.js
  var require_expand = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/expand.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.expand = void 0;
      var lift_1 = require_lift();
      var mergeInternals_1 = require_mergeInternals();
      function expand(project, concurrent, scheduler) {
        if (concurrent === void 0) {
          concurrent = Infinity;
        }
        concurrent = (concurrent || 0) < 1 ? Infinity : concurrent;
        return lift_1.operate(function(source, subscriber) {
          return mergeInternals_1.mergeInternals(source, subscriber, project, concurrent, void 0, true, scheduler);
        });
      }
      exports.expand = expand;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/finalize.js
  var require_finalize = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/finalize.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.finalize = void 0;
      var lift_1 = require_lift();
      function finalize(callback) {
        return lift_1.operate(function(source, subscriber) {
          try {
            source.subscribe(subscriber);
          } finally {
            subscriber.add(callback);
          }
        });
      }
      exports.finalize = finalize;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/find.js
  var require_find = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/find.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createFind = exports.find = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function find(predicate, thisArg) {
        return lift_1.operate(createFind(predicate, thisArg, "value"));
      }
      exports.find = find;
      function createFind(predicate, thisArg, emit) {
        var findIndex = emit === "index";
        return function(source, subscriber) {
          var index3 = 0;
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var i2 = index3++;
            if (predicate.call(thisArg, value, i2, source)) {
              subscriber.next(findIndex ? i2 : value);
              subscriber.complete();
            }
          }, function() {
            subscriber.next(findIndex ? -1 : void 0);
            subscriber.complete();
          }));
        };
      }
      exports.createFind = createFind;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/findIndex.js
  var require_findIndex = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/findIndex.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.findIndex = void 0;
      var lift_1 = require_lift();
      var find_1 = require_find();
      function findIndex(predicate, thisArg) {
        return lift_1.operate(find_1.createFind(predicate, thisArg, "index"));
      }
      exports.findIndex = findIndex;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/first.js
  var require_first = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/first.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.first = void 0;
      var EmptyError_1 = require_EmptyError();
      var filter_1 = require_filter();
      var take_1 = require_take();
      var defaultIfEmpty_1 = require_defaultIfEmpty();
      var throwIfEmpty_1 = require_throwIfEmpty();
      var identity_1 = require_identity();
      function first(predicate, defaultValue) {
        var hasDefaultValue = arguments.length >= 2;
        return function(source) {
          return source.pipe(predicate ? filter_1.filter(function(v2, i2) {
            return predicate(v2, i2, source);
          }) : identity_1.identity, take_1.take(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
            return new EmptyError_1.EmptyError();
          }));
        };
      }
      exports.first = first;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/groupBy.js
  var require_groupBy = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/groupBy.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.groupBy = void 0;
      var Observable_1 = require_Observable();
      var innerFrom_1 = require_innerFrom();
      var Subject_1 = require_Subject();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function groupBy2(keySelector, elementOrOptions, duration, connector) {
        return lift_1.operate(function(source, subscriber) {
          var element;
          if (!elementOrOptions || typeof elementOrOptions === "function") {
            element = elementOrOptions;
          } else {
            duration = elementOrOptions.duration, element = elementOrOptions.element, connector = elementOrOptions.connector;
          }
          var groups = /* @__PURE__ */ new Map();
          var notify = function(cb) {
            groups.forEach(cb);
            cb(subscriber);
          };
          var handleError = function(err2) {
            return notify(function(consumer) {
              return consumer.error(err2);
            });
          };
          var activeGroups = 0;
          var teardownAttempted = false;
          var groupBySourceSubscriber = new OperatorSubscriber_1.OperatorSubscriber(subscriber, function(value) {
            try {
              var key_1 = keySelector(value);
              var group_1 = groups.get(key_1);
              if (!group_1) {
                groups.set(key_1, group_1 = connector ? connector() : new Subject_1.Subject());
                var grouped = createGroupedObservable(key_1, group_1);
                subscriber.next(grouped);
                if (duration) {
                  var durationSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(group_1, function() {
                    group_1.complete();
                    durationSubscriber_1 === null || durationSubscriber_1 === void 0 ? void 0 : durationSubscriber_1.unsubscribe();
                  }, void 0, void 0, function() {
                    return groups.delete(key_1);
                  });
                  groupBySourceSubscriber.add(innerFrom_1.innerFrom(duration(grouped)).subscribe(durationSubscriber_1));
                }
              }
              group_1.next(element ? element(value) : value);
            } catch (err2) {
              handleError(err2);
            }
          }, function() {
            return notify(function(consumer) {
              return consumer.complete();
            });
          }, handleError, function() {
            return groups.clear();
          }, function() {
            teardownAttempted = true;
            return activeGroups === 0;
          });
          source.subscribe(groupBySourceSubscriber);
          function createGroupedObservable(key, groupSubject) {
            var result = new Observable_1.Observable(function(groupSubscriber) {
              activeGroups++;
              var innerSub = groupSubject.subscribe(groupSubscriber);
              return function() {
                innerSub.unsubscribe();
                --activeGroups === 0 && teardownAttempted && groupBySourceSubscriber.unsubscribe();
              };
            });
            result.key = key;
            return result;
          }
        });
      }
      exports.groupBy = groupBy2;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js
  var require_isEmpty = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/isEmpty.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isEmpty = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function isEmpty() {
        return lift_1.operate(function(source, subscriber) {
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            subscriber.next(false);
            subscriber.complete();
          }, function() {
            subscriber.next(true);
            subscriber.complete();
          }));
        });
      }
      exports.isEmpty = isEmpty;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/takeLast.js
  var require_takeLast = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/takeLast.js"(exports) {
      "use strict";
      var __values2 = exports && exports.__values || function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2) return m2.call(o2);
        if (o2 && typeof o2.length === "number") return {
          next: function() {
            if (o2 && i2 >= o2.length) o2 = void 0;
            return { value: o2 && o2[i2++], done: !o2 };
          }
        };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.takeLast = void 0;
      var empty_1 = require_empty();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function takeLast(count3) {
        return count3 <= 0 ? function() {
          return empty_1.EMPTY;
        } : lift_1.operate(function(source, subscriber) {
          var buffer = [];
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            buffer.push(value);
            count3 < buffer.length && buffer.shift();
          }, function() {
            var e_1, _a;
            try {
              for (var buffer_1 = __values2(buffer), buffer_1_1 = buffer_1.next(); !buffer_1_1.done; buffer_1_1 = buffer_1.next()) {
                var value = buffer_1_1.value;
                subscriber.next(value);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (buffer_1_1 && !buffer_1_1.done && (_a = buffer_1.return)) _a.call(buffer_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
            subscriber.complete();
          }, void 0, function() {
            buffer = null;
          }));
        });
      }
      exports.takeLast = takeLast;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/last.js
  var require_last = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/last.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.last = void 0;
      var EmptyError_1 = require_EmptyError();
      var filter_1 = require_filter();
      var takeLast_1 = require_takeLast();
      var throwIfEmpty_1 = require_throwIfEmpty();
      var defaultIfEmpty_1 = require_defaultIfEmpty();
      var identity_1 = require_identity();
      function last(predicate, defaultValue) {
        var hasDefaultValue = arguments.length >= 2;
        return function(source) {
          return source.pipe(predicate ? filter_1.filter(function(v2, i2) {
            return predicate(v2, i2, source);
          }) : identity_1.identity, takeLast_1.takeLast(1), hasDefaultValue ? defaultIfEmpty_1.defaultIfEmpty(defaultValue) : throwIfEmpty_1.throwIfEmpty(function() {
            return new EmptyError_1.EmptyError();
          }));
        };
      }
      exports.last = last;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/materialize.js
  var require_materialize = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/materialize.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.materialize = void 0;
      var Notification_1 = require_Notification();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function materialize() {
        return lift_1.operate(function(source, subscriber) {
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            subscriber.next(Notification_1.Notification.createNext(value));
          }, function() {
            subscriber.next(Notification_1.Notification.createComplete());
            subscriber.complete();
          }, function(err2) {
            subscriber.next(Notification_1.Notification.createError(err2));
            subscriber.complete();
          }));
        });
      }
      exports.materialize = materialize;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/max.js
  var require_max = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/max.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.max = void 0;
      var reduce_1 = require_reduce();
      var isFunction_1 = require_isFunction();
      function max3(comparer) {
        return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x2, y2) {
          return comparer(x2, y2) > 0 ? x2 : y2;
        } : function(x2, y2) {
          return x2 > y2 ? x2 : y2;
        });
      }
      exports.max = max3;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/flatMap.js
  var require_flatMap = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/flatMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.flatMap = void 0;
      var mergeMap_1 = require_mergeMap();
      exports.flatMap = mergeMap_1.mergeMap;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js
  var require_mergeMapTo = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/mergeMapTo.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mergeMapTo = void 0;
      var mergeMap_1 = require_mergeMap();
      var isFunction_1 = require_isFunction();
      function mergeMapTo(innerObservable, resultSelector, concurrent) {
        if (concurrent === void 0) {
          concurrent = Infinity;
        }
        if (isFunction_1.isFunction(resultSelector)) {
          return mergeMap_1.mergeMap(function() {
            return innerObservable;
          }, resultSelector, concurrent);
        }
        if (typeof resultSelector === "number") {
          concurrent = resultSelector;
        }
        return mergeMap_1.mergeMap(function() {
          return innerObservable;
        }, concurrent);
      }
      exports.mergeMapTo = mergeMapTo;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js
  var require_mergeScan = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/mergeScan.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mergeScan = void 0;
      var lift_1 = require_lift();
      var mergeInternals_1 = require_mergeInternals();
      function mergeScan(accumulator, seed, concurrent) {
        if (concurrent === void 0) {
          concurrent = Infinity;
        }
        return lift_1.operate(function(source, subscriber) {
          var state = seed;
          return mergeInternals_1.mergeInternals(source, subscriber, function(value, index3) {
            return accumulator(state, value, index3);
          }, concurrent, function(value) {
            state = value;
          }, false, void 0, function() {
            return state = null;
          });
        });
      }
      exports.mergeScan = mergeScan;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/merge.js
  var require_merge2 = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/merge.js"(exports) {
      "use strict";
      var __read2 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2) return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
          } finally {
            if (e2) throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
        for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from2[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.merge = void 0;
      var lift_1 = require_lift();
      var mergeAll_1 = require_mergeAll();
      var args_1 = require_args();
      var from_1 = require_from();
      function merge() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var scheduler = args_1.popScheduler(args);
        var concurrent = args_1.popNumber(args, Infinity);
        return lift_1.operate(function(source, subscriber) {
          mergeAll_1.mergeAll(concurrent)(from_1.from(__spreadArray2([source], __read2(args)), scheduler)).subscribe(subscriber);
        });
      }
      exports.merge = merge;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js
  var require_mergeWith = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/mergeWith.js"(exports) {
      "use strict";
      var __read2 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2) return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
          } finally {
            if (e2) throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
        for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from2[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mergeWith = void 0;
      var merge_1 = require_merge2();
      function mergeWith() {
        var otherSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          otherSources[_i] = arguments[_i];
        }
        return merge_1.merge.apply(void 0, __spreadArray2([], __read2(otherSources)));
      }
      exports.mergeWith = mergeWith;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/min.js
  var require_min = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/min.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.min = void 0;
      var reduce_1 = require_reduce();
      var isFunction_1 = require_isFunction();
      function min2(comparer) {
        return reduce_1.reduce(isFunction_1.isFunction(comparer) ? function(x2, y2) {
          return comparer(x2, y2) < 0 ? x2 : y2;
        } : function(x2, y2) {
          return x2 < y2 ? x2 : y2;
        });
      }
      exports.min = min2;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/multicast.js
  var require_multicast = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/multicast.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.multicast = void 0;
      var ConnectableObservable_1 = require_ConnectableObservable();
      var isFunction_1 = require_isFunction();
      var connect_1 = require_connect();
      function multicast(subjectOrSubjectFactory, selector) {
        var subjectFactory = isFunction_1.isFunction(subjectOrSubjectFactory) ? subjectOrSubjectFactory : function() {
          return subjectOrSubjectFactory;
        };
        if (isFunction_1.isFunction(selector)) {
          return connect_1.connect(selector, {
            connector: subjectFactory
          });
        }
        return function(source) {
          return new ConnectableObservable_1.ConnectableObservable(source, subjectFactory);
        };
      }
      exports.multicast = multicast;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js
  var require_onErrorResumeNextWith = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/onErrorResumeNextWith.js"(exports) {
      "use strict";
      var __read2 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2) return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
          } finally {
            if (e2) throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
        for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from2[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.onErrorResumeNext = exports.onErrorResumeNextWith = void 0;
      var argsOrArgArray_1 = require_argsOrArgArray();
      var onErrorResumeNext_1 = require_onErrorResumeNext();
      function onErrorResumeNextWith() {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          sources[_i] = arguments[_i];
        }
        var nextSources = argsOrArgArray_1.argsOrArgArray(sources);
        return function(source) {
          return onErrorResumeNext_1.onErrorResumeNext.apply(void 0, __spreadArray2([source], __read2(nextSources)));
        };
      }
      exports.onErrorResumeNextWith = onErrorResumeNextWith;
      exports.onErrorResumeNext = onErrorResumeNextWith;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/pairwise.js
  var require_pairwise = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/pairwise.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.pairwise = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function pairwise() {
        return lift_1.operate(function(source, subscriber) {
          var prev2;
          var hasPrev = false;
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var p2 = prev2;
            prev2 = value;
            hasPrev && subscriber.next([p2, value]);
            hasPrev = true;
          }));
        });
      }
      exports.pairwise = pairwise;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/pluck.js
  var require_pluck = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/pluck.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.pluck = void 0;
      var map_1 = require_map();
      function pluck() {
        var properties = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          properties[_i] = arguments[_i];
        }
        var length2 = properties.length;
        if (length2 === 0) {
          throw new Error("list of properties cannot be empty.");
        }
        return map_1.map(function(x2) {
          var currentProp = x2;
          for (var i2 = 0; i2 < length2; i2++) {
            var p2 = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i2]];
            if (typeof p2 !== "undefined") {
              currentProp = p2;
            } else {
              return void 0;
            }
          }
          return currentProp;
        });
      }
      exports.pluck = pluck;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/publish.js
  var require_publish = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/publish.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.publish = void 0;
      var Subject_1 = require_Subject();
      var multicast_1 = require_multicast();
      var connect_1 = require_connect();
      function publish(selector) {
        return selector ? function(source) {
          return connect_1.connect(selector)(source);
        } : function(source) {
          return multicast_1.multicast(new Subject_1.Subject())(source);
        };
      }
      exports.publish = publish;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js
  var require_publishBehavior = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/publishBehavior.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.publishBehavior = void 0;
      var BehaviorSubject_1 = require_BehaviorSubject();
      var ConnectableObservable_1 = require_ConnectableObservable();
      function publishBehavior(initialValue) {
        return function(source) {
          var subject = new BehaviorSubject_1.BehaviorSubject(initialValue);
          return new ConnectableObservable_1.ConnectableObservable(source, function() {
            return subject;
          });
        };
      }
      exports.publishBehavior = publishBehavior;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/publishLast.js
  var require_publishLast = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/publishLast.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.publishLast = void 0;
      var AsyncSubject_1 = require_AsyncSubject();
      var ConnectableObservable_1 = require_ConnectableObservable();
      function publishLast() {
        return function(source) {
          var subject = new AsyncSubject_1.AsyncSubject();
          return new ConnectableObservable_1.ConnectableObservable(source, function() {
            return subject;
          });
        };
      }
      exports.publishLast = publishLast;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js
  var require_publishReplay = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/publishReplay.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.publishReplay = void 0;
      var ReplaySubject_1 = require_ReplaySubject();
      var multicast_1 = require_multicast();
      var isFunction_1 = require_isFunction();
      function publishReplay(bufferSize, windowTime, selectorOrScheduler, timestampProvider) {
        if (selectorOrScheduler && !isFunction_1.isFunction(selectorOrScheduler)) {
          timestampProvider = selectorOrScheduler;
        }
        var selector = isFunction_1.isFunction(selectorOrScheduler) ? selectorOrScheduler : void 0;
        return function(source) {
          return multicast_1.multicast(new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, timestampProvider), selector)(source);
        };
      }
      exports.publishReplay = publishReplay;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/raceWith.js
  var require_raceWith = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/raceWith.js"(exports) {
      "use strict";
      var __read2 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2) return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
          } finally {
            if (e2) throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
        for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from2[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.raceWith = void 0;
      var race_1 = require_race();
      var lift_1 = require_lift();
      var identity_1 = require_identity();
      function raceWith() {
        var otherSources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          otherSources[_i] = arguments[_i];
        }
        return !otherSources.length ? identity_1.identity : lift_1.operate(function(source, subscriber) {
          race_1.raceInit(__spreadArray2([source], __read2(otherSources)))(subscriber);
        });
      }
      exports.raceWith = raceWith;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/repeat.js
  var require_repeat = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/repeat.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.repeat = void 0;
      var empty_1 = require_empty();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var innerFrom_1 = require_innerFrom();
      var timer_1 = require_timer();
      function repeat(countOrConfig) {
        var _a;
        var count3 = Infinity;
        var delay;
        if (countOrConfig != null) {
          if (typeof countOrConfig === "object") {
            _a = countOrConfig.count, count3 = _a === void 0 ? Infinity : _a, delay = countOrConfig.delay;
          } else {
            count3 = countOrConfig;
          }
        }
        return count3 <= 0 ? function() {
          return empty_1.EMPTY;
        } : lift_1.operate(function(source, subscriber) {
          var soFar = 0;
          var sourceSub;
          var resubscribe = function() {
            sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
            sourceSub = null;
            if (delay != null) {
              var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(soFar));
              var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                notifierSubscriber_1.unsubscribe();
                subscribeToSource();
              });
              notifier.subscribe(notifierSubscriber_1);
            } else {
              subscribeToSource();
            }
          };
          var subscribeToSource = function() {
            var syncUnsub = false;
            sourceSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
              if (++soFar < count3) {
                if (sourceSub) {
                  resubscribe();
                } else {
                  syncUnsub = true;
                }
              } else {
                subscriber.complete();
              }
            }));
            if (syncUnsub) {
              resubscribe();
            }
          };
          subscribeToSource();
        });
      }
      exports.repeat = repeat;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js
  var require_repeatWhen = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/repeatWhen.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.repeatWhen = void 0;
      var innerFrom_1 = require_innerFrom();
      var Subject_1 = require_Subject();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function repeatWhen(notifier) {
        return lift_1.operate(function(source, subscriber) {
          var innerSub;
          var syncResub = false;
          var completions$;
          var isNotifierComplete = false;
          var isMainComplete = false;
          var checkComplete = function() {
            return isMainComplete && isNotifierComplete && (subscriber.complete(), true);
          };
          var getCompletionSubject = function() {
            if (!completions$) {
              completions$ = new Subject_1.Subject();
              innerFrom_1.innerFrom(notifier(completions$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                if (innerSub) {
                  subscribeForRepeatWhen();
                } else {
                  syncResub = true;
                }
              }, function() {
                isNotifierComplete = true;
                checkComplete();
              }));
            }
            return completions$;
          };
          var subscribeForRepeatWhen = function() {
            isMainComplete = false;
            innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, function() {
              isMainComplete = true;
              !checkComplete() && getCompletionSubject().next();
            }));
            if (syncResub) {
              innerSub.unsubscribe();
              innerSub = null;
              syncResub = false;
              subscribeForRepeatWhen();
            }
          };
          subscribeForRepeatWhen();
        });
      }
      exports.repeatWhen = repeatWhen;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/retry.js
  var require_retry = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/retry.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.retry = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var identity_1 = require_identity();
      var timer_1 = require_timer();
      var innerFrom_1 = require_innerFrom();
      function retry(configOrCount) {
        if (configOrCount === void 0) {
          configOrCount = Infinity;
        }
        var config2;
        if (configOrCount && typeof configOrCount === "object") {
          config2 = configOrCount;
        } else {
          config2 = {
            count: configOrCount
          };
        }
        var _a = config2.count, count3 = _a === void 0 ? Infinity : _a, delay = config2.delay, _b = config2.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
        return count3 <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
          var soFar = 0;
          var innerSub;
          var subscribeForRetry = function() {
            var syncUnsub = false;
            innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
              if (resetOnSuccess) {
                soFar = 0;
              }
              subscriber.next(value);
            }, void 0, function(err2) {
              if (soFar++ < count3) {
                var resub_1 = function() {
                  if (innerSub) {
                    innerSub.unsubscribe();
                    innerSub = null;
                    subscribeForRetry();
                  } else {
                    syncUnsub = true;
                  }
                };
                if (delay != null) {
                  var notifier = typeof delay === "number" ? timer_1.timer(delay) : innerFrom_1.innerFrom(delay(err2, soFar));
                  var notifierSubscriber_1 = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                    notifierSubscriber_1.unsubscribe();
                    resub_1();
                  }, function() {
                    subscriber.complete();
                  });
                  notifier.subscribe(notifierSubscriber_1);
                } else {
                  resub_1();
                }
              } else {
                subscriber.error(err2);
              }
            }));
            if (syncUnsub) {
              innerSub.unsubscribe();
              innerSub = null;
              subscribeForRetry();
            }
          };
          subscribeForRetry();
        });
      }
      exports.retry = retry;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js
  var require_retryWhen = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/retryWhen.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.retryWhen = void 0;
      var innerFrom_1 = require_innerFrom();
      var Subject_1 = require_Subject();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function retryWhen(notifier) {
        return lift_1.operate(function(source, subscriber) {
          var innerSub;
          var syncResub = false;
          var errors$;
          var subscribeForRetryWhen = function() {
            innerSub = source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, void 0, void 0, function(err2) {
              if (!errors$) {
                errors$ = new Subject_1.Subject();
                innerFrom_1.innerFrom(notifier(errors$)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
                  return innerSub ? subscribeForRetryWhen() : syncResub = true;
                }));
              }
              if (errors$) {
                errors$.next(err2);
              }
            }));
            if (syncResub) {
              innerSub.unsubscribe();
              innerSub = null;
              syncResub = false;
              subscribeForRetryWhen();
            }
          };
          subscribeForRetryWhen();
        });
      }
      exports.retryWhen = retryWhen;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/sample.js
  var require_sample = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/sample.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sample = void 0;
      var innerFrom_1 = require_innerFrom();
      var lift_1 = require_lift();
      var noop_1 = require_noop();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function sample(notifier) {
        return lift_1.operate(function(source, subscriber) {
          var hasValue = false;
          var lastValue = null;
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            hasValue = true;
            lastValue = value;
          }));
          innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            if (hasValue) {
              hasValue = false;
              var value = lastValue;
              lastValue = null;
              subscriber.next(value);
            }
          }, noop_1.noop));
        });
      }
      exports.sample = sample;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js
  var require_sampleTime = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/sampleTime.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sampleTime = void 0;
      var async_1 = require_async();
      var sample_1 = require_sample();
      var interval_1 = require_interval();
      function sampleTime(period, scheduler) {
        if (scheduler === void 0) {
          scheduler = async_1.asyncScheduler;
        }
        return sample_1.sample(interval_1.interval(period, scheduler));
      }
      exports.sampleTime = sampleTime;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/scan.js
  var require_scan = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/scan.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.scan = void 0;
      var lift_1 = require_lift();
      var scanInternals_1 = require_scanInternals();
      function scan(accumulator, seed) {
        return lift_1.operate(scanInternals_1.scanInternals(accumulator, seed, arguments.length >= 2, true));
      }
      exports.scan = scan;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js
  var require_sequenceEqual = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/sequenceEqual.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sequenceEqual = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var innerFrom_1 = require_innerFrom();
      function sequenceEqual(compareTo, comparator) {
        if (comparator === void 0) {
          comparator = function(a2, b2) {
            return a2 === b2;
          };
        }
        return lift_1.operate(function(source, subscriber) {
          var aState = createState();
          var bState = createState();
          var emit = function(isEqual) {
            subscriber.next(isEqual);
            subscriber.complete();
          };
          var createSubscriber = function(selfState, otherState) {
            var sequenceEqualSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(a2) {
              var buffer = otherState.buffer, complete = otherState.complete;
              if (buffer.length === 0) {
                complete ? emit(false) : selfState.buffer.push(a2);
              } else {
                !comparator(a2, buffer.shift()) && emit(false);
              }
            }, function() {
              selfState.complete = true;
              var complete = otherState.complete, buffer = otherState.buffer;
              complete && emit(buffer.length === 0);
              sequenceEqualSubscriber === null || sequenceEqualSubscriber === void 0 ? void 0 : sequenceEqualSubscriber.unsubscribe();
            });
            return sequenceEqualSubscriber;
          };
          source.subscribe(createSubscriber(aState, bState));
          innerFrom_1.innerFrom(compareTo).subscribe(createSubscriber(bState, aState));
        });
      }
      exports.sequenceEqual = sequenceEqual;
      function createState() {
        return {
          buffer: [],
          complete: false
        };
      }
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/share.js
  var require_share = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/share.js"(exports) {
      "use strict";
      var __read2 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2) return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
          } finally {
            if (e2) throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
        for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from2[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.share = void 0;
      var innerFrom_1 = require_innerFrom();
      var Subject_1 = require_Subject();
      var Subscriber_1 = require_Subscriber();
      var lift_1 = require_lift();
      function share(options) {
        if (options === void 0) {
          options = {};
        }
        var _a = options.connector, connector = _a === void 0 ? function() {
          return new Subject_1.Subject();
        } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
        return function(wrapperSource) {
          var connection;
          var resetConnection;
          var subject;
          var refCount = 0;
          var hasCompleted = false;
          var hasErrored = false;
          var cancelReset = function() {
            resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
            resetConnection = void 0;
          };
          var reset = function() {
            cancelReset();
            connection = subject = void 0;
            hasCompleted = hasErrored = false;
          };
          var resetAndUnsubscribe = function() {
            var conn = connection;
            reset();
            conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
          };
          return lift_1.operate(function(source, subscriber) {
            refCount++;
            if (!hasErrored && !hasCompleted) {
              cancelReset();
            }
            var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
            subscriber.add(function() {
              refCount--;
              if (refCount === 0 && !hasErrored && !hasCompleted) {
                resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
              }
            });
            dest.subscribe(subscriber);
            if (!connection && refCount > 0) {
              connection = new Subscriber_1.SafeSubscriber({
                next: function(value) {
                  return dest.next(value);
                },
                error: function(err2) {
                  hasErrored = true;
                  cancelReset();
                  resetConnection = handleReset(reset, resetOnError, err2);
                  dest.error(err2);
                },
                complete: function() {
                  hasCompleted = true;
                  cancelReset();
                  resetConnection = handleReset(reset, resetOnComplete);
                  dest.complete();
                }
              });
              innerFrom_1.innerFrom(source).subscribe(connection);
            }
          })(wrapperSource);
        };
      }
      exports.share = share;
      function handleReset(reset, on) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        if (on === true) {
          reset();
          return;
        }
        if (on === false) {
          return;
        }
        var onSubscriber = new Subscriber_1.SafeSubscriber({
          next: function() {
            onSubscriber.unsubscribe();
            reset();
          }
        });
        return innerFrom_1.innerFrom(on.apply(void 0, __spreadArray2([], __read2(args)))).subscribe(onSubscriber);
      }
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js
  var require_shareReplay = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/shareReplay.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.shareReplay = void 0;
      var ReplaySubject_1 = require_ReplaySubject();
      var share_1 = require_share();
      function shareReplay(configOrBufferSize, windowTime, scheduler) {
        var _a, _b, _c;
        var bufferSize;
        var refCount = false;
        if (configOrBufferSize && typeof configOrBufferSize === "object") {
          _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
        } else {
          bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
        }
        return share_1.share({
          connector: function() {
            return new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler);
          },
          resetOnError: true,
          resetOnComplete: false,
          resetOnRefCountZero: refCount
        });
      }
      exports.shareReplay = shareReplay;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/single.js
  var require_single = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/single.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.single = void 0;
      var EmptyError_1 = require_EmptyError();
      var SequenceError_1 = require_SequenceError();
      var NotFoundError_1 = require_NotFoundError();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function single(predicate) {
        return lift_1.operate(function(source, subscriber) {
          var hasValue = false;
          var singleValue;
          var seenValue = false;
          var index3 = 0;
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            seenValue = true;
            if (!predicate || predicate(value, index3++, source)) {
              hasValue && subscriber.error(new SequenceError_1.SequenceError("Too many matching values"));
              hasValue = true;
              singleValue = value;
            }
          }, function() {
            if (hasValue) {
              subscriber.next(singleValue);
              subscriber.complete();
            } else {
              subscriber.error(seenValue ? new NotFoundError_1.NotFoundError("No matching values") : new EmptyError_1.EmptyError());
            }
          }));
        });
      }
      exports.single = single;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/skip.js
  var require_skip = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/skip.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.skip = void 0;
      var filter_1 = require_filter();
      function skip(count3) {
        return filter_1.filter(function(_, index3) {
          return count3 <= index3;
        });
      }
      exports.skip = skip;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/skipLast.js
  var require_skipLast = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/skipLast.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.skipLast = void 0;
      var identity_1 = require_identity();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function skipLast(skipCount) {
        return skipCount <= 0 ? identity_1.identity : lift_1.operate(function(source, subscriber) {
          var ring = new Array(skipCount);
          var seen = 0;
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var valueIndex = seen++;
            if (valueIndex < skipCount) {
              ring[valueIndex] = value;
            } else {
              var index3 = valueIndex % skipCount;
              var oldValue = ring[index3];
              ring[index3] = value;
              subscriber.next(oldValue);
            }
          }));
          return function() {
            ring = null;
          };
        });
      }
      exports.skipLast = skipLast;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js
  var require_skipUntil = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/skipUntil.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.skipUntil = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var innerFrom_1 = require_innerFrom();
      var noop_1 = require_noop();
      function skipUntil(notifier) {
        return lift_1.operate(function(source, subscriber) {
          var taking = false;
          var skipSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            skipSubscriber === null || skipSubscriber === void 0 ? void 0 : skipSubscriber.unsubscribe();
            taking = true;
          }, noop_1.noop);
          innerFrom_1.innerFrom(notifier).subscribe(skipSubscriber);
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            return taking && subscriber.next(value);
          }));
        });
      }
      exports.skipUntil = skipUntil;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js
  var require_skipWhile = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/skipWhile.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.skipWhile = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function skipWhile(predicate) {
        return lift_1.operate(function(source, subscriber) {
          var taking = false;
          var index3 = 0;
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            return (taking || (taking = !predicate(value, index3++))) && subscriber.next(value);
          }));
        });
      }
      exports.skipWhile = skipWhile;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/startWith.js
  var require_startWith = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/startWith.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.startWith = void 0;
      var concat_1 = require_concat();
      var args_1 = require_args();
      var lift_1 = require_lift();
      function startWith() {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          values[_i] = arguments[_i];
        }
        var scheduler = args_1.popScheduler(values);
        return lift_1.operate(function(source, subscriber) {
          (scheduler ? concat_1.concat(values, source, scheduler) : concat_1.concat(values, source)).subscribe(subscriber);
        });
      }
      exports.startWith = startWith;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/switchMap.js
  var require_switchMap = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/switchMap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.switchMap = void 0;
      var innerFrom_1 = require_innerFrom();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function switchMap(project, resultSelector) {
        return lift_1.operate(function(source, subscriber) {
          var innerSubscriber = null;
          var index3 = 0;
          var isComplete = false;
          var checkComplete = function() {
            return isComplete && !innerSubscriber && subscriber.complete();
          };
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
            var innerIndex = 0;
            var outerIndex = index3++;
            innerFrom_1.innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(innerValue) {
              return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
            }, function() {
              innerSubscriber = null;
              checkComplete();
            }));
          }, function() {
            isComplete = true;
            checkComplete();
          }));
        });
      }
      exports.switchMap = switchMap;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/switchAll.js
  var require_switchAll = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/switchAll.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.switchAll = void 0;
      var switchMap_1 = require_switchMap();
      var identity_1 = require_identity();
      function switchAll() {
        return switchMap_1.switchMap(identity_1.identity);
      }
      exports.switchAll = switchAll;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js
  var require_switchMapTo = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/switchMapTo.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.switchMapTo = void 0;
      var switchMap_1 = require_switchMap();
      var isFunction_1 = require_isFunction();
      function switchMapTo(innerObservable, resultSelector) {
        return isFunction_1.isFunction(resultSelector) ? switchMap_1.switchMap(function() {
          return innerObservable;
        }, resultSelector) : switchMap_1.switchMap(function() {
          return innerObservable;
        });
      }
      exports.switchMapTo = switchMapTo;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/switchScan.js
  var require_switchScan = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/switchScan.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.switchScan = void 0;
      var switchMap_1 = require_switchMap();
      var lift_1 = require_lift();
      function switchScan(accumulator, seed) {
        return lift_1.operate(function(source, subscriber) {
          var state = seed;
          switchMap_1.switchMap(function(value, index3) {
            return accumulator(state, value, index3);
          }, function(_, innerValue) {
            return state = innerValue, innerValue;
          })(source).subscribe(subscriber);
          return function() {
            state = null;
          };
        });
      }
      exports.switchScan = switchScan;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js
  var require_takeUntil = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/takeUntil.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.takeUntil = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var innerFrom_1 = require_innerFrom();
      var noop_1 = require_noop();
      function takeUntil(notifier) {
        return lift_1.operate(function(source, subscriber) {
          innerFrom_1.innerFrom(notifier).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            return subscriber.complete();
          }, noop_1.noop));
          !subscriber.closed && source.subscribe(subscriber);
        });
      }
      exports.takeUntil = takeUntil;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js
  var require_takeWhile = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/takeWhile.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.takeWhile = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function takeWhile(predicate, inclusive) {
        if (inclusive === void 0) {
          inclusive = false;
        }
        return lift_1.operate(function(source, subscriber) {
          var index3 = 0;
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var result = predicate(value, index3++);
            (result || inclusive) && subscriber.next(value);
            !result && subscriber.complete();
          }));
        });
      }
      exports.takeWhile = takeWhile;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/tap.js
  var require_tap = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/tap.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.tap = void 0;
      var isFunction_1 = require_isFunction();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var identity_1 = require_identity();
      function tap(observerOrNext, error2, complete) {
        var tapObserver = isFunction_1.isFunction(observerOrNext) || error2 || complete ? { next: observerOrNext, error: error2, complete } : observerOrNext;
        return tapObserver ? lift_1.operate(function(source, subscriber) {
          var _a;
          (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
          var isUnsub = true;
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var _a2;
            (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
            subscriber.next(value);
          }, function() {
            var _a2;
            isUnsub = false;
            (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
            subscriber.complete();
          }, function(err2) {
            var _a2;
            isUnsub = false;
            (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err2);
            subscriber.error(err2);
          }, function() {
            var _a2, _b;
            if (isUnsub) {
              (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
            }
            (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
          }));
        }) : identity_1.identity;
      }
      exports.tap = tap;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/throttle.js
  var require_throttle = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/throttle.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.throttle = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var innerFrom_1 = require_innerFrom();
      function throttle(durationSelector, config2) {
        return lift_1.operate(function(source, subscriber) {
          var _a = config2 !== null && config2 !== void 0 ? config2 : {}, _b = _a.leading, leading = _b === void 0 ? true : _b, _c = _a.trailing, trailing = _c === void 0 ? false : _c;
          var hasValue = false;
          var sendValue = null;
          var throttled = null;
          var isComplete = false;
          var endThrottling = function() {
            throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
            throttled = null;
            if (trailing) {
              send();
              isComplete && subscriber.complete();
            }
          };
          var cleanupThrottling = function() {
            throttled = null;
            isComplete && subscriber.complete();
          };
          var startThrottle = function(value) {
            return throttled = innerFrom_1.innerFrom(durationSelector(value)).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
          };
          var send = function() {
            if (hasValue) {
              hasValue = false;
              var value = sendValue;
              sendValue = null;
              subscriber.next(value);
              !isComplete && startThrottle(value);
            }
          };
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            hasValue = true;
            sendValue = value;
            !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
          }, function() {
            isComplete = true;
            !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
          }));
        });
      }
      exports.throttle = throttle;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js
  var require_throttleTime = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/throttleTime.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.throttleTime = void 0;
      var async_1 = require_async();
      var throttle_1 = require_throttle();
      var timer_1 = require_timer();
      function throttleTime(duration, scheduler, config2) {
        if (scheduler === void 0) {
          scheduler = async_1.asyncScheduler;
        }
        var duration$ = timer_1.timer(duration, scheduler);
        return throttle_1.throttle(function() {
          return duration$;
        }, config2);
      }
      exports.throttleTime = throttleTime;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js
  var require_timeInterval = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/timeInterval.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TimeInterval = exports.timeInterval = void 0;
      var async_1 = require_async();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function timeInterval(scheduler) {
        if (scheduler === void 0) {
          scheduler = async_1.asyncScheduler;
        }
        return lift_1.operate(function(source, subscriber) {
          var last = scheduler.now();
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var now = scheduler.now();
            var interval = now - last;
            last = now;
            subscriber.next(new TimeInterval(value, interval));
          }));
        });
      }
      exports.timeInterval = timeInterval;
      var TimeInterval = /* @__PURE__ */ (function() {
        function TimeInterval2(value, interval) {
          this.value = value;
          this.interval = interval;
        }
        return TimeInterval2;
      })();
      exports.TimeInterval = TimeInterval;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js
  var require_timeoutWith = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/timeoutWith.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.timeoutWith = void 0;
      var async_1 = require_async();
      var isDate_1 = require_isDate();
      var timeout_1 = require_timeout();
      function timeoutWith(due, withObservable, scheduler) {
        var first;
        var each;
        var _with;
        scheduler = scheduler !== null && scheduler !== void 0 ? scheduler : async_1.async;
        if (isDate_1.isValidDate(due)) {
          first = due;
        } else if (typeof due === "number") {
          each = due;
        }
        if (withObservable) {
          _with = function() {
            return withObservable;
          };
        } else {
          throw new TypeError("No observable provided to switch to");
        }
        if (first == null && each == null) {
          throw new TypeError("No timeout provided.");
        }
        return timeout_1.timeout({
          first,
          each,
          scheduler,
          with: _with
        });
      }
      exports.timeoutWith = timeoutWith;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/timestamp.js
  var require_timestamp = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/timestamp.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.timestamp = void 0;
      var dateTimestampProvider_1 = require_dateTimestampProvider();
      var map_1 = require_map();
      function timestamp(timestampProvider) {
        if (timestampProvider === void 0) {
          timestampProvider = dateTimestampProvider_1.dateTimestampProvider;
        }
        return map_1.map(function(value) {
          return { value, timestamp: timestampProvider.now() };
        });
      }
      exports.timestamp = timestamp;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/window.js
  var require_window = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/window.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.window = void 0;
      var Subject_1 = require_Subject();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var noop_1 = require_noop();
      var innerFrom_1 = require_innerFrom();
      function window2(windowBoundaries) {
        return lift_1.operate(function(source, subscriber) {
          var windowSubject = new Subject_1.Subject();
          subscriber.next(windowSubject.asObservable());
          var errorHandler = function(err2) {
            windowSubject.error(err2);
            subscriber.error(err2);
          };
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            return windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.next(value);
          }, function() {
            windowSubject.complete();
            subscriber.complete();
          }, errorHandler));
          innerFrom_1.innerFrom(windowBoundaries).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function() {
            windowSubject.complete();
            subscriber.next(windowSubject = new Subject_1.Subject());
          }, noop_1.noop, errorHandler));
          return function() {
            windowSubject === null || windowSubject === void 0 ? void 0 : windowSubject.unsubscribe();
            windowSubject = null;
          };
        });
      }
      exports.window = window2;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/windowCount.js
  var require_windowCount = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/windowCount.js"(exports) {
      "use strict";
      var __values2 = exports && exports.__values || function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2) return m2.call(o2);
        if (o2 && typeof o2.length === "number") return {
          next: function() {
            if (o2 && i2 >= o2.length) o2 = void 0;
            return { value: o2 && o2[i2++], done: !o2 };
          }
        };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.windowCount = void 0;
      var Subject_1 = require_Subject();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      function windowCount(windowSize, startWindowEvery) {
        if (startWindowEvery === void 0) {
          startWindowEvery = 0;
        }
        var startEvery = startWindowEvery > 0 ? startWindowEvery : windowSize;
        return lift_1.operate(function(source, subscriber) {
          var windows = [new Subject_1.Subject()];
          var starts = [];
          var count3 = 0;
          subscriber.next(windows[0].asObservable());
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var e_1, _a;
            try {
              for (var windows_1 = __values2(windows), windows_1_1 = windows_1.next(); !windows_1_1.done; windows_1_1 = windows_1.next()) {
                var window_1 = windows_1_1.value;
                window_1.next(value);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (windows_1_1 && !windows_1_1.done && (_a = windows_1.return)) _a.call(windows_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
            var c2 = count3 - windowSize + 1;
            if (c2 >= 0 && c2 % startEvery === 0) {
              windows.shift().complete();
            }
            if (++count3 % startEvery === 0) {
              var window_2 = new Subject_1.Subject();
              windows.push(window_2);
              subscriber.next(window_2.asObservable());
            }
          }, function() {
            while (windows.length > 0) {
              windows.shift().complete();
            }
            subscriber.complete();
          }, function(err2) {
            while (windows.length > 0) {
              windows.shift().error(err2);
            }
            subscriber.error(err2);
          }, function() {
            starts = null;
            windows = null;
          }));
        });
      }
      exports.windowCount = windowCount;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/windowTime.js
  var require_windowTime = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/windowTime.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.windowTime = void 0;
      var Subject_1 = require_Subject();
      var async_1 = require_async();
      var Subscription_1 = require_Subscription();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var arrRemove_1 = require_arrRemove();
      var args_1 = require_args();
      var executeSchedule_1 = require_executeSchedule();
      function windowTime(windowTimeSpan) {
        var _a, _b;
        var otherArgs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          otherArgs[_i - 1] = arguments[_i];
        }
        var scheduler = (_a = args_1.popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : async_1.asyncScheduler;
        var windowCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
        var maxWindowSize = otherArgs[1] || Infinity;
        return lift_1.operate(function(source, subscriber) {
          var windowRecords = [];
          var restartOnClose = false;
          var closeWindow = function(record) {
            var window2 = record.window, subs = record.subs;
            window2.complete();
            subs.unsubscribe();
            arrRemove_1.arrRemove(windowRecords, record);
            restartOnClose && startWindow();
          };
          var startWindow = function() {
            if (windowRecords) {
              var subs = new Subscription_1.Subscription();
              subscriber.add(subs);
              var window_1 = new Subject_1.Subject();
              var record_1 = {
                window: window_1,
                subs,
                seen: 0
              };
              windowRecords.push(record_1);
              subscriber.next(window_1.asObservable());
              executeSchedule_1.executeSchedule(subs, scheduler, function() {
                return closeWindow(record_1);
              }, windowTimeSpan);
            }
          };
          if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            executeSchedule_1.executeSchedule(subscriber, scheduler, startWindow, windowCreationInterval, true);
          } else {
            restartOnClose = true;
          }
          startWindow();
          var loop = function(cb) {
            return windowRecords.slice().forEach(cb);
          };
          var terminate = function(cb) {
            loop(function(_a2) {
              var window2 = _a2.window;
              return cb(window2);
            });
            cb(subscriber);
            subscriber.unsubscribe();
          };
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            loop(function(record) {
              record.window.next(value);
              maxWindowSize <= ++record.seen && closeWindow(record);
            });
          }, function() {
            return terminate(function(consumer) {
              return consumer.complete();
            });
          }, function(err2) {
            return terminate(function(consumer) {
              return consumer.error(err2);
            });
          }));
          return function() {
            windowRecords = null;
          };
        });
      }
      exports.windowTime = windowTime;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js
  var require_windowToggle = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/windowToggle.js"(exports) {
      "use strict";
      var __values2 = exports && exports.__values || function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2) return m2.call(o2);
        if (o2 && typeof o2.length === "number") return {
          next: function() {
            if (o2 && i2 >= o2.length) o2 = void 0;
            return { value: o2 && o2[i2++], done: !o2 };
          }
        };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.windowToggle = void 0;
      var Subject_1 = require_Subject();
      var Subscription_1 = require_Subscription();
      var lift_1 = require_lift();
      var innerFrom_1 = require_innerFrom();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var noop_1 = require_noop();
      var arrRemove_1 = require_arrRemove();
      function windowToggle(openings, closingSelector) {
        return lift_1.operate(function(source, subscriber) {
          var windows = [];
          var handleError = function(err2) {
            while (0 < windows.length) {
              windows.shift().error(err2);
            }
            subscriber.error(err2);
          };
          innerFrom_1.innerFrom(openings).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(openValue) {
            var window2 = new Subject_1.Subject();
            windows.push(window2);
            var closingSubscription = new Subscription_1.Subscription();
            var closeWindow = function() {
              arrRemove_1.arrRemove(windows, window2);
              window2.complete();
              closingSubscription.unsubscribe();
            };
            var closingNotifier;
            try {
              closingNotifier = innerFrom_1.innerFrom(closingSelector(openValue));
            } catch (err2) {
              handleError(err2);
              return;
            }
            subscriber.next(window2.asObservable());
            closingSubscription.add(closingNotifier.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, closeWindow, noop_1.noop, handleError)));
          }, noop_1.noop));
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            var e_1, _a;
            var windowsCopy = windows.slice();
            try {
              for (var windowsCopy_1 = __values2(windowsCopy), windowsCopy_1_1 = windowsCopy_1.next(); !windowsCopy_1_1.done; windowsCopy_1_1 = windowsCopy_1.next()) {
                var window_1 = windowsCopy_1_1.value;
                window_1.next(value);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (windowsCopy_1_1 && !windowsCopy_1_1.done && (_a = windowsCopy_1.return)) _a.call(windowsCopy_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          }, function() {
            while (0 < windows.length) {
              windows.shift().complete();
            }
            subscriber.complete();
          }, handleError, function() {
            while (0 < windows.length) {
              windows.shift().unsubscribe();
            }
          }));
        });
      }
      exports.windowToggle = windowToggle;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js
  var require_windowWhen = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/windowWhen.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.windowWhen = void 0;
      var Subject_1 = require_Subject();
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var innerFrom_1 = require_innerFrom();
      function windowWhen(closingSelector) {
        return lift_1.operate(function(source, subscriber) {
          var window2;
          var closingSubscriber;
          var handleError = function(err2) {
            window2.error(err2);
            subscriber.error(err2);
          };
          var openWindow = function() {
            closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
            window2 === null || window2 === void 0 ? void 0 : window2.complete();
            window2 = new Subject_1.Subject();
            subscriber.next(window2.asObservable());
            var closingNotifier;
            try {
              closingNotifier = innerFrom_1.innerFrom(closingSelector());
            } catch (err2) {
              handleError(err2);
              return;
            }
            closingNotifier.subscribe(closingSubscriber = OperatorSubscriber_1.createOperatorSubscriber(subscriber, openWindow, openWindow, handleError));
          };
          openWindow();
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            return window2.next(value);
          }, function() {
            window2.complete();
            subscriber.complete();
          }, handleError, function() {
            closingSubscriber === null || closingSubscriber === void 0 ? void 0 : closingSubscriber.unsubscribe();
            window2 = null;
          }));
        });
      }
      exports.windowWhen = windowWhen;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js
  var require_withLatestFrom = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/withLatestFrom.js"(exports) {
      "use strict";
      var __read2 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2) return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
          } finally {
            if (e2) throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
        for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from2[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.withLatestFrom = void 0;
      var lift_1 = require_lift();
      var OperatorSubscriber_1 = require_OperatorSubscriber();
      var innerFrom_1 = require_innerFrom();
      var identity_1 = require_identity();
      var noop_1 = require_noop();
      var args_1 = require_args();
      function withLatestFrom() {
        var inputs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          inputs[_i] = arguments[_i];
        }
        var project = args_1.popResultSelector(inputs);
        return lift_1.operate(function(source, subscriber) {
          var len2 = inputs.length;
          var otherValues = new Array(len2);
          var hasValue = inputs.map(function() {
            return false;
          });
          var ready = false;
          var _loop_1 = function(i3) {
            innerFrom_1.innerFrom(inputs[i3]).subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
              otherValues[i3] = value;
              if (!ready && !hasValue[i3]) {
                hasValue[i3] = true;
                (ready = hasValue.every(identity_1.identity)) && (hasValue = null);
              }
            }, noop_1.noop));
          };
          for (var i2 = 0; i2 < len2; i2++) {
            _loop_1(i2);
          }
          source.subscribe(OperatorSubscriber_1.createOperatorSubscriber(subscriber, function(value) {
            if (ready) {
              var values = __spreadArray2([value], __read2(otherValues));
              subscriber.next(project ? project.apply(void 0, __spreadArray2([], __read2(values))) : values);
            }
          }));
        });
      }
      exports.withLatestFrom = withLatestFrom;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/zipAll.js
  var require_zipAll = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/zipAll.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.zipAll = void 0;
      var zip_1 = require_zip();
      var joinAllInternals_1 = require_joinAllInternals();
      function zipAll(project) {
        return joinAllInternals_1.joinAllInternals(zip_1.zip, project);
      }
      exports.zipAll = zipAll;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/zip.js
  var require_zip2 = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/zip.js"(exports) {
      "use strict";
      var __read2 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2) return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
          } finally {
            if (e2) throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
        for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from2[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.zip = void 0;
      var zip_1 = require_zip();
      var lift_1 = require_lift();
      function zip() {
        var sources = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          sources[_i] = arguments[_i];
        }
        return lift_1.operate(function(source, subscriber) {
          zip_1.zip.apply(void 0, __spreadArray2([source], __read2(sources))).subscribe(subscriber);
        });
      }
      exports.zip = zip;
    }
  });

  // node_modules/rxjs/dist/cjs/internal/operators/zipWith.js
  var require_zipWith = __commonJS({
    "node_modules/rxjs/dist/cjs/internal/operators/zipWith.js"(exports) {
      "use strict";
      var __read2 = exports && exports.__read || function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2) return o2;
        var i2 = m2.call(o2), r2, ar = [], e2;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
        } catch (error2) {
          e2 = { error: error2 };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
          } finally {
            if (e2) throw e2.error;
          }
        }
        return ar;
      };
      var __spreadArray2 = exports && exports.__spreadArray || function(to, from2) {
        for (var i2 = 0, il = from2.length, j2 = to.length; i2 < il; i2++, j2++)
          to[j2] = from2[i2];
        return to;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.zipWith = void 0;
      var zip_1 = require_zip2();
      function zipWith() {
        var otherInputs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          otherInputs[_i] = arguments[_i];
        }
        return zip_1.zip.apply(void 0, __spreadArray2([], __read2(otherInputs)));
      }
      exports.zipWith = zipWith;
    }
  });

  // node_modules/rxjs/dist/cjs/index.js
  var require_cjs = __commonJS({
    "node_modules/rxjs/dist/cjs/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o2, m2, k2, k22) {
        if (k22 === void 0) k22 = k2;
        Object.defineProperty(o2, k22, { enumerable: true, get: function() {
          return m2[k2];
        } });
      }) : (function(o2, m2, k2, k22) {
        if (k22 === void 0) k22 = k2;
        o2[k22] = m2[k2];
      }));
      var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
        for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.interval = exports.iif = exports.generate = exports.fromEventPattern = exports.fromEvent = exports.from = exports.forkJoin = exports.empty = exports.defer = exports.connectable = exports.concat = exports.combineLatest = exports.bindNodeCallback = exports.bindCallback = exports.UnsubscriptionError = exports.TimeoutError = exports.SequenceError = exports.ObjectUnsubscribedError = exports.NotFoundError = exports.EmptyError = exports.ArgumentOutOfRangeError = exports.firstValueFrom = exports.lastValueFrom = exports.isObservable = exports.identity = exports.noop = exports.pipe = exports.NotificationKind = exports.Notification = exports.Subscriber = exports.Subscription = exports.Scheduler = exports.VirtualAction = exports.VirtualTimeScheduler = exports.animationFrameScheduler = exports.animationFrame = exports.queueScheduler = exports.queue = exports.asyncScheduler = exports.async = exports.asapScheduler = exports.asap = exports.AsyncSubject = exports.ReplaySubject = exports.BehaviorSubject = exports.Subject = exports.animationFrames = exports.observable = exports.ConnectableObservable = exports.Observable = void 0;
      exports.filter = exports.expand = exports.exhaustMap = exports.exhaustAll = exports.exhaust = exports.every = exports.endWith = exports.elementAt = exports.distinctUntilKeyChanged = exports.distinctUntilChanged = exports.distinct = exports.dematerialize = exports.delayWhen = exports.delay = exports.defaultIfEmpty = exports.debounceTime = exports.debounce = exports.count = exports.connect = exports.concatWith = exports.concatMapTo = exports.concatMap = exports.concatAll = exports.combineLatestWith = exports.combineLatestAll = exports.combineAll = exports.catchError = exports.bufferWhen = exports.bufferToggle = exports.bufferTime = exports.bufferCount = exports.buffer = exports.auditTime = exports.audit = exports.config = exports.NEVER = exports.EMPTY = exports.scheduled = exports.zip = exports.using = exports.timer = exports.throwError = exports.range = exports.race = exports.partition = exports.pairs = exports.onErrorResumeNext = exports.of = exports.never = exports.merge = void 0;
      exports.switchMap = exports.switchAll = exports.subscribeOn = exports.startWith = exports.skipWhile = exports.skipUntil = exports.skipLast = exports.skip = exports.single = exports.shareReplay = exports.share = exports.sequenceEqual = exports.scan = exports.sampleTime = exports.sample = exports.refCount = exports.retryWhen = exports.retry = exports.repeatWhen = exports.repeat = exports.reduce = exports.raceWith = exports.publishReplay = exports.publishLast = exports.publishBehavior = exports.publish = exports.pluck = exports.pairwise = exports.onErrorResumeNextWith = exports.observeOn = exports.multicast = exports.min = exports.mergeWith = exports.mergeScan = exports.mergeMapTo = exports.mergeMap = exports.flatMap = exports.mergeAll = exports.max = exports.materialize = exports.mapTo = exports.map = exports.last = exports.isEmpty = exports.ignoreElements = exports.groupBy = exports.first = exports.findIndex = exports.find = exports.finalize = void 0;
      exports.zipWith = exports.zipAll = exports.withLatestFrom = exports.windowWhen = exports.windowToggle = exports.windowTime = exports.windowCount = exports.window = exports.toArray = exports.timestamp = exports.timeoutWith = exports.timeout = exports.timeInterval = exports.throwIfEmpty = exports.throttleTime = exports.throttle = exports.tap = exports.takeWhile = exports.takeUntil = exports.takeLast = exports.take = exports.switchScan = exports.switchMapTo = void 0;
      var Observable_1 = require_Observable();
      Object.defineProperty(exports, "Observable", { enumerable: true, get: function() {
        return Observable_1.Observable;
      } });
      var ConnectableObservable_1 = require_ConnectableObservable();
      Object.defineProperty(exports, "ConnectableObservable", { enumerable: true, get: function() {
        return ConnectableObservable_1.ConnectableObservable;
      } });
      var observable_1 = require_observable();
      Object.defineProperty(exports, "observable", { enumerable: true, get: function() {
        return observable_1.observable;
      } });
      var animationFrames_1 = require_animationFrames();
      Object.defineProperty(exports, "animationFrames", { enumerable: true, get: function() {
        return animationFrames_1.animationFrames;
      } });
      var Subject_1 = require_Subject();
      Object.defineProperty(exports, "Subject", { enumerable: true, get: function() {
        return Subject_1.Subject;
      } });
      var BehaviorSubject_1 = require_BehaviorSubject();
      Object.defineProperty(exports, "BehaviorSubject", { enumerable: true, get: function() {
        return BehaviorSubject_1.BehaviorSubject;
      } });
      var ReplaySubject_1 = require_ReplaySubject();
      Object.defineProperty(exports, "ReplaySubject", { enumerable: true, get: function() {
        return ReplaySubject_1.ReplaySubject;
      } });
      var AsyncSubject_1 = require_AsyncSubject();
      Object.defineProperty(exports, "AsyncSubject", { enumerable: true, get: function() {
        return AsyncSubject_1.AsyncSubject;
      } });
      var asap_1 = require_asap();
      Object.defineProperty(exports, "asap", { enumerable: true, get: function() {
        return asap_1.asap;
      } });
      Object.defineProperty(exports, "asapScheduler", { enumerable: true, get: function() {
        return asap_1.asapScheduler;
      } });
      var async_1 = require_async();
      Object.defineProperty(exports, "async", { enumerable: true, get: function() {
        return async_1.async;
      } });
      Object.defineProperty(exports, "asyncScheduler", { enumerable: true, get: function() {
        return async_1.asyncScheduler;
      } });
      var queue_1 = require_queue();
      Object.defineProperty(exports, "queue", { enumerable: true, get: function() {
        return queue_1.queue;
      } });
      Object.defineProperty(exports, "queueScheduler", { enumerable: true, get: function() {
        return queue_1.queueScheduler;
      } });
      var animationFrame_1 = require_animationFrame();
      Object.defineProperty(exports, "animationFrame", { enumerable: true, get: function() {
        return animationFrame_1.animationFrame;
      } });
      Object.defineProperty(exports, "animationFrameScheduler", { enumerable: true, get: function() {
        return animationFrame_1.animationFrameScheduler;
      } });
      var VirtualTimeScheduler_1 = require_VirtualTimeScheduler();
      Object.defineProperty(exports, "VirtualTimeScheduler", { enumerable: true, get: function() {
        return VirtualTimeScheduler_1.VirtualTimeScheduler;
      } });
      Object.defineProperty(exports, "VirtualAction", { enumerable: true, get: function() {
        return VirtualTimeScheduler_1.VirtualAction;
      } });
      var Scheduler_1 = require_Scheduler();
      Object.defineProperty(exports, "Scheduler", { enumerable: true, get: function() {
        return Scheduler_1.Scheduler;
      } });
      var Subscription_1 = require_Subscription();
      Object.defineProperty(exports, "Subscription", { enumerable: true, get: function() {
        return Subscription_1.Subscription;
      } });
      var Subscriber_1 = require_Subscriber();
      Object.defineProperty(exports, "Subscriber", { enumerable: true, get: function() {
        return Subscriber_1.Subscriber;
      } });
      var Notification_1 = require_Notification();
      Object.defineProperty(exports, "Notification", { enumerable: true, get: function() {
        return Notification_1.Notification;
      } });
      Object.defineProperty(exports, "NotificationKind", { enumerable: true, get: function() {
        return Notification_1.NotificationKind;
      } });
      var pipe_1 = require_pipe();
      Object.defineProperty(exports, "pipe", { enumerable: true, get: function() {
        return pipe_1.pipe;
      } });
      var noop_1 = require_noop();
      Object.defineProperty(exports, "noop", { enumerable: true, get: function() {
        return noop_1.noop;
      } });
      var identity_1 = require_identity();
      Object.defineProperty(exports, "identity", { enumerable: true, get: function() {
        return identity_1.identity;
      } });
      var isObservable_1 = require_isObservable();
      Object.defineProperty(exports, "isObservable", { enumerable: true, get: function() {
        return isObservable_1.isObservable;
      } });
      var lastValueFrom_1 = require_lastValueFrom();
      Object.defineProperty(exports, "lastValueFrom", { enumerable: true, get: function() {
        return lastValueFrom_1.lastValueFrom;
      } });
      var firstValueFrom_1 = require_firstValueFrom();
      Object.defineProperty(exports, "firstValueFrom", { enumerable: true, get: function() {
        return firstValueFrom_1.firstValueFrom;
      } });
      var ArgumentOutOfRangeError_1 = require_ArgumentOutOfRangeError();
      Object.defineProperty(exports, "ArgumentOutOfRangeError", { enumerable: true, get: function() {
        return ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
      } });
      var EmptyError_1 = require_EmptyError();
      Object.defineProperty(exports, "EmptyError", { enumerable: true, get: function() {
        return EmptyError_1.EmptyError;
      } });
      var NotFoundError_1 = require_NotFoundError();
      Object.defineProperty(exports, "NotFoundError", { enumerable: true, get: function() {
        return NotFoundError_1.NotFoundError;
      } });
      var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
      Object.defineProperty(exports, "ObjectUnsubscribedError", { enumerable: true, get: function() {
        return ObjectUnsubscribedError_1.ObjectUnsubscribedError;
      } });
      var SequenceError_1 = require_SequenceError();
      Object.defineProperty(exports, "SequenceError", { enumerable: true, get: function() {
        return SequenceError_1.SequenceError;
      } });
      var timeout_1 = require_timeout();
      Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
        return timeout_1.TimeoutError;
      } });
      var UnsubscriptionError_1 = require_UnsubscriptionError();
      Object.defineProperty(exports, "UnsubscriptionError", { enumerable: true, get: function() {
        return UnsubscriptionError_1.UnsubscriptionError;
      } });
      var bindCallback_1 = require_bindCallback();
      Object.defineProperty(exports, "bindCallback", { enumerable: true, get: function() {
        return bindCallback_1.bindCallback;
      } });
      var bindNodeCallback_1 = require_bindNodeCallback();
      Object.defineProperty(exports, "bindNodeCallback", { enumerable: true, get: function() {
        return bindNodeCallback_1.bindNodeCallback;
      } });
      var combineLatest_1 = require_combineLatest();
      Object.defineProperty(exports, "combineLatest", { enumerable: true, get: function() {
        return combineLatest_1.combineLatest;
      } });
      var concat_1 = require_concat();
      Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
        return concat_1.concat;
      } });
      var connectable_1 = require_connectable();
      Object.defineProperty(exports, "connectable", { enumerable: true, get: function() {
        return connectable_1.connectable;
      } });
      var defer_1 = require_defer();
      Object.defineProperty(exports, "defer", { enumerable: true, get: function() {
        return defer_1.defer;
      } });
      var empty_1 = require_empty();
      Object.defineProperty(exports, "empty", { enumerable: true, get: function() {
        return empty_1.empty;
      } });
      var forkJoin_1 = require_forkJoin();
      Object.defineProperty(exports, "forkJoin", { enumerable: true, get: function() {
        return forkJoin_1.forkJoin;
      } });
      var from_1 = require_from();
      Object.defineProperty(exports, "from", { enumerable: true, get: function() {
        return from_1.from;
      } });
      var fromEvent_1 = require_fromEvent();
      Object.defineProperty(exports, "fromEvent", { enumerable: true, get: function() {
        return fromEvent_1.fromEvent;
      } });
      var fromEventPattern_1 = require_fromEventPattern();
      Object.defineProperty(exports, "fromEventPattern", { enumerable: true, get: function() {
        return fromEventPattern_1.fromEventPattern;
      } });
      var generate_1 = require_generate();
      Object.defineProperty(exports, "generate", { enumerable: true, get: function() {
        return generate_1.generate;
      } });
      var iif_1 = require_iif();
      Object.defineProperty(exports, "iif", { enumerable: true, get: function() {
        return iif_1.iif;
      } });
      var interval_1 = require_interval();
      Object.defineProperty(exports, "interval", { enumerable: true, get: function() {
        return interval_1.interval;
      } });
      var merge_1 = require_merge();
      Object.defineProperty(exports, "merge", { enumerable: true, get: function() {
        return merge_1.merge;
      } });
      var never_1 = require_never();
      Object.defineProperty(exports, "never", { enumerable: true, get: function() {
        return never_1.never;
      } });
      var of_1 = require_of();
      Object.defineProperty(exports, "of", { enumerable: true, get: function() {
        return of_1.of;
      } });
      var onErrorResumeNext_1 = require_onErrorResumeNext();
      Object.defineProperty(exports, "onErrorResumeNext", { enumerable: true, get: function() {
        return onErrorResumeNext_1.onErrorResumeNext;
      } });
      var pairs_1 = require_pairs();
      Object.defineProperty(exports, "pairs", { enumerable: true, get: function() {
        return pairs_1.pairs;
      } });
      var partition_1 = require_partition();
      Object.defineProperty(exports, "partition", { enumerable: true, get: function() {
        return partition_1.partition;
      } });
      var race_1 = require_race();
      Object.defineProperty(exports, "race", { enumerable: true, get: function() {
        return race_1.race;
      } });
      var range_1 = require_range2();
      Object.defineProperty(exports, "range", { enumerable: true, get: function() {
        return range_1.range;
      } });
      var throwError_1 = require_throwError();
      Object.defineProperty(exports, "throwError", { enumerable: true, get: function() {
        return throwError_1.throwError;
      } });
      var timer_1 = require_timer();
      Object.defineProperty(exports, "timer", { enumerable: true, get: function() {
        return timer_1.timer;
      } });
      var using_1 = require_using();
      Object.defineProperty(exports, "using", { enumerable: true, get: function() {
        return using_1.using;
      } });
      var zip_1 = require_zip();
      Object.defineProperty(exports, "zip", { enumerable: true, get: function() {
        return zip_1.zip;
      } });
      var scheduled_1 = require_scheduled();
      Object.defineProperty(exports, "scheduled", { enumerable: true, get: function() {
        return scheduled_1.scheduled;
      } });
      var empty_2 = require_empty();
      Object.defineProperty(exports, "EMPTY", { enumerable: true, get: function() {
        return empty_2.EMPTY;
      } });
      var never_2 = require_never();
      Object.defineProperty(exports, "NEVER", { enumerable: true, get: function() {
        return never_2.NEVER;
      } });
      __exportStar(require_types2(), exports);
      var config_1 = require_config();
      Object.defineProperty(exports, "config", { enumerable: true, get: function() {
        return config_1.config;
      } });
      var audit_1 = require_audit();
      Object.defineProperty(exports, "audit", { enumerable: true, get: function() {
        return audit_1.audit;
      } });
      var auditTime_1 = require_auditTime();
      Object.defineProperty(exports, "auditTime", { enumerable: true, get: function() {
        return auditTime_1.auditTime;
      } });
      var buffer_1 = require_buffer();
      Object.defineProperty(exports, "buffer", { enumerable: true, get: function() {
        return buffer_1.buffer;
      } });
      var bufferCount_1 = require_bufferCount();
      Object.defineProperty(exports, "bufferCount", { enumerable: true, get: function() {
        return bufferCount_1.bufferCount;
      } });
      var bufferTime_1 = require_bufferTime();
      Object.defineProperty(exports, "bufferTime", { enumerable: true, get: function() {
        return bufferTime_1.bufferTime;
      } });
      var bufferToggle_1 = require_bufferToggle();
      Object.defineProperty(exports, "bufferToggle", { enumerable: true, get: function() {
        return bufferToggle_1.bufferToggle;
      } });
      var bufferWhen_1 = require_bufferWhen();
      Object.defineProperty(exports, "bufferWhen", { enumerable: true, get: function() {
        return bufferWhen_1.bufferWhen;
      } });
      var catchError_1 = require_catchError();
      Object.defineProperty(exports, "catchError", { enumerable: true, get: function() {
        return catchError_1.catchError;
      } });
      var combineAll_1 = require_combineAll();
      Object.defineProperty(exports, "combineAll", { enumerable: true, get: function() {
        return combineAll_1.combineAll;
      } });
      var combineLatestAll_1 = require_combineLatestAll();
      Object.defineProperty(exports, "combineLatestAll", { enumerable: true, get: function() {
        return combineLatestAll_1.combineLatestAll;
      } });
      var combineLatestWith_1 = require_combineLatestWith();
      Object.defineProperty(exports, "combineLatestWith", { enumerable: true, get: function() {
        return combineLatestWith_1.combineLatestWith;
      } });
      var concatAll_1 = require_concatAll();
      Object.defineProperty(exports, "concatAll", { enumerable: true, get: function() {
        return concatAll_1.concatAll;
      } });
      var concatMap_1 = require_concatMap();
      Object.defineProperty(exports, "concatMap", { enumerable: true, get: function() {
        return concatMap_1.concatMap;
      } });
      var concatMapTo_1 = require_concatMapTo();
      Object.defineProperty(exports, "concatMapTo", { enumerable: true, get: function() {
        return concatMapTo_1.concatMapTo;
      } });
      var concatWith_1 = require_concatWith();
      Object.defineProperty(exports, "concatWith", { enumerable: true, get: function() {
        return concatWith_1.concatWith;
      } });
      var connect_1 = require_connect();
      Object.defineProperty(exports, "connect", { enumerable: true, get: function() {
        return connect_1.connect;
      } });
      var count_1 = require_count();
      Object.defineProperty(exports, "count", { enumerable: true, get: function() {
        return count_1.count;
      } });
      var debounce_1 = require_debounce();
      Object.defineProperty(exports, "debounce", { enumerable: true, get: function() {
        return debounce_1.debounce;
      } });
      var debounceTime_1 = require_debounceTime();
      Object.defineProperty(exports, "debounceTime", { enumerable: true, get: function() {
        return debounceTime_1.debounceTime;
      } });
      var defaultIfEmpty_1 = require_defaultIfEmpty();
      Object.defineProperty(exports, "defaultIfEmpty", { enumerable: true, get: function() {
        return defaultIfEmpty_1.defaultIfEmpty;
      } });
      var delay_1 = require_delay();
      Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
        return delay_1.delay;
      } });
      var delayWhen_1 = require_delayWhen();
      Object.defineProperty(exports, "delayWhen", { enumerable: true, get: function() {
        return delayWhen_1.delayWhen;
      } });
      var dematerialize_1 = require_dematerialize();
      Object.defineProperty(exports, "dematerialize", { enumerable: true, get: function() {
        return dematerialize_1.dematerialize;
      } });
      var distinct_1 = require_distinct();
      Object.defineProperty(exports, "distinct", { enumerable: true, get: function() {
        return distinct_1.distinct;
      } });
      var distinctUntilChanged_1 = require_distinctUntilChanged();
      Object.defineProperty(exports, "distinctUntilChanged", { enumerable: true, get: function() {
        return distinctUntilChanged_1.distinctUntilChanged;
      } });
      var distinctUntilKeyChanged_1 = require_distinctUntilKeyChanged();
      Object.defineProperty(exports, "distinctUntilKeyChanged", { enumerable: true, get: function() {
        return distinctUntilKeyChanged_1.distinctUntilKeyChanged;
      } });
      var elementAt_1 = require_elementAt();
      Object.defineProperty(exports, "elementAt", { enumerable: true, get: function() {
        return elementAt_1.elementAt;
      } });
      var endWith_1 = require_endWith();
      Object.defineProperty(exports, "endWith", { enumerable: true, get: function() {
        return endWith_1.endWith;
      } });
      var every_1 = require_every();
      Object.defineProperty(exports, "every", { enumerable: true, get: function() {
        return every_1.every;
      } });
      var exhaust_1 = require_exhaust();
      Object.defineProperty(exports, "exhaust", { enumerable: true, get: function() {
        return exhaust_1.exhaust;
      } });
      var exhaustAll_1 = require_exhaustAll();
      Object.defineProperty(exports, "exhaustAll", { enumerable: true, get: function() {
        return exhaustAll_1.exhaustAll;
      } });
      var exhaustMap_1 = require_exhaustMap();
      Object.defineProperty(exports, "exhaustMap", { enumerable: true, get: function() {
        return exhaustMap_1.exhaustMap;
      } });
      var expand_1 = require_expand();
      Object.defineProperty(exports, "expand", { enumerable: true, get: function() {
        return expand_1.expand;
      } });
      var filter_1 = require_filter();
      Object.defineProperty(exports, "filter", { enumerable: true, get: function() {
        return filter_1.filter;
      } });
      var finalize_1 = require_finalize();
      Object.defineProperty(exports, "finalize", { enumerable: true, get: function() {
        return finalize_1.finalize;
      } });
      var find_1 = require_find();
      Object.defineProperty(exports, "find", { enumerable: true, get: function() {
        return find_1.find;
      } });
      var findIndex_1 = require_findIndex();
      Object.defineProperty(exports, "findIndex", { enumerable: true, get: function() {
        return findIndex_1.findIndex;
      } });
      var first_1 = require_first();
      Object.defineProperty(exports, "first", { enumerable: true, get: function() {
        return first_1.first;
      } });
      var groupBy_1 = require_groupBy();
      Object.defineProperty(exports, "groupBy", { enumerable: true, get: function() {
        return groupBy_1.groupBy;
      } });
      var ignoreElements_1 = require_ignoreElements();
      Object.defineProperty(exports, "ignoreElements", { enumerable: true, get: function() {
        return ignoreElements_1.ignoreElements;
      } });
      var isEmpty_1 = require_isEmpty();
      Object.defineProperty(exports, "isEmpty", { enumerable: true, get: function() {
        return isEmpty_1.isEmpty;
      } });
      var last_1 = require_last();
      Object.defineProperty(exports, "last", { enumerable: true, get: function() {
        return last_1.last;
      } });
      var map_1 = require_map();
      Object.defineProperty(exports, "map", { enumerable: true, get: function() {
        return map_1.map;
      } });
      var mapTo_1 = require_mapTo();
      Object.defineProperty(exports, "mapTo", { enumerable: true, get: function() {
        return mapTo_1.mapTo;
      } });
      var materialize_1 = require_materialize();
      Object.defineProperty(exports, "materialize", { enumerable: true, get: function() {
        return materialize_1.materialize;
      } });
      var max_1 = require_max();
      Object.defineProperty(exports, "max", { enumerable: true, get: function() {
        return max_1.max;
      } });
      var mergeAll_1 = require_mergeAll();
      Object.defineProperty(exports, "mergeAll", { enumerable: true, get: function() {
        return mergeAll_1.mergeAll;
      } });
      var flatMap_1 = require_flatMap();
      Object.defineProperty(exports, "flatMap", { enumerable: true, get: function() {
        return flatMap_1.flatMap;
      } });
      var mergeMap_1 = require_mergeMap();
      Object.defineProperty(exports, "mergeMap", { enumerable: true, get: function() {
        return mergeMap_1.mergeMap;
      } });
      var mergeMapTo_1 = require_mergeMapTo();
      Object.defineProperty(exports, "mergeMapTo", { enumerable: true, get: function() {
        return mergeMapTo_1.mergeMapTo;
      } });
      var mergeScan_1 = require_mergeScan();
      Object.defineProperty(exports, "mergeScan", { enumerable: true, get: function() {
        return mergeScan_1.mergeScan;
      } });
      var mergeWith_1 = require_mergeWith();
      Object.defineProperty(exports, "mergeWith", { enumerable: true, get: function() {
        return mergeWith_1.mergeWith;
      } });
      var min_1 = require_min();
      Object.defineProperty(exports, "min", { enumerable: true, get: function() {
        return min_1.min;
      } });
      var multicast_1 = require_multicast();
      Object.defineProperty(exports, "multicast", { enumerable: true, get: function() {
        return multicast_1.multicast;
      } });
      var observeOn_1 = require_observeOn();
      Object.defineProperty(exports, "observeOn", { enumerable: true, get: function() {
        return observeOn_1.observeOn;
      } });
      var onErrorResumeNextWith_1 = require_onErrorResumeNextWith();
      Object.defineProperty(exports, "onErrorResumeNextWith", { enumerable: true, get: function() {
        return onErrorResumeNextWith_1.onErrorResumeNextWith;
      } });
      var pairwise_1 = require_pairwise();
      Object.defineProperty(exports, "pairwise", { enumerable: true, get: function() {
        return pairwise_1.pairwise;
      } });
      var pluck_1 = require_pluck();
      Object.defineProperty(exports, "pluck", { enumerable: true, get: function() {
        return pluck_1.pluck;
      } });
      var publish_1 = require_publish();
      Object.defineProperty(exports, "publish", { enumerable: true, get: function() {
        return publish_1.publish;
      } });
      var publishBehavior_1 = require_publishBehavior();
      Object.defineProperty(exports, "publishBehavior", { enumerable: true, get: function() {
        return publishBehavior_1.publishBehavior;
      } });
      var publishLast_1 = require_publishLast();
      Object.defineProperty(exports, "publishLast", { enumerable: true, get: function() {
        return publishLast_1.publishLast;
      } });
      var publishReplay_1 = require_publishReplay();
      Object.defineProperty(exports, "publishReplay", { enumerable: true, get: function() {
        return publishReplay_1.publishReplay;
      } });
      var raceWith_1 = require_raceWith();
      Object.defineProperty(exports, "raceWith", { enumerable: true, get: function() {
        return raceWith_1.raceWith;
      } });
      var reduce_1 = require_reduce();
      Object.defineProperty(exports, "reduce", { enumerable: true, get: function() {
        return reduce_1.reduce;
      } });
      var repeat_1 = require_repeat();
      Object.defineProperty(exports, "repeat", { enumerable: true, get: function() {
        return repeat_1.repeat;
      } });
      var repeatWhen_1 = require_repeatWhen();
      Object.defineProperty(exports, "repeatWhen", { enumerable: true, get: function() {
        return repeatWhen_1.repeatWhen;
      } });
      var retry_1 = require_retry();
      Object.defineProperty(exports, "retry", { enumerable: true, get: function() {
        return retry_1.retry;
      } });
      var retryWhen_1 = require_retryWhen();
      Object.defineProperty(exports, "retryWhen", { enumerable: true, get: function() {
        return retryWhen_1.retryWhen;
      } });
      var refCount_1 = require_refCount();
      Object.defineProperty(exports, "refCount", { enumerable: true, get: function() {
        return refCount_1.refCount;
      } });
      var sample_1 = require_sample();
      Object.defineProperty(exports, "sample", { enumerable: true, get: function() {
        return sample_1.sample;
      } });
      var sampleTime_1 = require_sampleTime();
      Object.defineProperty(exports, "sampleTime", { enumerable: true, get: function() {
        return sampleTime_1.sampleTime;
      } });
      var scan_1 = require_scan();
      Object.defineProperty(exports, "scan", { enumerable: true, get: function() {
        return scan_1.scan;
      } });
      var sequenceEqual_1 = require_sequenceEqual();
      Object.defineProperty(exports, "sequenceEqual", { enumerable: true, get: function() {
        return sequenceEqual_1.sequenceEqual;
      } });
      var share_1 = require_share();
      Object.defineProperty(exports, "share", { enumerable: true, get: function() {
        return share_1.share;
      } });
      var shareReplay_1 = require_shareReplay();
      Object.defineProperty(exports, "shareReplay", { enumerable: true, get: function() {
        return shareReplay_1.shareReplay;
      } });
      var single_1 = require_single();
      Object.defineProperty(exports, "single", { enumerable: true, get: function() {
        return single_1.single;
      } });
      var skip_1 = require_skip();
      Object.defineProperty(exports, "skip", { enumerable: true, get: function() {
        return skip_1.skip;
      } });
      var skipLast_1 = require_skipLast();
      Object.defineProperty(exports, "skipLast", { enumerable: true, get: function() {
        return skipLast_1.skipLast;
      } });
      var skipUntil_1 = require_skipUntil();
      Object.defineProperty(exports, "skipUntil", { enumerable: true, get: function() {
        return skipUntil_1.skipUntil;
      } });
      var skipWhile_1 = require_skipWhile();
      Object.defineProperty(exports, "skipWhile", { enumerable: true, get: function() {
        return skipWhile_1.skipWhile;
      } });
      var startWith_1 = require_startWith();
      Object.defineProperty(exports, "startWith", { enumerable: true, get: function() {
        return startWith_1.startWith;
      } });
      var subscribeOn_1 = require_subscribeOn();
      Object.defineProperty(exports, "subscribeOn", { enumerable: true, get: function() {
        return subscribeOn_1.subscribeOn;
      } });
      var switchAll_1 = require_switchAll();
      Object.defineProperty(exports, "switchAll", { enumerable: true, get: function() {
        return switchAll_1.switchAll;
      } });
      var switchMap_1 = require_switchMap();
      Object.defineProperty(exports, "switchMap", { enumerable: true, get: function() {
        return switchMap_1.switchMap;
      } });
      var switchMapTo_1 = require_switchMapTo();
      Object.defineProperty(exports, "switchMapTo", { enumerable: true, get: function() {
        return switchMapTo_1.switchMapTo;
      } });
      var switchScan_1 = require_switchScan();
      Object.defineProperty(exports, "switchScan", { enumerable: true, get: function() {
        return switchScan_1.switchScan;
      } });
      var take_1 = require_take();
      Object.defineProperty(exports, "take", { enumerable: true, get: function() {
        return take_1.take;
      } });
      var takeLast_1 = require_takeLast();
      Object.defineProperty(exports, "takeLast", { enumerable: true, get: function() {
        return takeLast_1.takeLast;
      } });
      var takeUntil_1 = require_takeUntil();
      Object.defineProperty(exports, "takeUntil", { enumerable: true, get: function() {
        return takeUntil_1.takeUntil;
      } });
      var takeWhile_1 = require_takeWhile();
      Object.defineProperty(exports, "takeWhile", { enumerable: true, get: function() {
        return takeWhile_1.takeWhile;
      } });
      var tap_1 = require_tap();
      Object.defineProperty(exports, "tap", { enumerable: true, get: function() {
        return tap_1.tap;
      } });
      var throttle_1 = require_throttle();
      Object.defineProperty(exports, "throttle", { enumerable: true, get: function() {
        return throttle_1.throttle;
      } });
      var throttleTime_1 = require_throttleTime();
      Object.defineProperty(exports, "throttleTime", { enumerable: true, get: function() {
        return throttleTime_1.throttleTime;
      } });
      var throwIfEmpty_1 = require_throwIfEmpty();
      Object.defineProperty(exports, "throwIfEmpty", { enumerable: true, get: function() {
        return throwIfEmpty_1.throwIfEmpty;
      } });
      var timeInterval_1 = require_timeInterval();
      Object.defineProperty(exports, "timeInterval", { enumerable: true, get: function() {
        return timeInterval_1.timeInterval;
      } });
      var timeout_2 = require_timeout();
      Object.defineProperty(exports, "timeout", { enumerable: true, get: function() {
        return timeout_2.timeout;
      } });
      var timeoutWith_1 = require_timeoutWith();
      Object.defineProperty(exports, "timeoutWith", { enumerable: true, get: function() {
        return timeoutWith_1.timeoutWith;
      } });
      var timestamp_1 = require_timestamp();
      Object.defineProperty(exports, "timestamp", { enumerable: true, get: function() {
        return timestamp_1.timestamp;
      } });
      var toArray_1 = require_toArray();
      Object.defineProperty(exports, "toArray", { enumerable: true, get: function() {
        return toArray_1.toArray;
      } });
      var window_1 = require_window();
      Object.defineProperty(exports, "window", { enumerable: true, get: function() {
        return window_1.window;
      } });
      var windowCount_1 = require_windowCount();
      Object.defineProperty(exports, "windowCount", { enumerable: true, get: function() {
        return windowCount_1.windowCount;
      } });
      var windowTime_1 = require_windowTime();
      Object.defineProperty(exports, "windowTime", { enumerable: true, get: function() {
        return windowTime_1.windowTime;
      } });
      var windowToggle_1 = require_windowToggle();
      Object.defineProperty(exports, "windowToggle", { enumerable: true, get: function() {
        return windowToggle_1.windowToggle;
      } });
      var windowWhen_1 = require_windowWhen();
      Object.defineProperty(exports, "windowWhen", { enumerable: true, get: function() {
        return windowWhen_1.windowWhen;
      } });
      var withLatestFrom_1 = require_withLatestFrom();
      Object.defineProperty(exports, "withLatestFrom", { enumerable: true, get: function() {
        return withLatestFrom_1.withLatestFrom;
      } });
      var zipAll_1 = require_zipAll();
      Object.defineProperty(exports, "zipAll", { enumerable: true, get: function() {
        return zipAll_1.zipAll;
      } });
      var zipWith_1 = require_zipWith();
      Object.defineProperty(exports, "zipWith", { enumerable: true, get: function() {
        return zipWith_1.zipWith;
      } });
    }
  });

  // node_modules/@jbrowse/core/util/aborting.js
  var require_aborting = __commonJS({
    "node_modules/@jbrowse/core/util/aborting.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.checkAbortSignal = checkAbortSignal;
      exports.abortBreakPoint = abortBreakPoint;
      exports.makeAbortError = makeAbortError;
      exports.observeAbortSignal = observeAbortSignal;
      exports.isAbortException = isAbortException;
      var rxjs_1 = require_cjs();
      var AbortError = class extends Error {
      };
      function checkAbortSignal(signal) {
        if (!signal) {
          return;
        }
        if (!(signal instanceof AbortSignal)) {
          throw new TypeError("must pass an AbortSignal");
        }
        if (signal.aborted) {
          throw makeAbortError();
        }
      }
      function timeout3(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }
      async function abortBreakPoint(signal) {
        await timeout3(1);
        checkAbortSignal(signal);
      }
      function makeAbortError() {
        if (typeof DOMException !== "undefined") {
          return new DOMException("aborted", "AbortError");
        }
        const e2 = new AbortError("aborted");
        e2.code = "ERR_ABORTED";
        return e2;
      }
      function observeAbortSignal(signal) {
        if (!signal) {
          return new rxjs_1.Observable();
        }
        return (0, rxjs_1.fromEvent)(signal, "abort");
      }
      function isAbortException(exception) {
        return exception instanceof Error && (exception.name === "AbortError" || exception.code === "ERR_ABORTED" || /\b(aborted|aborterror)\b/i.test(exception.message));
      }
    }
  });

  // node_modules/@jbrowse/core/util/makeAbortableReaction.js
  var require_makeAbortableReaction = __commonJS({
    "node_modules/@jbrowse/core/util/makeAbortableReaction.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.makeAbortableReaction = makeAbortableReaction;
      var mobx_1 = require_mobx();
      var mobx_state_tree_1 = require_mobx_state_tree();
      var aborting_1 = require_aborting();
      var stopToken_1 = require_stopToken();
      function makeAbortableReaction(self2, dataFunction, asyncReactionFunction, reactionOptions, startedFunction, successFunction, errorFunction) {
        let inProgress;
        function handleError(error2) {
          if (!(0, aborting_1.isAbortException)(error2)) {
            console.error(error2);
            if ((0, mobx_state_tree_1.isAlive)(self2)) {
              errorFunction(error2);
            }
          }
        }
        (0, mobx_state_tree_1.addDisposer)(self2, (0, mobx_1.reaction)(() => {
          try {
            return dataFunction(self2);
          } catch (e2) {
            handleError(e2);
            return void 0;
          }
        }, async (data, mobxReactionHandle) => {
          if (inProgress) {
            (0, stopToken_1.stopStopToken)(inProgress);
          }
          if (!(0, mobx_state_tree_1.isAlive)(self2)) {
            return;
          }
          inProgress = (0, stopToken_1.createStopToken)();
          startedFunction(inProgress);
          try {
            const result = await asyncReactionFunction(data, inProgress, self2, mobxReactionHandle);
            if ((0, mobx_state_tree_1.isAlive)(self2)) {
              successFunction(result);
            }
          } catch (e2) {
            handleError(e2);
          }
        }, reactionOptions));
        (0, mobx_state_tree_1.addDisposer)(self2, () => {
          if (inProgress) {
            (0, stopToken_1.stopStopToken)(inProgress);
          }
        });
      }
    }
  });

  // node_modules/@jbrowse/core/util/index.js
  var require_util5 = __commonJS({
    "node_modules/@jbrowse/core/util/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o2, m2, k2, k22) {
        if (k22 === void 0) k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m2, k2);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k2];
          } };
        }
        Object.defineProperty(o2, k22, desc);
      }) : (function(o2, m2, k2, k22) {
        if (k22 === void 0) k22 = k2;
        o2[k22] = m2[k2];
      }));
      var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
        for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.makeAbortableReaction = exports.blobToDataURL = exports.isFeature = exports.SimpleFeature = exports.defaultCodonTable = exports.defaultStops = exports.defaultStarts = exports.rIC = exports.complementTable = exports.isElectron = void 0;
      exports.useDebounce = useDebounce;
      exports.useWidthSetter = useWidthSetter;
      exports.useDebouncedCallback = useDebouncedCallback;
      exports.findParentThat = findParentThat;
      exports.springAnimate = springAnimate;
      exports.findParentThatIs = findParentThatIs;
      exports.getSession = getSession15;
      exports.getContainingView = getContainingView6;
      exports.getContainingTrack = getContainingTrack2;
      exports.getContainingDisplay = getContainingDisplay;
      exports.assembleLocString = assembleLocString;
      exports.assembleLocStringFast = assembleLocStringFast;
      exports.parseLocStringOneBased = parseLocStringOneBased;
      exports.parseLocString = parseLocString;
      exports.compareLocs = compareLocs;
      exports.compareLocStrings = compareLocStrings;
      exports.clamp = clamp4;
      exports.bpToPx = bpToPx;
      exports.radToDeg = radToDeg;
      exports.degToRad = degToRad;
      exports.polarToCartesian = polarToCartesian;
      exports.cartesianToPolar = cartesianToPolar;
      exports.featureSpanPx = featureSpanPx;
      exports.bpSpanPx = bpSpanPx;
      exports.iterMap = iterMap;
      exports.findLastIndex = findLastIndex;
      exports.findLast = findLast;
      exports.renameRegionIfNeeded = renameRegionIfNeeded;
      exports.renameRegionsIfNeeded = renameRegionsIfNeeded;
      exports.minmax = minmax;
      exports.shorten = shorten;
      exports.shorten2 = shorten22;
      exports.stringify = stringify2;
      exports.revcom = revcom2;
      exports.reverse = reverse;
      exports.complement = complement;
      exports.measureText = measureText;
      exports.getFrame = getFrame;
      exports.generateCodonTable = generateCodonTable2;
      exports.updateStatus = updateStatus;
      exports.updateStatus2 = updateStatus2;
      exports.hashCode = hashCode;
      exports.objectHash = objectHash;
      exports.bytesForRegions = bytesForRegions;
      exports.isSupportedIndexingAdapter = isSupportedIndexingAdapter;
      exports.getBpDisplayStr = getBpDisplayStr;
      exports.getProgressDisplayStr = getProgressDisplayStr;
      exports.toLocale = toLocale;
      exports.getTickDisplayStr = getTickDisplayStr;
      exports.getViewParams = getViewParams;
      exports.getLayoutId = getLayoutId;
      exports.useLocalStorage = useLocalStorage2;
      exports.getUriLink = getUriLink;
      exports.getStr = getStr;
      exports.coarseStripHTML = coarseStripHTML;
      exports.linkify = linkify;
      exports.measureGridWidth = measureGridWidth;
      exports.getEnv = getEnv2;
      exports.localStorageGetItem = localStorageGetItem;
      exports.localStorageSetItem = localStorageSetItem;
      exports.max = max3;
      exports.min = min2;
      exports.sum = sum3;
      exports.avg = avg;
      exports.groupBy = groupBy2;
      exports.notEmpty = notEmpty2;
      exports.mergeIntervals = mergeIntervals;
      exports.gatherOverlaps = gatherOverlaps;
      exports.stripAlpha = stripAlpha;
      exports.getStrokeProps = getStrokeProps;
      exports.getFillProps = getFillProps;
      exports.renderToStaticMarkup = renderToStaticMarkup2;
      exports.isGzip = isGzip;
      exports.fetchAndMaybeUnzip = fetchAndMaybeUnzip;
      exports.fetchAndMaybeUnzipText = fetchAndMaybeUnzipText2;
      exports.isObject = isObject;
      exports.localStorageGetNumber = localStorageGetNumber;
      exports.localStorageGetBoolean = localStorageGetBoolean2;
      exports.localStorageSetBoolean = localStorageSetBoolean2;
      exports.forEachWithStopTokenCheck = forEachWithStopTokenCheck;
      exports.testAdapter = testAdapter;
      var react_1 = require_react();
      var bgzf_filehandle_1 = require_dist();
      var useMeasure_1 = __importDefault(require_useMeasure());
      var mobx_state_tree_1 = require_mobx_state_tree();
      var react_dom_1 = require_react_dom();
      var client_1 = require_client();
      var colord_1 = require_colord2();
      var stopToken_1 = require_stopToken();
      var types_1 = require_types();
      __exportStar(require_types(), exports);
      __exportStar(require_when(), exports);
      __exportStar(require_range(), exports);
      __exportStar(require_dedupe(), exports);
      __exportStar(require_offscreenCanvasPonyfill(), exports);
      __exportStar(require_offscreenCanvasUtils(), exports);
      function useDebounce(value, delay) {
        const [debouncedValue, setDebouncedValue] = (0, react_1.useState)(value);
        (0, react_1.useEffect)(() => {
          const handle = setTimeout(() => {
            setDebouncedValue(value);
          }, delay);
          return () => {
            clearTimeout(handle);
          };
        }, [value, delay]);
        return debouncedValue;
      }
      function useWidthSetter(view, padding2) {
        const [ref, { width }] = (0, useMeasure_1.default)();
        (0, react_1.useEffect)(() => {
          let token2;
          if (width && (0, mobx_state_tree_1.isAlive)(view)) {
            token2 = requestAnimationFrame(() => {
              view.setWidth(width);
            });
          }
          return () => {
            if (token2) {
              cancelAnimationFrame(token2);
            }
          };
        }, [padding2, view, width]);
        return ref;
      }
      function useDebouncedCallback(callback, wait3 = 400) {
        const argsRef = (0, react_1.useRef)(null);
        const timeout3 = (0, react_1.useRef)(null);
        (0, react_1.useEffect)(() => {
          if (timeout3.current) {
            clearTimeout(timeout3.current);
          }
        }, []);
        return function debouncedCallback(...args) {
          argsRef.current = args;
          if (timeout3.current) {
            clearTimeout(timeout3.current);
          }
          timeout3.current = setTimeout(() => {
            if (argsRef.current) {
              callback(...argsRef.current);
            }
          }, wait3);
        };
      }
      function findParentThat(node2, predicate) {
        if (!(0, mobx_state_tree_1.hasParent)(node2)) {
          throw new Error("node does not have parent");
        }
        let currentNode = (0, mobx_state_tree_1.getParent)(node2);
        while (currentNode && (0, mobx_state_tree_1.isAlive)(currentNode)) {
          if (predicate(currentNode)) {
            return currentNode;
          }
          if ((0, mobx_state_tree_1.hasParent)(currentNode)) {
            currentNode = (0, mobx_state_tree_1.getParent)(currentNode);
          } else {
            break;
          }
        }
        throw new Error("no matching node found");
      }
      function springAnimate(fromValue, toValue, setValue, onFinish = () => {
      }, precision = 0, tension = 400, friction = 20, clamp5 = true) {
        const mass = 1;
        if (!precision) {
          precision = Math.abs(toValue - fromValue) / 1e3;
        }
        let animationFrameId;
        function update(animation) {
          const time = Date.now();
          let position2 = animation.lastPosition;
          let lastTime = animation.lastTime || time;
          let velocity = animation.lastVelocity || 0;
          if (time > lastTime + 64) {
            lastTime = time;
          }
          const numSteps = Math.floor(time - lastTime);
          for (let i2 = 0; i2 < numSteps; ++i2) {
            const force = -tension * (position2 - toValue);
            const damping = -friction * velocity;
            const acceleration = (force + damping) / mass;
            velocity += acceleration * 1 / 1e3;
            position2 += velocity * 1 / 1e3;
          }
          const isVelocity = Math.abs(velocity) <= precision;
          const isDisplacement = tension !== 0 ? Math.abs(toValue - position2) <= precision : true;
          const isOvershooting = clamp5 && tension !== 0 ? fromValue < toValue ? position2 > toValue : position2 < toValue : false;
          const endOfAnimation = isOvershooting || isVelocity && isDisplacement;
          if (endOfAnimation) {
            setValue(toValue);
            onFinish();
          } else {
            setValue(position2);
            animationFrameId = requestAnimationFrame(() => {
              update({
                lastPosition: position2,
                lastTime: time,
                lastVelocity: velocity
              });
            });
          }
        }
        return [
          () => {
            update({ lastPosition: fromValue });
          },
          () => {
            cancelAnimationFrame(animationFrameId);
          }
        ];
      }
      function findParentThatIs(node2, predicate) {
        return findParentThat(node2, predicate);
      }
      function getSession15(node2) {
        try {
          return findParentThatIs(node2, types_1.isSessionModel);
        } catch (e2) {
          throw new Error("no session model found!");
        }
      }
      function getContainingView6(node2) {
        try {
          return findParentThatIs(node2, types_1.isViewModel);
        } catch (e2) {
          throw new Error("no containing view found");
        }
      }
      function getContainingTrack2(node2) {
        try {
          return findParentThatIs(node2, types_1.isTrackModel);
        } catch (e2) {
          throw new Error("no containing track found");
        }
      }
      function getContainingDisplay(node2) {
        try {
          return findParentThatIs(node2, types_1.isDisplayModel);
        } catch (e2) {
          throw new Error("no containing display found");
        }
      }
      function assembleLocString(region) {
        return assembleLocStringFast(region, toLocale);
      }
      function assembleLocStringFast(region, cb = (n2) => n2) {
        const { assemblyName, refName, start, end, reversed } = region;
        const assemblyNameString = assemblyName ? `{${assemblyName}}` : "";
        let startString;
        if (start !== void 0) {
          startString = `:${cb(start + 1)}`;
        } else if (end !== void 0) {
          startString = ":1";
        } else {
          startString = "";
        }
        let endString;
        if (end !== void 0) {
          endString = start !== void 0 && start + 1 === end ? "" : `..${cb(end)}`;
        } else {
          endString = start !== void 0 ? ".." : "";
        }
        let rev = "";
        if (reversed) {
          rev = "[rev]";
        }
        return `${assemblyNameString}${refName}${startString}${endString}${rev}`;
      }
      function parseLocStringOneBased(locString, isValidRefName) {
        if (!locString) {
          throw new Error("no location string provided, could not parse");
        }
        let reversed = false;
        if (locString.endsWith("[rev]")) {
          reversed = true;
          locString = locString.replace(/\[rev]$/, "");
        }
        locString = locString.replace(/\s/, "");
        const assemblyMatch = /({(.+)})?(.+)/.exec(locString);
        if (!assemblyMatch) {
          throw new Error(`invalid location string: "${locString}"`);
        }
        const [, , assemblyName2, location2] = assemblyMatch;
        const assemblyName = assemblyName2;
        const location3 = location2;
        if (!assemblyName && location3.startsWith("{}")) {
          throw new Error(`no assembly name was provided in location "${location3}"`);
        }
        const lastColonIdx = location3.lastIndexOf(":");
        if (lastColonIdx === -1) {
          if (isValidRefName(location3, assemblyName)) {
            return {
              assemblyName,
              refName: location3,
              reversed
            };
          }
          throw new Error(`Unknown reference sequence "${location3}"`);
        }
        const prefix2 = location3.slice(0, lastColonIdx);
        const suffix = location3.slice(lastColonIdx + 1);
        if (isValidRefName(prefix2, assemblyName) && isValidRefName(location3, assemblyName)) {
          throw new Error(`ambiguous location string: "${locString}"`);
        } else if (isValidRefName(prefix2, assemblyName)) {
          if (suffix) {
            const rangeMatch = /^(-?(\d+|\d{1,3}(,\d{3})*))(\.\.|-)(-?(\d+|\d{1,3}(,\d{3})*))$/.exec(suffix);
            const singleMatch = /^(-?(\d+|\d{1,3}(,\d{3})*))(\.\.|-)?$/.exec(suffix);
            if (rangeMatch) {
              const [, start, , , , end] = rangeMatch;
              if (start !== void 0 && end !== void 0) {
                return {
                  assemblyName,
                  refName: prefix2,
                  start: +start.replaceAll(",", ""),
                  end: +end.replaceAll(",", ""),
                  reversed
                };
              }
            } else if (singleMatch) {
              const [, start, , , separator] = singleMatch;
              if (start !== void 0) {
                if (separator) {
                  return {
                    assemblyName,
                    refName: prefix2,
                    start: +start.replaceAll(",", ""),
                    reversed
                  };
                }
                return {
                  assemblyName,
                  refName: prefix2,
                  start: +start.replaceAll(",", ""),
                  end: +start.replaceAll(",", ""),
                  reversed
                };
              }
            } else {
              throw new Error(`could not parse range "${suffix}" on location "${locString}"`);
            }
          } else {
            return {
              assemblyName,
              refName: prefix2,
              reversed
            };
          }
        } else if (isValidRefName(location3, assemblyName)) {
          return {
            assemblyName,
            refName: location3,
            reversed
          };
        }
        throw new Error(`unknown reference sequence name in location "${locString}"`);
      }
      function parseLocString(locString, isValidRefName) {
        const parsed = parseLocStringOneBased(locString, isValidRefName);
        if (typeof parsed.start === "number") {
          parsed.start -= 1;
        }
        return parsed;
      }
      function compareLocs(locA, locB) {
        const assemblyComp = locA.assemblyName || locB.assemblyName ? (locA.assemblyName || "").localeCompare(locB.assemblyName || "") : 0;
        if (assemblyComp) {
          return assemblyComp;
        }
        const refComp = locA.refName || locB.refName ? (locA.refName || "").localeCompare(locB.refName || "") : 0;
        if (refComp) {
          return refComp;
        }
        if (locA.start !== void 0 && locB.start !== void 0) {
          const startComp = locA.start - locB.start;
          if (startComp) {
            return startComp;
          }
        }
        if (locA.end !== void 0 && locB.end !== void 0) {
          const endComp = locA.end - locB.end;
          if (endComp) {
            return endComp;
          }
        }
        return 0;
      }
      function compareLocStrings(a2, b2, isValidRefName) {
        const locA = parseLocString(a2, isValidRefName);
        const locB = parseLocString(b2, isValidRefName);
        return compareLocs(locA, locB);
      }
      function clamp4(num, min3, max4) {
        if (num < min3) {
          return min3;
        }
        if (num > max4) {
          return max4;
        }
        return num;
      }
      function roundToNearestPointOne(num) {
        return Math.round(num * 10) / 10;
      }
      function bpToPx(bp, { reversed, end = 0, start = 0 }, bpPerPx) {
        return roundToNearestPointOne((reversed ? end - bp : bp - start) / bpPerPx);
      }
      var oneEightyOverPi = 180 / Math.PI;
      var piOverOneEighty = Math.PI / 180;
      function radToDeg(radians) {
        return radians * oneEightyOverPi % 360;
      }
      function degToRad(degrees) {
        return degrees * piOverOneEighty % (2 * Math.PI);
      }
      function polarToCartesian(rho, theta) {
        return [rho * Math.cos(theta), rho * Math.sin(theta)];
      }
      function cartesianToPolar(x2, y2) {
        const rho = Math.sqrt(x2 * x2 + y2 * y2);
        const theta = Math.atan(y2 / x2);
        return [rho, theta];
      }
      function featureSpanPx(feature, region, bpPerPx) {
        return bpSpanPx(feature.get("start"), feature.get("end"), region, bpPerPx);
      }
      function bpSpanPx(leftBp, rightBp, region, bpPerPx) {
        const start = bpToPx(leftBp, region, bpPerPx);
        const end = bpToPx(rightBp, region, bpPerPx);
        return region.reversed ? [end, start] : [start, end];
      }
      function iterMap(iter, func, sizeHint) {
        const results = Array.from({ length: sizeHint || 0 });
        let counter4 = 0;
        for (const item of iter) {
          results[counter4] = func(item);
          counter4 += 1;
        }
        return results;
      }
      function findLastIndex(array, predicate) {
        let l2 = array.length;
        while (l2--) {
          if (predicate(array[l2], l2, array)) {
            return l2;
          }
        }
        return -1;
      }
      function findLast(array, predicate) {
        let l2 = array.length;
        while (l2--) {
          if (predicate(array[l2], l2, array)) {
            return array[l2];
          }
        }
        return void 0;
      }
      function renameRegionIfNeeded(refNameMap, region) {
        if ((0, mobx_state_tree_1.isStateTreeNode)(region) && !(0, mobx_state_tree_1.isAlive)(region)) {
          return region;
        }
        if (refNameMap === null || refNameMap === void 0 ? void 0 : refNameMap[region.refName]) {
          region = (0, mobx_state_tree_1.isStateTreeNode)(region) ? { ...(0, mobx_state_tree_1.getSnapshot)(region) } : { ...region };
          const newRef = refNameMap[region.refName];
          if (newRef) {
            return { ...region, refName: newRef, originalRefName: region.refName };
          }
        }
        return region;
      }
      async function renameRegionsIfNeeded(assemblyManager, args) {
        const { regions = [], adapterConfig } = args;
        if (!args.sessionId) {
          throw new Error("sessionId is required");
        }
        const assemblyNames = regions.map((region) => region.assemblyName);
        const assemblyMaps = Object.fromEntries(await Promise.all([...new Set(assemblyNames)].map(async (assemblyName) => {
          return [
            assemblyName,
            await assemblyManager.getRefNameMapForAdapter(adapterConfig, assemblyName, args)
          ];
        })));
        return {
          ...args,
          regions: regions.map((region, i2) => renameRegionIfNeeded(assemblyMaps[assemblyNames[i2]], region))
        };
      }
      function minmax(a2, b2) {
        return [Math.min(a2, b2), Math.max(a2, b2)];
      }
      function shorten(name, max4 = 70, short = 30) {
        return name.length > max4 ? `${name.slice(0, short)}...${name.slice(-short)}` : name;
      }
      function shorten22(name, max4 = 70) {
        return name.length > max4 ? `${name.slice(0, max4)}...` : name;
      }
      function stringify2({ refName, coord, assemblyName, oob }, useAssemblyName) {
        return [
          assemblyName && useAssemblyName ? `{${assemblyName}}` : "",
          refName ? `${shorten(refName)}:${toLocale(coord)}${oob ? " (out of bounds)" : ""}` : ""
        ].join("");
      }
      exports.isElectron = /electron/i.test(typeof navigator !== "undefined" ? navigator.userAgent : "");
      exports.complementTable = {
        S: "S",
        w: "w",
        T: "A",
        r: "y",
        a: "t",
        N: "N",
        K: "M",
        x: "x",
        d: "h",
        Y: "R",
        V: "B",
        y: "r",
        M: "K",
        h: "d",
        k: "m",
        C: "G",
        g: "c",
        t: "a",
        A: "T",
        n: "n",
        W: "W",
        X: "X",
        m: "k",
        v: "b",
        B: "V",
        s: "s",
        H: "D",
        c: "g",
        D: "H",
        b: "v",
        R: "Y",
        G: "C"
      };
      function revcom2(str) {
        var _a;
        const revcomped = [];
        for (let i2 = str.length - 1; i2 >= 0; i2--) {
          revcomped.push((_a = exports.complementTable[str[i2]]) !== null && _a !== void 0 ? _a : str[i2]);
        }
        return revcomped.join("");
      }
      function reverse(str) {
        const reversed = [];
        for (let i2 = str.length - 1; i2 >= 0; i2--) {
          reversed.push(str[i2]);
        }
        return reversed.join("");
      }
      function complement(str) {
        var _a;
        const comp = [];
        for (let i2 = 0, l2 = str.length; i2 < l2; i2++) {
          comp.push((_a = exports.complementTable[str[i2]]) !== null && _a !== void 0 ? _a : str[i2]);
        }
        return comp.join("");
      }
      exports.rIC = typeof jest === "undefined" ? typeof window !== "undefined" && window.requestIdleCallback ? window.requestIdleCallback : (cb) => setTimeout(() => {
        cb();
      }, 1) : (cb) => {
        cb();
      };
      var widths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2796875, 0.2765625, 0.3546875, 0.5546875, 0.5546875, 0.8890625, 0.665625, 0.190625, 0.3328125, 0.3328125, 0.3890625, 0.5828125, 0.2765625, 0.3328125, 0.2765625, 0.3015625, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.2765625, 0.2765625, 0.584375, 0.5828125, 0.584375, 0.5546875, 1.0140625, 0.665625, 0.665625, 0.721875, 0.721875, 0.665625, 0.609375, 0.7765625, 0.721875, 0.2765625, 0.5, 0.665625, 0.5546875, 0.8328125, 0.721875, 0.7765625, 0.665625, 0.7765625, 0.721875, 0.665625, 0.609375, 0.721875, 0.665625, 0.94375, 0.665625, 0.665625, 0.609375, 0.2765625, 0.3546875, 0.2765625, 0.4765625, 0.5546875, 0.3328125, 0.5546875, 0.5546875, 0.5, 0.5546875, 0.5546875, 0.2765625, 0.5546875, 0.5546875, 0.221875, 0.240625, 0.5, 0.221875, 0.8328125, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.3328125, 0.5, 0.2765625, 0.5546875, 0.5, 0.721875, 0.5, 0.5, 0.5, 0.3546875, 0.259375, 0.353125, 0.5890625];
      function measureText(str, fontSize = 10) {
        var _a;
        const avg2 = 0.5279276315789471;
        const s2 = String(str);
        let total = 0;
        for (let i2 = 0; i2 < s2.length; i2++) {
          const code = s2.charCodeAt(i2);
          total += (_a = widths[code]) !== null && _a !== void 0 ? _a : avg2;
        }
        return total * fontSize;
      }
      function getFrame(start, end, strand, phase) {
        return strand === 1 ? (start + phase) % 3 + 1 : -1 * ((end - phase) % 3) - 1;
      }
      exports.defaultStarts = ["ATG"];
      exports.defaultStops = ["TAA", "TAG", "TGA"];
      exports.defaultCodonTable = {
        TCA: "S",
        TCC: "S",
        TCG: "S",
        TCT: "S",
        TTC: "F",
        TTT: "F",
        TTA: "L",
        TTG: "L",
        TAC: "Y",
        TAT: "Y",
        TAA: "*",
        TAG: "*",
        TGC: "C",
        TGT: "C",
        TGA: "*",
        TGG: "W",
        CTA: "L",
        CTC: "L",
        CTG: "L",
        CTT: "L",
        CCA: "P",
        CCC: "P",
        CCG: "P",
        CCT: "P",
        CAC: "H",
        CAT: "H",
        CAA: "Q",
        CAG: "Q",
        CGA: "R",
        CGC: "R",
        CGG: "R",
        CGT: "R",
        ATA: "I",
        ATC: "I",
        ATT: "I",
        ATG: "M",
        ACA: "T",
        ACC: "T",
        ACG: "T",
        ACT: "T",
        AAC: "N",
        AAT: "N",
        AAA: "K",
        AAG: "K",
        AGC: "S",
        AGT: "S",
        AGA: "R",
        AGG: "R",
        GTA: "V",
        GTC: "V",
        GTG: "V",
        GTT: "V",
        GCA: "A",
        GCC: "A",
        GCG: "A",
        GCT: "A",
        GAC: "D",
        GAT: "D",
        GAA: "E",
        GAG: "E",
        GGA: "G",
        GGC: "G",
        GGG: "G",
        GGT: "G"
      };
      function generateCodonTable2(table2) {
        const tempCodonTable = {};
        for (const codon of Object.keys(table2)) {
          const aa = table2[codon];
          const nucs = [];
          for (let i2 = 0; i2 < 3; i2++) {
            const nuc = codon.charAt(i2);
            nucs[i2] = [];
            nucs[i2][0] = nuc.toUpperCase();
            nucs[i2][1] = nuc.toLowerCase();
          }
          for (let i2 = 0; i2 < 2; i2++) {
            const n0 = nucs[0][i2];
            for (let j2 = 0; j2 < 2; j2++) {
              const n1 = nucs[1][j2];
              for (let k2 = 0; k2 < 2; k2++) {
                const n2 = nucs[2][k2];
                const triplet = n0 + n1 + n2;
                tempCodonTable[triplet] = aa;
              }
            }
          }
        }
        return tempCodonTable;
      }
      async function updateStatus(msg, cb, fn) {
        cb(msg);
        const res = await fn();
        cb("");
        return res;
      }
      async function updateStatus2(msg, cb, stopToken, fn) {
        cb(msg);
        const res = await fn();
        (0, stopToken_1.checkStopToken)(stopToken);
        cb("");
        return res;
      }
      function hashCode(str) {
        let hash2 = 0;
        if (str.length === 0) {
          return hash2;
        }
        for (let i2 = 0; i2 < str.length; i2++) {
          const chr = str.charCodeAt(i2);
          hash2 = (hash2 << 5) - hash2 + chr;
          hash2 |= 0;
        }
        return hash2;
      }
      function objectHash(obj) {
        return `${hashCode(JSON.stringify(obj))}`;
      }
      async function bytesForRegions(regions, index3) {
        const blockResults = await Promise.all(regions.map((r3) => index3.blocksForRange(r3.refName, r3.start, r3.end)));
        return blockResults.flat().map((block) => ({
          start: block.minv.blockPosition,
          end: block.maxv.blockPosition + 65535
        })).reduce((a2, b2) => a2 + b2.end - b2.start, 0);
      }
      function isSupportedIndexingAdapter(type = "") {
        return [
          "Gff3TabixAdapter",
          "VcfTabixAdapter",
          "Gff3Adapter",
          "VcfAdapter"
        ].includes(type);
      }
      function getBpDisplayStr(total) {
        if (Math.floor(total / 1e6) > 0) {
          return `${r2(total / 1e6)}Mbp`;
        } else if (Math.floor(total / 1e3) > 0) {
          return `${r2(total / 1e3)}Kbp`;
        } else {
          return `${Math.floor(total)}bp`;
        }
      }
      function r2(s2) {
        return toLocale(Number.parseFloat(s2.toPrecision(3)));
      }
      function getProgressDisplayStr(current, total) {
        if (Math.floor(total / 1e6) > 0) {
          return `${r2(current / 1e6)}/${r2(total / 1e6)}Mb`;
        } else if (Math.floor(total / 1e3) > 0) {
          return `${r2(current / 1e3)}/${r2(total / 1e3)}Kb`;
        } else {
          return `${r2(current)}/${r2(total)}}bytes`;
        }
      }
      function toLocale(n2) {
        return n2.toLocaleString("en-US");
      }
      function getTickDisplayStr(totalBp, bpPerPx) {
        return Math.floor(bpPerPx / 1e3) > 0 ? `${toLocale(Number.parseFloat((totalBp / 1e6).toFixed(2)))}M` : toLocale(Math.floor(totalBp));
      }
      function getViewParams(model, exportSVG) {
        const { dynamicBlocks, staticBlocks, offsetPx } = getContainingView6(model);
        const b2 = (dynamicBlocks === null || dynamicBlocks === void 0 ? void 0 : dynamicBlocks.contentBlocks[0]) || {};
        const staticblock = (staticBlocks === null || staticBlocks === void 0 ? void 0 : staticBlocks.contentBlocks[0]) || {};
        const staticblock1 = (staticBlocks === null || staticBlocks === void 0 ? void 0 : staticBlocks.contentBlocks[1]) || {};
        return {
          offsetPx: exportSVG ? 0 : offsetPx - staticblock.offsetPx,
          offsetPx1: exportSVG ? 0 : offsetPx - staticblock1.offsetPx,
          start: b2.start,
          end: b2.end
        };
      }
      function getLayoutId({ sessionId, layoutId }) {
        return `${sessionId}-${layoutId}`;
      }
      function useLocalStorage2(key, initialValue) {
        const [storedValue, setStoredValue] = (0, react_1.useState)(() => {
          if (typeof window === "undefined") {
            return initialValue;
          }
          try {
            const item = window.localStorage.getItem(key);
            return item ? JSON.parse(item) : initialValue;
          } catch (error2) {
            console.error(error2);
            return initialValue;
          }
        });
        const setValue = (value) => {
          try {
            const valueToStore = value instanceof Function ? value(storedValue) : value;
            setStoredValue(valueToStore);
            if (typeof window !== "undefined") {
              window.localStorage.setItem(key, JSON.stringify(valueToStore));
            }
          } catch (error2) {
            console.error(error2);
          }
        };
        return [storedValue, setValue];
      }
      function getUriLink(value) {
        const { uri, baseUri = "" } = value;
        let href;
        try {
          href = new URL(uri, baseUri).href;
        } catch (e2) {
          href = uri;
        }
        return href;
      }
      function getStr(obj) {
        return isObject(obj) ? (0, types_1.isUriLocation)(obj) ? getUriLink(obj) : JSON.stringify(obj) : String(obj);
      }
      function coarseStripHTML(s2) {
        return s2.replaceAll(/(<([^>]+)>)/gi, "");
      }
      function linkify(s2) {
        const pattern = /(^|[\s\n]|<[A-Za-z]*\/?>)((?:https?|ftp):\/\/[-A-Z0-9+\u0026\u2019@#/%?=()~_|!:,.;]*[-A-Z0-9+\u0026@#/%=~()_|])/gi;
        return s2.replaceAll(pattern, `$1<a href='$2' target="_blank">$2</a>`);
      }
      function measureGridWidth(elements, args) {
        const { padding: padding2 = 30, minWidth = 80, fontSize = 12, maxWidth = 1e3, stripHTML = false } = args || {};
        return max3(elements.map((element) => getStr(element)).map((str) => stripHTML ? coarseStripHTML(str) : str).map((str) => measureText(str, fontSize)).map((n2) => Math.min(Math.max(n2 + padding2, minWidth), maxWidth)));
      }
      function getEnv2(obj) {
        return (0, mobx_state_tree_1.getEnv)(obj);
      }
      function localStorageGetItem(item) {
        return typeof localStorage !== "undefined" ? localStorage.getItem(item) : void 0;
      }
      function localStorageSetItem(str, item) {
        if (typeof localStorage !== "undefined") {
          localStorage.setItem(str, item);
        }
      }
      function max3(arr, init = Number.NEGATIVE_INFINITY) {
        let max4 = init;
        for (const entry of arr) {
          max4 = Math.max(entry, max4);
        }
        return max4;
      }
      function min2(arr, init = Number.POSITIVE_INFINITY) {
        let min3 = init;
        for (const entry of arr) {
          min3 = Math.min(entry, min3);
        }
        return min3;
      }
      function sum3(arr) {
        let sum4 = 0;
        for (const entry of arr) {
          sum4 += entry;
        }
        return sum4;
      }
      function avg(arr) {
        return sum3(arr) / arr.length;
      }
      function groupBy2(array, predicate) {
        const result = {};
        for (const value of array) {
          const t2 = predicate(value);
          if (!result[t2]) {
            result[t2] = [];
          }
          result[t2].push(value);
        }
        return result;
      }
      function notEmpty2(value) {
        return value !== null && value !== void 0;
      }
      function mergeIntervals(intervals, w2 = 5e3) {
        if (intervals.length <= 1) {
          return intervals;
        }
        const stack = [];
        let top = null;
        intervals = intervals.sort((a2, b2) => a2.start - b2.start);
        stack.push(intervals[0]);
        for (let i2 = 1; i2 < intervals.length; i2++) {
          top = stack.at(-1);
          if (top.end + w2 < intervals[i2].start - w2) {
            stack.push(intervals[i2]);
          } else if (top.end < intervals[i2].end) {
            top.end = Math.max(top.end, intervals[i2].end);
            stack.pop();
            stack.push(top);
          }
        }
        return stack;
      }
      function gatherOverlaps(regions, w2 = 5e3) {
        const memo = {};
        for (const x2 of regions) {
          if (!memo[x2.refName]) {
            memo[x2.refName] = [];
          }
          memo[x2.refName].push(x2);
        }
        return Object.values(memo).flatMap((group) => mergeIntervals(group.sort((a2, b2) => a2.start - b2.start), w2));
      }
      function stripAlpha(str) {
        return (0, colord_1.colord)(str).alpha(1).toHex();
      }
      function getStrokeProps(str) {
        if (str) {
          const c2 = (0, colord_1.colord)(str);
          return {
            strokeOpacity: c2.alpha(),
            stroke: c2.alpha(1).toHex()
          };
        } else {
          return {};
        }
      }
      function getFillProps(str) {
        if (str) {
          const c2 = (0, colord_1.colord)(str);
          return {
            fillOpacity: c2.alpha(),
            fill: c2.alpha(1).toHex()
          };
        } else {
          return {};
        }
      }
      function renderToStaticMarkup2(node2) {
        const div = document.createElement("div");
        (0, react_dom_1.flushSync)(() => {
          (0, client_1.createRoot)(div).render(node2);
        });
        return div.innerHTML.replaceAll(/\brgba\((.+?),[^,]+?\)/g, "rgb($1)");
      }
      function isGzip(buf) {
        return buf[0] === 31 && buf[1] === 139 && buf[2] === 8;
      }
      async function fetchAndMaybeUnzip(loc, opts = {}) {
        const { statusCallback = () => {
        } } = opts;
        const buf = await updateStatus("Downloading file", statusCallback, () => loc.readFile(opts));
        return isGzip(buf) ? await updateStatus("Unzipping", statusCallback, () => (0, bgzf_filehandle_1.unzip)(buf)) : buf;
      }
      async function fetchAndMaybeUnzipText2(loc, opts) {
        const buffer = await fetchAndMaybeUnzip(loc, opts);
        if (buffer.length > 536870888) {
          throw new Error("Data exceeds maximum string length (512MB)");
        }
        return new TextDecoder("utf8", { fatal: true }).decode(buffer);
      }
      function isObject(x2) {
        return typeof x2 === "object" && x2 !== null;
      }
      function localStorageGetNumber(key, defaultVal) {
        var _a;
        return +((_a = localStorageGetItem(key)) !== null && _a !== void 0 ? _a : defaultVal);
      }
      function localStorageGetBoolean2(key, defaultVal) {
        return Boolean(JSON.parse(localStorageGetItem(key) || JSON.stringify(defaultVal)));
      }
      function localStorageSetBoolean2(key, value) {
        localStorageSetItem(key, JSON.stringify(value));
      }
      function forEachWithStopTokenCheck(iter, stopToken, arg, durationMs = 400) {
        let start = performance.now();
        let i2 = 0;
        for (const t2 of iter) {
          if (performance.now() - start > durationMs) {
            (0, stopToken_1.checkStopToken)(stopToken);
            start = performance.now();
          }
          arg(t2, i2++);
        }
      }
      function testAdapter(fileName, regex, adapterHint, expected) {
        return regex.test(fileName) && !adapterHint || adapterHint === expected;
      }
      var simpleFeature_1 = require_simpleFeature();
      Object.defineProperty(exports, "SimpleFeature", { enumerable: true, get: function() {
        return __importDefault(simpleFeature_1).default;
      } });
      Object.defineProperty(exports, "isFeature", { enumerable: true, get: function() {
        return simpleFeature_1.isFeature;
      } });
      var blobToDataURL_1 = require_blobToDataURL();
      Object.defineProperty(exports, "blobToDataURL", { enumerable: true, get: function() {
        return blobToDataURL_1.blobToDataURL;
      } });
      var makeAbortableReaction_1 = require_makeAbortableReaction();
      Object.defineProperty(exports, "makeAbortableReaction", { enumerable: true, get: function() {
        return makeAbortableReaction_1.makeAbortableReaction;
      } });
      __exportStar(require_aborting(), exports);
    }
  });

  // node_modules/@jbrowse/core/util/idMaker.js
  var require_idMaker = __commonJS({
    "node_modules/@jbrowse/core/util/idMaker.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = idMaker;
      var _1 = require_util5();
      function idMaker(args, id = "", len2 = 5e3) {
        const stack = [args];
        while (stack.length) {
          const obj = stack.pop();
          for (const [key, val] of Object.entries(obj)) {
            if (id.length > len2) {
              return (0, _1.hashCode)(id);
            } else {
              if (typeof val === "object" && val !== null) {
                stack.push(val);
              } else {
                id += `${key}-${val}`;
              }
            }
          }
        }
        return `adp-${(0, _1.hashCode)(id)}`;
      }
    }
  });

  // node_modules/@jbrowse/core/data_adapters/util.js
  var require_util6 = __commonJS({
    "node_modules/@jbrowse/core/data_adapters/util.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.adapterConfigCacheKey = adapterConfigCacheKey;
      var idMaker_1 = __importDefault(require_idMaker());
      function adapterConfigCacheKey(conf = {}) {
        return `${(0, idMaker_1.default)(conf)}`;
      }
    }
  });

  // node_modules/@jbrowse/core/data_adapters/dataAdapterCache.js
  var require_dataAdapterCache = __commonJS({
    "node_modules/@jbrowse/core/data_adapters/dataAdapterCache.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getAdapter = getAdapter2;
      exports.freeAdapterResources = freeAdapterResources;
      exports.clearAdapterCache = clearAdapterCache;
      var util_1 = require_util6();
      var adapterCache = {};
      async function getAdapterPre(pluginManager, sessionId, adapterConfigSnapshot) {
        const adapterType = adapterConfigSnapshot === null || adapterConfigSnapshot === void 0 ? void 0 : adapterConfigSnapshot.type;
        if (!adapterType) {
          throw new Error(`could not determine adapter type from adapter config snapshot ${JSON.stringify(adapterConfigSnapshot)}`);
        }
        const dataAdapterType = pluginManager.getAdapterType(adapterType);
        if (!dataAdapterType) {
          throw new Error(`unknown data adapter type ${adapterType}`);
        }
        const adapterConfig = dataAdapterType.configSchema.create(adapterConfigSnapshot, { pluginManager });
        const getSubAdapter = getAdapter2.bind(null, pluginManager, sessionId);
        const CLASS = await dataAdapterType.getAdapterClass();
        const dataAdapter = new CLASS(adapterConfig, getSubAdapter, pluginManager);
        return {
          dataAdapter,
          sessionIds: /* @__PURE__ */ new Set([sessionId])
        };
      }
      async function getAdapter2(pluginManager, sessionId, adapterConfigSnapshot) {
        var _a;
        const cacheKey = (0, util_1.adapterConfigCacheKey)(adapterConfigSnapshot);
        (_a = adapterCache[cacheKey]) !== null && _a !== void 0 ? _a : adapterCache[cacheKey] = getAdapterPre(pluginManager, sessionId, adapterConfigSnapshot);
        const ret = await adapterCache[cacheKey];
        ret.sessionIds.add(sessionId);
        return ret;
      }
      async function freeAdapterResources(args) {
        const specKeys = Object.keys(args);
        if (specKeys.length === 1 && specKeys[0] === "sessionId") {
          const { sessionId } = args;
          for (const [cacheKey, cacheEntryP] of Object.entries(adapterCache)) {
            const cacheEntry = await cacheEntryP;
            cacheEntry.sessionIds.delete(sessionId);
            if (cacheEntry.sessionIds.size === 0) {
              delete adapterCache[cacheKey];
            }
          }
        } else {
          for (const cacheEntryP of Object.values(adapterCache)) {
            const cacheEntry = await cacheEntryP;
            const regions = args.regions || (args.region ? [args.region] : []);
            for (const region of regions) {
              if (region.refName !== void 0) {
                cacheEntry.dataAdapter.freeResources(region);
              }
            }
          }
        }
      }
      function clearAdapterCache() {
        adapterCache = {};
      }
    }
  });

  // global-externals:@jbrowse/core/pluggableElementTypes/ViewType
  var require_ViewType = __commonJS({
    "global-externals:@jbrowse/core/pluggableElementTypes/ViewType"(exports, module) {
      module.exports = JBrowseExports["@jbrowse/core/pluggableElementTypes/ViewType"];
    }
  });

  // node_modules/@jbrowse/core/ui/ErrorBoundary.js
  var require_ErrorBoundary = __commonJS({
    "node_modules/@jbrowse/core/ui/ErrorBoundary.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ErrorBoundary = void 0;
      var jsx_runtime_1 = require_jsx_runtime();
      var react_1 = require_react();
      var ErrorBoundary2 = class extends react_1.Component {
        constructor(props) {
          super(props);
          this.state = { error: void 0 };
        }
        componentDidCatch(error2, errorInfo) {
          console.error("ErrorBoundary caught an error:", error2, errorInfo);
          this.setState({ error: error2 });
        }
        render() {
          return this.state.error ? (0, jsx_runtime_1.jsx)(this.props.FallbackComponent, { error: this.state.error }) : this.props.children;
        }
      };
      exports.ErrorBoundary = ErrorBoundary2;
    }
  });

  // node_modules/react-msaview/dist/components/ResizeHandles.js
  var import_react23, import_mobx_react9, VerticalResizeHandle, HorizontalResizeHandle;
  var init_ResizeHandles = __esm({
    "node_modules/react-msaview/dist/components/ResizeHandles.js"() {
      import_react23 = __toESM(require_react());
      import_mobx_react9 = __toESM(require_mobx_react());
      VerticalResizeHandle = (0, import_mobx_react9.observer)(function({ model }) {
        const { resizeHandleWidth } = model;
        const [mouseDragging, setMouseDragging] = (0, import_react23.useState)(false);
        const scheduled = (0, import_react23.useRef)(false);
        const prevX = (0, import_react23.useRef)(0);
        (0, import_react23.useEffect)(() => {
          function globalMouseMove(event) {
            event.preventDefault();
            const currX = event.clientX;
            if (prevX.current === 0) {
              prevX.current = event.clientX;
            } else {
              const distance = currX - prevX.current;
              if (distance) {
                if (!scheduled.current) {
                  scheduled.current = true;
                  window.requestAnimationFrame(() => {
                    model.setTreeAreaWidth(model.treeAreaWidth + distance);
                    scheduled.current = false;
                    prevX.current = event.clientX;
                  });
                }
              }
            }
          }
          function globalMouseUp() {
            prevX.current = 0;
            if (mouseDragging) {
              setMouseDragging(false);
            }
          }
          if (mouseDragging) {
            document.addEventListener("mousemove", globalMouseMove, true);
            document.addEventListener("mouseup", globalMouseUp, true);
            return () => {
              document.removeEventListener("mousemove", globalMouseMove, true);
              document.removeEventListener("mouseup", globalMouseUp, true);
            };
          }
          return () => {
          };
        }, [mouseDragging, model]);
        return import_react23.default.createElement(
          "div",
          null,
          import_react23.default.createElement("div", { onMouseDown: () => {
            setMouseDragging(true);
          }, style: {
            cursor: "ew-resize",
            height: "100%",
            width: resizeHandleWidth,
            background: "rgba(200,200,200)",
            position: "relative"
          } })
        );
      });
      HorizontalResizeHandle = (0, import_mobx_react9.observer)(function({ model }) {
        const { resizeHandleWidth } = model;
        const [mouseDragging, setMouseDragging] = (0, import_react23.useState)(false);
        const scheduled = (0, import_react23.useRef)(false);
        const prevY = (0, import_react23.useRef)(0);
        (0, import_react23.useEffect)(() => {
          function globalMouseMove(event) {
            event.preventDefault();
            const currY = event.clientY;
            if (prevY.current === 0) {
              prevY.current = event.clientY;
            } else {
              const distance = currY - prevY.current;
              if (distance) {
                if (!scheduled.current) {
                  scheduled.current = true;
                  window.requestAnimationFrame(() => {
                    model.setHeight(model.height + distance);
                    scheduled.current = false;
                    prevY.current = event.clientY;
                  });
                }
              }
            }
          }
          function globalMouseUp() {
            prevY.current = 0;
            if (mouseDragging) {
              setMouseDragging(false);
            }
          }
          if (mouseDragging) {
            document.addEventListener("mousemove", globalMouseMove, true);
            document.addEventListener("mouseup", globalMouseUp, true);
            return () => {
              document.removeEventListener("mousemove", globalMouseMove, true);
              document.removeEventListener("mouseup", globalMouseUp, true);
            };
          }
          return () => {
          };
        }, [mouseDragging, model]);
        return import_react23.default.createElement(
          "div",
          null,
          import_react23.default.createElement("div", { onMouseDown: () => {
            setMouseDragging(true);
          }, style: {
            cursor: "ns-resize",
            width: "100%",
            height: resizeHandleWidth,
            background: "rgba(200,200,200)",
            position: "relative"
          } })
        );
      });
    }
  });

  // node_modules/@mui/icons-material/esm/ArrowDropDown.js
  var import_jsx_runtime5, ArrowDropDown_default;
  var init_ArrowDropDown = __esm({
    "node_modules/@mui/icons-material/esm/ArrowDropDown.js"() {
      "use client";
      init_createSvgIcon();
      import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
      ArrowDropDown_default = (0, import_utils.createSvgIcon)(/* @__PURE__ */ (0, import_jsx_runtime5.jsx)("path", {
        d: "m7 10 5 5 5-5z"
      }), "ArrowDropDown");
    }
  });

  // node_modules/toggle-selection/index.js
  var require_toggle_selection = __commonJS({
    "node_modules/toggle-selection/index.js"(exports, module) {
      module.exports = function() {
        var selection = document.getSelection();
        if (!selection.rangeCount) {
          return function() {
          };
        }
        var active = document.activeElement;
        var ranges = [];
        for (var i2 = 0; i2 < selection.rangeCount; i2++) {
          ranges.push(selection.getRangeAt(i2));
        }
        switch (active.tagName.toUpperCase()) {
          // .toUpperCase handles XHTML
          case "INPUT":
          case "TEXTAREA":
            active.blur();
            break;
          default:
            active = null;
            break;
        }
        selection.removeAllRanges();
        return function() {
          selection.type === "Caret" && selection.removeAllRanges();
          if (!selection.rangeCount) {
            ranges.forEach(function(range) {
              selection.addRange(range);
            });
          }
          active && active.focus();
        };
      };
    }
  });

  // node_modules/copy-to-clipboard/index.js
  var require_copy_to_clipboard = __commonJS({
    "node_modules/copy-to-clipboard/index.js"(exports, module) {
      "use strict";
      var deselectCurrent = require_toggle_selection();
      var clipboardToIE11Formatting = {
        "text/plain": "Text",
        "text/html": "Url",
        "default": "Text"
      };
      var defaultMessage = "Copy to clipboard: #{key}, Enter";
      function format(message) {
        var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
        return message.replace(/#{\s*key\s*}/g, copyKey);
      }
      function copy4(text, options) {
        var debug, message, reselectPrevious, range, selection, mark, success = false;
        if (!options) {
          options = {};
        }
        debug = options.debug || false;
        try {
          reselectPrevious = deselectCurrent();
          range = document.createRange();
          selection = document.getSelection();
          mark = document.createElement("span");
          mark.textContent = text;
          mark.ariaHidden = "true";
          mark.style.all = "unset";
          mark.style.position = "fixed";
          mark.style.top = 0;
          mark.style.clip = "rect(0, 0, 0, 0)";
          mark.style.whiteSpace = "pre";
          mark.style.webkitUserSelect = "text";
          mark.style.MozUserSelect = "text";
          mark.style.msUserSelect = "text";
          mark.style.userSelect = "text";
          mark.addEventListener("copy", function(e2) {
            e2.stopPropagation();
            if (options.format) {
              e2.preventDefault();
              if (typeof e2.clipboardData === "undefined") {
                debug && console.warn("unable to use e.clipboardData");
                debug && console.warn("trying IE specific stuff");
                window.clipboardData.clearData();
                var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
                window.clipboardData.setData(format2, text);
              } else {
                e2.clipboardData.clearData();
                e2.clipboardData.setData(options.format, text);
              }
            }
            if (options.onCopy) {
              e2.preventDefault();
              options.onCopy(e2.clipboardData);
            }
          });
          document.body.appendChild(mark);
          range.selectNodeContents(mark);
          selection.addRange(range);
          var successful = document.execCommand("copy");
          if (!successful) {
            throw new Error("copy command was unsuccessful");
          }
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using execCommand: ", err2);
          debug && console.warn("trying IE specific stuff");
          try {
            window.clipboardData.setData(options.format || "text", text);
            options.onCopy && options.onCopy(window.clipboardData);
            success = true;
          } catch (err3) {
            debug && console.error("unable to copy using clipboardData: ", err3);
            debug && console.error("falling back to prompt");
            message = format("message" in options ? options.message : defaultMessage);
            window.prompt(message, text);
          }
        } finally {
          if (selection) {
            if (typeof selection.removeRange == "function") {
              selection.removeRange(range);
            } else {
              selection.removeAllRanges();
            }
          }
          if (mark) {
            document.body.removeChild(mark);
          }
          reselectPrevious();
        }
        return success;
      }
      module.exports = copy4;
    }
  });

  // node_modules/react-msaview/dist/components/dialogs/TrackInfoDialog.js
  var TrackInfoDialog_exports = {};
  __export(TrackInfoDialog_exports, {
    default: () => TrackInfoDialog_default
  });
  var import_react24, import_ui7, import_material13, import_copy_to_clipboard, import_mobx_react10, import_mui9, useStyles9, TrackInfoDialog, TrackInfoDialog_default;
  var init_TrackInfoDialog = __esm({
    "node_modules/react-msaview/dist/components/dialogs/TrackInfoDialog.js"() {
      import_react24 = __toESM(require_react());
      import_ui7 = __toESM(require_ui());
      import_material13 = __toESM(require_material());
      import_copy_to_clipboard = __toESM(require_copy_to_clipboard());
      import_mobx_react10 = __toESM(require_mobx_react());
      import_mui9 = __toESM(require_mui());
      useStyles9 = (0, import_mui9.makeStyles)()((theme) => ({
        textArea: {
          padding: theme.spacing(2),
          overflow: "auto",
          background: "#ddd",
          wordBreak: "break-word"
        }
      }));
      TrackInfoDialog = (0, import_mobx_react10.observer)(function({ model, onClose }) {
        const [label, setLabel] = (0, import_react24.useState)("Copy to clipboard");
        const { classes } = useStyles9();
        return import_react24.default.createElement(
          import_ui7.Dialog,
          { open: true, onClose, fullWidth: true, maxWidth: "lg", title: `Track info - ${model.name}` },
          import_react24.default.createElement(
            import_material13.DialogContent,
            null,
            import_react24.default.createElement(import_material13.Button, { variant: "contained", color: "primary", onClick: () => {
              (0, import_copy_to_clipboard.default)(model.data);
              setLabel("Copied!");
              setTimeout(() => {
                setLabel("Copy to clipboard");
              }, 300);
            } }, label),
            import_react24.default.createElement("pre", { className: classes.textArea }, model.data)
          ),
          import_react24.default.createElement(
            import_material13.DialogActions,
            null,
            import_react24.default.createElement(import_material13.Button, { variant: "contained", onClick: onClose, color: "secondary" }, "Close")
          )
        );
      });
      TrackInfoDialog_default = TrackInfoDialog;
    }
  });

  // node_modules/react-msaview/dist/components/Track.js
  var import_react25, import_material14, import_mobx_react11, import_mui10, TrackInfoDialog2, useStyles10, TrackLabel, Track, Track_default;
  var init_Track = __esm({
    "node_modules/react-msaview/dist/components/Track.js"() {
      import_react25 = __toESM(require_react());
      init_ArrowDropDown();
      import_material14 = __toESM(require_material());
      import_mobx_react11 = __toESM(require_mobx_react());
      import_mui10 = __toESM(require_mui());
      TrackInfoDialog2 = (0, import_react25.lazy)(() => Promise.resolve().then(() => (init_TrackInfoDialog(), TrackInfoDialog_exports)));
      useStyles10 = (0, import_mui10.makeStyles)()({
        button: {
          padding: 0
        }
      });
      TrackLabel = (0, import_mobx_react11.observer)(function({ model, track }) {
        const [anchorEl, setAnchorEl] = (0, import_react25.useState)();
        const { drawLabels, rowHeight, treeAreaWidth: width } = model;
        const { model: { name, height } } = track;
        const { classes } = useStyles10();
        const trackLabelHeight = Math.max(8, rowHeight - 8);
        return import_react25.default.createElement(
          "div",
          { style: {
            width,
            height,
            flexShrink: 0,
            textAlign: "right",
            fontSize: trackLabelHeight
          } },
          drawLabels ? name : "",
          " ",
          import_react25.default.createElement(
            import_material14.IconButton,
            { className: classes.button, style: {
              width: trackLabelHeight,
              height: trackLabelHeight
            }, onClick: (event) => {
              setAnchorEl(event.currentTarget);
            } },
            import_react25.default.createElement(ArrowDropDown_default, null)
          ),
          anchorEl ? import_react25.default.createElement(
            import_material14.Menu,
            { anchorEl, transitionDuration: 0, open: true, onClose: () => {
              setAnchorEl(void 0);
            } },
            import_react25.default.createElement(import_material14.MenuItem, { dense: true, onClick: () => {
              model.toggleTrack(track.model.id);
              setAnchorEl(void 0);
            } }, "Close"),
            import_react25.default.createElement(import_material14.MenuItem, { dense: true, onClick: () => {
              model.queueDialog((onClose) => [
                TrackInfoDialog2,
                { onClose, model: track.model }
              ]);
              setAnchorEl(void 0);
            } }, "Get info")
          ) : null
        );
      });
      Track = (0, import_mobx_react11.observer)(function({ model, track }) {
        const { resizeHandleWidth, colWidth, scrollX, numColumns } = model;
        const { model: { height, error: error2 } } = track;
        const ref = (0, import_react25.useRef)(null);
        const scheduled = (0, import_react25.useRef)(false);
        const deltaX = (0, import_react25.useRef)(0);
        (0, import_react25.useEffect)(() => {
          const curr = ref.current;
          if (!curr) {
            return;
          }
          function onWheel(event) {
            deltaX.current += event.deltaX;
            if (!scheduled.current) {
              scheduled.current = true;
              requestAnimationFrame(() => {
                model.doScrollX(-deltaX.current);
                deltaX.current = 0;
                scheduled.current = false;
              });
            }
            event.preventDefault();
          }
          curr.addEventListener("wheel", onWheel);
          return () => {
            curr.removeEventListener("wheel", onWheel);
          };
        }, [model]);
        return import_react25.default.createElement(
          "div",
          { key: track.id, style: { display: "flex", height } },
          import_react25.default.createElement(TrackLabel, { model, track }),
          import_react25.default.createElement("div", { style: { width: resizeHandleWidth, flexShrink: 0 } }),
          import_react25.default.createElement("div", { ref, onMouseMove: (event) => {
            if (!ref.current) {
              return;
            }
            const { left } = ref.current.getBoundingClientRect();
            const mouseX = event.clientX - left - scrollX;
            const col = Math.floor(mouseX / colWidth);
            if (col >= 0 && col < numColumns) {
              model.setMousePos(col, void 0);
            } else {
              model.setMousePos(void 0, void 0);
            }
          }, onMouseLeave: () => {
            model.setMousePos(void 0, void 0);
          } }, error2 ? import_react25.default.createElement("div", { style: { color: "red", fontSize: 10 } }, `${error2}`) : import_react25.default.createElement(track.ReactComponent, { model, track }))
        );
      });
      Track_default = Track;
    }
  });

  // node_modules/react-msaview/dist/components/VerticalScrollbar.js
  var import_react26, import_util24, import_mobx_react12, VerticalScrollbar, VerticalScrollbar_default;
  var init_VerticalScrollbar = __esm({
    "node_modules/react-msaview/dist/components/VerticalScrollbar.js"() {
      import_react26 = __toESM(require_react());
      import_util24 = __toESM(require_util());
      import_mobx_react12 = __toESM(require_mobx_react());
      VerticalScrollbar = (0, import_mobx_react12.observer)(({ model }) => {
        const { msaAreaHeight, scrollY, totalHeight } = model;
        const [hovered, setHovered] = (0, import_react26.useState)(false);
        const scheduled = (0, import_react26.useRef)(false);
        const [mouseDown, setMouseDown] = (0, import_react26.useState)();
        const fill = "rgba(66, 119, 127, 0.3)";
        const unit = msaAreaHeight / totalHeight;
        const top = -scrollY;
        const bottom = top + msaAreaHeight;
        const t2 = top * unit;
        const b2 = bottom * unit;
        (0, import_react26.useEffect)(() => {
          function fn(event) {
            if (mouseDown !== void 0) {
              if (!scheduled.current) {
                scheduled.current = true;
                window.requestAnimationFrame(() => {
                  model.setScrollY((0, import_util24.clamp)(mouseDown.scrollY - (event.clientY - mouseDown.clientY) / unit, -totalHeight, 0));
                  scheduled.current = false;
                });
              }
            }
          }
          function fn2() {
            setMouseDown(void 0);
          }
          if (mouseDown !== void 0) {
            document.addEventListener("mousemove", fn);
            document.addEventListener("mouseup", fn2);
            return () => {
              document.removeEventListener("mousemove", fn);
              document.removeEventListener("mousemove", fn2);
            };
          }
        }, [model, unit, totalHeight, mouseDown]);
        return import_react26.default.createElement(
          "div",
          { style: {
            position: "relative",
            width: 20,
            height: msaAreaHeight,
            borderLeft: "1px solid #555",
            borderTop: "1px solid #555",
            boxSizing: "border-box"
          } },
          import_react26.default.createElement("div", { style: {
            position: "absolute",
            top: Math.max(0, t2),
            left: 0,
            background: hovered ? "rgba(66,119,127,0.6)" : fill,
            cursor: "pointer",
            boxSizing: "border-box",
            width: 20,
            height: Math.max(b2 - t2, 20),
            zIndex: 100
          }, onMouseOver: () => {
            setHovered(true);
          }, onMouseOut: () => {
            setHovered(false);
          }, onMouseDown: (event) => {
            setMouseDown({
              clientY: event.clientY,
              scrollY: model.scrollY
            });
          } })
        );
      });
      VerticalScrollbar_default = VerticalScrollbar;
    }
  });

  // node_modules/@mui/icons-material/esm/Help.js
  var import_jsx_runtime6, Help_default;
  var init_Help = __esm({
    "node_modules/@mui/icons-material/esm/Help.js"() {
      "use client";
      init_createSvgIcon();
      import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
      Help_default = (0, import_utils.createSvgIcon)(/* @__PURE__ */ (0, import_jsx_runtime6.jsx)("path", {
        d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m1 17h-2v-2h2zm2.07-7.75-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25"
      }), "Help");
    }
  });

  // node_modules/react-msaview/dist/components/header/GappynessSlider.js
  var import_react27, import_material15, import_mobx_react13, GappynessSlider, GappynessSlider_default;
  var init_GappynessSlider = __esm({
    "node_modules/react-msaview/dist/components/header/GappynessSlider.js"() {
      import_react27 = __toESM(require_react());
      import_material15 = __toESM(require_material());
      import_mobx_react13 = __toESM(require_mobx_react());
      GappynessSlider = (0, import_mobx_react13.observer)(function GappynessSlider2({ model }) {
        const { hideGaps, allowedGappyness } = model;
        if (!hideGaps) {
          return null;
        }
        return import_react27.default.createElement(
          "div",
          { style: { display: "flex", alignItems: "center", gap: 8 } },
          import_react27.default.createElement(
            import_material15.Typography,
            { style: { whiteSpace: "nowrap" } },
            "Hide columns w/ >",
            allowedGappyness,
            "% gaps"
          ),
          import_react27.default.createElement(import_material15.Slider, { style: { width: 100 }, min: 1, max: 100, value: allowedGappyness, onChange: (_, val) => {
            model.setAllowedGappyness(val);
          } })
        );
      });
      GappynessSlider_default = GappynessSlider;
    }
  });

  // node_modules/react-msaview/dist/components/header/HeaderInfoArea.js
  var import_react28, import_material16, import_mobx_react14, import_mui11, useStyles11, HeaderInfoArea, HeaderInfoArea_default;
  var init_HeaderInfoArea = __esm({
    "node_modules/react-msaview/dist/components/header/HeaderInfoArea.js"() {
      import_react28 = __toESM(require_react());
      import_material16 = __toESM(require_material());
      import_mobx_react14 = __toESM(require_mobx_react());
      import_mui11 = __toESM(require_mui());
      useStyles11 = (0, import_mui11.makeStyles)()({
        margin: {
          margin: "auto",
          marginLeft: 10
        }
      });
      HeaderInfoArea = (0, import_mobx_react14.observer)(function({ model }) {
        const { mouseOverRowName, mouseCol } = model;
        const { classes } = useStyles11();
        return mouseOverRowName && mouseCol !== void 0 ? import_react28.default.createElement(
          import_material16.Typography,
          { className: classes.margin },
          mouseOverRowName,
          ":",
          model.visibleColToSeqPosOneBased(mouseOverRowName, mouseCol),
          " (",
          model.visibleColToRowLetter(mouseOverRowName, mouseCol),
          ")"
        ) : null;
      });
      HeaderInfoArea_default = HeaderInfoArea;
    }
  });

  // node_modules/@mui/icons-material/utils/createSvgIcon.js
  var require_createSvgIcon = __commonJS({
    "node_modules/@mui/icons-material/utils/createSvgIcon.js"(exports) {
      "use strict";
      "use client";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "default", {
        enumerable: true,
        get: function() {
          return _utils.createSvgIcon;
        }
      });
      var _utils = require_utils();
    }
  });

  // node_modules/@mui/icons-material/ChevronRight.js
  var require_ChevronRight = __commonJS({
    "node_modules/@mui/icons-material/ChevronRight.js"(exports) {
      "use strict";
      "use client";
      var _interopRequireDefault = require_interopRequireDefault().default;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
      var _jsxRuntime = require_jsx_runtime();
      var _default = exports.default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
        d: "M10 6 8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"
      }), "ChevronRight");
    }
  });

  // node_modules/@mui/icons-material/HelpOutline.js
  var require_HelpOutline = __commonJS({
    "node_modules/@mui/icons-material/HelpOutline.js"(exports) {
      "use strict";
      "use client";
      var _interopRequireDefault = require_interopRequireDefault().default;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
      var _jsxRuntime = require_jsx_runtime();
      var _default = exports.default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
        d: "M11 18h2v-2h-2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8m0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4"
      }), "HelpOutline");
    }
  });

  // node_modules/@mui/icons-material/Close.js
  var require_Close = __commonJS({
    "node_modules/@mui/icons-material/Close.js"(exports) {
      "use strict";
      "use client";
      var _interopRequireDefault = require_interopRequireDefault().default;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
      var _jsxRuntime = require_jsx_runtime();
      var _default = exports.default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
        d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
      }), "Close");
    }
  });

  // node_modules/@mui/icons-material/Refresh.js
  var require_Refresh = __commonJS({
    "node_modules/@mui/icons-material/Refresh.js"(exports) {
      "use strict";
      "use client";
      var _interopRequireDefault = require_interopRequireDefault().default;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
      var _jsxRuntime = require_jsx_runtime();
      var _default = exports.default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
        d: "M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4z"
      }), "Refresh");
    }
  });

  // node_modules/@mui/icons-material/Report.js
  var require_Report = __commonJS({
    "node_modules/@mui/icons-material/Report.js"(exports) {
      "use strict";
      "use client";
      var _interopRequireDefault = require_interopRequireDefault().default;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
      var _jsxRuntime = require_jsx_runtime();
      var _default = exports.default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
        d: "M15.73 3H8.27L3 8.27v7.46L8.27 21h7.46L21 15.73V8.27zM12 17.3c-.72 0-1.3-.58-1.3-1.3s.58-1.3 1.3-1.3 1.3.58 1.3 1.3-.58 1.3-1.3 1.3m1-4.3h-2V7h2z"
      }), "Report");
    }
  });

  // node_modules/@jbrowse/core/ui/RedErrorMessageBox.js
  var require_RedErrorMessageBox = __commonJS({
    "node_modules/@jbrowse/core/ui/RedErrorMessageBox.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = RedErrorMessageBox;
      var jsx_runtime_1 = require_jsx_runtime();
      var mui_1 = require_mui();
      var useStyles18 = (0, mui_1.makeStyles)()((theme) => ({
        bg: {
          padding: 4,
          margin: 4,
          overflow: "auto",
          maxHeight: 200,
          background: theme.palette.mode === "dark" ? "#833" : "#f88",
          border: `1px solid ${theme.palette.divider}`
        }
      }));
      function RedErrorMessageBox({ children }) {
        const { classes } = useStyles18();
        return (0, jsx_runtime_1.jsx)("div", { className: classes.bg, children });
      }
    }
  });

  // node_modules/source-map-js/lib/base64.js
  var require_base64 = __commonJS({
    "node_modules/source-map-js/lib/base64.js"(exports) {
      var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
      exports.encode = function(number) {
        if (0 <= number && number < intToCharMap.length) {
          return intToCharMap[number];
        }
        throw new TypeError("Must be between 0 and 63: " + number);
      };
      exports.decode = function(charCode) {
        var bigA = 65;
        var bigZ = 90;
        var littleA = 97;
        var littleZ = 122;
        var zero2 = 48;
        var nine = 57;
        var plus = 43;
        var slash = 47;
        var littleOffset = 26;
        var numberOffset = 52;
        if (bigA <= charCode && charCode <= bigZ) {
          return charCode - bigA;
        }
        if (littleA <= charCode && charCode <= littleZ) {
          return charCode - littleA + littleOffset;
        }
        if (zero2 <= charCode && charCode <= nine) {
          return charCode - zero2 + numberOffset;
        }
        if (charCode == plus) {
          return 62;
        }
        if (charCode == slash) {
          return 63;
        }
        return -1;
      };
    }
  });

  // node_modules/source-map-js/lib/base64-vlq.js
  var require_base64_vlq = __commonJS({
    "node_modules/source-map-js/lib/base64-vlq.js"(exports) {
      var base64 = require_base64();
      var VLQ_BASE_SHIFT = 5;
      var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
      var VLQ_BASE_MASK = VLQ_BASE - 1;
      var VLQ_CONTINUATION_BIT = VLQ_BASE;
      function toVLQSigned(aValue) {
        return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
      }
      function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1;
        var shifted = aValue >> 1;
        return isNegative ? -shifted : shifted;
      }
      exports.encode = function base64VLQ_encode(aValue) {
        var encoded = "";
        var digit;
        var vlq = toVLQSigned(aValue);
        do {
          digit = vlq & VLQ_BASE_MASK;
          vlq >>>= VLQ_BASE_SHIFT;
          if (vlq > 0) {
            digit |= VLQ_CONTINUATION_BIT;
          }
          encoded += base64.encode(digit);
        } while (vlq > 0);
        return encoded;
      };
      exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
        var strLen = aStr.length;
        var result = 0;
        var shift4 = 0;
        var continuation, digit;
        do {
          if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
          }
          digit = base64.decode(aStr.charCodeAt(aIndex++));
          if (digit === -1) {
            throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
          }
          continuation = !!(digit & VLQ_CONTINUATION_BIT);
          digit &= VLQ_BASE_MASK;
          result = result + (digit << shift4);
          shift4 += VLQ_BASE_SHIFT;
        } while (continuation);
        aOutParam.value = fromVLQSigned(result);
        aOutParam.rest = aIndex;
      };
    }
  });

  // node_modules/source-map-js/lib/util.js
  var require_util7 = __commonJS({
    "node_modules/source-map-js/lib/util.js"(exports) {
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports.getArg = getArg;
      var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
      var dataUrlRegexp = /^data:.+\,.+$/;
      function urlParse(aUrl) {
        var match2 = aUrl.match(urlRegexp);
        if (!match2) {
          return null;
        }
        return {
          scheme: match2[1],
          auth: match2[2],
          host: match2[3],
          port: match2[4],
          path: match2[5]
        };
      }
      exports.urlParse = urlParse;
      function urlGenerate(aParsedUrl) {
        var url = "";
        if (aParsedUrl.scheme) {
          url += aParsedUrl.scheme + ":";
        }
        url += "//";
        if (aParsedUrl.auth) {
          url += aParsedUrl.auth + "@";
        }
        if (aParsedUrl.host) {
          url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url += ":" + aParsedUrl.port;
        }
        if (aParsedUrl.path) {
          url += aParsedUrl.path;
        }
        return url;
      }
      exports.urlGenerate = urlGenerate;
      var MAX_CACHED_INPUTS = 32;
      function lruMemoize(f2) {
        var cache2 = [];
        return function(input) {
          for (var i2 = 0; i2 < cache2.length; i2++) {
            if (cache2[i2].input === input) {
              var temp = cache2[0];
              cache2[0] = cache2[i2];
              cache2[i2] = temp;
              return cache2[0].result;
            }
          }
          var result = f2(input);
          cache2.unshift({
            input,
            result
          });
          if (cache2.length > MAX_CACHED_INPUTS) {
            cache2.pop();
          }
          return result;
        };
      }
      var normalize2 = lruMemoize(function normalize3(aPath) {
        var path = aPath;
        var url = urlParse(aPath);
        if (url) {
          if (!url.path) {
            return aPath;
          }
          path = url.path;
        }
        var isAbsolute = exports.isAbsolute(path);
        var parts = [];
        var start = 0;
        var i2 = 0;
        while (true) {
          start = i2;
          i2 = path.indexOf("/", start);
          if (i2 === -1) {
            parts.push(path.slice(start));
            break;
          } else {
            parts.push(path.slice(start, i2));
            while (i2 < path.length && path[i2] === "/") {
              i2++;
            }
          }
        }
        for (var part, up = 0, i2 = parts.length - 1; i2 >= 0; i2--) {
          part = parts[i2];
          if (part === ".") {
            parts.splice(i2, 1);
          } else if (part === "..") {
            up++;
          } else if (up > 0) {
            if (part === "") {
              parts.splice(i2 + 1, up);
              up = 0;
            } else {
              parts.splice(i2, 2);
              up--;
            }
          }
        }
        path = parts.join("/");
        if (path === "") {
          path = isAbsolute ? "/" : ".";
        }
        if (url) {
          url.path = path;
          return urlGenerate(url);
        }
        return path;
      });
      exports.normalize = normalize2;
      function join(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        if (aPath === "") {
          aPath = ".";
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
          aRoot = aRootUrl.path || "/";
        }
        if (aPathUrl && !aPathUrl.scheme) {
          if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
          }
          return urlGenerate(aPathUrl);
        }
        if (aPathUrl || aPath.match(dataUrlRegexp)) {
          return aPath;
        }
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
          aRootUrl.host = aPath;
          return urlGenerate(aRootUrl);
        }
        var joined = aPath.charAt(0) === "/" ? aPath : normalize2(aRoot.replace(/\/+$/, "") + "/" + aPath);
        if (aRootUrl) {
          aRootUrl.path = joined;
          return urlGenerate(aRootUrl);
        }
        return joined;
      }
      exports.join = join;
      exports.isAbsolute = function(aPath) {
        return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
      };
      function relative(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        aRoot = aRoot.replace(/\/$/, "");
        var level = 0;
        while (aPath.indexOf(aRoot + "/") !== 0) {
          var index3 = aRoot.lastIndexOf("/");
          if (index3 < 0) {
            return aPath;
          }
          aRoot = aRoot.slice(0, index3);
          if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
            return aPath;
          }
          ++level;
        }
        return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
      }
      exports.relative = relative;
      var supportsNullProto = (function() {
        var obj = /* @__PURE__ */ Object.create(null);
        return !("__proto__" in obj);
      })();
      function identity(s2) {
        return s2;
      }
      function toSetString(aStr) {
        if (isProtoString(aStr)) {
          return "$" + aStr;
        }
        return aStr;
      }
      exports.toSetString = supportsNullProto ? identity : toSetString;
      function fromSetString(aStr) {
        if (isProtoString(aStr)) {
          return aStr.slice(1);
        }
        return aStr;
      }
      exports.fromSetString = supportsNullProto ? identity : fromSetString;
      function isProtoString(s2) {
        if (!s2) {
          return false;
        }
        var length2 = s2.length;
        if (length2 < 9) {
          return false;
        }
        if (s2.charCodeAt(length2 - 1) !== 95 || s2.charCodeAt(length2 - 2) !== 95 || s2.charCodeAt(length2 - 3) !== 111 || s2.charCodeAt(length2 - 4) !== 116 || s2.charCodeAt(length2 - 5) !== 111 || s2.charCodeAt(length2 - 6) !== 114 || s2.charCodeAt(length2 - 7) !== 112 || s2.charCodeAt(length2 - 8) !== 95 || s2.charCodeAt(length2 - 9) !== 95) {
          return false;
        }
        for (var i2 = length2 - 10; i2 >= 0; i2--) {
          if (s2.charCodeAt(i2) !== 36) {
            return false;
          }
        }
        return true;
      }
      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0 || onlyCompareOriginal) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByOriginalPositions = compareByOriginalPositions;
      function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
        var cmp;
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0 || onlyCompareOriginal) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
      function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0 || onlyCompareGenerated) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
      function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
        var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0 || onlyCompareGenerated) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
      function strcmp(aStr1, aStr2) {
        if (aStr1 === aStr2) {
          return 0;
        }
        if (aStr1 === null) {
          return 1;
        }
        if (aStr2 === null) {
          return -1;
        }
        if (aStr1 > aStr2) {
          return 1;
        }
        return -1;
      }
      function compareByGeneratedPositionsInflated(mappingA, mappingB) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
      function parseSourceMapInput(str) {
        return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
      }
      exports.parseSourceMapInput = parseSourceMapInput;
      function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
        sourceURL = sourceURL || "";
        if (sourceRoot) {
          if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
            sourceRoot += "/";
          }
          sourceURL = sourceRoot + sourceURL;
        }
        if (sourceMapURL) {
          var parsed = urlParse(sourceMapURL);
          if (!parsed) {
            throw new Error("sourceMapURL could not be parsed");
          }
          if (parsed.path) {
            var index3 = parsed.path.lastIndexOf("/");
            if (index3 >= 0) {
              parsed.path = parsed.path.substring(0, index3 + 1);
            }
          }
          sourceURL = join(urlGenerate(parsed), sourceURL);
        }
        return normalize2(sourceURL);
      }
      exports.computeSourceURL = computeSourceURL;
    }
  });

  // node_modules/source-map-js/lib/array-set.js
  var require_array_set = __commonJS({
    "node_modules/source-map-js/lib/array-set.js"(exports) {
      var util = require_util7();
      var has2 = Object.prototype.hasOwnProperty;
      var hasNativeMap = typeof Map !== "undefined";
      function ArraySet() {
        this._array = [];
        this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
      }
      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
        var set = new ArraySet();
        for (var i2 = 0, len2 = aArray.length; i2 < len2; i2++) {
          set.add(aArray[i2], aAllowDuplicates);
        }
        return set;
      };
      ArraySet.prototype.size = function ArraySet_size() {
        return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
      };
      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
        var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
        var isDuplicate = hasNativeMap ? this.has(aStr) : has2.call(this._set, sStr);
        var idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          if (hasNativeMap) {
            this._set.set(aStr, idx);
          } else {
            this._set[sStr] = idx;
          }
        }
      };
      ArraySet.prototype.has = function ArraySet_has(aStr) {
        if (hasNativeMap) {
          return this._set.has(aStr);
        } else {
          var sStr = util.toSetString(aStr);
          return has2.call(this._set, sStr);
        }
      };
      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
        if (hasNativeMap) {
          var idx = this._set.get(aStr);
          if (idx >= 0) {
            return idx;
          }
        } else {
          var sStr = util.toSetString(aStr);
          if (has2.call(this._set, sStr)) {
            return this._set[sStr];
          }
        }
        throw new Error('"' + aStr + '" is not in the set.');
      };
      ArraySet.prototype.at = function ArraySet_at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error("No element indexed by " + aIdx);
      };
      ArraySet.prototype.toArray = function ArraySet_toArray() {
        return this._array.slice();
      };
      exports.ArraySet = ArraySet;
    }
  });

  // node_modules/source-map-js/lib/mapping-list.js
  var require_mapping_list = __commonJS({
    "node_modules/source-map-js/lib/mapping-list.js"(exports) {
      var util = require_util7();
      function generatedPositionAfter(mappingA, mappingB) {
        var lineA = mappingA.generatedLine;
        var lineB = mappingB.generatedLine;
        var columnA = mappingA.generatedColumn;
        var columnB = mappingB.generatedColumn;
        return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
      }
      function MappingList() {
        this._array = [];
        this._sorted = true;
        this._last = { generatedLine: -1, generatedColumn: 0 };
      }
      MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
        this._array.forEach(aCallback, aThisArg);
      };
      MappingList.prototype.add = function MappingList_add(aMapping) {
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      };
      MappingList.prototype.toArray = function MappingList_toArray() {
        if (!this._sorted) {
          this._array.sort(util.compareByGeneratedPositionsInflated);
          this._sorted = true;
        }
        return this._array;
      };
      exports.MappingList = MappingList;
    }
  });

  // node_modules/source-map-js/lib/source-map-generator.js
  var require_source_map_generator = __commonJS({
    "node_modules/source-map-js/lib/source-map-generator.js"(exports) {
      var base64VLQ = require_base64_vlq();
      var util = require_util7();
      var ArraySet = require_array_set().ArraySet;
      var MappingList = require_mapping_list().MappingList;
      function SourceMapGenerator(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, "file", null);
        this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
        this._skipValidation = util.getArg(aArgs, "skipValidation", false);
        this._ignoreInvalidMapping = util.getArg(aArgs, "ignoreInvalidMapping", false);
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = new MappingList();
        this._sourcesContents = null;
      }
      SourceMapGenerator.prototype._version = 3;
      SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
        var sourceRoot = aSourceMapConsumer.sourceRoot;
        var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {
          file: aSourceMapConsumer.file,
          sourceRoot
        }));
        aSourceMapConsumer.eachMapping(function(mapping) {
          var newMapping = {
            generated: {
              line: mapping.generatedLine,
              column: mapping.generatedColumn
            }
          };
          if (mapping.source != null) {
            newMapping.source = mapping.source;
            if (sourceRoot != null) {
              newMapping.source = util.relative(sourceRoot, newMapping.source);
            }
            newMapping.original = {
              line: mapping.originalLine,
              column: mapping.originalColumn
            };
            if (mapping.name != null) {
              newMapping.name = mapping.name;
            }
          }
          generator.addMapping(newMapping);
        });
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          var sourceRelative = sourceFile;
          if (sourceRoot !== null) {
            sourceRelative = util.relative(sourceRoot, sourceFile);
          }
          if (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
          }
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            generator.setSourceContent(sourceFile, content);
          }
        });
        return generator;
      };
      SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
        var generated = util.getArg(aArgs, "generated");
        var original = util.getArg(aArgs, "original", null);
        var source = util.getArg(aArgs, "source", null);
        var name = util.getArg(aArgs, "name", null);
        if (!this._skipValidation) {
          if (this._validateMapping(generated, original, source, name) === false) {
            return;
          }
        }
        if (source != null) {
          source = String(source);
          if (!this._sources.has(source)) {
            this._sources.add(source);
          }
        }
        if (name != null) {
          name = String(name);
          if (!this._names.has(name)) {
            this._names.add(name);
          }
        }
        this._mappings.add({
          generatedLine: generated.line,
          generatedColumn: generated.column,
          originalLine: original != null && original.line,
          originalColumn: original != null && original.column,
          source,
          name
        });
      };
      SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
        var source = aSourceFile;
        if (this._sourceRoot != null) {
          source = util.relative(this._sourceRoot, source);
        }
        if (aSourceContent != null) {
          if (!this._sourcesContents) {
            this._sourcesContents = /* @__PURE__ */ Object.create(null);
          }
          this._sourcesContents[util.toSetString(source)] = aSourceContent;
        } else if (this._sourcesContents) {
          delete this._sourcesContents[util.toSetString(source)];
          if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
          }
        }
      };
      SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
        var sourceFile = aSourceFile;
        if (aSourceFile == null) {
          if (aSourceMapConsumer.file == null) {
            throw new Error(
              `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
            );
          }
          sourceFile = aSourceMapConsumer.file;
        }
        var sourceRoot = this._sourceRoot;
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        var newSources = new ArraySet();
        var newNames = new ArraySet();
        this._mappings.unsortedForEach(function(mapping) {
          if (mapping.source === sourceFile && mapping.originalLine != null) {
            var original = aSourceMapConsumer.originalPositionFor({
              line: mapping.originalLine,
              column: mapping.originalColumn
            });
            if (original.source != null) {
              mapping.source = original.source;
              if (aSourceMapPath != null) {
                mapping.source = util.join(aSourceMapPath, mapping.source);
              }
              if (sourceRoot != null) {
                mapping.source = util.relative(sourceRoot, mapping.source);
              }
              mapping.originalLine = original.line;
              mapping.originalColumn = original.column;
              if (original.name != null) {
                mapping.name = original.name;
              }
            }
          }
          var source = mapping.source;
          if (source != null && !newSources.has(source)) {
            newSources.add(source);
          }
          var name = mapping.name;
          if (name != null && !newNames.has(name)) {
            newNames.add(name);
          }
        }, this);
        this._sources = newSources;
        this._names = newNames;
        aSourceMapConsumer.sources.forEach(function(sourceFile2) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
          if (content != null) {
            if (aSourceMapPath != null) {
              sourceFile2 = util.join(aSourceMapPath, sourceFile2);
            }
            if (sourceRoot != null) {
              sourceFile2 = util.relative(sourceRoot, sourceFile2);
            }
            this.setSourceContent(sourceFile2, content);
          }
        }, this);
      };
      SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
        if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
          var message = "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.";
          if (this._ignoreInvalidMapping) {
            if (typeof console !== "undefined" && console.warn) {
              console.warn(message);
            }
            return false;
          } else {
            throw new Error(message);
          }
        }
        if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
          return;
        } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
          return;
        } else {
          var message = "Invalid mapping: " + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
          });
          if (this._ignoreInvalidMapping) {
            if (typeof console !== "undefined" && console.warn) {
              console.warn(message);
            }
            return false;
          } else {
            throw new Error(message);
          }
        }
      };
      SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
        var previousGeneratedColumn = 0;
        var previousGeneratedLine = 1;
        var previousOriginalColumn = 0;
        var previousOriginalLine = 0;
        var previousName = 0;
        var previousSource = 0;
        var result = "";
        var next2;
        var mapping;
        var nameIdx;
        var sourceIdx;
        var mappings = this._mappings.toArray();
        for (var i2 = 0, len2 = mappings.length; i2 < len2; i2++) {
          mapping = mappings[i2];
          next2 = "";
          if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while (mapping.generatedLine !== previousGeneratedLine) {
              next2 += ";";
              previousGeneratedLine++;
            }
          } else {
            if (i2 > 0) {
              if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i2 - 1])) {
                continue;
              }
              next2 += ",";
            }
          }
          next2 += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
          previousGeneratedColumn = mapping.generatedColumn;
          if (mapping.source != null) {
            sourceIdx = this._sources.indexOf(mapping.source);
            next2 += base64VLQ.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;
            next2 += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;
            next2 += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;
            if (mapping.name != null) {
              nameIdx = this._names.indexOf(mapping.name);
              next2 += base64VLQ.encode(nameIdx - previousName);
              previousName = nameIdx;
            }
          }
          result += next2;
        }
        return result;
      };
      SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
        return aSources.map(function(source) {
          if (!this._sourcesContents) {
            return null;
          }
          if (aSourceRoot != null) {
            source = util.relative(aSourceRoot, source);
          }
          var key = util.toSetString(source);
          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
        }, this);
      };
      SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
        var map = {
          version: this._version,
          sources: this._sources.toArray(),
          names: this._names.toArray(),
          mappings: this._serializeMappings()
        };
        if (this._file != null) {
          map.file = this._file;
        }
        if (this._sourceRoot != null) {
          map.sourceRoot = this._sourceRoot;
        }
        if (this._sourcesContents) {
          map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
        }
        return map;
      };
      SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
        return JSON.stringify(this.toJSON());
      };
      exports.SourceMapGenerator = SourceMapGenerator;
    }
  });

  // node_modules/source-map-js/lib/binary-search.js
  var require_binary_search = __commonJS({
    "node_modules/source-map-js/lib/binary-search.js"(exports) {
      exports.GREATEST_LOWER_BOUND = 1;
      exports.LEAST_UPPER_BOUND = 2;
      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
        var mid = Math.floor((aHigh - aLow) / 2) + aLow;
        var cmp = aCompare(aNeedle, aHaystack[mid], true);
        if (cmp === 0) {
          return mid;
        } else if (cmp > 0) {
          if (aHigh - mid > 1) {
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
          }
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return aHigh < aHaystack.length ? aHigh : -1;
          } else {
            return mid;
          }
        } else {
          if (mid - aLow > 1) {
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
          }
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return mid;
          } else {
            return aLow < 0 ? -1 : aLow;
          }
        }
      }
      exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
        if (aHaystack.length === 0) {
          return -1;
        }
        var index3 = recursiveSearch(
          -1,
          aHaystack.length,
          aNeedle,
          aHaystack,
          aCompare,
          aBias || exports.GREATEST_LOWER_BOUND
        );
        if (index3 < 0) {
          return -1;
        }
        while (index3 - 1 >= 0) {
          if (aCompare(aHaystack[index3], aHaystack[index3 - 1], true) !== 0) {
            break;
          }
          --index3;
        }
        return index3;
      };
    }
  });

  // node_modules/source-map-js/lib/quick-sort.js
  var require_quick_sort = __commonJS({
    "node_modules/source-map-js/lib/quick-sort.js"(exports) {
      function SortTemplate(comparator) {
        function swap2(ary, x2, y2) {
          var temp = ary[x2];
          ary[x2] = ary[y2];
          ary[y2] = temp;
        }
        function randomIntInRange(low, high) {
          return Math.round(low + Math.random() * (high - low));
        }
        function doQuickSort(ary, comparator2, p2, r2) {
          if (p2 < r2) {
            var pivotIndex = randomIntInRange(p2, r2);
            var i2 = p2 - 1;
            swap2(ary, pivotIndex, r2);
            var pivot = ary[r2];
            for (var j2 = p2; j2 < r2; j2++) {
              if (comparator2(ary[j2], pivot, false) <= 0) {
                i2 += 1;
                swap2(ary, i2, j2);
              }
            }
            swap2(ary, i2 + 1, j2);
            var q = i2 + 1;
            doQuickSort(ary, comparator2, p2, q - 1);
            doQuickSort(ary, comparator2, q + 1, r2);
          }
        }
        return doQuickSort;
      }
      function cloneSort(comparator) {
        let template = SortTemplate.toString();
        let templateFn = new Function(`return ${template}`)();
        return templateFn(comparator);
      }
      var sortCache = /* @__PURE__ */ new WeakMap();
      exports.quickSort = function(ary, comparator, start = 0) {
        let doQuickSort = sortCache.get(comparator);
        if (doQuickSort === void 0) {
          doQuickSort = cloneSort(comparator);
          sortCache.set(comparator, doQuickSort);
        }
        doQuickSort(ary, comparator, start, ary.length - 1);
      };
    }
  });

  // node_modules/source-map-js/lib/source-map-consumer.js
  var require_source_map_consumer = __commonJS({
    "node_modules/source-map-js/lib/source-map-consumer.js"(exports) {
      var util = require_util7();
      var binarySearch = require_binary_search();
      var ArraySet = require_array_set().ArraySet;
      var base64VLQ = require_base64_vlq();
      var quickSort = require_quick_sort().quickSort;
      function SourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
      }
      SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
        return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
      };
      SourceMapConsumer.prototype._version = 3;
      SourceMapConsumer.prototype.__generatedMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
        configurable: true,
        enumerable: true,
        get: function() {
          if (!this.__generatedMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__generatedMappings;
        }
      });
      SourceMapConsumer.prototype.__originalMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
        configurable: true,
        enumerable: true,
        get: function() {
          if (!this.__originalMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__originalMappings;
        }
      });
      SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index3) {
        var c2 = aStr.charAt(index3);
        return c2 === ";" || c2 === ",";
      };
      SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        throw new Error("Subclasses must implement _parseMappings");
      };
      SourceMapConsumer.GENERATED_ORDER = 1;
      SourceMapConsumer.ORIGINAL_ORDER = 2;
      SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
      SourceMapConsumer.LEAST_UPPER_BOUND = 2;
      SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
        var context2 = aContext || null;
        var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
        var mappings;
        switch (order) {
          case SourceMapConsumer.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
          case SourceMapConsumer.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
          default:
            throw new Error("Unknown order of iteration.");
        }
        var sourceRoot = this.sourceRoot;
        var boundCallback = aCallback.bind(context2);
        var names = this._names;
        var sources = this._sources;
        var sourceMapURL = this._sourceMapURL;
        for (var i2 = 0, n2 = mappings.length; i2 < n2; i2++) {
          var mapping = mappings[i2];
          var source = mapping.source === null ? null : sources.at(mapping.source);
          if (source !== null) {
            source = util.computeSourceURL(sourceRoot, source, sourceMapURL);
          }
          boundCallback({
            source,
            generatedLine: mapping.generatedLine,
            generatedColumn: mapping.generatedColumn,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name === null ? null : names.at(mapping.name)
          });
        }
      };
      SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
        var line2 = util.getArg(aArgs, "line");
        var needle = {
          source: util.getArg(aArgs, "source"),
          originalLine: line2,
          originalColumn: util.getArg(aArgs, "column", 0)
        };
        needle.source = this._findSourceIndex(needle.source);
        if (needle.source < 0) {
          return [];
        }
        var mappings = [];
        var index3 = this._findMapping(
          needle,
          this._originalMappings,
          "originalLine",
          "originalColumn",
          util.compareByOriginalPositions,
          binarySearch.LEAST_UPPER_BOUND
        );
        if (index3 >= 0) {
          var mapping = this._originalMappings[index3];
          if (aArgs.column === void 0) {
            var originalLine = mapping.originalLine;
            while (mapping && mapping.originalLine === originalLine) {
              mappings.push({
                line: util.getArg(mapping, "generatedLine", null),
                column: util.getArg(mapping, "generatedColumn", null),
                lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
              });
              mapping = this._originalMappings[++index3];
            }
          } else {
            var originalColumn = mapping.originalColumn;
            while (mapping && mapping.originalLine === line2 && mapping.originalColumn == originalColumn) {
              mappings.push({
                line: util.getArg(mapping, "generatedLine", null),
                column: util.getArg(mapping, "generatedColumn", null),
                lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
              });
              mapping = this._originalMappings[++index3];
            }
          }
        }
        return mappings;
      };
      exports.SourceMapConsumer = SourceMapConsumer;
      function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        var version3 = util.getArg(sourceMap, "version");
        var sources = util.getArg(sourceMap, "sources");
        var names = util.getArg(sourceMap, "names", []);
        var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
        var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
        var mappings = util.getArg(sourceMap, "mappings");
        var file = util.getArg(sourceMap, "file", null);
        if (version3 != this._version) {
          throw new Error("Unsupported version: " + version3);
        }
        if (sourceRoot) {
          sourceRoot = util.normalize(sourceRoot);
        }
        sources = sources.map(String).map(util.normalize).map(function(source) {
          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
        });
        this._names = ArraySet.fromArray(names.map(String), true);
        this._sources = ArraySet.fromArray(sources, true);
        this._absoluteSources = this._sources.toArray().map(function(s2) {
          return util.computeSourceURL(sourceRoot, s2, aSourceMapURL);
        });
        this.sourceRoot = sourceRoot;
        this.sourcesContent = sourcesContent;
        this._mappings = mappings;
        this._sourceMapURL = aSourceMapURL;
        this.file = file;
      }
      BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
      BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
        var relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }
        if (this._sources.has(relativeSource)) {
          return this._sources.indexOf(relativeSource);
        }
        var i2;
        for (i2 = 0; i2 < this._absoluteSources.length; ++i2) {
          if (this._absoluteSources[i2] == aSource) {
            return i2;
          }
        }
        return -1;
      };
      BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
        var smc = Object.create(BasicSourceMapConsumer.prototype);
        var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
        var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
        smc.sourceRoot = aSourceMap._sourceRoot;
        smc.sourcesContent = aSourceMap._generateSourcesContent(
          smc._sources.toArray(),
          smc.sourceRoot
        );
        smc.file = aSourceMap._file;
        smc._sourceMapURL = aSourceMapURL;
        smc._absoluteSources = smc._sources.toArray().map(function(s2) {
          return util.computeSourceURL(smc.sourceRoot, s2, aSourceMapURL);
        });
        var generatedMappings = aSourceMap._mappings.toArray().slice();
        var destGeneratedMappings = smc.__generatedMappings = [];
        var destOriginalMappings = smc.__originalMappings = [];
        for (var i2 = 0, length2 = generatedMappings.length; i2 < length2; i2++) {
          var srcMapping = generatedMappings[i2];
          var destMapping = new Mapping();
          destMapping.generatedLine = srcMapping.generatedLine;
          destMapping.generatedColumn = srcMapping.generatedColumn;
          if (srcMapping.source) {
            destMapping.source = sources.indexOf(srcMapping.source);
            destMapping.originalLine = srcMapping.originalLine;
            destMapping.originalColumn = srcMapping.originalColumn;
            if (srcMapping.name) {
              destMapping.name = names.indexOf(srcMapping.name);
            }
            destOriginalMappings.push(destMapping);
          }
          destGeneratedMappings.push(destMapping);
        }
        quickSort(smc.__originalMappings, util.compareByOriginalPositions);
        return smc;
      };
      BasicSourceMapConsumer.prototype._version = 3;
      Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
        get: function() {
          return this._absoluteSources.slice();
        }
      });
      function Mapping() {
        this.generatedLine = 0;
        this.generatedColumn = 0;
        this.source = null;
        this.originalLine = null;
        this.originalColumn = null;
        this.name = null;
      }
      var compareGenerated = util.compareByGeneratedPositionsDeflatedNoLine;
      function sortGenerated(array, start) {
        let l2 = array.length;
        let n2 = array.length - start;
        if (n2 <= 1) {
          return;
        } else if (n2 == 2) {
          let a2 = array[start];
          let b2 = array[start + 1];
          if (compareGenerated(a2, b2) > 0) {
            array[start] = b2;
            array[start + 1] = a2;
          }
        } else if (n2 < 20) {
          for (let i2 = start; i2 < l2; i2++) {
            for (let j2 = i2; j2 > start; j2--) {
              let a2 = array[j2 - 1];
              let b2 = array[j2];
              if (compareGenerated(a2, b2) <= 0) {
                break;
              }
              array[j2 - 1] = b2;
              array[j2] = a2;
            }
          }
        } else {
          quickSort(array, compareGenerated, start);
        }
      }
      BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        var generatedLine = 1;
        var previousGeneratedColumn = 0;
        var previousOriginalLine = 0;
        var previousOriginalColumn = 0;
        var previousSource = 0;
        var previousName = 0;
        var length2 = aStr.length;
        var index3 = 0;
        var cachedSegments = {};
        var temp = {};
        var originalMappings = [];
        var generatedMappings = [];
        var mapping, str, segment, end, value;
        let subarrayStart = 0;
        while (index3 < length2) {
          if (aStr.charAt(index3) === ";") {
            generatedLine++;
            index3++;
            previousGeneratedColumn = 0;
            sortGenerated(generatedMappings, subarrayStart);
            subarrayStart = generatedMappings.length;
          } else if (aStr.charAt(index3) === ",") {
            index3++;
          } else {
            mapping = new Mapping();
            mapping.generatedLine = generatedLine;
            for (end = index3; end < length2; end++) {
              if (this._charIsMappingSeparator(aStr, end)) {
                break;
              }
            }
            str = aStr.slice(index3, end);
            segment = [];
            while (index3 < end) {
              base64VLQ.decode(aStr, index3, temp);
              value = temp.value;
              index3 = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            mapping.generatedColumn = previousGeneratedColumn + segment[0];
            previousGeneratedColumn = mapping.generatedColumn;
            if (segment.length > 1) {
              mapping.source = previousSource + segment[1];
              previousSource += segment[1];
              mapping.originalLine = previousOriginalLine + segment[2];
              previousOriginalLine = mapping.originalLine;
              mapping.originalLine += 1;
              mapping.originalColumn = previousOriginalColumn + segment[3];
              previousOriginalColumn = mapping.originalColumn;
              if (segment.length > 4) {
                mapping.name = previousName + segment[4];
                previousName += segment[4];
              }
            }
            generatedMappings.push(mapping);
            if (typeof mapping.originalLine === "number") {
              let currentSource = mapping.source;
              while (originalMappings.length <= currentSource) {
                originalMappings.push(null);
              }
              if (originalMappings[currentSource] === null) {
                originalMappings[currentSource] = [];
              }
              originalMappings[currentSource].push(mapping);
            }
          }
        }
        sortGenerated(generatedMappings, subarrayStart);
        this.__generatedMappings = generatedMappings;
        for (var i2 = 0; i2 < originalMappings.length; i2++) {
          if (originalMappings[i2] != null) {
            quickSort(originalMappings[i2], util.compareByOriginalPositionsNoSource);
          }
        }
        this.__originalMappings = [].concat(...originalMappings);
      };
      BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
        if (aNeedle[aLineName] <= 0) {
          throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
        }
        if (aNeedle[aColumnName] < 0) {
          throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
        }
        return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
      };
      BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
        for (var index3 = 0; index3 < this._generatedMappings.length; ++index3) {
          var mapping = this._generatedMappings[index3];
          if (index3 + 1 < this._generatedMappings.length) {
            var nextMapping = this._generatedMappings[index3 + 1];
            if (mapping.generatedLine === nextMapping.generatedLine) {
              mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
              continue;
            }
          }
          mapping.lastGeneratedColumn = Infinity;
        }
      };
      BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
          generatedLine: util.getArg(aArgs, "line"),
          generatedColumn: util.getArg(aArgs, "column")
        };
        var index3 = this._findMapping(
          needle,
          this._generatedMappings,
          "generatedLine",
          "generatedColumn",
          util.compareByGeneratedPositionsDeflated,
          util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
        );
        if (index3 >= 0) {
          var mapping = this._generatedMappings[index3];
          if (mapping.generatedLine === needle.generatedLine) {
            var source = util.getArg(mapping, "source", null);
            if (source !== null) {
              source = this._sources.at(source);
              source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
            }
            var name = util.getArg(mapping, "name", null);
            if (name !== null) {
              name = this._names.at(name);
            }
            return {
              source,
              line: util.getArg(mapping, "originalLine", null),
              column: util.getArg(mapping, "originalColumn", null),
              name
            };
          }
        }
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      };
      BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
        if (!this.sourcesContent) {
          return false;
        }
        return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
          return sc == null;
        });
      };
      BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        if (!this.sourcesContent) {
          return null;
        }
        var index3 = this._findSourceIndex(aSource);
        if (index3 >= 0) {
          return this.sourcesContent[index3];
        }
        var relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }
        var url;
        if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
          var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
          if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
          }
          if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
            return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
          }
        }
        if (nullOnMissing) {
          return null;
        } else {
          throw new Error('"' + relativeSource + '" is not in the SourceMap.');
        }
      };
      BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
        var source = util.getArg(aArgs, "source");
        source = this._findSourceIndex(source);
        if (source < 0) {
          return {
            line: null,
            column: null,
            lastColumn: null
          };
        }
        var needle = {
          source,
          originalLine: util.getArg(aArgs, "line"),
          originalColumn: util.getArg(aArgs, "column")
        };
        var index3 = this._findMapping(
          needle,
          this._originalMappings,
          "originalLine",
          "originalColumn",
          util.compareByOriginalPositions,
          util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
        );
        if (index3 >= 0) {
          var mapping = this._originalMappings[index3];
          if (mapping.source === needle.source) {
            return {
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            };
          }
        }
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      };
      exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
      function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        var version3 = util.getArg(sourceMap, "version");
        var sections = util.getArg(sourceMap, "sections");
        if (version3 != this._version) {
          throw new Error("Unsupported version: " + version3);
        }
        this._sources = new ArraySet();
        this._names = new ArraySet();
        var lastOffset = {
          line: -1,
          column: 0
        };
        this._sections = sections.map(function(s2) {
          if (s2.url) {
            throw new Error("Support for url field in sections not implemented.");
          }
          var offset4 = util.getArg(s2, "offset");
          var offsetLine = util.getArg(offset4, "line");
          var offsetColumn = util.getArg(offset4, "column");
          if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
            throw new Error("Section offsets must be ordered and non-overlapping.");
          }
          lastOffset = offset4;
          return {
            generatedOffset: {
              // The offset fields are 0-based, but we use 1-based indices when
              // encoding/decoding from VLQ.
              generatedLine: offsetLine + 1,
              generatedColumn: offsetColumn + 1
            },
            consumer: new SourceMapConsumer(util.getArg(s2, "map"), aSourceMapURL)
          };
        });
      }
      IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
      IndexedSourceMapConsumer.prototype._version = 3;
      Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
        get: function() {
          var sources = [];
          for (var i2 = 0; i2 < this._sections.length; i2++) {
            for (var j2 = 0; j2 < this._sections[i2].consumer.sources.length; j2++) {
              sources.push(this._sections[i2].consumer.sources[j2]);
            }
          }
          return sources;
        }
      });
      IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
          generatedLine: util.getArg(aArgs, "line"),
          generatedColumn: util.getArg(aArgs, "column")
        };
        var sectionIndex = binarySearch.search(
          needle,
          this._sections,
          function(needle2, section2) {
            var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
            if (cmp) {
              return cmp;
            }
            return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
          }
        );
        var section = this._sections[sectionIndex];
        if (!section) {
          return {
            source: null,
            line: null,
            column: null,
            name: null
          };
        }
        return section.consumer.originalPositionFor({
          line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
          column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          bias: aArgs.bias
        });
      };
      IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
        return this._sections.every(function(s2) {
          return s2.consumer.hasContentsOfAllSources();
        });
      };
      IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        for (var i2 = 0; i2 < this._sections.length; i2++) {
          var section = this._sections[i2];
          var content = section.consumer.sourceContentFor(aSource, true);
          if (content || content === "") {
            return content;
          }
        }
        if (nullOnMissing) {
          return null;
        } else {
          throw new Error('"' + aSource + '" is not in the SourceMap.');
        }
      };
      IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
        for (var i2 = 0; i2 < this._sections.length; i2++) {
          var section = this._sections[i2];
          if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
            continue;
          }
          var generatedPosition = section.consumer.generatedPositionFor(aArgs);
          if (generatedPosition) {
            var ret = {
              line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
              column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
            };
            return ret;
          }
        }
        return {
          line: null,
          column: null
        };
      };
      IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        for (var i2 = 0; i2 < this._sections.length; i2++) {
          var section = this._sections[i2];
          var sectionMappings = section.consumer._generatedMappings;
          for (var j2 = 0; j2 < sectionMappings.length; j2++) {
            var mapping = sectionMappings[j2];
            var source = section.consumer._sources.at(mapping.source);
            if (source !== null) {
              source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
            }
            this._sources.add(source);
            source = this._sources.indexOf(source);
            var name = null;
            if (mapping.name) {
              name = section.consumer._names.at(mapping.name);
              this._names.add(name);
              name = this._names.indexOf(name);
            }
            var adjustedMapping = {
              source,
              generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
              generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
              originalLine: mapping.originalLine,
              originalColumn: mapping.originalColumn,
              name
            };
            this.__generatedMappings.push(adjustedMapping);
            if (typeof adjustedMapping.originalLine === "number") {
              this.__originalMappings.push(adjustedMapping);
            }
          }
        }
        quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
        quickSort(this.__originalMappings, util.compareByOriginalPositions);
      };
      exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
    }
  });

  // node_modules/source-map-js/lib/source-node.js
  var require_source_node = __commonJS({
    "node_modules/source-map-js/lib/source-node.js"(exports) {
      var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
      var util = require_util7();
      var REGEX_NEWLINE = /(\r?\n)/;
      var NEWLINE_CODE = 10;
      var isSourceNode = "$$$isSourceNode$$$";
      function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [];
        this.sourceContents = {};
        this.line = aLine == null ? null : aLine;
        this.column = aColumn == null ? null : aColumn;
        this.source = aSource == null ? null : aSource;
        this.name = aName == null ? null : aName;
        this[isSourceNode] = true;
        if (aChunks != null) this.add(aChunks);
      }
      SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
        var node2 = new SourceNode();
        var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
        var remainingLinesIndex = 0;
        var shiftNextLine = function() {
          var lineContents = getNextLine();
          var newLine = getNextLine() || "";
          return lineContents + newLine;
          function getNextLine() {
            return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
          }
        };
        var lastGeneratedLine = 1, lastGeneratedColumn = 0;
        var lastMapping = null;
        aSourceMapConsumer.eachMapping(function(mapping) {
          if (lastMapping !== null) {
            if (lastGeneratedLine < mapping.generatedLine) {
              addMappingWithCode(lastMapping, shiftNextLine());
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
            } else {
              var nextLine = remainingLines[remainingLinesIndex] || "";
              var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
              remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
              addMappingWithCode(lastMapping, code);
              lastMapping = mapping;
              return;
            }
          }
          while (lastGeneratedLine < mapping.generatedLine) {
            node2.add(shiftNextLine());
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            node2.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
          lastMapping = mapping;
        }, this);
        if (remainingLinesIndex < remainingLines.length) {
          if (lastMapping) {
            addMappingWithCode(lastMapping, shiftNextLine());
          }
          node2.add(remainingLines.splice(remainingLinesIndex).join(""));
        }
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            if (aRelativePath != null) {
              sourceFile = util.join(aRelativePath, sourceFile);
            }
            node2.setSourceContent(sourceFile, content);
          }
        });
        return node2;
        function addMappingWithCode(mapping, code) {
          if (mapping === null || mapping.source === void 0) {
            node2.add(code);
          } else {
            var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
            node2.add(new SourceNode(
              mapping.originalLine,
              mapping.originalColumn,
              source,
              code,
              mapping.name
            ));
          }
        }
      };
      SourceNode.prototype.add = function SourceNode_add(aChunk) {
        if (Array.isArray(aChunk)) {
          aChunk.forEach(function(chunk) {
            this.add(chunk);
          }, this);
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          if (aChunk) {
            this.children.push(aChunk);
          }
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
      SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
        if (Array.isArray(aChunk)) {
          for (var i2 = aChunk.length - 1; i2 >= 0; i2--) {
            this.prepend(aChunk[i2]);
          }
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          this.children.unshift(aChunk);
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
      SourceNode.prototype.walk = function SourceNode_walk(aFn) {
        var chunk;
        for (var i2 = 0, len2 = this.children.length; i2 < len2; i2++) {
          chunk = this.children[i2];
          if (chunk[isSourceNode]) {
            chunk.walk(aFn);
          } else {
            if (chunk !== "") {
              aFn(chunk, {
                source: this.source,
                line: this.line,
                column: this.column,
                name: this.name
              });
            }
          }
        }
      };
      SourceNode.prototype.join = function SourceNode_join(aSep) {
        var newChildren;
        var i2;
        var len2 = this.children.length;
        if (len2 > 0) {
          newChildren = [];
          for (i2 = 0; i2 < len2 - 1; i2++) {
            newChildren.push(this.children[i2]);
            newChildren.push(aSep);
          }
          newChildren.push(this.children[i2]);
          this.children = newChildren;
        }
        return this;
      };
      SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
        var lastChild = this.children[this.children.length - 1];
        if (lastChild[isSourceNode]) {
          lastChild.replaceRight(aPattern, aReplacement);
        } else if (typeof lastChild === "string") {
          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
        } else {
          this.children.push("".replace(aPattern, aReplacement));
        }
        return this;
      };
      SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
        this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
      };
      SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
        for (var i2 = 0, len2 = this.children.length; i2 < len2; i2++) {
          if (this.children[i2][isSourceNode]) {
            this.children[i2].walkSourceContents(aFn);
          }
        }
        var sources = Object.keys(this.sourceContents);
        for (var i2 = 0, len2 = sources.length; i2 < len2; i2++) {
          aFn(util.fromSetString(sources[i2]), this.sourceContents[sources[i2]]);
        }
      };
      SourceNode.prototype.toString = function SourceNode_toString() {
        var str = "";
        this.walk(function(chunk) {
          str += chunk;
        });
        return str;
      };
      SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
        var generated = {
          code: "",
          line: 1,
          column: 0
        };
        var map = new SourceMapGenerator(aArgs);
        var sourceMappingActive = false;
        var lastOriginalSource = null;
        var lastOriginalLine = null;
        var lastOriginalColumn = null;
        var lastOriginalName = null;
        this.walk(function(chunk, original) {
          generated.code += chunk;
          if (original.source !== null && original.line !== null && original.column !== null) {
            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
          } else if (sourceMappingActive) {
            map.addMapping({
              generated: {
                line: generated.line,
                column: generated.column
              }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
          }
          for (var idx = 0, length2 = chunk.length; idx < length2; idx++) {
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
              generated.line++;
              generated.column = 0;
              if (idx + 1 === length2) {
                lastOriginalSource = null;
                sourceMappingActive = false;
              } else if (sourceMappingActive) {
                map.addMapping({
                  source: original.source,
                  original: {
                    line: original.line,
                    column: original.column
                  },
                  generated: {
                    line: generated.line,
                    column: generated.column
                  },
                  name: original.name
                });
              }
            } else {
              generated.column++;
            }
          }
        });
        this.walkSourceContents(function(sourceFile, sourceContent) {
          map.setSourceContent(sourceFile, sourceContent);
        });
        return { code: generated.code, map };
      };
      exports.SourceNode = SourceNode;
    }
  });

  // node_modules/source-map-js/source-map.js
  var require_source_map = __commonJS({
    "node_modules/source-map-js/source-map.js"(exports) {
      exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
      exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
      exports.SourceNode = require_source_node().SourceNode;
    }
  });

  // node_modules/@mui/icons-material/OpenInNew.js
  var require_OpenInNew = __commonJS({
    "node_modules/@mui/icons-material/OpenInNew.js"(exports) {
      "use strict";
      "use client";
      var _interopRequireDefault = require_interopRequireDefault().default;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
      var _jsxRuntime = require_jsx_runtime();
      var _default = exports.default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
        d: "M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3z"
      }), "OpenInNew");
    }
  });

  // node_modules/@jbrowse/core/ui/ExternalLink.js
  var require_ExternalLink = __commonJS({
    "node_modules/@jbrowse/core/ui/ExternalLink.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = ExternalLink2;
      var jsx_runtime_1 = require_jsx_runtime();
      var OpenInNew_1 = __importDefault(require_OpenInNew());
      var material_1 = require_material();
      function ExternalLink2(props) {
        const { children, ...rest } = props;
        return (0, jsx_runtime_1.jsxs)(material_1.Link, { ...rest, target: "_blank", rel: "noopener noreferrer", children: [children, " ", (0, jsx_runtime_1.jsx)(OpenInNew_1.default, { fontSize: "small" })] });
      }
    }
  });

  // node_modules/tss-react/esm/tools/polyfills/Object.fromEntries.js
  var objectFromEntries;
  var init_Object_fromEntries = __esm({
    "node_modules/tss-react/esm/tools/polyfills/Object.fromEntries.js"() {
      objectFromEntries = !Object.fromEntries ? (entries) => {
        if (!entries || !entries[Symbol.iterator]) {
          throw new Error("Object.fromEntries() requires a single iterable argument");
        }
        const o2 = {};
        Object.keys(entries).forEach((key) => {
          const [k2, v2] = entries[key];
          o2[k2] = v2;
        });
        return o2;
      } : Object.fromEntries;
    }
  });

  // node_modules/tss-react/esm/tools/objectKeys.js
  function objectKeys(o2) {
    return Object.keys(o2);
  }
  var init_objectKeys = __esm({
    "node_modules/tss-react/esm/tools/objectKeys.js"() {
    }
  });

  // node_modules/tss-react/esm/tools/assert.js
  function assert(condition, msg) {
    if (!condition) {
      throw new Error(msg);
    }
  }
  var init_assert = __esm({
    "node_modules/tss-react/esm/tools/assert.js"() {
    }
  });

  // node_modules/tss-react/esm/tools/typeGuard.js
  function typeGuard(_value, isMatched) {
    return isMatched;
  }
  var init_typeGuard = __esm({
    "node_modules/tss-react/esm/tools/typeGuard.js"() {
    }
  });

  // node_modules/tss-react/esm/tools/classnames.js
  var classnames;
  var init_classnames = __esm({
    "node_modules/tss-react/esm/tools/classnames.js"() {
      init_assert();
      init_typeGuard();
      classnames = (args) => {
        const len2 = args.length;
        let i2 = 0;
        let cls = "";
        for (; i2 < len2; i2++) {
          const arg = args[i2];
          if (arg == null)
            continue;
          let toAdd;
          switch (typeof arg) {
            case "boolean":
              break;
            case "object": {
              if (Array.isArray(arg)) {
                toAdd = classnames(arg);
              } else {
                assert(!typeGuard(arg, false));
                if (arg.styles !== void 0 && arg.name !== void 0) {
                  console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.");
                }
                toAdd = "";
                for (const k2 in arg) {
                  if (arg[k2] && k2) {
                    toAdd && (toAdd += " ");
                    toAdd += k2;
                  }
                }
              }
              break;
            }
            default: {
              toAdd = arg;
            }
          }
          if (toAdd) {
            cls && (cls += " ");
            cls += toAdd;
          }
        }
        return cls;
      };
    }
  });

  // node_modules/@emotion/hash/dist/emotion-hash.esm.js
  function murmur2(str) {
    var h2 = 0;
    var k2, i2 = 0, len2 = str.length;
    for (; len2 >= 4; ++i2, len2 -= 4) {
      k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
      k2 = /* Math.imul(k, m): */
      (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
      k2 ^= /* k >>> r: */
      k2 >>> 24;
      h2 = /* Math.imul(k, m): */
      (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    switch (len2) {
      case 3:
        h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
      case 2:
        h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
      case 1:
        h2 ^= str.charCodeAt(i2) & 255;
        h2 = /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    h2 ^= h2 >>> 13;
    h2 = /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
  }
  var init_emotion_hash_esm = __esm({
    "node_modules/@emotion/hash/dist/emotion-hash.esm.js"() {
    }
  });

  // node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
  var unitlessKeys;
  var init_emotion_unitless_esm = __esm({
    "node_modules/@emotion/unitless/dist/emotion-unitless.esm.js"() {
      unitlessKeys = {
        animationIterationCount: 1,
        aspectRatio: 1,
        borderImageOutset: 1,
        borderImageSlice: 1,
        borderImageWidth: 1,
        boxFlex: 1,
        boxFlexGroup: 1,
        boxOrdinalGroup: 1,
        columnCount: 1,
        columns: 1,
        flex: 1,
        flexGrow: 1,
        flexPositive: 1,
        flexShrink: 1,
        flexNegative: 1,
        flexOrder: 1,
        gridRow: 1,
        gridRowEnd: 1,
        gridRowSpan: 1,
        gridRowStart: 1,
        gridColumn: 1,
        gridColumnEnd: 1,
        gridColumnSpan: 1,
        gridColumnStart: 1,
        msGridRow: 1,
        msGridRowSpan: 1,
        msGridColumn: 1,
        msGridColumnSpan: 1,
        fontWeight: 1,
        lineHeight: 1,
        opacity: 1,
        order: 1,
        orphans: 1,
        scale: 1,
        tabSize: 1,
        widows: 1,
        zIndex: 1,
        zoom: 1,
        WebkitLineClamp: 1,
        // SVG-related properties
        fillOpacity: 1,
        floodOpacity: 1,
        stopOpacity: 1,
        strokeDasharray: 1,
        strokeDashoffset: 1,
        strokeMiterlimit: 1,
        strokeOpacity: 1,
        strokeWidth: 1
      };
    }
  });

  // node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
  function memoize(fn) {
    var cache2 = /* @__PURE__ */ Object.create(null);
    return function(arg) {
      if (cache2[arg] === void 0) cache2[arg] = fn(arg);
      return cache2[arg];
    };
  }
  var init_emotion_memoize_esm = __esm({
    "node_modules/@emotion/memoize/dist/emotion-memoize.esm.js"() {
    }
  });

  // node_modules/@emotion/serialize/dist/emotion-serialize.esm.js
  function handleInterpolation(mergedProps, registered, interpolation) {
    if (interpolation == null) {
      return "";
    }
    var componentSelector = interpolation;
    if (componentSelector.__emotion_styles !== void 0) {
      return componentSelector;
    }
    switch (typeof interpolation) {
      case "boolean": {
        return "";
      }
      case "object": {
        var keyframes2 = interpolation;
        if (keyframes2.anim === 1) {
          cursor = {
            name: keyframes2.name,
            styles: keyframes2.styles,
            next: cursor
          };
          return keyframes2.name;
        }
        var serializedStyles = interpolation;
        if (serializedStyles.styles !== void 0) {
          var next2 = serializedStyles.next;
          if (next2 !== void 0) {
            while (next2 !== void 0) {
              cursor = {
                name: next2.name,
                styles: next2.styles,
                next: cursor
              };
              next2 = next2.next;
            }
          }
          var styles = serializedStyles.styles + ";";
          return styles;
        }
        return createStringFromObject(mergedProps, registered, interpolation);
      }
      case "function": {
        if (mergedProps !== void 0) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        }
        break;
      }
    }
    var asString = interpolation;
    if (registered == null) {
      return asString;
    }
    var cached = registered[asString];
    return cached !== void 0 ? cached : asString;
  }
  function createStringFromObject(mergedProps, registered, obj) {
    var string = "";
    if (Array.isArray(obj)) {
      for (var i2 = 0; i2 < obj.length; i2++) {
        string += handleInterpolation(mergedProps, registered, obj[i2]) + ";";
      }
    } else {
      for (var key in obj) {
        var value = obj[key];
        if (typeof value !== "object") {
          var asString = value;
          if (registered != null && registered[asString] !== void 0) {
            string += key + "{" + registered[asString] + "}";
          } else if (isProcessableValue(asString)) {
            string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
          }
        } else {
          if (key === "NO_COMPONENT_SELECTOR" && isDevelopment) {
            throw new Error(noComponentSelectorMessage);
          }
          if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
            for (var _i = 0; _i < value.length; _i++) {
              if (isProcessableValue(value[_i])) {
                string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
              }
            }
          } else {
            var interpolated = handleInterpolation(mergedProps, registered, value);
            switch (key) {
              case "animation":
              case "animationName": {
                string += processStyleName(key) + ":" + interpolated + ";";
                break;
              }
              default: {
                string += key + "{" + interpolated + "}";
              }
            }
          }
        }
      }
    }
    return string;
  }
  function serializeStyles(args, registered, mergedProps) {
    if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
      return args[0];
    }
    var stringMode = true;
    var styles = "";
    cursor = void 0;
    var strings2 = args[0];
    if (strings2 == null || strings2.raw === void 0) {
      stringMode = false;
      styles += handleInterpolation(mergedProps, registered, strings2);
    } else {
      var asTemplateStringsArr = strings2;
      styles += asTemplateStringsArr[0];
    }
    for (var i2 = 1; i2 < args.length; i2++) {
      styles += handleInterpolation(mergedProps, registered, args[i2]);
      if (stringMode) {
        var templateStringsArr = strings2;
        styles += templateStringsArr[i2];
      }
    }
    labelPattern.lastIndex = 0;
    var identifierName = "";
    var match2;
    while ((match2 = labelPattern.exec(styles)) !== null) {
      identifierName += "-" + match2[1];
    }
    var name = murmur2(styles) + identifierName;
    return {
      name,
      styles,
      next: cursor
    };
  }
  var isDevelopment, hyphenateRegex, animationRegex, isCustomProperty, isProcessableValue, processStyleName, processStyleValue, noComponentSelectorMessage, labelPattern, cursor;
  var init_emotion_serialize_esm = __esm({
    "node_modules/@emotion/serialize/dist/emotion-serialize.esm.js"() {
      init_emotion_hash_esm();
      init_emotion_unitless_esm();
      init_emotion_memoize_esm();
      isDevelopment = false;
      hyphenateRegex = /[A-Z]|^ms/g;
      animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
      isCustomProperty = function isCustomProperty2(property) {
        return property.charCodeAt(1) === 45;
      };
      isProcessableValue = function isProcessableValue2(value) {
        return value != null && typeof value !== "boolean";
      };
      processStyleName = /* @__PURE__ */ memoize(function(styleName) {
        return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
      });
      processStyleValue = function processStyleValue2(key, value) {
        switch (key) {
          case "animation":
          case "animationName": {
            if (typeof value === "string") {
              return value.replace(animationRegex, function(match2, p1, p2) {
                cursor = {
                  name: p1,
                  styles: p2,
                  next: cursor
                };
                return p1;
              });
            }
          }
        }
        if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
          return value + "px";
        }
        return value;
      };
      noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
      labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
    }
  });

  // node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js
  function getRegisteredStyles(registered, registeredStyles, classNames) {
    var rawClassName = "";
    classNames.split(" ").forEach(function(className) {
      if (registered[className] !== void 0) {
        registeredStyles.push(registered[className] + ";");
      } else if (className) {
        rawClassName += className + " ";
      }
    });
    return rawClassName;
  }
  var isBrowser, registerStyles, insertStyles;
  var init_emotion_utils_browser_esm = __esm({
    "node_modules/@emotion/utils/dist/emotion-utils.browser.esm.js"() {
      isBrowser = true;
      registerStyles = function registerStyles2(cache2, serialized, isStringTag) {
        var className = cache2.key + "-" + serialized.name;
        if (
          // we only need to add the styles to the registered cache if the
          // class name could be used further down
          // the tree but if it's a string tag, we know it won't
          // so we don't have to add it to registered cache.
          // this improves memory usage since we can avoid storing the whole style string
          (isStringTag === false || // we need to always store it if we're in compat mode and
          // in node since emotion-server relies on whether a style is in
          // the registered cache to know whether a style is global or not
          // also, note that this check will be dead code eliminated in the browser
          isBrowser === false) && cache2.registered[className] === void 0
        ) {
          cache2.registered[className] = serialized.styles;
        }
      };
      insertStyles = function insertStyles2(cache2, serialized, isStringTag) {
        registerStyles(cache2, serialized, isStringTag);
        var className = cache2.key + "-" + serialized.name;
        if (cache2.inserted[serialized.name] === void 0) {
          var current = serialized;
          do {
            cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
            current = current.next;
          } while (current !== void 0);
        }
      };
    }
  });

  // node_modules/tss-react/esm/tools/useGuaranteedMemo.js
  function useGuaranteedMemo(fn, deps) {
    var _a;
    const ref = (0, import_react29.useRef)();
    if (!ref.current || deps.length !== ((_a = ref.current.prevDeps) === null || _a === void 0 ? void 0 : _a.length) || ref.current.prevDeps.map((v2, i2) => v2 === deps[i2]).indexOf(false) >= 0) {
      ref.current = {
        "v": fn(),
        "prevDeps": [...deps]
      };
    }
    return ref.current.v;
  }
  var import_react29;
  var init_useGuaranteedMemo = __esm({
    "node_modules/tss-react/esm/tools/useGuaranteedMemo.js"() {
      import_react29 = __toESM(require_react());
    }
  });

  // node_modules/tss-react/esm/types.js
  function matchCSSObject(arg) {
    return arg instanceof Object && !("styles" in arg) && !("length" in arg) && !("__emotion_styles" in arg);
  }
  var init_types2 = __esm({
    "node_modules/tss-react/esm/types.js"() {
    }
  });

  // node_modules/tss-react/esm/cssAndCx.js
  function createUseCssAndCx(params) {
    const { useCache } = params;
    function useCssAndCx() {
      const cache2 = useCache();
      const { css: css2, cx } = useGuaranteedMemo(() => createCssAndCx({ cache: cache2 }), [cache2]);
      return { css: css2, cx };
    }
    return { useCssAndCx };
  }
  var createCssAndCx, increaseSpecificityToTakePrecedenceOverMediaQueries;
  var init_cssAndCx = __esm({
    "node_modules/tss-react/esm/cssAndCx.js"() {
      init_classnames();
      init_emotion_serialize_esm();
      init_emotion_utils_browser_esm();
      init_useGuaranteedMemo();
      init_types2();
      ({ createCssAndCx } = /* @__PURE__ */ (() => {
        function merge(registered, css2, className) {
          const registeredStyles = [];
          const rawClassName = getRegisteredStyles(registered, registeredStyles, className);
          if (registeredStyles.length < 2) {
            return className;
          }
          return rawClassName + css2(registeredStyles);
        }
        function createCssAndCx2(params) {
          const { cache: cache2 } = params;
          const css2 = (...args) => {
            const serialized = serializeStyles(args, cache2.registered);
            insertStyles(cache2, serialized, false);
            const className = `${cache2.key}-${serialized.name}`;
            scope: {
              const arg = args[0];
              if (!matchCSSObject(arg)) {
                break scope;
              }
              increaseSpecificityToTakePrecedenceOverMediaQueries.saveClassNameCSSObjectMapping(cache2, className, arg);
            }
            return className;
          };
          const cx = (...args) => {
            const className = classnames(args);
            const feat27FixedClassnames = increaseSpecificityToTakePrecedenceOverMediaQueries.fixClassName(cache2, className, css2);
            return merge(cache2.registered, css2, feat27FixedClassnames);
          };
          return { css: css2, cx };
        }
        return { createCssAndCx: createCssAndCx2 };
      })());
      increaseSpecificityToTakePrecedenceOverMediaQueries = /* @__PURE__ */ (() => {
        const cssObjectMapByCache = /* @__PURE__ */ new WeakMap();
        return {
          "saveClassNameCSSObjectMapping": (cache2, className, cssObject) => {
            let cssObjectMap = cssObjectMapByCache.get(cache2);
            if (cssObjectMap === void 0) {
              cssObjectMap = /* @__PURE__ */ new Map();
              cssObjectMapByCache.set(cache2, cssObjectMap);
            }
            cssObjectMap.set(className, cssObject);
          },
          "fixClassName": /* @__PURE__ */ (() => {
            function fix(classNameCSSObjects) {
              let isThereAnyMediaQueriesInPreviousClasses = false;
              return classNameCSSObjects.map(([className, cssObject]) => {
                if (cssObject === void 0) {
                  return className;
                }
                let out;
                if (!isThereAnyMediaQueriesInPreviousClasses) {
                  out = className;
                  for (const key in cssObject) {
                    if (key.startsWith("@media")) {
                      isThereAnyMediaQueriesInPreviousClasses = true;
                      break;
                    }
                  }
                } else {
                  out = {
                    "&&": cssObject
                  };
                }
                return out;
              });
            }
            return (cache2, className, css2) => {
              const cssObjectMap = cssObjectMapByCache.get(cache2);
              return classnames(fix(className.split(" ").map((className2) => [
                className2,
                cssObjectMap === null || cssObjectMap === void 0 ? void 0 : cssObjectMap.get(className2)
              ])).map((classNameOrCSSObject) => typeof classNameOrCSSObject === "string" ? classNameOrCSSObject : css2(classNameOrCSSObject)));
            };
          })()
        };
      })();
    }
  });

  // node_modules/tss-react/esm/tools/getDependencyArrayRef.js
  function getDependencyArrayRef(obj) {
    if (!(obj instanceof Object) || typeof obj === "function") {
      return obj;
    }
    const arr = [];
    for (const key in obj) {
      const value = obj[key];
      const typeofValue = typeof value;
      if (!(typeofValue === "string" || typeofValue === "number" && !isNaN(value) || typeofValue === "boolean" || value === void 0 || value === null)) {
        return obj;
      }
      arr.push(`${key}:${typeofValue}_${value}`);
    }
    return "xSqLiJdLMd9s" + arr.join("|");
  }
  var init_getDependencyArrayRef = __esm({
    "node_modules/tss-react/esm/tools/getDependencyArrayRef.js"() {
    }
  });

  // node_modules/tss-react/esm/mergeClasses.js
  function mergeClasses(classesFromUseStyles, classesOverrides, cx) {
    if (!(classesOverrides instanceof Object)) {
      return classesFromUseStyles;
    }
    const out = {};
    objectKeys(classesFromUseStyles).forEach((ruleName) => out[ruleName] = cx(classesFromUseStyles[ruleName], classesOverrides[ruleName]));
    objectKeys(classesOverrides).forEach((ruleName) => {
      if (ruleName in classesFromUseStyles) {
        return;
      }
      const className = classesOverrides[ruleName];
      if (typeof className !== "string") {
        return;
      }
      out[ruleName] = className;
    });
    return out;
  }
  var init_mergeClasses = __esm({
    "node_modules/tss-react/esm/mergeClasses.js"() {
      init_objectKeys();
    }
  });

  // node_modules/tss-react/esm/mui/themeStyleOverridesPlugin.js
  var import_react30, useMuiThemeStyleOverridesPlugin;
  var init_themeStyleOverridesPlugin = __esm({
    "node_modules/tss-react/esm/mui/themeStyleOverridesPlugin.js"() {
      import_react30 = __toESM(require_react());
      init_getDependencyArrayRef();
      init_mergeClasses();
      useMuiThemeStyleOverridesPlugin = ({ classes, theme, muiStyleOverridesParams, css: css2, cx, name }) => {
        var _a, _b;
        require_named: {
          if (name === "makeStyle no name") {
            name = void 0;
            break require_named;
          }
          if (muiStyleOverridesParams !== void 0 && name === void 0) {
            throw new Error("To use muiStyleOverridesParams, you must specify a name using .withName('MyComponent')");
          }
        }
        let styleOverrides = void 0;
        try {
          styleOverrides = name === void 0 ? void 0 : ((_b = (_a = theme.components) === null || _a === void 0 ? void 0 : _a[
            name
            /*example*/
          ]) === null || _b === void 0 ? void 0 : _b.styleOverrides) || void 0;
        } catch (_c) {
        }
        const classesFromThemeStyleOverrides = (0, import_react30.useMemo)(() => {
          if (styleOverrides === void 0) {
            return void 0;
          }
          const themeClasses = {};
          for (const ruleName in styleOverrides) {
            const cssObjectOrGetCssObject = styleOverrides[ruleName];
            if (!(cssObjectOrGetCssObject instanceof Object)) {
              continue;
            }
            themeClasses[ruleName] = css2(typeof cssObjectOrGetCssObject === "function" ? cssObjectOrGetCssObject({
              theme,
              "ownerState": muiStyleOverridesParams === null || muiStyleOverridesParams === void 0 ? void 0 : muiStyleOverridesParams.ownerState,
              ...muiStyleOverridesParams === null || muiStyleOverridesParams === void 0 ? void 0 : muiStyleOverridesParams.props
            }) : cssObjectOrGetCssObject);
          }
          return themeClasses;
        }, [
          styleOverrides,
          getDependencyArrayRef(muiStyleOverridesParams === null || muiStyleOverridesParams === void 0 ? void 0 : muiStyleOverridesParams.props),
          getDependencyArrayRef(muiStyleOverridesParams === null || muiStyleOverridesParams === void 0 ? void 0 : muiStyleOverridesParams.ownerState),
          css2
        ]);
        classes = (0, import_react30.useMemo)(() => mergeClasses(classes, classesFromThemeStyleOverrides, cx), [classes, classesFromThemeStyleOverrides, cx]);
        return { classes };
      };
    }
  });

  // node_modules/@emotion/sheet/dist/emotion-sheet.esm.js
  function sheetForTag(tag) {
    if (tag.sheet) {
      return tag.sheet;
    }
    for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
      if (document.styleSheets[i2].ownerNode === tag) {
        return document.styleSheets[i2];
      }
    }
    return void 0;
  }
  function createStyleElement(options) {
    var tag = document.createElement("style");
    tag.setAttribute("data-emotion", options.key);
    if (options.nonce !== void 0) {
      tag.setAttribute("nonce", options.nonce);
    }
    tag.appendChild(document.createTextNode(""));
    tag.setAttribute("data-s", "");
    return tag;
  }
  var isDevelopment2, StyleSheet;
  var init_emotion_sheet_esm = __esm({
    "node_modules/@emotion/sheet/dist/emotion-sheet.esm.js"() {
      isDevelopment2 = false;
      StyleSheet = /* @__PURE__ */ (function() {
        function StyleSheet2(options) {
          var _this = this;
          this._insertTag = function(tag) {
            var before;
            if (_this.tags.length === 0) {
              if (_this.insertionPoint) {
                before = _this.insertionPoint.nextSibling;
              } else if (_this.prepend) {
                before = _this.container.firstChild;
              } else {
                before = _this.before;
              }
            } else {
              before = _this.tags[_this.tags.length - 1].nextSibling;
            }
            _this.container.insertBefore(tag, before);
            _this.tags.push(tag);
          };
          this.isSpeedy = options.speedy === void 0 ? !isDevelopment2 : options.speedy;
          this.tags = [];
          this.ctr = 0;
          this.nonce = options.nonce;
          this.key = options.key;
          this.container = options.container;
          this.prepend = options.prepend;
          this.insertionPoint = options.insertionPoint;
          this.before = null;
        }
        var _proto = StyleSheet2.prototype;
        _proto.hydrate = function hydrate(nodes) {
          nodes.forEach(this._insertTag);
        };
        _proto.insert = function insert(rule) {
          if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
            this._insertTag(createStyleElement(this));
          }
          var tag = this.tags[this.tags.length - 1];
          if (this.isSpeedy) {
            var sheet = sheetForTag(tag);
            try {
              sheet.insertRule(rule, sheet.cssRules.length);
            } catch (e2) {
            }
          } else {
            tag.appendChild(document.createTextNode(rule));
          }
          this.ctr++;
        };
        _proto.flush = function flush() {
          this.tags.forEach(function(tag) {
            var _tag$parentNode;
            return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
          });
          this.tags = [];
          this.ctr = 0;
        };
        return StyleSheet2;
      })();
    }
  });

  // node_modules/stylis/src/Enum.js
  var MS, MOZ, WEBKIT, COMMENT2, RULESET, DECLARATION, IMPORT, KEYFRAMES, LAYER;
  var init_Enum = __esm({
    "node_modules/stylis/src/Enum.js"() {
      MS = "-ms-";
      MOZ = "-moz-";
      WEBKIT = "-webkit-";
      COMMENT2 = "comm";
      RULESET = "rule";
      DECLARATION = "decl";
      IMPORT = "@import";
      KEYFRAMES = "@keyframes";
      LAYER = "@layer";
    }
  });

  // node_modules/stylis/src/Utility.js
  function hash(value, length2) {
    return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
  }
  function trim(value) {
    return value.trim();
  }
  function match(value, pattern) {
    return (value = pattern.exec(value)) ? value[0] : value;
  }
  function replace(value, pattern, replacement) {
    return value.replace(pattern, replacement);
  }
  function indexof(value, search) {
    return value.indexOf(search);
  }
  function charat(value, index3) {
    return value.charCodeAt(index3) | 0;
  }
  function substr(value, begin, end) {
    return value.slice(begin, end);
  }
  function strlen(value) {
    return value.length;
  }
  function sizeof(value) {
    return value.length;
  }
  function append(value, array) {
    return array.push(value), value;
  }
  function combine(array, callback) {
    return array.map(callback).join("");
  }
  var abs, from, assign2;
  var init_Utility = __esm({
    "node_modules/stylis/src/Utility.js"() {
      abs = Math.abs;
      from = String.fromCharCode;
      assign2 = Object.assign;
    }
  });

  // node_modules/stylis/src/Tokenizer.js
  function node(value, root, parent, type, props, children, length2) {
    return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
  }
  function copy2(root, props) {
    return assign2(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
  }
  function char() {
    return character;
  }
  function prev() {
    character = position > 0 ? charat(characters, --position) : 0;
    if (column--, character === 10)
      column = 1, line--;
    return character;
  }
  function next() {
    character = position < length ? charat(characters, position++) : 0;
    if (column++, character === 10)
      column = 1, line++;
    return character;
  }
  function peek() {
    return charat(characters, position);
  }
  function caret() {
    return position;
  }
  function slice(begin, end) {
    return substr(characters, begin, end);
  }
  function token(type) {
    switch (type) {
      // \0 \t \n \r \s whitespace token
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      // ! + , / > @ ~ isolate token
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      // ; { } breakpoint token
      case 59:
      case 123:
      case 125:
        return 4;
      // : accompanied token
      case 58:
        return 3;
      // " ' ( [ opening delimit token
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      // ) ] closing delimit token
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function alloc(value) {
    return line = column = 1, length = strlen(characters = value), position = 0, [];
  }
  function dealloc(value) {
    return characters = "", value;
  }
  function delimit(type) {
    return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
  }
  function whitespace(type) {
    while (character = peek())
      if (character < 33)
        next();
      else
        break;
    return token(type) > 2 || token(character) > 3 ? "" : " ";
  }
  function escaping(index3, count3) {
    while (--count3 && next())
      if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
        break;
    return slice(index3, caret() + (count3 < 6 && peek() == 32 && next() == 32));
  }
  function delimiter(type) {
    while (next())
      switch (character) {
        // ] ) " '
        case type:
          return position;
        // " '
        case 34:
        case 39:
          if (type !== 34 && type !== 39)
            delimiter(character);
          break;
        // (
        case 40:
          if (type === 41)
            delimiter(type);
          break;
        // \
        case 92:
          next();
          break;
      }
    return position;
  }
  function commenter(type, index3) {
    while (next())
      if (type + character === 47 + 10)
        break;
      else if (type + character === 42 + 42 && peek() === 47)
        break;
    return "/*" + slice(index3, position - 1) + "*" + from(type === 47 ? type : next());
  }
  function identifier(index3) {
    while (!token(peek()))
      next();
    return slice(index3, position);
  }
  var line, column, length, position, character, characters;
  var init_Tokenizer = __esm({
    "node_modules/stylis/src/Tokenizer.js"() {
      init_Utility();
      line = 1;
      column = 1;
      length = 0;
      position = 0;
      character = 0;
      characters = "";
    }
  });

  // node_modules/stylis/src/Parser.js
  function compile(value) {
    return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
  }
  function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
    var index3 = 0;
    var offset4 = 0;
    var length2 = pseudo;
    var atrule = 0;
    var property = 0;
    var previous = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character2 = 0;
    var type = "";
    var props = rules;
    var children = rulesets;
    var reference = rule;
    var characters2 = type;
    while (scanning)
      switch (previous = character2, character2 = next()) {
        // (
        case 40:
          if (previous != 108 && charat(characters2, length2 - 1) == 58) {
            if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
              ampersand = -1;
            break;
          }
        // " ' [
        case 34:
        case 39:
        case 91:
          characters2 += delimit(character2);
          break;
        // \t \n \r \s
        case 9:
        case 10:
        case 13:
        case 32:
          characters2 += whitespace(previous);
          break;
        // \
        case 92:
          characters2 += escaping(caret() - 1, 7);
          continue;
        // /
        case 47:
          switch (peek()) {
            case 42:
            case 47:
              append(comment(commenter(next(), caret()), root, parent), declarations);
              break;
            default:
              characters2 += "/";
          }
          break;
        // {
        case 123 * variable:
          points[index3++] = strlen(characters2) * ampersand;
        // } ; \0
        case 125 * variable:
        case 59:
        case 0:
          switch (character2) {
            // \0 }
            case 0:
            case 125:
              scanning = 0;
            // ;
            case 59 + offset4:
              if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
              if (property > 0 && strlen(characters2) - length2)
                append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
              break;
            // @ ;
            case 59:
              characters2 += ";";
            // { rule/at-rule
            default:
              append(reference = ruleset(characters2, root, parent, index3, offset4, rules, points, type, props = [], children = [], length2), rulesets);
              if (character2 === 123)
                if (offset4 === 0)
                  parse(characters2, root, reference, reference, props, rulesets, length2, points, children);
                else
                  switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                    // d l m s
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                      break;
                    default:
                      parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                  }
          }
          index3 = offset4 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
          break;
        // :
        case 58:
          length2 = 1 + strlen(characters2), property = previous;
        default:
          if (variable < 1) {
            if (character2 == 123)
              --variable;
            else if (character2 == 125 && variable++ == 0 && prev() == 125)
              continue;
          }
          switch (characters2 += from(character2), character2 * variable) {
            // &
            case 38:
              ampersand = offset4 > 0 ? 1 : (characters2 += "\f", -1);
              break;
            // ,
            case 44:
              points[index3++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
              break;
            // @
            case 64:
              if (peek() === 45)
                characters2 += delimit(next());
              atrule = peek(), offset4 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
              break;
            // -
            case 45:
              if (previous === 45 && strlen(characters2) == 2)
                variable = 0;
          }
      }
    return rulesets;
  }
  function ruleset(value, root, parent, index3, offset4, rules, points, type, props, children, length2) {
    var post = offset4 - 1;
    var rule = offset4 === 0 ? rules : [""];
    var size4 = sizeof(rule);
    for (var i2 = 0, j2 = 0, k2 = 0; i2 < index3; ++i2)
      for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i2])), z = value; x2 < size4; ++x2)
        if (z = trim(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
          props[k2++] = z;
    return node(value, root, parent, offset4 === 0 ? RULESET : type, props, children, length2);
  }
  function comment(value, root, parent) {
    return node(value, root, parent, COMMENT2, from(char()), substr(value, 2, -2), 0);
  }
  function declaration(value, root, parent, length2) {
    return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
  }
  var init_Parser = __esm({
    "node_modules/stylis/src/Parser.js"() {
      init_Enum();
      init_Utility();
      init_Tokenizer();
    }
  });

  // node_modules/stylis/src/Prefixer.js
  var init_Prefixer = __esm({
    "node_modules/stylis/src/Prefixer.js"() {
    }
  });

  // node_modules/stylis/src/Serializer.js
  function serialize2(children, callback) {
    var output = "";
    var length2 = sizeof(children);
    for (var i2 = 0; i2 < length2; i2++)
      output += callback(children[i2], i2, children, callback) || "";
    return output;
  }
  function stringify(element, index3, children, callback) {
    switch (element.type) {
      case LAYER:
        if (element.children.length) break;
      case IMPORT:
      case DECLARATION:
        return element.return = element.return || element.value;
      case COMMENT2:
        return "";
      case KEYFRAMES:
        return element.return = element.value + "{" + serialize2(element.children, callback) + "}";
      case RULESET:
        element.value = element.props.join(",");
    }
    return strlen(children = serialize2(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
  }
  var init_Serializer = __esm({
    "node_modules/stylis/src/Serializer.js"() {
      init_Enum();
      init_Utility();
    }
  });

  // node_modules/stylis/src/Middleware.js
  function middleware2(collection) {
    var length2 = sizeof(collection);
    return function(element, index3, children, callback) {
      var output = "";
      for (var i2 = 0; i2 < length2; i2++)
        output += collection[i2](element, index3, children, callback) || "";
      return output;
    };
  }
  function rulesheet(callback) {
    return function(element) {
      if (!element.root) {
        if (element = element.return)
          callback(element);
      }
    };
  }
  var init_Middleware = __esm({
    "node_modules/stylis/src/Middleware.js"() {
      init_Utility();
    }
  });

  // node_modules/stylis/index.js
  var init_stylis = __esm({
    "node_modules/stylis/index.js"() {
      init_Enum();
      init_Utility();
      init_Parser();
      init_Prefixer();
      init_Tokenizer();
      init_Serializer();
      init_Middleware();
    }
  });

  // node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js
  var init_emotion_weak_memoize_esm = __esm({
    "node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js"() {
    }
  });

  // node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js
  function prefix(value, length2) {
    switch (hash(value, length2)) {
      // color-adjust
      case 5103:
        return WEBKIT + "print-" + value + value;
      // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
      case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
      // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
      case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
      // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
      case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
      // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
      case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return WEBKIT + value + value;
      // appearance, user-select, transform, hyphens, text-size-adjust
      case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return WEBKIT + value + MOZ + value + MS + value + value;
      // flex, flex-direction
      case 6828:
      case 4268:
        return WEBKIT + value + MS + value + value;
      // order
      case 6165:
        return WEBKIT + value + MS + "flex-" + value + value;
      // align-items
      case 5187:
        return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
      // align-self
      case 5443:
        return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
      // align-content
      case 4675:
        return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
      // flex-shrink
      case 5548:
        return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
      // flex-basis
      case 5292:
        return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
      // flex-grow
      case 6060:
        return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
      // transition
      case 4554:
        return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
      // cursor
      case 6187:
        return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
      // background, background-image
      case 5495:
      case 3959:
        return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
      // justify-content
      case 4968:
        return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
      // (margin|padding)-inline-(start|end)
      case 4095:
      case 3583:
      case 4068:
      case 2532:
        return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
      // (min|max)?(width|height|inline-size|block-size)
      case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
          // (m)ax-content, (m)in-content
          case 109:
            if (charat(value, length2 + 4) !== 45) break;
          // (f)ill-available, (f)it-content
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          // (s)tretch
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
        }
        break;
      // position: sticky
      case 4949:
        if (charat(value, length2 + 1) !== 115) break;
      // display: (flex|inline-flex)
      case 6444:
        switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
          // stic(k)y
          case 107:
            return replace(value, ":", ":" + WEBKIT) + value;
          // (inline-)?fl(e)x
          case 101:
            return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
        }
        break;
      // writing-mode
      case 5936:
        switch (charat(value, length2 + 11)) {
          // vertical-l(r)
          case 114:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
          // vertical-r(l)
          case 108:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
          // horizontal(-)tb
          case 45:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
        }
        return WEBKIT + value + MS + value + value;
    }
    return value;
  }
  var identifierWithPointTracking, toRules, getRules, fixedElements, compat, removeLabel, prefixer, defaultStylisPlugins, createCache;
  var init_emotion_cache_browser_esm = __esm({
    "node_modules/@emotion/cache/dist/emotion-cache.browser.esm.js"() {
      init_emotion_sheet_esm();
      init_stylis();
      init_emotion_weak_memoize_esm();
      init_emotion_memoize_esm();
      identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index3) {
        var previous = 0;
        var character2 = 0;
        while (true) {
          previous = character2;
          character2 = peek();
          if (previous === 38 && character2 === 12) {
            points[index3] = 1;
          }
          if (token(character2)) {
            break;
          }
          next();
        }
        return slice(begin, position);
      };
      toRules = function toRules2(parsed, points) {
        var index3 = -1;
        var character2 = 44;
        do {
          switch (token(character2)) {
            case 0:
              if (character2 === 38 && peek() === 12) {
                points[index3] = 1;
              }
              parsed[index3] += identifierWithPointTracking(position - 1, points, index3);
              break;
            case 2:
              parsed[index3] += delimit(character2);
              break;
            case 4:
              if (character2 === 44) {
                parsed[++index3] = peek() === 58 ? "&\f" : "";
                points[index3] = parsed[index3].length;
                break;
              }
            // fallthrough
            default:
              parsed[index3] += from(character2);
          }
        } while (character2 = next());
        return parsed;
      };
      getRules = function getRules2(value, points) {
        return dealloc(toRules(alloc(value), points));
      };
      fixedElements = /* @__PURE__ */ new WeakMap();
      compat = function compat2(element) {
        if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
        // negative .length indicates that this rule has been already prefixed
        element.length < 1) {
          return;
        }
        var value = element.value;
        var parent = element.parent;
        var isImplicitRule = element.column === parent.column && element.line === parent.line;
        while (parent.type !== "rule") {
          parent = parent.parent;
          if (!parent) return;
        }
        if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
          return;
        }
        if (isImplicitRule) {
          return;
        }
        fixedElements.set(element, true);
        var points = [];
        var rules = getRules(value, points);
        var parentRules = parent.props;
        for (var i2 = 0, k2 = 0; i2 < rules.length; i2++) {
          for (var j2 = 0; j2 < parentRules.length; j2++, k2++) {
            element.props[k2] = points[i2] ? rules[i2].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i2];
          }
        }
      };
      removeLabel = function removeLabel2(element) {
        if (element.type === "decl") {
          var value = element.value;
          if (
            // charcode for l
            value.charCodeAt(0) === 108 && // charcode for b
            value.charCodeAt(2) === 98
          ) {
            element["return"] = "";
            element.value = "";
          }
        }
      };
      prefixer = function prefixer2(element, index3, children, callback) {
        if (element.length > -1) {
          if (!element["return"]) switch (element.type) {
            case DECLARATION:
              element["return"] = prefix(element.value, element.length);
              break;
            case KEYFRAMES:
              return serialize2([copy2(element, {
                value: replace(element.value, "@", "@" + WEBKIT)
              })], callback);
            case RULESET:
              if (element.length) return combine(element.props, function(value) {
                switch (match(value, /(::plac\w+|:read-\w+)/)) {
                  // :read-(only|write)
                  case ":read-only":
                  case ":read-write":
                    return serialize2([copy2(element, {
                      props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                    })], callback);
                  // :placeholder
                  case "::placeholder":
                    return serialize2([copy2(element, {
                      props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                    }), copy2(element, {
                      props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                    }), copy2(element, {
                      props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                    })], callback);
                }
                return "";
              });
          }
        }
      };
      defaultStylisPlugins = [prefixer];
      createCache = function createCache2(options) {
        var key = options.key;
        if (key === "css") {
          var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
          Array.prototype.forEach.call(ssrStyles, function(node2) {
            var dataEmotionAttribute = node2.getAttribute("data-emotion");
            if (dataEmotionAttribute.indexOf(" ") === -1) {
              return;
            }
            document.head.appendChild(node2);
            node2.setAttribute("data-s", "");
          });
        }
        var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
        var inserted = {};
        var container;
        var nodesToHydrate = [];
        {
          container = options.container || document.head;
          Array.prototype.forEach.call(
            // this means we will ignore elements which don't have a space in them which
            // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
            document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
            function(node2) {
              var attrib = node2.getAttribute("data-emotion").split(" ");
              for (var i2 = 1; i2 < attrib.length; i2++) {
                inserted[attrib[i2]] = true;
              }
              nodesToHydrate.push(node2);
            }
          );
        }
        var _insert;
        var omnipresentPlugins = [compat, removeLabel];
        {
          var currentSheet;
          var finalizingPlugins = [stringify, rulesheet(function(rule) {
            currentSheet.insert(rule);
          })];
          var serializer = middleware2(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
          var stylis = function stylis2(styles) {
            return serialize2(compile(styles), serializer);
          };
          _insert = function insert(selector, serialized, sheet, shouldCache) {
            currentSheet = sheet;
            stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
            if (shouldCache) {
              cache2.inserted[serialized.name] = true;
            }
          };
        }
        var cache2 = {
          key,
          sheet: new StyleSheet({
            key,
            container,
            nonce: options.nonce,
            speedy: options.speedy,
            prepend: options.prepend,
            insertionPoint: options.insertionPoint
          }),
          nonce: options.nonce,
          inserted,
          registered: {},
          insert: _insert
        };
        cache2.sheet.hydrate(nodesToHydrate);
        return cache2;
      };
    }
  });

  // node_modules/@babel/runtime/helpers/esm/extends.js
  var init_extends = __esm({
    "node_modules/@babel/runtime/helpers/esm/extends.js"() {
    }
  });

  // node_modules/react-is/cjs/react-is.development.js
  var require_react_is_development = __commonJS({
    "node_modules/react-is/cjs/react-is.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var hasSymbol = typeof Symbol === "function" && Symbol.for;
          var REACT_ELEMENT_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.element") : 60103;
          var REACT_PORTAL_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.portal") : 60106;
          var REACT_FRAGMENT_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.fragment") : 60107;
          var REACT_STRICT_MODE_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.strict_mode") : 60108;
          var REACT_PROFILER_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.profiler") : 60114;
          var REACT_PROVIDER_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.provider") : 60109;
          var REACT_CONTEXT_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.context") : 60110;
          var REACT_ASYNC_MODE_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.async_mode") : 60111;
          var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.concurrent_mode") : 60111;
          var REACT_FORWARD_REF_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.forward_ref") : 60112;
          var REACT_SUSPENSE_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.suspense") : 60113;
          var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.suspense_list") : 60120;
          var REACT_MEMO_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.memo") : 60115;
          var REACT_LAZY_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.lazy") : 60116;
          var REACT_BLOCK_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.block") : 60121;
          var REACT_FUNDAMENTAL_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.fundamental") : 60117;
          var REACT_RESPONDER_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.responder") : 60118;
          var REACT_SCOPE_TYPE = hasSymbol ? /* @__PURE__ */ Symbol.for("react.scope") : 60119;
          function isValidElementType(type) {
            return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
            type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
          }
          function typeOf(object) {
            if (typeof object === "object" && object !== null) {
              var $$typeof = object.$$typeof;
              switch ($$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type = object.type;
                  switch (type) {
                    case REACT_ASYNC_MODE_TYPE:
                    case REACT_CONCURRENT_MODE_TYPE:
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                      return type;
                    default:
                      var $$typeofType = type && type.$$typeof;
                      switch ($$typeofType) {
                        case REACT_CONTEXT_TYPE:
                        case REACT_FORWARD_REF_TYPE:
                        case REACT_LAZY_TYPE:
                        case REACT_MEMO_TYPE:
                        case REACT_PROVIDER_TYPE:
                          return $$typeofType;
                        default:
                          return $$typeof;
                      }
                  }
                case REACT_PORTAL_TYPE:
                  return $$typeof;
              }
            }
            return void 0;
          }
          var AsyncMode = REACT_ASYNC_MODE_TYPE;
          var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
          var ContextConsumer = REACT_CONTEXT_TYPE;
          var ContextProvider = REACT_PROVIDER_TYPE;
          var Element2 = REACT_ELEMENT_TYPE;
          var ForwardRef = REACT_FORWARD_REF_TYPE;
          var Fragment4 = REACT_FRAGMENT_TYPE;
          var Lazy = REACT_LAZY_TYPE;
          var Memo = REACT_MEMO_TYPE;
          var Portal = REACT_PORTAL_TYPE;
          var Profiler = REACT_PROFILER_TYPE;
          var StrictMode = REACT_STRICT_MODE_TYPE;
          var Suspense2 = REACT_SUSPENSE_TYPE;
          var hasWarnedAboutDeprecatedIsAsyncMode = false;
          function isAsyncMode(object) {
            {
              if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true;
                console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
              }
            }
            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
          }
          function isConcurrentMode(object) {
            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
          }
          function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
          }
          function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
          }
          function isElement2(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
          }
          function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
          }
          function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
          }
          function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
          }
          function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
          }
          function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
          }
          function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
          }
          function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
          }
          exports.AsyncMode = AsyncMode;
          exports.ConcurrentMode = ConcurrentMode;
          exports.ContextConsumer = ContextConsumer;
          exports.ContextProvider = ContextProvider;
          exports.Element = Element2;
          exports.ForwardRef = ForwardRef;
          exports.Fragment = Fragment4;
          exports.Lazy = Lazy;
          exports.Memo = Memo;
          exports.Portal = Portal;
          exports.Profiler = Profiler;
          exports.StrictMode = StrictMode;
          exports.Suspense = Suspense2;
          exports.isAsyncMode = isAsyncMode;
          exports.isConcurrentMode = isConcurrentMode;
          exports.isContextConsumer = isContextConsumer;
          exports.isContextProvider = isContextProvider;
          exports.isElement = isElement2;
          exports.isForwardRef = isForwardRef;
          exports.isFragment = isFragment;
          exports.isLazy = isLazy;
          exports.isMemo = isMemo;
          exports.isPortal = isPortal;
          exports.isProfiler = isProfiler;
          exports.isStrictMode = isStrictMode;
          exports.isSuspense = isSuspense;
          exports.isValidElementType = isValidElementType;
          exports.typeOf = typeOf;
        })();
      }
    }
  });

  // node_modules/react-is/index.js
  var require_react_is = __commonJS({
    "node_modules/react-is/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_is_development();
      }
    }
  });

  // node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
  var require_hoist_non_react_statics_cjs = __commonJS({
    "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
      "use strict";
      var reactIs = require_react_is();
      var REACT_STATICS = {
        childContextTypes: true,
        contextType: true,
        contextTypes: true,
        defaultProps: true,
        displayName: true,
        getDefaultProps: true,
        getDerivedStateFromError: true,
        getDerivedStateFromProps: true,
        mixins: true,
        propTypes: true,
        type: true
      };
      var KNOWN_STATICS = {
        name: true,
        length: true,
        prototype: true,
        caller: true,
        callee: true,
        arguments: true,
        arity: true
      };
      var FORWARD_REF_STATICS = {
        "$$typeof": true,
        render: true,
        defaultProps: true,
        displayName: true,
        propTypes: true
      };
      var MEMO_STATICS = {
        "$$typeof": true,
        compare: true,
        defaultProps: true,
        displayName: true,
        propTypes: true,
        type: true
      };
      var TYPE_STATICS = {};
      TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
      TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
      function getStatics(component) {
        if (reactIs.isMemo(component)) {
          return MEMO_STATICS;
        }
        return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
      }
      var defineProperty = Object.defineProperty;
      var getOwnPropertyNames = Object.getOwnPropertyNames;
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var getPrototypeOf = Object.getPrototypeOf;
      var objectPrototype = Object.prototype;
      function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
        if (typeof sourceComponent !== "string") {
          if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
              hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
          }
          var keys = getOwnPropertyNames(sourceComponent);
          if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
          }
          var targetStatics = getStatics(targetComponent);
          var sourceStatics = getStatics(sourceComponent);
          for (var i2 = 0; i2 < keys.length; ++i2) {
            var key = keys[i2];
            if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
              var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
              try {
                defineProperty(targetComponent, key, descriptor);
              } catch (e2) {
              }
            }
          }
        }
        return targetComponent;
      }
      module.exports = hoistNonReactStatics;
    }
  });

  // node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js
  var React28, syncFallback, useInsertionEffect2, useInsertionEffectAlwaysWithSyncFallback, useInsertionEffectWithLayoutFallback;
  var init_emotion_use_insertion_effect_with_fallbacks_browser_esm = __esm({
    "node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.browser.esm.js"() {
      React28 = __toESM(require_react());
      syncFallback = function syncFallback2(create) {
        return create();
      };
      useInsertionEffect2 = React28["useInsertionEffect"] ? React28["useInsertionEffect"] : false;
      useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect2 || syncFallback;
      useInsertionEffectWithLayoutFallback = useInsertionEffect2 || React28.useLayoutEffect;
    }
  });

  // node_modules/@emotion/react/dist/emotion-element-f0de968e.browser.esm.js
  var React29, import_react31, isDevelopment3, EmotionCacheContext, CacheProvider, __unsafe_useEmotionCache, withEmotionCache, ThemeContext, hasOwn, typePropName, createEmotionProps, Insertion, Emotion, Emotion$1;
  var init_emotion_element_f0de968e_browser_esm = __esm({
    "node_modules/@emotion/react/dist/emotion-element-f0de968e.browser.esm.js"() {
      React29 = __toESM(require_react());
      import_react31 = __toESM(require_react());
      init_emotion_cache_browser_esm();
      init_extends();
      init_emotion_weak_memoize_esm();
      init_emotion_utils_browser_esm();
      init_emotion_serialize_esm();
      init_emotion_use_insertion_effect_with_fallbacks_browser_esm();
      isDevelopment3 = false;
      EmotionCacheContext = /* @__PURE__ */ React29.createContext(
        // we're doing this to avoid preconstruct's dead code elimination in this one case
        // because this module is primarily intended for the browser and node
        // but it's also required in react native and similar environments sometimes
        // and we could have a special build just for that
        // but this is much easier and the native packages
        // might use a different theme context in the future anyway
        typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
          key: "css"
        }) : null
      );
      CacheProvider = EmotionCacheContext.Provider;
      __unsafe_useEmotionCache = function useEmotionCache() {
        return (0, import_react31.useContext)(EmotionCacheContext);
      };
      withEmotionCache = function withEmotionCache2(func) {
        return /* @__PURE__ */ (0, import_react31.forwardRef)(function(props, ref) {
          var cache2 = (0, import_react31.useContext)(EmotionCacheContext);
          return func(props, cache2, ref);
        });
      };
      ThemeContext = /* @__PURE__ */ React29.createContext({});
      hasOwn = {}.hasOwnProperty;
      typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
      createEmotionProps = function createEmotionProps2(type, props) {
        var newProps = {};
        for (var _key in props) {
          if (hasOwn.call(props, _key)) {
            newProps[_key] = props[_key];
          }
        }
        newProps[typePropName] = type;
        return newProps;
      };
      Insertion = function Insertion2(_ref) {
        var cache2 = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
        registerStyles(cache2, serialized, isStringTag);
        useInsertionEffectAlwaysWithSyncFallback(function() {
          return insertStyles(cache2, serialized, isStringTag);
        });
        return null;
      };
      Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache2, ref) {
        var cssProp = props.css;
        if (typeof cssProp === "string" && cache2.registered[cssProp] !== void 0) {
          cssProp = cache2.registered[cssProp];
        }
        var WrappedComponent = props[typePropName];
        var registeredStyles = [cssProp];
        var className = "";
        if (typeof props.className === "string") {
          className = getRegisteredStyles(cache2.registered, registeredStyles, props.className);
        } else if (props.className != null) {
          className = props.className + " ";
        }
        var serialized = serializeStyles(registeredStyles, void 0, React29.useContext(ThemeContext));
        className += cache2.key + "-" + serialized.name;
        var newProps = {};
        for (var _key2 in props) {
          if (hasOwn.call(props, _key2) && _key2 !== "css" && _key2 !== typePropName && !isDevelopment3) {
            newProps[_key2] = props[_key2];
          }
        }
        newProps.className = className;
        if (ref) {
          newProps.ref = ref;
        }
        return /* @__PURE__ */ React29.createElement(React29.Fragment, null, /* @__PURE__ */ React29.createElement(Insertion, {
          cache: cache2,
          serialized,
          isStringTag: typeof WrappedComponent === "string"
        }), /* @__PURE__ */ React29.createElement(WrappedComponent, newProps));
      });
      Emotion$1 = Emotion;
    }
  });

  // node_modules/@emotion/react/dist/emotion-react.browser.esm.js
  function css() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return serializeStyles(args);
  }
  function keyframes() {
    var insertable = css.apply(void 0, arguments);
    var name = "animation-" + insertable.name;
    return {
      name,
      styles: "@keyframes " + name + "{" + insertable.styles + "}",
      anim: 1,
      toString: function toString2() {
        return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
      }
    };
  }
  var React30, import_hoist_non_react_statics, jsx, Global;
  var init_emotion_react_browser_esm = __esm({
    "node_modules/@emotion/react/dist/emotion-react.browser.esm.js"() {
      init_emotion_element_f0de968e_browser_esm();
      init_emotion_element_f0de968e_browser_esm();
      React30 = __toESM(require_react());
      init_emotion_utils_browser_esm();
      init_emotion_use_insertion_effect_with_fallbacks_browser_esm();
      init_emotion_serialize_esm();
      init_emotion_cache_browser_esm();
      init_extends();
      init_emotion_weak_memoize_esm();
      import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
      jsx = function jsx2(type, props) {
        var args = arguments;
        if (props == null || !hasOwn.call(props, "css")) {
          return React30.createElement.apply(void 0, args);
        }
        var argsLength = args.length;
        var createElementArgArray = new Array(argsLength);
        createElementArgArray[0] = Emotion$1;
        createElementArgArray[1] = createEmotionProps(type, props);
        for (var i2 = 2; i2 < argsLength; i2++) {
          createElementArgArray[i2] = args[i2];
        }
        return React30.createElement.apply(null, createElementArgArray);
      };
      (function(_jsx21) {
        var JSX;
        /* @__PURE__ */ (function(_JSX) {
        })(JSX || (JSX = _jsx21.JSX || (_jsx21.JSX = {})));
      })(jsx || (jsx = {}));
      Global = /* @__PURE__ */ withEmotionCache(function(props, cache2) {
        var styles = props.styles;
        var serialized = serializeStyles([styles], void 0, React30.useContext(ThemeContext));
        var sheetRef = React30.useRef();
        useInsertionEffectWithLayoutFallback(function() {
          var key = cache2.key + "-global";
          var sheet = new cache2.sheet.constructor({
            key,
            nonce: cache2.sheet.nonce,
            container: cache2.sheet.container,
            speedy: cache2.sheet.isSpeedy
          });
          var rehydrating = false;
          var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
          if (cache2.sheet.tags.length) {
            sheet.before = cache2.sheet.tags[0];
          }
          if (node2 !== null) {
            rehydrating = true;
            node2.setAttribute("data-emotion", key);
            sheet.hydrate([node2]);
          }
          sheetRef.current = [sheet, rehydrating];
          return function() {
            sheet.flush();
          };
        }, [cache2]);
        useInsertionEffectWithLayoutFallback(function() {
          var sheetRefCurrent = sheetRef.current;
          var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
          if (rehydrating) {
            sheetRefCurrent[1] = false;
            return;
          }
          if (serialized.next !== void 0) {
            insertStyles(cache2, serialized.next, true);
          }
          if (sheet.tags.length) {
            var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
            sheet.before = element;
            sheet.flush();
          }
          cache2.insert("", serialized, sheet, false);
        }, [cache2, serialized.name]);
        return null;
      });
    }
  });

  // node_modules/tss-react/esm/makeStyles.js
  function createMakeStyles(params) {
    const { useTheme: useTheme6, cache: cacheProvidedAtInception } = params;
    const { useCache } = createUseCache({ cacheProvidedAtInception });
    const { useCssAndCx } = createUseCssAndCx({ useCache });
    function makeStyles17(params2) {
      const { name: nameOrWrappedName, uniqId = `${counter2++}` } = params2 !== null && params2 !== void 0 ? params2 : {};
      const name = typeof nameOrWrappedName !== "object" ? nameOrWrappedName : Object.keys(nameOrWrappedName)[0];
      return function(cssObjectByRuleNameOrGetCssObjectByRuleName) {
        const getCssObjectByRuleName = typeof cssObjectByRuleNameOrGetCssObjectByRuleName === "function" ? cssObjectByRuleNameOrGetCssObjectByRuleName : () => cssObjectByRuleNameOrGetCssObjectByRuleName;
        return function useStyles19(params3, muiStyleOverridesParams) {
          const theme = useTheme6();
          let { css: css2, cx } = useCssAndCx();
          const cache2 = useCache();
          let classes = (0, import_react32.useMemo)(() => {
            const refClassesCache = {};
            const refClasses = typeof Proxy !== "undefined" && new Proxy({}, {
              "get": (_target, propertyKey) => {
                if (typeof propertyKey === "symbol") {
                  assert(false);
                }
                return refClassesCache[propertyKey] = `${cache2.key}-${uniqId}${name !== void 0 ? `-${name}` : ""}-${propertyKey}-ref`;
              }
            });
            const cssObjectByRuleName = getCssObjectByRuleName(theme, params3, refClasses || {});
            const classes2 = objectFromEntries(objectKeys(cssObjectByRuleName).map((ruleName) => {
              const cssObject = cssObjectByRuleName[ruleName];
              if (!cssObject.label) {
                cssObject.label = `${name !== void 0 ? `${name}-` : ""}${ruleName}`;
              }
              return [
                ruleName,
                `${css2(cssObject)}${typeGuard(ruleName, ruleName in refClassesCache) ? ` ${refClassesCache[ruleName]}` : ""}`
              ];
            }));
            objectKeys(refClassesCache).forEach((ruleName) => {
              if (ruleName in classes2) {
                return;
              }
              classes2[ruleName] = refClassesCache[ruleName];
            });
            return classes2;
          }, [cache2, css2, cx, theme, getDependencyArrayRef(params3)]);
          {
            const propsClasses = muiStyleOverridesParams === null || muiStyleOverridesParams === void 0 ? void 0 : muiStyleOverridesParams.props.classes;
            classes = (0, import_react32.useMemo)(() => mergeClasses(classes, propsClasses, cx), [classes, getDependencyArrayRef(propsClasses), cx]);
          }
          {
            const pluginResultWrap = useMuiThemeStyleOverridesPlugin({
              classes,
              css: css2,
              cx,
              "name": name !== null && name !== void 0 ? name : "makeStyle no name",
              "idOfUseStyles": uniqId,
              muiStyleOverridesParams,
              // NOTE: If it's not a Mui Theme the plugin is resilient, it will not crash
              "theme": theme
            });
            if (pluginResultWrap.classes !== void 0) {
              classes = pluginResultWrap.classes;
            }
            if (pluginResultWrap.css !== void 0) {
              css2 = pluginResultWrap.css;
            }
            if (pluginResultWrap.cx !== void 0) {
              cx = pluginResultWrap.cx;
            }
          }
          return {
            classes,
            theme,
            css: css2,
            cx
          };
        };
      };
    }
    function useStyles18() {
      const theme = useTheme6();
      const { css: css2, cx } = useCssAndCx();
      return { theme, css: css2, cx };
    }
    return { makeStyles: makeStyles17, useStyles: useStyles18 };
  }
  function TssCacheProvider(props) {
    const { children, value } = props;
    return import_react32.default.createElement(reactContext.Provider, { value }, children);
  }
  var import_react32, import_react33, useContextualCache, counter2, reactContext, createUseCache;
  var init_makeStyles = __esm({
    "node_modules/tss-react/esm/makeStyles.js"() {
      "use client";
      import_react32 = __toESM(require_react());
      init_Object_fromEntries();
      init_objectKeys();
      init_cssAndCx();
      init_getDependencyArrayRef();
      init_typeGuard();
      init_assert();
      init_mergeClasses();
      import_react33 = __toESM(require_react());
      init_themeStyleOverridesPlugin();
      init_emotion_react_browser_esm();
      useContextualCache = __unsafe_useEmotionCache;
      counter2 = 0;
      reactContext = (0, import_react33.createContext)(void 0);
      ({ createUseCache } = /* @__PURE__ */ (() => {
        function useCacheProvidedByProvider() {
          const cacheExplicitlyProvidedForTss = (0, import_react33.useContext)(reactContext);
          return cacheExplicitlyProvidedForTss;
        }
        function createUseCache2(params) {
          const { cacheProvidedAtInception } = params;
          function useCache() {
            var _a;
            const contextualCache = useContextualCache();
            const cacheExplicitlyProvidedForTss = useCacheProvidedByProvider();
            const cacheToBeUsed = (_a = cacheProvidedAtInception !== null && cacheProvidedAtInception !== void 0 ? cacheProvidedAtInception : cacheExplicitlyProvidedForTss) !== null && _a !== void 0 ? _a : contextualCache;
            if (cacheToBeUsed === null) {
              throw new Error([
                "In order to get SSR working with tss-react you need to explicitly provide an Emotion cache.",
                "MUI users be aware: This is not an error strictly related to tss-react, with or without tss-react,",
                "MUI needs an Emotion cache to be provided for SSR to work.",
                "Here is the MUI documentation related to SSR setup: https://mui.com/material-ui/guides/server-rendering/",
                "TSS provides helper that makes the process of setting up SSR easier: https://docs.tss-react.dev/ssr"
              ].join("\n"));
            }
            return cacheToBeUsed;
          }
          return { useCache };
        }
        return { createUseCache: createUseCache2 };
      })());
    }
  });

  // node_modules/tss-react/esm/tools/capitalize.js
  function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
  var init_capitalize = __esm({
    "node_modules/tss-react/esm/tools/capitalize.js"() {
    }
  });

  // node_modules/tss-react/esm/withStyles.js
  function createWithStyles(params) {
    const { useTheme: useTheme6, cache: cache2 } = params;
    const { makeStyles: makeStyles17 } = createMakeStyles({ useTheme: useTheme6, cache: cache2 });
    function withStyles(Component, cssObjectByRuleNameOrGetCssObjectByRuleName, params2) {
      const Component_ = typeof Component === "string" ? (() => {
        const tag = Component;
        const Out2 = function({ children, ...props }) {
          return (0, import_react35.createElement)(tag, props, children);
        };
        Object.defineProperty(Out2, "name", {
          "value": capitalize(tag)
        });
        return Out2;
      })() : Component;
      const name = (() => {
        {
          const { name: nameOrWrappedName } = params2 !== null && params2 !== void 0 ? params2 : {};
          if (nameOrWrappedName !== void 0) {
            return typeof nameOrWrappedName !== "object" ? nameOrWrappedName : Object.keys(nameOrWrappedName)[0];
          }
        }
        let name2 = void 0;
        displayName: {
          const displayName = Component_.displayName;
          if (typeof displayName !== "string" || displayName === "") {
            break displayName;
          }
          name2 = displayName;
        }
        functionName: {
          if (name2 !== void 0) {
            break functionName;
          }
          const functionName = Component_.name;
          if (typeof functionName !== "string" || functionName === "") {
            break functionName;
          }
          name2 = functionName;
        }
        if (name2 === void 0) {
          return void 0;
        }
        name2 = name2.replace(/\$/g, "usd");
        name2 = name2.replace(/\(/g, "_").replace(/\)/g, "_");
        name2 = name2.replace(/[^a-zA-Z0-9-_]/g, "_");
        return name2;
      })();
      const useStyles18 = makeStyles17({ ...params2, name })(typeof cssObjectByRuleNameOrGetCssObjectByRuleName === "function" ? (theme, props, classes) => incorporateMediaQueries(cssObjectByRuleNameOrGetCssObjectByRuleName(theme, props, classes)) : incorporateMediaQueries(cssObjectByRuleNameOrGetCssObjectByRuleName));
      function getHasNonRootClasses(classes) {
        for (const name2 in classes) {
          if (name2 === "root") {
            continue;
          }
          return true;
        }
        return false;
      }
      const Out = (0, import_react35.forwardRef)(function(props, ref) {
        const { className, classes: _classes, ...rest } = props;
        const { classes, cx } = useStyles18(props, { props });
        const rootClassName = cx(classes.root, className);
        fixedClassesByClasses.set(classes, {
          ...classes,
          "root": rootClassName
        });
        return import_react35.default.createElement(Component_, { ref, className: getHasNonRootClasses(classes) ? className : rootClassName, ...typeof Component === "string" ? {} : { classes }, ...rest });
      });
      if (name !== void 0) {
        Out.displayName = `${capitalize(name)}WithStyles`;
        Object.defineProperty(Out, "name", { "value": Out.displayName });
      }
      return Out;
    }
    withStyles.getClasses = getClasses;
    return { withStyles };
  }
  function getClasses(props) {
    const classesIn = props.classes;
    if (classesIn === void 0) {
      throw new Error(errorMessageGetClasses);
    }
    const classes = fixedClassesByClasses.get(classesIn);
    if (classes === void 0) {
      throw new Error(errorMessageGetClasses);
    }
    return classes;
  }
  function incorporateMediaQueries(cssObjectByRuleNameWithMediaQueries) {
    const cssObjectByRuleName = {};
    const cssObjectByRuleNameWithMediaQueriesByMediaQuery = {};
    Object.keys(cssObjectByRuleNameWithMediaQueries).forEach((ruleNameOrMediaQuery) => (ruleNameOrMediaQuery.startsWith("@media") ? cssObjectByRuleNameWithMediaQueriesByMediaQuery : cssObjectByRuleName)[ruleNameOrMediaQuery] = cssObjectByRuleNameWithMediaQueries[ruleNameOrMediaQuery]);
    Object.keys(cssObjectByRuleNameWithMediaQueriesByMediaQuery).forEach((mediaQuery) => {
      const cssObjectByRuleNameBis = cssObjectByRuleNameWithMediaQueriesByMediaQuery[mediaQuery];
      Object.keys(cssObjectByRuleNameBis).forEach((ruleName) => {
        var _a;
        return cssObjectByRuleName[ruleName] = {
          ...(_a = cssObjectByRuleName[ruleName]) !== null && _a !== void 0 ? _a : {},
          [mediaQuery]: cssObjectByRuleNameBis[ruleName]
        };
      });
    });
    return cssObjectByRuleName;
  }
  var import_react35, fixedClassesByClasses, errorMessageGetClasses;
  var init_withStyles = __esm({
    "node_modules/tss-react/esm/withStyles.js"() {
      import_react35 = __toESM(require_react());
      init_makeStyles();
      init_capitalize();
      fixedClassesByClasses = /* @__PURE__ */ new WeakMap();
      errorMessageGetClasses = "getClasses should only be used in conjunction with withStyles";
    }
  });

  // node_modules/tss-react/esm/tools/isSSR.js
  var isSSR;
  var init_isSSR = __esm({
    "node_modules/tss-react/esm/tools/isSSR.js"() {
      isSSR = (() => {
        const isBrowser2 = typeof document === "object" && typeof (document === null || document === void 0 ? void 0 : document.getElementById) === "function";
        const isJest = typeof jest !== "undefined";
        const isMocha = typeof mocha !== "undefined";
        const isVitest = typeof __vitest_worker__ !== "undefined";
        return !isBrowser2 && !isJest && !isMocha && !isVitest;
      })();
    }
  });

  // node_modules/tss-react/esm/tss.js
  function createTss(params) {
    counter3 = 0;
    nestedSelectorUsageTrackRecord.splice(0, nestedSelectorUsageTrackRecord.length);
    const { useContext: useContext8, usePlugin, cache: cacheProvidedAtInception } = params;
    const { useCache } = createUseCache({ cacheProvidedAtInception });
    const { useCssAndCx } = createUseCssAndCx({ useCache });
    const usePluginDefault = ({ classes, cx, css: css2 }) => ({ classes, cx, css: css2 });
    const tss2 = createTss_internal({
      useContext: useContext8,
      useCache,
      useCssAndCx,
      "usePlugin": usePlugin !== null && usePlugin !== void 0 ? usePlugin : usePluginDefault,
      "name": void 0,
      "doesUseNestedSelectors": false
    });
    return { tss: tss2 };
  }
  function createTss_internal(params) {
    const { useContext: useContext8, useCache, useCssAndCx, usePlugin, name, doesUseNestedSelectors } = params;
    return {
      "withParams": () => createTss_internal({ ...params }),
      "withName": (nameOrWrappedName) => createTss_internal({
        ...params,
        "name": typeof nameOrWrappedName !== "object" ? nameOrWrappedName : Object.keys(nameOrWrappedName)[0]
      }),
      "withNestedSelectors": () => createTss_internal({
        ...params,
        "doesUseNestedSelectors": true
      }),
      "create": (cssObjectByRuleNameOrGetCssObjectByRuleName) => {
        const idOfUseStyles = `x${counter3++}`;
        if (name !== void 0) {
          while (true) {
            const wrap = nestedSelectorUsageTrackRecord.find((wrap2) => wrap2.name === name);
            if (wrap === void 0) {
              break;
            }
            nestedSelectorUsageTrackRecord.splice(nestedSelectorUsageTrackRecord.indexOf(wrap), 1);
          }
        }
        const getCssObjectByRuleName = typeof cssObjectByRuleNameOrGetCssObjectByRuleName === "function" ? cssObjectByRuleNameOrGetCssObjectByRuleName : () => cssObjectByRuleNameOrGetCssObjectByRuleName;
        return function useStyles18(params2) {
          var _a, _b, _c;
          const { classesOverrides, ...paramsAndPluginParams } = params2 !== null && params2 !== void 0 ? params2 : {};
          const context2 = useContext8();
          const { css: css2, cx } = useCssAndCx();
          const cache2 = useCache();
          const getClasses2 = () => {
            const refClassesCache = {};
            const cssObjectByRuleName = getCssObjectByRuleName({
              ...params2,
              ...context2,
              ...!doesUseNestedSelectors ? {} : {
                "classes": typeof Proxy === "undefined" ? {} : new Proxy({}, {
                  "get": (_target, ruleName) => {
                    if (typeof ruleName === "symbol") {
                      assert(false);
                    }
                    if (isSSR && name === void 0) {
                      throw new Error([
                        `tss-react: In SSR setups, in order to use nested selectors, you must also give a unique name to the useStyle function.`,
                        `Solution: Use tss.withName("ComponentName").withNestedSelectors<...>()... to set a name.`
                      ].join("\n"));
                    }
                    update_nested_selector_usage_track_record: {
                      if (name === void 0) {
                        break update_nested_selector_usage_track_record;
                      }
                      let wrap = nestedSelectorUsageTrackRecord.find((wrap2) => wrap2.name === name && wrap2.idOfUseStyles === idOfUseStyles);
                      if (wrap === void 0) {
                        wrap = { name, idOfUseStyles, "nestedSelectorRuleNames": /* @__PURE__ */ new Set() };
                        nestedSelectorUsageTrackRecord.push(wrap);
                      }
                      wrap.nestedSelectorRuleNames.add(ruleName);
                    }
                    detect_potential_conflicts: {
                      if (name === void 0) {
                        break detect_potential_conflicts;
                      }
                      const hasPotentialConflict = nestedSelectorUsageTrackRecord.find((wrap) => wrap.name === name && wrap.idOfUseStyles !== idOfUseStyles && wrap.nestedSelectorRuleNames.has(ruleName)) !== void 0;
                      if (!hasPotentialConflict) {
                        break detect_potential_conflicts;
                      }
                      throw new Error([
                        `tss-react: There are in your codebase two different useStyles named "${name}" that`,
                        `both use use the nested selector ${ruleName}.
`,
                        `This may lead to CSS class name collisions, causing nested selectors to target elements outside of the intended scope.
`,
                        `Solution: Ensure each useStyles using nested selectors has a unique name.
`,
                        `Use: tss.withName("UniqueName").withNestedSelectors<...>()...`
                      ].join(" "));
                    }
                    return refClassesCache[ruleName] = `${cache2.key}-${name !== void 0 ? name : idOfUseStyles}-${ruleName}-ref`;
                  }
                })
              }
            });
            let classes2 = objectFromEntries(objectKeys(cssObjectByRuleName).map((ruleName) => {
              const cssObject = cssObjectByRuleName[ruleName];
              if (!cssObject.label) {
                cssObject.label = `${name !== void 0 ? `${name}-` : ""}${ruleName}`;
              }
              return [
                ruleName,
                `${css2(cssObject)}${typeGuard(ruleName, ruleName in refClassesCache) ? ` ${refClassesCache[ruleName]}` : ""}`
              ];
            }));
            objectKeys(refClassesCache).forEach((ruleName) => {
              if (ruleName in classes2) {
                return;
              }
              classes2[ruleName] = refClassesCache[ruleName];
            });
            classes2 = mergeClasses(classes2, classesOverrides, cx);
            return classes2;
          };
          const classes = runGetClassesOrUseCache({
            cache: cache2,
            cssObjectByRuleNameOrGetCssObjectByRuleName,
            "classesOverridesRef": getDependencyArrayRef(classesOverrides),
            "paramsAndPluginParamsRef": getDependencyArrayRef(paramsAndPluginParams),
            idOfUseStyles,
            context: context2,
            getClasses: getClasses2
          });
          const pluginResultWrap = usePlugin({
            classes,
            css: css2,
            cx,
            idOfUseStyles,
            name,
            ...context2,
            ...paramsAndPluginParams
          });
          return {
            "classes": (_a = pluginResultWrap.classes) !== null && _a !== void 0 ? _a : classes,
            "css": (_b = pluginResultWrap.css) !== null && _b !== void 0 ? _b : css2,
            "cx": (_c = pluginResultWrap.cx) !== null && _c !== void 0 ? _c : cx,
            ...context2
          };
        };
      }
    };
  }
  function runGetClassesOrUseCache(params) {
    const { cache: cache2, cssObjectByRuleNameOrGetCssObjectByRuleName, classesOverridesRef, paramsAndPluginParamsRef, idOfUseStyles, context: context2, getClasses: getClasses2 } = params;
    use_cache: {
      const mapCache_in = mapCache.get(cache2);
      if (mapCache_in === void 0) {
        break use_cache;
      }
      const mapCache_in_in = mapCache_in.get(cssObjectByRuleNameOrGetCssObjectByRuleName);
      if (mapCache_in_in === void 0) {
        break use_cache;
      }
      const mapCache_in_in_in = mapCache_in_in.get(classesOverridesRef);
      if (mapCache_in_in_in === void 0) {
        break use_cache;
      }
      const arr = mapCache_in_in_in.get(paramsAndPluginParamsRef);
      if (arr === void 0) {
        break use_cache;
      }
      const entry = arr.find(({ context: context_i }) => {
        if (context_i === context2) {
          return true;
        }
        if (objectKeys(context_i).length !== objectKeys(context2).length) {
          return false;
        }
        for (const key in context_i) {
          if (getDependencyArrayRef(context_i[key]) !== getDependencyArrayRef(context2[key])) {
            return false;
          }
        }
        return true;
      });
      if (entry === void 0) {
        break use_cache;
      }
      if ((entry === null || entry === void 0 ? void 0 : entry.idOfUseStyles) !== idOfUseStyles) {
        arr.splice(arr.indexOf(entry), 1);
        break use_cache;
      }
      return entry.result;
    }
    const result = getClasses2();
    {
      if (!mapCache.has(cache2)) {
        mapCache.set(cache2, /* @__PURE__ */ new WeakMap());
      }
      const mapCache_in = mapCache.get(cache2);
      assert(mapCache_in !== void 0);
      if (!mapCache_in.has(cssObjectByRuleNameOrGetCssObjectByRuleName)) {
        mapCache_in.set(cssObjectByRuleNameOrGetCssObjectByRuleName, /* @__PURE__ */ new Map());
      }
      const mapCache_in_in = mapCache_in.get(cssObjectByRuleNameOrGetCssObjectByRuleName);
      assert(mapCache_in_in !== void 0);
      if (!mapCache_in_in.has(classesOverridesRef)) {
        if (mapCache_in_in.size > 200) {
          mapCache_in_in.clear();
        }
        mapCache_in_in.set(classesOverridesRef, /* @__PURE__ */ new Map());
      }
      const mapCache_in_in_in = mapCache_in_in.get(classesOverridesRef);
      assert(mapCache_in_in_in !== void 0);
      if (!mapCache_in_in_in.has(paramsAndPluginParamsRef)) {
        clear_cache: {
          const threshold = typeof paramsAndPluginParamsRef === "string" ? 257 : 5;
          if (mapCache_in_in_in.size < threshold) {
            break clear_cache;
          }
          mapCache_in_in_in.clear();
        }
        mapCache_in_in_in.set(paramsAndPluginParamsRef, []);
      }
      let arr = mapCache_in_in_in.get(paramsAndPluginParamsRef);
      assert(arr !== void 0);
      if (arr.length > 5) {
        arr = [];
      }
      arr.push({ idOfUseStyles, context: context2, result });
    }
    return result;
  }
  var counter3, nestedSelectorUsageTrackRecord, mapCache;
  var init_tss = __esm({
    "node_modules/tss-react/esm/tss.js"() {
      init_makeStyles();
      init_cssAndCx();
      init_assert();
      init_Object_fromEntries();
      init_objectKeys();
      init_typeGuard();
      init_getDependencyArrayRef();
      init_mergeClasses();
      init_isSSR();
      counter3 = 0;
      nestedSelectorUsageTrackRecord = [];
      mapCache = /* @__PURE__ */ new WeakMap();
    }
  });

  // node_modules/tss-react/esm/GlobalStyles.js
  function GlobalStyles(props) {
    const { styles } = props;
    return import_react36.default.createElement(Global, { styles: css(styles) });
  }
  var import_react36;
  var init_GlobalStyles = __esm({
    "node_modules/tss-react/esm/GlobalStyles.js"() {
      "use client";
      import_react36 = __toESM(require_react());
      init_emotion_react_browser_esm();
    }
  });

  // node_modules/tss-react/esm/index.js
  var esm_exports = {};
  __export(esm_exports, {
    GlobalStyles: () => GlobalStyles,
    TssCacheProvider: () => TssCacheProvider,
    createMakeAndWithStyles: () => createMakeAndWithStyles,
    createMakeStyles: () => createMakeStyles,
    createTss: () => createTss,
    createWithStyles: () => createWithStyles,
    keyframes: () => keyframes,
    tss: () => tss,
    useStyles: () => useStyles12
  });
  function createMakeAndWithStyles(params) {
    return {
      ...createMakeStyles(params),
      ...createWithStyles(params)
    };
  }
  var tss, useStyles12;
  var init_esm = __esm({
    "node_modules/tss-react/esm/index.js"() {
      "use client";
      init_makeStyles();
      init_withStyles();
      init_tss();
      init_emotion_react_browser_esm();
      init_GlobalStyles();
      ({ tss } = createTss({
        "useContext": () => ({})
      }));
      useStyles12 = tss.create({});
    }
  });

  // node_modules/@jbrowse/core/ui/LoadingEllipses.js
  var require_LoadingEllipses = __commonJS({
    "node_modules/@jbrowse/core/ui/LoadingEllipses.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = LoadingEllipses6;
      var jsx_runtime_1 = require_jsx_runtime();
      var material_1 = require_material();
      var tss_react_1 = (init_esm(), __toCommonJS(esm_exports));
      var mui_1 = require_mui();
      var useStyles18 = (0, mui_1.makeStyles)()({
        dots: {
          "&::after": {
            display: "inline-block",
            content: '""',
            width: "1em",
            textAlign: "left",
            animation: `${(0, tss_react_1.keyframes)`
      0% {
        content: '';
      }
      25% {
          content: '.';
      }
      50% {
        content: '..';
      }
      75% {
        content: '...';
      }
      `} 1.2s infinite ease-in-out`
          }
        }
      });
      function LoadingEllipses6({ message, children, variant = "body2", ...rest }) {
        const { cx, classes } = useStyles18();
        return (0, jsx_runtime_1.jsx)(material_1.Typography, { className: cx(classes.dots, rest.className), ...rest, variant, children: message || "Loading" });
      }
    }
  });

  // node_modules/@jbrowse/core/ui/ErrorMessageStackTraceDialog.js
  var require_ErrorMessageStackTraceDialog = __commonJS({
    "node_modules/@jbrowse/core/ui/ErrorMessageStackTraceDialog.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = ErrorMessageStackTraceDialog;
      var jsx_runtime_1 = require_jsx_runtime();
      var react_1 = require_react();
      var material_1 = require_material();
      var copy_to_clipboard_1 = __importDefault(require_copy_to_clipboard());
      var source_map_js_1 = require_source_map();
      var mui_1 = require_mui();
      var Dialog_1 = __importDefault(require_Dialog());
      var ExternalLink_1 = __importDefault(require_ExternalLink());
      var LoadingEllipses_1 = __importDefault(require_LoadingEllipses());
      async function myfetch2(uri) {
        const res = await fetch(uri);
        if (!res.ok) {
          throw new Error(`HTTP ${res.status} fetching ${uri}: ${await res.text()}`);
        }
        return res;
      }
      async function myfetchjson(uri) {
        const res = await myfetch2(uri);
        return res.json();
      }
      async function myfetchtext(uri) {
        const res = await myfetch2(uri);
        return res.text();
      }
      var sourceMaps = {};
      async function getSourceMapFromUri(uri) {
        var _a;
        if (sourceMaps[uri] !== void 0) {
          return sourceMaps[uri];
        }
        const uriQuery = new URL(uri).search;
        const currentScriptContent = await myfetchtext(uri);
        let mapUri = ((_a = new RegExp(/\/\/# sourceMappingURL=(.*)/).exec(currentScriptContent)) === null || _a === void 0 ? void 0 : _a[1]) || "";
        mapUri = new URL(mapUri, uri).href + uriQuery;
        const data = await myfetchjson(mapUri);
        const map = new source_map_js_1.SourceMapConsumer(data);
        sourceMaps[uri] = map;
        return map;
      }
      async function mapStackTrace(stack) {
        const stackLines = stack.split("\n");
        const mappedStack = [];
        for (const line2 of stackLines) {
          const match2 = new RegExp(/(.*)(https?:\/\/.*):(\d+):(\d+)/).exec(line2);
          if (match2 === null) {
            mappedStack.push(line2);
            continue;
          }
          const uri = match2[2];
          const consumer = await getSourceMapFromUri(uri);
          const originalPosition = consumer.originalPositionFor({
            line: Number.parseInt(match2[3]),
            column: Number.parseInt(match2[4])
          });
          if (!originalPosition.source || !originalPosition.line || !originalPosition.column) {
            mappedStack.push(line2);
            continue;
          }
          mappedStack.push(`${originalPosition.source}:${originalPosition.line}:${originalPosition.column + 1} (${match2[1].trim()})`);
        }
        return mappedStack.join("\n");
      }
      var MAX_ERR_LEN = 1e4;
      function stripMessage(trace, error2) {
        if (trace.startsWith("Error:")) {
          const err2 = `${error2}`;
          return trace.slice(err2.length);
        } else {
          return trace;
        }
      }
      var useStyles18 = (0, mui_1.makeStyles)()((theme) => ({
        pre: {
          background: (0, material_1.alpha)(theme.palette.error.main, 0.2),
          border: `1px solid ${theme.palette.divider}`,
          overflow: "auto",
          margin: 20,
          maxHeight: 300
        }
      }));
      function Contents({ text, extra }) {
        const { classes } = useStyles18();
        const err2 = encodeURIComponent(`${[
          "I got this error from JBrowse, here is the stack trace:\n",
          "```",
          text,
          "```",
          extra ? `supporting data: ${JSON.stringify(extra, null, 2)}` : ""
        ].join("\n")}
`);
        const err22 = [
          text,
          extra ? `supporting data: ${JSON.stringify(extra, null, 2)}` : ""
        ].join("\n");
        const email = "jbrowse2@berkeley.edu";
        const githubLink = `https://github.com/GMOD/jbrowse-components/issues/new?labels=bug&title=JBrowse+issue&body=${err2}`;
        const emailLink = `mailto:${email}?subject=JBrowse%202%20error&body=${err2}`;
        return (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsxs)(material_1.Typography, { children: ["Post a new issue at", " ", (0, jsx_runtime_1.jsx)(ExternalLink_1.default, { href: githubLink, children: "GitHub" }), " or send an email to ", (0, jsx_runtime_1.jsx)(ExternalLink_1.default, { href: emailLink, children: email }), " "] }), (0, jsx_runtime_1.jsx)("pre", { className: classes.pre, children: err22 })] });
      }
      function ErrorMessageStackTraceDialog({ error: error2, onClose, extra }) {
        const [mappedStackTrace, setMappedStackTrace] = (0, react_1.useState)();
        const [secondaryError, setSecondaryError] = (0, react_1.useState)();
        const [clicked, setClicked] = (0, react_1.useState)(false);
        const stackTracePreProcessed = `${typeof error2 === "object" && error2 !== null && "stack" in error2 ? error2.stack : ""}`;
        const errorText = error2 ? `${error2}` : "";
        const stackTrace = stripMessage(stackTracePreProcessed, errorText);
        (0, react_1.useEffect)(() => {
          ;
          (async () => {
            try {
              const res = await mapStackTrace(stackTrace);
              setMappedStackTrace(res);
            } catch (e2) {
              console.error(e2);
              setMappedStackTrace(stackTrace);
              setSecondaryError(e2);
            }
          })();
        }, [stackTrace]);
        const errorBoxText = [
          secondaryError ? "Error loading source map, showing raw stack trace below:" : "",
          errorText.length > MAX_ERR_LEN ? `${errorText.slice(0, MAX_ERR_LEN)}...` : errorText,
          mappedStackTrace || "No stack trace available",
          window.JBrowseSession ? `JBrowse ${window.JBrowseSession.version}` : ""
        ].filter((f2) => !!f2).join("\n");
        return (0, jsx_runtime_1.jsxs)(Dialog_1.default, { open: true, onClose, title: "Stack trace", maxWidth: "xl", children: [(0, jsx_runtime_1.jsx)(material_1.DialogContent, { children: mappedStackTrace === void 0 ? (0, jsx_runtime_1.jsx)(LoadingEllipses_1.default, { variant: "h6" }) : (0, jsx_runtime_1.jsx)(Contents, { text: errorBoxText, extra }) }), (0, jsx_runtime_1.jsxs)(material_1.DialogActions, { children: [(0, jsx_runtime_1.jsx)(material_1.Button, { variant: "contained", color: "secondary", onClick: () => {
          (0, copy_to_clipboard_1.default)(errorBoxText);
          setClicked(true);
          setTimeout(() => {
            setClicked(false);
          }, 1e3);
        }, children: clicked ? "Copied!" : "Copy stack trace to clipboard" }), (0, jsx_runtime_1.jsx)(material_1.Button, { variant: "contained", color: "primary", onClick: onClose, children: "Close" })] })] });
      }
    }
  });

  // node_modules/@jbrowse/core/ui/ErrorMessage.js
  var require_ErrorMessage = __commonJS({
    "node_modules/@jbrowse/core/ui/ErrorMessage.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o2, m2, k2, k22) {
        if (k22 === void 0) k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m2, k2);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k2];
          } };
        }
        Object.defineProperty(o2, k22, desc);
      }) : (function(o2, m2, k2, k22) {
        if (k22 === void 0) k22 = k2;
        o2[k22] = m2[k2];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v2) {
        Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
      }) : function(o2, v2) {
        o2["default"] = v2;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o2) {
          ownKeys = Object.getOwnPropertyNames || function(o3) {
            var ar = [];
            for (var k2 in o3) if (Object.prototype.hasOwnProperty.call(o3, k2)) ar[ar.length] = k2;
            return ar;
          };
          return ownKeys(o2);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k2 = ownKeys(mod), i2 = 0; i2 < k2.length; i2++) if (k2[i2] !== "default") __createBinding(result, mod, k2[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var jsx_runtime_1 = require_jsx_runtime();
      var react_1 = require_react();
      var Refresh_1 = __importDefault(require_Refresh());
      var Report_1 = __importDefault(require_Report());
      var material_1 = require_material();
      var mui_1 = require_mui();
      var RedErrorMessageBox_1 = __importDefault(require_RedErrorMessageBox());
      var ErrorMessageStackTraceDialog = (0, react_1.lazy)(() => Promise.resolve().then(() => __importStar(require_ErrorMessageStackTraceDialog())));
      var useStyles18 = (0, mui_1.makeStyles)()((theme) => ({
        bg: {
          background: theme.palette.divider,
          border: "1px solid black",
          margin: 20
        },
        iconFloat: {
          float: "right",
          marginLeft: 100
        }
      }));
      function parseError(str) {
        let snapshotError = "";
        const findStr = "is not assignable";
        const idx = str.indexOf(findStr);
        if (idx !== -1) {
          const trim2 = str.slice(0, idx + findStr.length);
          const match2 = /.*at path "(.*)" snapshot `(.*)` is not assignable/m.exec(trim2);
          if (match2) {
            str = `Failed to load element at ${match2[1]}...Failed element had snapshot`;
            snapshotError = match2[2];
          }
          const match22 = /.*snapshot `(.*)` is not assignable/.exec(trim2);
          if (match22) {
            str = "Failed to load element...Failed element had snapshot";
            snapshotError = match22[1];
          }
        }
        return snapshotError;
      }
      function ErrorButtons({ error: error2, onReset }) {
        const { classes } = useStyles18();
        const [showStack, setShowStack] = (0, react_1.useState)(false);
        return (0, jsx_runtime_1.jsxs)("div", { className: classes.iconFloat, children: [typeof error2 === "object" && error2 && "stack" in error2 ? (0, jsx_runtime_1.jsx)(material_1.Tooltip, { title: "Get stack trace", children: (0, jsx_runtime_1.jsx)(material_1.IconButton, { onClick: () => {
          setShowStack(true);
        }, color: "primary", children: (0, jsx_runtime_1.jsx)(Report_1.default, {}) }) }) : null, onReset ? (0, jsx_runtime_1.jsx)(material_1.Tooltip, { title: "Retry", children: (0, jsx_runtime_1.jsx)(material_1.IconButton, { onClick: onReset, color: "primary", children: (0, jsx_runtime_1.jsx)(Refresh_1.default, {}) }) }) : null, showStack ? (0, jsx_runtime_1.jsx)(react_1.Suspense, { fallback: null, children: (0, jsx_runtime_1.jsx)(ErrorMessageStackTraceDialog, { error: error2, onClose: () => {
          setShowStack(false);
        } }) }) : null] });
      }
      function ErrorMessage10({ error: error2, onReset }) {
        const { classes } = useStyles18();
        const str = `${error2}`;
        const str2 = str.indexOf("expected an instance of");
        const str3 = str2 !== -1 ? str.slice(0, str2) : str;
        const snapshotError = parseError(str);
        return (0, jsx_runtime_1.jsxs)(RedErrorMessageBox_1.default, { children: [str3.slice(0, 1e4), (0, jsx_runtime_1.jsx)(ErrorButtons, { error: error2, onReset }), snapshotError ? (0, jsx_runtime_1.jsx)("pre", { className: classes.bg, children: JSON.stringify(JSON.parse(snapshotError), null, 2) }) : null] });
      }
      exports.default = ErrorMessage10;
    }
  });

  // node_modules/dompurify/dist/purify.cjs.js
  var require_purify_cjs = __commonJS({
    "node_modules/dompurify/dist/purify.cjs.js"(exports, module) {
      "use strict";
      var {
        entries,
        setPrototypeOf,
        isFrozen,
        getPrototypeOf,
        getOwnPropertyDescriptor
      } = Object;
      var {
        freeze,
        seal,
        create
      } = Object;
      var {
        apply,
        construct
      } = typeof Reflect !== "undefined" && Reflect;
      if (!freeze) {
        freeze = function freeze2(x2) {
          return x2;
        };
      }
      if (!seal) {
        seal = function seal2(x2) {
          return x2;
        };
      }
      if (!apply) {
        apply = function apply2(func, thisArg) {
          for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }
          return func.apply(thisArg, args);
        };
      }
      if (!construct) {
        construct = function construct2(Func) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          return new Func(...args);
        };
      }
      var arrayForEach = unapply(Array.prototype.forEach);
      var arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
      var arrayPop = unapply(Array.prototype.pop);
      var arrayPush = unapply(Array.prototype.push);
      var arraySplice = unapply(Array.prototype.splice);
      var stringToLowerCase = unapply(String.prototype.toLowerCase);
      var stringToString = unapply(String.prototype.toString);
      var stringMatch = unapply(String.prototype.match);
      var stringReplace = unapply(String.prototype.replace);
      var stringIndexOf = unapply(String.prototype.indexOf);
      var stringTrim = unapply(String.prototype.trim);
      var objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
      var regExpTest = unapply(RegExp.prototype.test);
      var typeErrorCreate = unconstruct(TypeError);
      function unapply(func) {
        return function(thisArg) {
          if (thisArg instanceof RegExp) {
            thisArg.lastIndex = 0;
          }
          for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            args[_key3 - 1] = arguments[_key3];
          }
          return apply(func, thisArg, args);
        };
      }
      function unconstruct(Func) {
        return function() {
          for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }
          return construct(Func, args);
        };
      }
      function addToSet(set, array) {
        let transformCaseFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
        if (setPrototypeOf) {
          setPrototypeOf(set, null);
        }
        let l2 = array.length;
        while (l2--) {
          let element = array[l2];
          if (typeof element === "string") {
            const lcElement = transformCaseFunc(element);
            if (lcElement !== element) {
              if (!isFrozen(array)) {
                array[l2] = lcElement;
              }
              element = lcElement;
            }
          }
          set[element] = true;
        }
        return set;
      }
      function cleanArray(array) {
        for (let index3 = 0; index3 < array.length; index3++) {
          const isPropertyExist = objectHasOwnProperty(array, index3);
          if (!isPropertyExist) {
            array[index3] = null;
          }
        }
        return array;
      }
      function clone(object) {
        const newObject = create(null);
        for (const [property, value] of entries(object)) {
          const isPropertyExist = objectHasOwnProperty(object, property);
          if (isPropertyExist) {
            if (Array.isArray(value)) {
              newObject[property] = cleanArray(value);
            } else if (value && typeof value === "object" && value.constructor === Object) {
              newObject[property] = clone(value);
            } else {
              newObject[property] = value;
            }
          }
        }
        return newObject;
      }
      function lookupGetter(object, prop) {
        while (object !== null) {
          const desc = getOwnPropertyDescriptor(object, prop);
          if (desc) {
            if (desc.get) {
              return unapply(desc.get);
            }
            if (typeof desc.value === "function") {
              return unapply(desc.value);
            }
          }
          object = getPrototypeOf(object);
        }
        function fallbackValue() {
          return null;
        }
        return fallbackValue;
      }
      var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
      var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "enterkeyhint", "exportparts", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "inputmode", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "part", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
      var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
      var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
      var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
      var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
      var text = freeze(["#text"]);
      var html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "exportparts", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inert", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "part", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "slot", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
      var svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "mask-type", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
      var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
      var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
      var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
      var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
      var TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm);
      var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/);
      var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
      var IS_ALLOWED_URI = seal(
        /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
        // eslint-disable-line no-useless-escape
      );
      var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
      var ATTR_WHITESPACE = seal(
        /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
        // eslint-disable-line no-control-regex
      );
      var DOCTYPE_NAME = seal(/^html$/i);
      var CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
      var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        ARIA_ATTR,
        ATTR_WHITESPACE,
        CUSTOM_ELEMENT,
        DATA_ATTR,
        DOCTYPE_NAME,
        ERB_EXPR,
        IS_ALLOWED_URI,
        IS_SCRIPT_OR_DATA,
        MUSTACHE_EXPR,
        TMPLIT_EXPR
      });
      var NODE_TYPE = {
        element: 1,
        attribute: 2,
        text: 3,
        cdataSection: 4,
        entityReference: 5,
        // Deprecated
        entityNode: 6,
        // Deprecated
        progressingInstruction: 7,
        comment: 8,
        document: 9,
        documentType: 10,
        documentFragment: 11,
        notation: 12
        // Deprecated
      };
      var getGlobal = function getGlobal2() {
        return typeof window === "undefined" ? null : window;
      };
      var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
        if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
          return null;
        }
        let suffix = null;
        const ATTR_NAME = "data-tt-policy-suffix";
        if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
          suffix = purifyHostElement.getAttribute(ATTR_NAME);
        }
        const policyName = "dompurify" + (suffix ? "#" + suffix : "");
        try {
          return trustedTypes.createPolicy(policyName, {
            createHTML(html2) {
              return html2;
            },
            createScriptURL(scriptUrl) {
              return scriptUrl;
            }
          });
        } catch (_) {
          console.warn("TrustedTypes policy " + policyName + " could not be created.");
          return null;
        }
      };
      var _createHooksMap = function _createHooksMap2() {
        return {
          afterSanitizeAttributes: [],
          afterSanitizeElements: [],
          afterSanitizeShadowDOM: [],
          beforeSanitizeAttributes: [],
          beforeSanitizeElements: [],
          beforeSanitizeShadowDOM: [],
          uponSanitizeAttribute: [],
          uponSanitizeElement: [],
          uponSanitizeShadowNode: []
        };
      };
      function createDOMPurify() {
        let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
        const DOMPurify = (root) => createDOMPurify(root);
        DOMPurify.version = "3.3.1";
        DOMPurify.removed = [];
        if (!window2 || !window2.document || window2.document.nodeType !== NODE_TYPE.document || !window2.Element) {
          DOMPurify.isSupported = false;
          return DOMPurify;
        }
        let {
          document: document2
        } = window2;
        const originalDocument = document2;
        const currentScript = originalDocument.currentScript;
        const {
          DocumentFragment,
          HTMLTemplateElement,
          Node: Node3,
          Element: Element2,
          NodeFilter,
          NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
          HTMLFormElement,
          DOMParser,
          trustedTypes
        } = window2;
        const ElementPrototype = Element2.prototype;
        const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
        const remove = lookupGetter(ElementPrototype, "remove");
        const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
        const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
        const getParentNode2 = lookupGetter(ElementPrototype, "parentNode");
        if (typeof HTMLTemplateElement === "function") {
          const template = document2.createElement("template");
          if (template.content && template.content.ownerDocument) {
            document2 = template.content.ownerDocument;
          }
        }
        let trustedTypesPolicy;
        let emptyHTML = "";
        const {
          implementation,
          createNodeIterator,
          createDocumentFragment,
          getElementsByTagName
        } = document2;
        const {
          importNode
        } = originalDocument;
        let hooks = _createHooksMap();
        DOMPurify.isSupported = typeof entries === "function" && typeof getParentNode2 === "function" && implementation && implementation.createHTMLDocument !== void 0;
        const {
          MUSTACHE_EXPR: MUSTACHE_EXPR2,
          ERB_EXPR: ERB_EXPR2,
          TMPLIT_EXPR: TMPLIT_EXPR2,
          DATA_ATTR: DATA_ATTR2,
          ARIA_ATTR: ARIA_ATTR2,
          IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
          ATTR_WHITESPACE: ATTR_WHITESPACE2,
          CUSTOM_ELEMENT: CUSTOM_ELEMENT2
        } = EXPRESSIONS;
        let {
          IS_ALLOWED_URI: IS_ALLOWED_URI$1
        } = EXPRESSIONS;
        let ALLOWED_TAGS = null;
        const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
        let ALLOWED_ATTR = null;
        const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
        let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
          tagNameCheck: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: null
          },
          attributeNameCheck: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: null
          },
          allowCustomizedBuiltInElements: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: false
          }
        }));
        let FORBID_TAGS = null;
        let FORBID_ATTR = null;
        const EXTRA_ELEMENT_HANDLING = Object.seal(create(null, {
          tagCheck: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: null
          },
          attributeCheck: {
            writable: true,
            configurable: false,
            enumerable: true,
            value: null
          }
        }));
        let ALLOW_ARIA_ATTR = true;
        let ALLOW_DATA_ATTR = true;
        let ALLOW_UNKNOWN_PROTOCOLS = false;
        let ALLOW_SELF_CLOSE_IN_ATTR = true;
        let SAFE_FOR_TEMPLATES = false;
        let SAFE_FOR_XML = true;
        let WHOLE_DOCUMENT = false;
        let SET_CONFIG = false;
        let FORCE_BODY = false;
        let RETURN_DOM = false;
        let RETURN_DOM_FRAGMENT = false;
        let RETURN_TRUSTED_TYPE = false;
        let SANITIZE_DOM = true;
        let SANITIZE_NAMED_PROPS = false;
        const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
        let KEEP_CONTENT = true;
        let IN_PLACE = false;
        let USE_PROFILES = {};
        let FORBID_CONTENTS = null;
        const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
        let DATA_URI_TAGS = null;
        const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
        let URI_SAFE_ATTRIBUTES = null;
        const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
        const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
        const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
        const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
        let NAMESPACE = HTML_NAMESPACE;
        let IS_EMPTY_INPUT = false;
        let ALLOWED_NAMESPACES = null;
        const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
        let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
        let HTML_INTEGRATION_POINTS = addToSet({}, ["annotation-xml"]);
        const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
        let PARSER_MEDIA_TYPE = null;
        const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
        const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
        let transformCaseFunc = null;
        let CONFIG = null;
        const formElement = document2.createElement("form");
        const isRegexOrFunction = function isRegexOrFunction2(testValue) {
          return testValue instanceof RegExp || testValue instanceof Function;
        };
        const _parseConfig = function _parseConfig2() {
          let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          if (CONFIG && CONFIG === cfg) {
            return;
          }
          if (!cfg || typeof cfg !== "object") {
            cfg = {};
          }
          cfg = clone(cfg);
          PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
          SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
          transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
          ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
          ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
          ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
          URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR") ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
          DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS") ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
          FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
          FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({});
          FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({});
          USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES") ? cfg.USE_PROFILES : false;
          ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
          ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
          ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
          ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
          SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
          SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false;
          WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
          RETURN_DOM = cfg.RETURN_DOM || false;
          RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
          RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
          FORCE_BODY = cfg.FORCE_BODY || false;
          SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
          SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
          KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
          IN_PLACE = cfg.IN_PLACE || false;
          IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
          NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
          MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
          HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
          CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
          if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
            CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
          }
          if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
            CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
          }
          if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
            CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
          }
          if (SAFE_FOR_TEMPLATES) {
            ALLOW_DATA_ATTR = false;
          }
          if (RETURN_DOM_FRAGMENT) {
            RETURN_DOM = true;
          }
          if (USE_PROFILES) {
            ALLOWED_TAGS = addToSet({}, text);
            ALLOWED_ATTR = [];
            if (USE_PROFILES.html === true) {
              addToSet(ALLOWED_TAGS, html$1);
              addToSet(ALLOWED_ATTR, html);
            }
            if (USE_PROFILES.svg === true) {
              addToSet(ALLOWED_TAGS, svg$1);
              addToSet(ALLOWED_ATTR, svg);
              addToSet(ALLOWED_ATTR, xml);
            }
            if (USE_PROFILES.svgFilters === true) {
              addToSet(ALLOWED_TAGS, svgFilters);
              addToSet(ALLOWED_ATTR, svg);
              addToSet(ALLOWED_ATTR, xml);
            }
            if (USE_PROFILES.mathMl === true) {
              addToSet(ALLOWED_TAGS, mathMl$1);
              addToSet(ALLOWED_ATTR, mathMl);
              addToSet(ALLOWED_ATTR, xml);
            }
          }
          if (cfg.ADD_TAGS) {
            if (typeof cfg.ADD_TAGS === "function") {
              EXTRA_ELEMENT_HANDLING.tagCheck = cfg.ADD_TAGS;
            } else {
              if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
                ALLOWED_TAGS = clone(ALLOWED_TAGS);
              }
              addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
            }
          }
          if (cfg.ADD_ATTR) {
            if (typeof cfg.ADD_ATTR === "function") {
              EXTRA_ELEMENT_HANDLING.attributeCheck = cfg.ADD_ATTR;
            } else {
              if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
                ALLOWED_ATTR = clone(ALLOWED_ATTR);
              }
              addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
            }
          }
          if (cfg.ADD_URI_SAFE_ATTR) {
            addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
          }
          if (cfg.FORBID_CONTENTS) {
            if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
              FORBID_CONTENTS = clone(FORBID_CONTENTS);
            }
            addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
          }
          if (cfg.ADD_FORBID_CONTENTS) {
            if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
              FORBID_CONTENTS = clone(FORBID_CONTENTS);
            }
            addToSet(FORBID_CONTENTS, cfg.ADD_FORBID_CONTENTS, transformCaseFunc);
          }
          if (KEEP_CONTENT) {
            ALLOWED_TAGS["#text"] = true;
          }
          if (WHOLE_DOCUMENT) {
            addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
          }
          if (ALLOWED_TAGS.table) {
            addToSet(ALLOWED_TAGS, ["tbody"]);
            delete FORBID_TAGS.tbody;
          }
          if (cfg.TRUSTED_TYPES_POLICY) {
            if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
              throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
            }
            if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
              throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
            }
            trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
            emptyHTML = trustedTypesPolicy.createHTML("");
          } else {
            if (trustedTypesPolicy === void 0) {
              trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
            }
            if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
              emptyHTML = trustedTypesPolicy.createHTML("");
            }
          }
          if (freeze) {
            freeze(cfg);
          }
          CONFIG = cfg;
        };
        const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
        const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
        const _checkValidNamespace = function _checkValidNamespace2(element) {
          let parent = getParentNode2(element);
          if (!parent || !parent.tagName) {
            parent = {
              namespaceURI: NAMESPACE,
              tagName: "template"
            };
          }
          const tagName = stringToLowerCase(element.tagName);
          const parentTagName = stringToLowerCase(parent.tagName);
          if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
            return false;
          }
          if (element.namespaceURI === SVG_NAMESPACE) {
            if (parent.namespaceURI === HTML_NAMESPACE) {
              return tagName === "svg";
            }
            if (parent.namespaceURI === MATHML_NAMESPACE) {
              return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
            }
            return Boolean(ALL_SVG_TAGS[tagName]);
          }
          if (element.namespaceURI === MATHML_NAMESPACE) {
            if (parent.namespaceURI === HTML_NAMESPACE) {
              return tagName === "math";
            }
            if (parent.namespaceURI === SVG_NAMESPACE) {
              return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
            }
            return Boolean(ALL_MATHML_TAGS[tagName]);
          }
          if (element.namespaceURI === HTML_NAMESPACE) {
            if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
              return false;
            }
            if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
              return false;
            }
            return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
          }
          if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
            return true;
          }
          return false;
        };
        const _forceRemove = function _forceRemove2(node2) {
          arrayPush(DOMPurify.removed, {
            element: node2
          });
          try {
            getParentNode2(node2).removeChild(node2);
          } catch (_) {
            remove(node2);
          }
        };
        const _removeAttribute = function _removeAttribute2(name, element) {
          try {
            arrayPush(DOMPurify.removed, {
              attribute: element.getAttributeNode(name),
              from: element
            });
          } catch (_) {
            arrayPush(DOMPurify.removed, {
              attribute: null,
              from: element
            });
          }
          element.removeAttribute(name);
          if (name === "is") {
            if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
              try {
                _forceRemove(element);
              } catch (_) {
              }
            } else {
              try {
                element.setAttribute(name, "");
              } catch (_) {
              }
            }
          }
        };
        const _initDocument = function _initDocument2(dirty) {
          let doc = null;
          let leadingWhitespace = null;
          if (FORCE_BODY) {
            dirty = "<remove></remove>" + dirty;
          } else {
            const matches2 = stringMatch(dirty, /^[\r\n\t ]+/);
            leadingWhitespace = matches2 && matches2[0];
          }
          if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
            dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
          }
          const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
          if (NAMESPACE === HTML_NAMESPACE) {
            try {
              doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
            } catch (_) {
            }
          }
          if (!doc || !doc.documentElement) {
            doc = implementation.createDocument(NAMESPACE, "template", null);
            try {
              doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
            } catch (_) {
            }
          }
          const body = doc.body || doc.documentElement;
          if (dirty && leadingWhitespace) {
            body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
          }
          if (NAMESPACE === HTML_NAMESPACE) {
            return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
          }
          return WHOLE_DOCUMENT ? doc.documentElement : body;
        };
        const _createNodeIterator = function _createNodeIterator2(root) {
          return createNodeIterator.call(
            root.ownerDocument || root,
            root,
            // eslint-disable-next-line no-bitwise
            NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION,
            null
          );
        };
        const _isClobbered = function _isClobbered2(element) {
          return element instanceof HTMLFormElement && (typeof element.nodeName !== "string" || typeof element.textContent !== "string" || typeof element.removeChild !== "function" || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== "function" || typeof element.setAttribute !== "function" || typeof element.namespaceURI !== "string" || typeof element.insertBefore !== "function" || typeof element.hasChildNodes !== "function");
        };
        const _isNode = function _isNode2(value) {
          return typeof Node3 === "function" && value instanceof Node3;
        };
        function _executeHooks(hooks2, currentNode, data) {
          arrayForEach(hooks2, (hook) => {
            hook.call(DOMPurify, currentNode, data, CONFIG);
          });
        }
        const _sanitizeElements = function _sanitizeElements2(currentNode) {
          let content = null;
          _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
          if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);
            return true;
          }
          const tagName = transformCaseFunc(currentNode.nodeName);
          _executeHooks(hooks.uponSanitizeElement, currentNode, {
            tagName,
            allowedTags: ALLOWED_TAGS
          });
          if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\w!]/g, currentNode.textContent)) {
            _forceRemove(currentNode);
            return true;
          }
          if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
            _forceRemove(currentNode);
            return true;
          }
          if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
            _forceRemove(currentNode);
            return true;
          }
          if (!(EXTRA_ELEMENT_HANDLING.tagCheck instanceof Function && EXTRA_ELEMENT_HANDLING.tagCheck(tagName)) && (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName])) {
            if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
              if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
                return false;
              }
              if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
                return false;
              }
            }
            if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
              const parentNode = getParentNode2(currentNode) || currentNode.parentNode;
              const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
              if (childNodes && parentNode) {
                const childCount = childNodes.length;
                for (let i2 = childCount - 1; i2 >= 0; --i2) {
                  const childClone = cloneNode(childNodes[i2], true);
                  childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
                  parentNode.insertBefore(childClone, getNextSibling(currentNode));
                }
              }
            }
            _forceRemove(currentNode);
            return true;
          }
          if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
            _forceRemove(currentNode);
            return true;
          }
          if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
            _forceRemove(currentNode);
            return true;
          }
          if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
            content = currentNode.textContent;
            arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
              content = stringReplace(content, expr, " ");
            });
            if (currentNode.textContent !== content) {
              arrayPush(DOMPurify.removed, {
                element: currentNode.cloneNode()
              });
              currentNode.textContent = content;
            }
          }
          _executeHooks(hooks.afterSanitizeElements, currentNode, null);
          return false;
        };
        const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
          if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
            return false;
          }
          if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName)) ;
          else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName)) ;
          else if (EXTRA_ELEMENT_HANDLING.attributeCheck instanceof Function && EXTRA_ELEMENT_HANDLING.attributeCheck(lcName, lcTag)) ;
          else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
            if (
              // First condition does a very basic check if a) it's basically a valid custom element tagname AND
              // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
              _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName, lcTag)) || // Alternative, second condition checks if it's an `is`-attribute, AND
              // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
              lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
            ) ;
            else {
              return false;
            }
          } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
          else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
          else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
          else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
          else if (value) {
            return false;
          } else ;
          return true;
        };
        const _isBasicCustomElement = function _isBasicCustomElement2(tagName) {
          return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT2);
        };
        const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
          _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
          const {
            attributes
          } = currentNode;
          if (!attributes || _isClobbered(currentNode)) {
            return;
          }
          const hookEvent = {
            attrName: "",
            attrValue: "",
            keepAttr: true,
            allowedAttributes: ALLOWED_ATTR,
            forceKeepAttr: void 0
          };
          let l2 = attributes.length;
          while (l2--) {
            const attr2 = attributes[l2];
            const {
              name,
              namespaceURI,
              value: attrValue
            } = attr2;
            const lcName = transformCaseFunc(name);
            const initValue = attrValue;
            let value = name === "value" ? initValue : stringTrim(initValue);
            hookEvent.attrName = lcName;
            hookEvent.attrValue = value;
            hookEvent.keepAttr = true;
            hookEvent.forceKeepAttr = void 0;
            _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
            value = hookEvent.attrValue;
            if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
              _removeAttribute(name, currentNode);
              value = SANITIZE_NAMED_PROPS_PREFIX + value;
            }
            if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title|textarea)/i, value)) {
              _removeAttribute(name, currentNode);
              continue;
            }
            if (lcName === "attributename" && stringMatch(value, "href")) {
              _removeAttribute(name, currentNode);
              continue;
            }
            if (hookEvent.forceKeepAttr) {
              continue;
            }
            if (!hookEvent.keepAttr) {
              _removeAttribute(name, currentNode);
              continue;
            }
            if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
              _removeAttribute(name, currentNode);
              continue;
            }
            if (SAFE_FOR_TEMPLATES) {
              arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
                value = stringReplace(value, expr, " ");
              });
            }
            const lcTag = transformCaseFunc(currentNode.nodeName);
            if (!_isValidAttribute(lcTag, lcName, value)) {
              _removeAttribute(name, currentNode);
              continue;
            }
            if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
              if (namespaceURI) ;
              else {
                switch (trustedTypes.getAttributeType(lcTag, lcName)) {
                  case "TrustedHTML": {
                    value = trustedTypesPolicy.createHTML(value);
                    break;
                  }
                  case "TrustedScriptURL": {
                    value = trustedTypesPolicy.createScriptURL(value);
                    break;
                  }
                }
              }
            }
            if (value !== initValue) {
              try {
                if (namespaceURI) {
                  currentNode.setAttributeNS(namespaceURI, name, value);
                } else {
                  currentNode.setAttribute(name, value);
                }
                if (_isClobbered(currentNode)) {
                  _forceRemove(currentNode);
                } else {
                  arrayPop(DOMPurify.removed);
                }
              } catch (_) {
                _removeAttribute(name, currentNode);
              }
            }
          }
          _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
        };
        const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
          let shadowNode = null;
          const shadowIterator = _createNodeIterator(fragment);
          _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
          while (shadowNode = shadowIterator.nextNode()) {
            _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
            _sanitizeElements(shadowNode);
            _sanitizeAttributes(shadowNode);
            if (shadowNode.content instanceof DocumentFragment) {
              _sanitizeShadowDOM2(shadowNode.content);
            }
          }
          _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
        };
        DOMPurify.sanitize = function(dirty) {
          let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          let body = null;
          let importedNode = null;
          let currentNode = null;
          let returnNode = null;
          IS_EMPTY_INPUT = !dirty;
          if (IS_EMPTY_INPUT) {
            dirty = "<!-->";
          }
          if (typeof dirty !== "string" && !_isNode(dirty)) {
            if (typeof dirty.toString === "function") {
              dirty = dirty.toString();
              if (typeof dirty !== "string") {
                throw typeErrorCreate("dirty is not a string, aborting");
              }
            } else {
              throw typeErrorCreate("toString is not a function");
            }
          }
          if (!DOMPurify.isSupported) {
            return dirty;
          }
          if (!SET_CONFIG) {
            _parseConfig(cfg);
          }
          DOMPurify.removed = [];
          if (typeof dirty === "string") {
            IN_PLACE = false;
          }
          if (IN_PLACE) {
            if (dirty.nodeName) {
              const tagName = transformCaseFunc(dirty.nodeName);
              if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
                throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
              }
            }
          } else if (dirty instanceof Node3) {
            body = _initDocument("<!---->");
            importedNode = body.ownerDocument.importNode(dirty, true);
            if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === "BODY") {
              body = importedNode;
            } else if (importedNode.nodeName === "HTML") {
              body = importedNode;
            } else {
              body.appendChild(importedNode);
            }
          } else {
            if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
            dirty.indexOf("<") === -1) {
              return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
            }
            body = _initDocument(dirty);
            if (!body) {
              return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
            }
          }
          if (body && FORCE_BODY) {
            _forceRemove(body.firstChild);
          }
          const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
          while (currentNode = nodeIterator.nextNode()) {
            _sanitizeElements(currentNode);
            _sanitizeAttributes(currentNode);
            if (currentNode.content instanceof DocumentFragment) {
              _sanitizeShadowDOM(currentNode.content);
            }
          }
          if (IN_PLACE) {
            return dirty;
          }
          if (RETURN_DOM) {
            if (RETURN_DOM_FRAGMENT) {
              returnNode = createDocumentFragment.call(body.ownerDocument);
              while (body.firstChild) {
                returnNode.appendChild(body.firstChild);
              }
            } else {
              returnNode = body;
            }
            if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
              returnNode = importNode.call(originalDocument, returnNode, true);
            }
            return returnNode;
          }
          let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
          if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
            serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
          }
          if (SAFE_FOR_TEMPLATES) {
            arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
              serializedHTML = stringReplace(serializedHTML, expr, " ");
            });
          }
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
        };
        DOMPurify.setConfig = function() {
          let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          _parseConfig(cfg);
          SET_CONFIG = true;
        };
        DOMPurify.clearConfig = function() {
          CONFIG = null;
          SET_CONFIG = false;
        };
        DOMPurify.isValidAttribute = function(tag, attr2, value) {
          if (!CONFIG) {
            _parseConfig({});
          }
          const lcTag = transformCaseFunc(tag);
          const lcName = transformCaseFunc(attr2);
          return _isValidAttribute(lcTag, lcName, value);
        };
        DOMPurify.addHook = function(entryPoint, hookFunction) {
          if (typeof hookFunction !== "function") {
            return;
          }
          arrayPush(hooks[entryPoint], hookFunction);
        };
        DOMPurify.removeHook = function(entryPoint, hookFunction) {
          if (hookFunction !== void 0) {
            const index3 = arrayLastIndexOf(hooks[entryPoint], hookFunction);
            return index3 === -1 ? void 0 : arraySplice(hooks[entryPoint], index3, 1)[0];
          }
          return arrayPop(hooks[entryPoint]);
        };
        DOMPurify.removeHooks = function(entryPoint) {
          hooks[entryPoint] = [];
        };
        DOMPurify.removeAllHooks = function() {
          hooks = _createHooksMap();
        };
        return DOMPurify;
      }
      var purify = createDOMPurify();
      module.exports = purify;
    }
  });

  // node_modules/escape-html/index.js
  var require_escape_html = __commonJS({
    "node_modules/escape-html/index.js"(exports, module) {
      "use strict";
      var matchHtmlRegExp = /["'&<>]/;
      module.exports = escapeHtml;
      function escapeHtml(string) {
        var str = "" + string;
        var match2 = matchHtmlRegExp.exec(str);
        if (!match2) {
          return str;
        }
        var escape;
        var html = "";
        var index3 = 0;
        var lastIndex = 0;
        for (index3 = match2.index; index3 < str.length; index3++) {
          switch (str.charCodeAt(index3)) {
            case 34:
              escape = "&quot;";
              break;
            case 38:
              escape = "&amp;";
              break;
            case 39:
              escape = "&#39;";
              break;
            case 60:
              escape = "&lt;";
              break;
            case 62:
              escape = "&gt;";
              break;
            default:
              continue;
          }
          if (lastIndex !== index3) {
            html += str.substring(lastIndex, index3);
          }
          lastIndex = index3 + 1;
          html += escape;
        }
        return lastIndex !== index3 ? html + str.substring(lastIndex, index3) : html;
      }
    }
  });

  // node_modules/@jbrowse/core/ui/SanitizedHTML.js
  var require_SanitizedHTML = __commonJS({
    "node_modules/@jbrowse/core/ui/SanitizedHTML.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = SanitizedHTML2;
      var jsx_runtime_1 = require_jsx_runtime();
      var react_1 = require_react();
      var dompurify_1 = __importDefault(require_purify_cjs());
      var escape_html_1 = __importDefault(require_escape_html());
      var util_1 = require_util5();
      var htmlTags = [
        "a",
        "b",
        "br",
        "code",
        "div",
        "em",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "i",
        "img",
        "li",
        "p",
        "pre",
        "span",
        "small",
        "strong",
        "table",
        "tbody",
        "sup",
        "sub",
        "td",
        "tfoot",
        "th",
        "thead",
        "tr",
        "u",
        "ul"
      ];
      var added = false;
      var full = new RegExp(htmlTags.map((tag) => String.raw`<${tag}\b[^>]*>`).join("|"), "i");
      function isHTML(str) {
        return full.test(str);
      }
      function SanitizedHTML2({ html: pre, className }) {
        const html = (0, util_1.linkify)(`${pre}`);
        const value = isHTML(html) ? html : (0, escape_html_1.default)(html);
        (0, react_1.useEffect)(() => {
          if (!added) {
            added = true;
            dompurify_1.default.addHook("afterSanitizeAttributes", (node2) => {
              if (node2.tagName === "A") {
                node2.setAttribute("rel", "noopener noreferrer");
                node2.setAttribute("target", "_blank");
              }
            });
          }
        }, []);
        return (0, jsx_runtime_1.jsx)("span", { className, dangerouslySetInnerHTML: {
          __html: dompurify_1.default.sanitize(value)
        } });
      }
    }
  });

  // node_modules/@jbrowse/core/ui/Dialog.js
  var require_Dialog = __commonJS({
    "node_modules/@jbrowse/core/ui/Dialog.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var jsx_runtime_1 = require_jsx_runtime();
      var react_1 = require_react();
      var ErrorBoundary_1 = require_ErrorBoundary();
      var Close_1 = __importDefault(require_Close());
      var material_1 = require_material();
      var mobx_react_1 = require_mobx_react();
      var mui_1 = require_mui();
      var ErrorMessage_1 = __importDefault(require_ErrorMessage());
      var SanitizedHTML_1 = __importDefault(require_SanitizedHTML());
      var useStyles18 = (0, mui_1.makeStyles)()((theme) => ({
        closeButton: {
          position: "absolute",
          right: theme.spacing(1),
          top: theme.spacing(1),
          color: theme.palette.grey[500]
        },
        errorBox: {
          width: 800,
          margin: 40
        }
      }));
      function DialogError({ error: error2 }) {
        const { classes } = useStyles18();
        return (0, jsx_runtime_1.jsx)("div", { className: classes.errorBox, children: (0, jsx_runtime_1.jsx)(ErrorMessage_1.default, { error: error2 }) });
      }
      var Dialog13 = (0, mobx_react_1.observer)(function(props) {
        const { classes } = useStyles18();
        const { titleNode, ...rest } = props;
        const { title, header, children, onClose } = rest;
        const theme = (0, material_1.useTheme)();
        return (0, jsx_runtime_1.jsx)(material_1.Dialog, { ...rest, children: (0, jsx_runtime_1.jsxs)(material_1.ScopedCssBaseline, { children: [(0, react_1.isValidElement)(header) ? header : (0, jsx_runtime_1.jsxs)(material_1.DialogTitle, { children: [titleNode || (0, jsx_runtime_1.jsx)(SanitizedHTML_1.default, { html: title || "" }), onClose ? (0, jsx_runtime_1.jsx)(material_1.IconButton, { className: classes.closeButton, onClick: () => {
          onClose();
        }, children: (0, jsx_runtime_1.jsx)(Close_1.default, {}) }) : null] }), (0, jsx_runtime_1.jsx)(material_1.Divider, {}), (0, jsx_runtime_1.jsx)(ErrorBoundary_1.ErrorBoundary, { FallbackComponent: DialogError, children: (0, jsx_runtime_1.jsx)(material_1.ThemeProvider, { theme: (0, material_1.createTheme)(theme, {
          components: {
            MuiInputBase: {
              styleOverrides: {
                input: {
                  boxSizing: "content-box!important"
                }
              }
            }
          }
        }), children }) })] }) });
      });
      exports.default = Dialog13;
    }
  });

  // node_modules/@jbrowse/core/ui/HoverMenu.js
  var require_HoverMenu = __commonJS({
    "node_modules/@jbrowse/core/ui/HoverMenu.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o2, m2, k2, k22) {
        if (k22 === void 0) k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m2, k2);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k2];
          } };
        }
        Object.defineProperty(o2, k22, desc);
      }) : (function(o2, m2, k2, k22) {
        if (k22 === void 0) k22 = k2;
        o2[k22] = m2[k2];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v2) {
        Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
      }) : function(o2, v2) {
        o2["default"] = v2;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o2) {
          ownKeys = Object.getOwnPropertyNames || function(o3) {
            var ar = [];
            for (var k2 in o3) if (Object.prototype.hasOwnProperty.call(o3, k2)) ar[ar.length] = k2;
            return ar;
          };
          return ownKeys(o2);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k2 = ownKeys(mod), i2 = 0; i2 < k2.length; i2++) if (k2[i2] !== "default") __createBinding(result, mod, k2[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      var jsx_runtime_1 = require_jsx_runtime();
      var React79 = __importStar(require_react());
      var material_1 = require_material();
      var HoverMenu = React79.forwardRef(function HoverMenu2(props, ref) {
        return (0, jsx_runtime_1.jsx)(material_1.Menu, { ...props, ref, style: {
          pointerEvents: "none",
          ...props.style
        }, slotProps: {
          ...props.slotProps,
          paper: {
            style: { pointerEvents: "auto" }
          }
        } });
      });
      exports.default = HoverMenu;
    }
  });

  // node_modules/@mui/icons-material/ArrowRight.js
  var require_ArrowRight = __commonJS({
    "node_modules/@mui/icons-material/ArrowRight.js"(exports) {
      "use strict";
      "use client";
      var _interopRequireDefault = require_interopRequireDefault().default;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
      var _jsxRuntime = require_jsx_runtime();
      var _default = exports.default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
        d: "m10 17 5-5-5-5z"
      }), "ArrowRight");
    }
  });

  // node_modules/@mui/icons-material/CheckBox.js
  var require_CheckBox = __commonJS({
    "node_modules/@mui/icons-material/CheckBox.js"(exports) {
      "use strict";
      "use client";
      var _interopRequireDefault = require_interopRequireDefault().default;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
      var _jsxRuntime = require_jsx_runtime();
      var _default = exports.default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
        d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2m-9 14-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8z"
      }), "CheckBox");
    }
  });

  // node_modules/@mui/icons-material/CheckBoxOutlineBlank.js
  var require_CheckBoxOutlineBlank = __commonJS({
    "node_modules/@mui/icons-material/CheckBoxOutlineBlank.js"(exports) {
      "use strict";
      "use client";
      var _interopRequireDefault = require_interopRequireDefault().default;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
      var _jsxRuntime = require_jsx_runtime();
      var _default = exports.default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
        d: "M19 5v14H5V5zm0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2"
      }), "CheckBoxOutlineBlank");
    }
  });

  // node_modules/@mui/icons-material/RadioButtonChecked.js
  var require_RadioButtonChecked = __commonJS({
    "node_modules/@mui/icons-material/RadioButtonChecked.js"(exports) {
      "use strict";
      "use client";
      var _interopRequireDefault = require_interopRequireDefault().default;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
      var _jsxRuntime = require_jsx_runtime();
      var _default = exports.default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
        d: "M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5m0-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8"
      }), "RadioButtonChecked");
    }
  });

  // node_modules/@mui/icons-material/RadioButtonUnchecked.js
  var require_RadioButtonUnchecked = __commonJS({
    "node_modules/@mui/icons-material/RadioButtonUnchecked.js"(exports) {
      "use strict";
      "use client";
      var _interopRequireDefault = require_interopRequireDefault().default;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
      var _jsxRuntime = require_jsx_runtime();
      var _default = exports.default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
        d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8"
      }), "RadioButtonUnchecked");
    }
  });

  // node_modules/@jbrowse/core/ui/Menu.js
  var require_Menu = __commonJS({
    "node_modules/@jbrowse/core/ui/Menu.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MenuItemEndDecoration = MenuItemEndDecoration;
      var jsx_runtime_1 = require_jsx_runtime();
      var react_1 = require_react();
      var ArrowRight_1 = __importDefault(require_ArrowRight());
      var CheckBox_1 = __importDefault(require_CheckBox());
      var CheckBoxOutlineBlank_1 = __importDefault(require_CheckBoxOutlineBlank());
      var RadioButtonChecked_1 = __importDefault(require_RadioButtonChecked());
      var RadioButtonUnchecked_1 = __importDefault(require_RadioButtonUnchecked());
      var material_1 = require_material();
      var mui_1 = require_mui();
      var util_1 = require_util5();
      var useStyles18 = (0, mui_1.makeStyles)()({
        paper: {
          position: "fixed",
          overflowY: "auto",
          overflowX: "hidden",
          minWidth: 16,
          minHeight: 16,
          maxWidth: "calc(100% - 32px)",
          maxHeight: "calc(100% - 32px)",
          top: 0,
          left: 0,
          outline: 0
        },
        menuItemEndDecoration: {
          padding: 0,
          margin: 0,
          height: 16
        }
      });
      function MenuItemEndDecoration(props) {
        const { classes } = useStyles18();
        const { type } = props;
        let checked;
        let disabled;
        if ("checked" in props) {
          ;
          ({ checked, disabled } = props);
        }
        let icon;
        switch (type) {
          case "subMenu": {
            icon = (0, jsx_runtime_1.jsx)(ArrowRight_1.default, { color: "action" });
            break;
          }
          case "checkbox": {
            if (checked) {
              const color = disabled ? "inherit" : void 0;
              icon = (0, jsx_runtime_1.jsx)(CheckBox_1.default, { color });
            } else {
              icon = (0, jsx_runtime_1.jsx)(CheckBoxOutlineBlank_1.default, { color: "action" });
            }
            break;
          }
          case "radio": {
            if (checked) {
              const color = disabled ? "inherit" : void 0;
              icon = (0, jsx_runtime_1.jsx)(RadioButtonChecked_1.default, { color });
            } else {
              icon = (0, jsx_runtime_1.jsx)(RadioButtonUnchecked_1.default, { color: "action" });
            }
            break;
          }
        }
        return (0, jsx_runtime_1.jsx)("div", { className: classes.menuItemEndDecoration, children: icon });
      }
      function checkIfValid(m2) {
        return m2.type !== "divider" && m2.type !== "subHeader" && !m2.disabled;
      }
      function findNextValidIdx(menuItems, currentIdx) {
        const idx = menuItems.slice(currentIdx + 1).findIndex(checkIfValid);
        if (idx === -1) {
          return idx;
        }
        return currentIdx + 1 + idx;
      }
      function findPreviousValidIdx(menuItems, currentIdx) {
        return (0, util_1.findLastIndex)(menuItems.slice(0, currentIdx), checkIfValid);
      }
      var MenuPage = (0, react_1.forwardRef)(function MenuPage2(props, ref) {
        const [subMenuAnchorEl, setSubMenuAnchorEl] = (0, react_1.useState)();
        const [openSubMenuIdx, setOpenSubMenuIdx] = (0, react_1.useState)();
        const [isSubMenuOpen, setIsSubMenuOpen] = (0, react_1.useState)(false);
        const [selectedMenuItemIdx, setSelectedMenuItemIdx] = (0, react_1.useState)();
        const [position2, setPosition] = (0, react_1.useState)();
        const paperRef = (0, react_1.useRef)(null);
        const { classes } = useStyles18();
        const { menuItems, onMenuItemClick, open: open2, onClose, anchorEl, top = false } = props;
        (0, react_1.useEffect)(() => {
          if (!open2) {
            setSubMenuAnchorEl(void 0);
            setOpenSubMenuIdx(void 0);
          }
        }, [open2]);
        (0, react_1.useEffect)(() => {
          const shouldSubMenuBeOpen = open2 && Boolean(subMenuAnchorEl);
          let timer;
          if (shouldSubMenuBeOpen && !isSubMenuOpen) {
            timer = setTimeout(() => {
              setIsSubMenuOpen(true);
            }, 300);
          } else if (!shouldSubMenuBeOpen && isSubMenuOpen) {
            timer = setTimeout(() => {
              setIsSubMenuOpen(false);
            }, 300);
          }
          return () => {
            clearTimeout(timer);
          };
        }, [isSubMenuOpen, open2, subMenuAnchorEl]);
        (0, react_1.useLayoutEffect)(() => {
          if (anchorEl) {
            const rect = anchorEl.getBoundingClientRect();
            if (position2) {
              if (rect.top !== position2.top || rect.left + rect.width !== position2.left) {
                setPosition({ top: rect.top, left: rect.left + rect.width });
              }
            } else {
              setPosition({ top: rect.top, left: rect.left + rect.width });
            }
          } else if (!position2) {
            setPosition({});
          }
        }, [position2, anchorEl]);
        const hasIcon = menuItems.some((menuItem) => "icon" in menuItem && menuItem.icon);
        const menuItemStyle = {};
        function handleClick(callback) {
          return (event) => {
            onMenuItemClick(event, callback);
          };
        }
        const ListContents = (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(material_1.MenuList, { autoFocusItem: open2 && !isSubMenuOpen, dense: true, children: menuItems.sort((a2, b2) => (b2.priority || 0) - (a2.priority || 0)).map((menuItem, idx) => {
          if (menuItem.type === "divider") {
            return (0, jsx_runtime_1.jsx)(material_1.Divider, { component: "li" }, `divider-${JSON.stringify(menuItem)}-${idx}`);
          }
          if (menuItem.type === "subHeader") {
            return (0, jsx_runtime_1.jsx)(material_1.ListSubheader, { children: menuItem.label }, `subHeader-${menuItem.label}-${idx}`);
          }
          let icon = null;
          let endDecoration = null;
          if (menuItem.icon) {
            const Icon = menuItem.icon;
            icon = (0, jsx_runtime_1.jsx)(material_1.ListItemIcon, { children: (0, jsx_runtime_1.jsx)(Icon, {}) });
          }
          if ("subMenu" in menuItem) {
            endDecoration = (0, jsx_runtime_1.jsx)(MenuItemEndDecoration, { type: "subMenu" });
          } else if (menuItem.type === "checkbox" || menuItem.type === "radio") {
            endDecoration = (0, jsx_runtime_1.jsx)(MenuItemEndDecoration, { type: menuItem.type, checked: menuItem.checked, disabled: menuItem.disabled });
          }
          const onClick = "onClick" in menuItem ? handleClick(menuItem.onClick) : void 0;
          return (0, jsx_runtime_1.jsxs)(material_1.MenuItem, { style: menuItemStyle, selected: idx === selectedMenuItemIdx, onClick, onMouseMove: (e2) => {
            if (e2.currentTarget !== document.activeElement) {
              e2.currentTarget.focus();
              setSelectedMenuItemIdx(idx);
            }
            if ("subMenu" in menuItem) {
              if (openSubMenuIdx !== idx) {
                setSubMenuAnchorEl(e2.currentTarget);
                setOpenSubMenuIdx(idx);
              }
            } else {
              setSubMenuAnchorEl(void 0);
              setOpenSubMenuIdx(void 0);
            }
          }, onKeyDown: (e2) => {
            switch (e2.key) {
              case "ArrowLeft":
              case "Escape": {
                onClose === null || onClose === void 0 ? void 0 : onClose(e2, "escapeKeyDown");
                break;
              }
              case "ArrowUp": {
                setSelectedMenuItemIdx(findPreviousValidIdx(menuItems, idx));
                break;
              }
              case "ArrowDown": {
                const a2 = findNextValidIdx(menuItems, idx);
                setSelectedMenuItemIdx(a2);
                break;
              }
              default: {
                if ("subMenu" in menuItem && (e2.key === "ArrowRight" || e2.key === "Enter")) {
                  setSubMenuAnchorEl(e2.currentTarget);
                  setOpenSubMenuIdx(idx);
                  setIsSubMenuOpen(true);
                }
              }
            }
          }, disabled: Boolean(menuItem.disabled), children: [icon, (0, jsx_runtime_1.jsx)(material_1.ListItemText, { primary: menuItem.label, secondary: menuItem.subLabel, inset: hasIcon && !menuItem.icon }), endDecoration] }, menuItem.id || String(menuItem.label));
        }) }), menuItems.map((menuItem, idx) => {
          let subMenu = null;
          if ("subMenu" in menuItem) {
            subMenu = (0, jsx_runtime_1.jsx)(MenuPage, { anchorEl: subMenuAnchorEl, open: isSubMenuOpen && openSubMenuIdx === idx, onClose: () => {
              setIsSubMenuOpen(false);
              setSubMenuAnchorEl(void 0);
            }, onMenuItemClick, menuItems: menuItem.subMenu }, menuItem.id || String(menuItem.label));
          }
          return subMenu;
        })] });
        return top ? ListContents : (0, jsx_runtime_1.jsx)(material_1.Grow, { in: open2, style: { transformOrigin: "0 0 0" }, ref, children: (0, jsx_runtime_1.jsx)(material_1.Paper, { elevation: 8, ref: paperRef, className: classes.paper, style: { ...position2 }, children: ListContents }) });
      });
      function Menu4(props) {
        const { open: open2, onClose, menuItems, onMenuItemClick, ...other } = props;
        return (0, jsx_runtime_1.jsx)(material_1.Popover, { open: open2, onClose, style: { zIndex: 1e4, ...other.style }, anchorOrigin: {
          vertical: "bottom",
          horizontal: "right",
          ...other.anchorOrigin
        }, transformOrigin: {
          vertical: "top",
          horizontal: "left",
          ...other.transformOrigin
        }, ...other, children: (0, jsx_runtime_1.jsx)(MenuPage, { open: open2, onClose, menuItems, onMenuItemClick, top: true }) });
      }
      exports.default = Menu4;
    }
  });

  // node_modules/@jbrowse/core/ui/hooks.js
  var require_hooks = __commonJS({
    "node_modules/@jbrowse/core/ui/hooks.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o2, m2, k2, k22) {
        if (k22 === void 0) k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m2, k2);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k2];
          } };
        }
        Object.defineProperty(o2, k22, desc);
      }) : (function(o2, m2, k2, k22) {
        if (k22 === void 0) k22 = k2;
        o2[k22] = m2[k2];
      }));
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o2, v2) {
        Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
      }) : function(o2, v2) {
        o2["default"] = v2;
      });
      var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
        var ownKeys = function(o2) {
          ownKeys = Object.getOwnPropertyNames || function(o3) {
            var ar = [];
            for (var k2 in o3) if (Object.prototype.hasOwnProperty.call(o3, k2)) ar[ar.length] = k2;
            return ar;
          };
          return ownKeys(o2);
        };
        return function(mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) {
            for (var k2 = ownKeys(mod), i2 = 0; i2 < k2.length; i2++) if (k2[i2] !== "default") __createBinding(result, mod, k2[i2]);
          }
          __setModuleDefault(result, mod);
          return result;
        };
      })();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.usePopupState = usePopupState;
      exports.bindTrigger = bindTrigger;
      exports.bindToggle = bindToggle;
      exports.bindHover = bindHover;
      exports.bindFocus = bindFocus;
      exports.bindPopover = bindPopover;
      exports.bindMenu = bindMenu;
      exports.bindPopper = bindPopper;
      var react_1 = require_react();
      var React79 = __importStar(require_react());
      function usePopupState(arg) {
        const { parentPopupState } = arg || {};
        const popupId = React79.useId();
        const [isOpen, setIsOpen] = (0, react_1.useState)(false);
        const [setAnchorElUsed, setSetAnchorElUsed] = (0, react_1.useState)(false);
        const [anchorEl, _setAnchorEl] = (0, react_1.useState)();
        const [hovered, setHovered] = (0, react_1.useState)(false);
        const [focused, setFocused] = (0, react_1.useState)(false);
        const [openEventType, setOpenEventType] = (0, react_1.useState)();
        const [childHandle, setChildHandle] = (0, react_1.useState)();
        const setAnchorEl = (0, react_1.useCallback)((el) => {
          setSetAnchorElUsed(true);
          _setAnchorEl(el);
        }, []);
        const toggle = (eventOrAnchorEl) => {
          if (isOpen) {
            close(eventOrAnchorEl);
          } else {
            open2(eventOrAnchorEl);
          }
        };
        const open2 = (eventOrAnchorEl) => {
          const event = eventOrAnchorEl instanceof Element ? void 0 : eventOrAnchorEl;
          const element = eventOrAnchorEl instanceof Element ? eventOrAnchorEl : (eventOrAnchorEl === null || eventOrAnchorEl === void 0 ? void 0 : eventOrAnchorEl.currentTarget) instanceof Element ? eventOrAnchorEl.currentTarget : void 0;
          if ((event === null || event === void 0 ? void 0 : event.type) === "touchstart") {
            return;
          }
          if (parentPopupState) {
            if (!parentPopupState.isOpen) {
              return;
            }
            if (parentPopupState.childHandle) {
              parentPopupState.childHandle.close();
            }
            parentPopupState.setChildHandle({
              popupId,
              close
            });
          }
          setIsOpen(true);
          setHovered((prev2) => (event === null || event === void 0 ? void 0 : event.type) === "mouseover" || prev2);
          setFocused((prev2) => (event === null || event === void 0 ? void 0 : event.type) === "focus" || prev2);
          setOpenEventType(event === null || event === void 0 ? void 0 : event.type);
          if (!setAnchorElUsed) {
            if (event === null || event === void 0 ? void 0 : event.currentTarget) {
              _setAnchorEl(event.currentTarget);
            } else if (element) {
              _setAnchorEl(element);
            }
          }
        };
        const close = (eventOrAnchorEl) => {
          const event = eventOrAnchorEl instanceof Element ? void 0 : eventOrAnchorEl;
          if ((event === null || event === void 0 ? void 0 : event.type) === "touchstart") {
            return;
          }
          childHandle === null || childHandle === void 0 ? void 0 : childHandle.close();
          parentPopupState === null || parentPopupState === void 0 ? void 0 : parentPopupState.setChildHandle(void 0);
          setIsOpen(false);
          setHovered(false);
          setFocused(false);
        };
        const setOpen = (nextOpen, eventOrAnchorEl) => {
          if (nextOpen) {
            open2(eventOrAnchorEl);
          } else {
            close(eventOrAnchorEl);
          }
        };
        return {
          isOpen,
          anchorEl,
          setAnchorElUsed,
          setAnchorEl,
          popupId,
          open: open2,
          close,
          toggle,
          setOpen,
          hovered,
          focused,
          _openEventType: openEventType,
          childHandle,
          setChildHandle
        };
      }
      function bindTrigger(popupState) {
        return {
          onClick: popupState.open
        };
      }
      function bindToggle(popupState) {
        return {
          onClick: popupState.toggle
        };
      }
      function bindHover(popupState) {
        const { open: open2 } = popupState;
        return {
          onMouseOver: open2
        };
      }
      function bindFocus(popupState) {
        const { open: open2 } = popupState;
        return {
          onFocus: open2
        };
      }
      function bindPopover({ isOpen, anchorEl, close, popupId }) {
        return {
          id: popupId,
          anchorEl,
          anchorReference: "anchorEl",
          open: isOpen,
          onClose: close
        };
      }
      function bindMenu({ isOpen, anchorEl, close, popupId }) {
        return {
          id: popupId,
          anchorEl,
          anchorReference: "anchorEl",
          open: isOpen,
          onClose: close
        };
      }
      function bindPopper({ isOpen, anchorEl, popupId }) {
        return {
          id: popupId,
          anchorEl,
          open: isOpen
        };
      }
    }
  });

  // node_modules/@jbrowse/core/ui/CascadingMenu.js
  var require_CascadingMenu = __commonJS({
    "node_modules/@jbrowse/core/ui/CascadingMenu.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var jsx_runtime_1 = require_jsx_runtime();
      var react_1 = require_react();
      var ChevronRight_1 = __importDefault(require_ChevronRight());
      var HelpOutline_1 = __importDefault(require_HelpOutline());
      var material_1 = require_material();
      var Dialog_1 = __importDefault(require_Dialog());
      var HoverMenu_1 = __importDefault(require_HoverMenu());
      var Menu_1 = require_Menu();
      var hooks_1 = require_hooks();
      var CascadingContext = (0, react_1.createContext)({
        parentPopupState: void 0,
        rootPopupState: void 0
      });
      function HelpIconButton({ helpText }) {
        const [helpDialogOpen, setHelpDialogOpen] = (0, react_1.useState)(false);
        const handleHelpClick = (event) => {
          event.stopPropagation();
          setHelpDialogOpen(true);
        };
        const handleClose = (event) => {
          event.stopPropagation();
          setHelpDialogOpen(false);
        };
        return (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(material_1.IconButton, { size: "small", onClick: handleHelpClick, style: { marginLeft: 4, padding: 4 }, children: (0, jsx_runtime_1.jsx)(HelpOutline_1.default, { fontSize: "small" }) }), (0, jsx_runtime_1.jsx)(Dialog_1.default, { open: helpDialogOpen, onClose: handleClose, title: "Help", onClick: (e2) => {
          e2.stopPropagation();
        }, children: (0, jsx_runtime_1.jsx)(material_1.DialogContent, { children: helpText }) })] });
      }
      function HelpIconSpacer() {
        return (0, jsx_runtime_1.jsx)("div", { style: { marginLeft: 4, padding: 4, width: 28, height: 28 } });
      }
      function CascadingMenuItem({ onClick, closeAfterItemClick, children, ...props }) {
        const { rootPopupState, parentPopupState } = (0, react_1.useContext)(CascadingContext);
        if (!rootPopupState) {
          throw new Error("must be used inside a CascadingMenu");
        }
        return (0, jsx_runtime_1.jsx)(material_1.MenuItem, { ...props, onClick: (event) => {
          if (closeAfterItemClick) {
            rootPopupState.close();
          }
          onClick === null || onClick === void 0 ? void 0 : onClick(event);
        }, onMouseOver: () => {
          if (parentPopupState === null || parentPopupState === void 0 ? void 0 : parentPopupState.childHandle) {
            parentPopupState.childHandle.close();
            parentPopupState.setChildHandle(void 0);
          }
        }, children });
      }
      function CascadingSubmenu({ title, Icon, inset, ...props }) {
        const { parentPopupState } = (0, react_1.useContext)(CascadingContext);
        const popupState = (0, hooks_1.usePopupState)({
          parentPopupState
        });
        const { onMouseOver: originalOnMouseOver, ...hoverProps } = (0, hooks_1.bindHover)(popupState);
        return (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsxs)(material_1.MenuItem, { ...(0, hooks_1.bindFocus)(popupState), ...hoverProps, onMouseOver: (event) => {
          if (parentPopupState === null || parentPopupState === void 0 ? void 0 : parentPopupState.childHandle) {
            parentPopupState.childHandle.close();
            parentPopupState.setChildHandle(void 0);
          }
          originalOnMouseOver(event);
        }, children: [Icon ? (0, jsx_runtime_1.jsx)(material_1.ListItemIcon, { children: (0, jsx_runtime_1.jsx)(Icon, {}) }) : null, (0, jsx_runtime_1.jsx)(material_1.ListItemText, { primary: title, inset }), (0, jsx_runtime_1.jsx)(ChevronRight_1.default, {})] }), (0, jsx_runtime_1.jsx)(CascadingSubmenuHover, { ...props, anchorOrigin: { vertical: "top", horizontal: "right" }, transformOrigin: { vertical: "top", horizontal: "left" }, popupState })] });
      }
      function CascadingSubmenuHover({ popupState, onMenuItemClick, menuItems, classes, ...props }) {
        const { rootPopupState } = (0, react_1.useContext)(CascadingContext);
        const context2 = (0, react_1.useMemo)(() => ({
          rootPopupState: rootPopupState || popupState,
          parentPopupState: popupState
        }), [rootPopupState, popupState]);
        return (0, jsx_runtime_1.jsx)(CascadingContext.Provider, { value: context2, children: (0, jsx_runtime_1.jsx)(HoverMenu_1.default, { ...props, ...(0, hooks_1.bindMenu)(popupState) }) });
      }
      function CascadingMenu({ popupState, onMenuItemClick, menuItems, ...props }) {
        const { rootPopupState } = (0, react_1.useContext)(CascadingContext);
        const context2 = (0, react_1.useMemo)(() => ({
          rootPopupState: rootPopupState || popupState,
          parentPopupState: popupState
        }), [rootPopupState, popupState]);
        return (0, jsx_runtime_1.jsx)(CascadingContext.Provider, { value: context2, children: (0, jsx_runtime_1.jsx)(material_1.Menu, { ...props, ...(0, hooks_1.bindMenu)(popupState) }) });
      }
      function EndDecoration({ item }) {
        if ("subMenu" in item) {
          return (0, jsx_runtime_1.jsx)(Menu_1.MenuItemEndDecoration, { type: "subMenu" });
        } else if (item.type === "checkbox" || item.type === "radio") {
          return (0, jsx_runtime_1.jsx)(Menu_1.MenuItemEndDecoration, { type: item.type, checked: item.checked, disabled: item.disabled });
        }
        return null;
      }
      function CascadingMenuList({ onMenuItemClick, closeAfterItemClick, menuItems, ...props }) {
        const hasIcon = menuItems.some((m2) => "icon" in m2 && m2.icon);
        const hasCheckboxOrRadioWithHelp = menuItems.some((m2) => (m2.type === "checkbox" || m2.type === "radio") && "helpText" in m2 && m2.helpText);
        return (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: menuItems.toSorted((a2, b2) => (b2.priority || 0) - (a2.priority || 0)).map((item, idx) => {
          return "subMenu" in item ? (0, jsx_runtime_1.jsx)(CascadingSubmenu, { title: item.label, Icon: item.icon, inset: hasIcon && !item.icon, onMenuItemClick, menuItems: item.subMenu, children: (0, jsx_runtime_1.jsx)(CascadingMenuList, { ...props, closeAfterItemClick, onMenuItemClick, menuItems: item.subMenu }) }, `subMenu-${item.label}-${idx}`) : item.type === "divider" ? (0, jsx_runtime_1.jsx)(material_1.Divider, { component: "li" }, `divider-${JSON.stringify(item)}-${idx}`) : item.type === "subHeader" ? (0, jsx_runtime_1.jsx)(material_1.ListSubheader, { children: item.label }, `subHeader-${item.label}-${idx}`) : (0, jsx_runtime_1.jsxs)(CascadingMenuItem, { closeAfterItemClick, onClick: "onClick" in item ? (event) => {
            onMenuItemClick(event, item.onClick);
          } : void 0, disabled: Boolean(item.disabled), children: [item.icon ? (0, jsx_runtime_1.jsx)(material_1.ListItemIcon, { children: (0, jsx_runtime_1.jsx)(item.icon, {}) }) : null, " ", (0, jsx_runtime_1.jsx)(material_1.ListItemText, { primary: item.label, secondary: item.subLabel, inset: hasIcon && !item.icon }), (0, jsx_runtime_1.jsx)(CascadingSpacer, {}), (0, jsx_runtime_1.jsx)(EndDecoration, { item }), item.type === "checkbox" || item.type === "radio" ? "helpText" in item && item.helpText ? (0, jsx_runtime_1.jsx)(HelpIconButton, { helpText: item.helpText }) : hasCheckboxOrRadioWithHelp ? (0, jsx_runtime_1.jsx)(HelpIconSpacer, {}) : null : "helpText" in item && item.helpText ? (0, jsx_runtime_1.jsx)(HelpIconButton, { helpText: item.helpText }) : null] }, `${item.label}-${idx}`);
        }) });
      }
      function CascadingSpacer() {
        return (0, jsx_runtime_1.jsx)("div", { style: { flexGrow: 1, minWidth: 10 } });
      }
      function CascadingMenuChildren(props) {
        const { closeAfterItemClick = true, ...rest } = props;
        return (0, jsx_runtime_1.jsx)(CascadingMenu, { ...rest, children: (0, jsx_runtime_1.jsx)(CascadingMenuList, { ...rest, closeAfterItemClick }) });
      }
      exports.default = CascadingMenuChildren;
    }
  });

  // node_modules/@jbrowse/core/ui/CascadingMenuButton.js
  var require_CascadingMenuButton = __commonJS({
    "node_modules/@jbrowse/core/ui/CascadingMenuButton.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var jsx_runtime_1 = require_jsx_runtime();
      var react_1 = require_react();
      var CascadingMenu_1 = __importDefault(require_CascadingMenu());
      var material_1 = require_material();
      var mobx_react_1 = require_mobx_react();
      var hooks_1 = require_hooks();
      var CascadingMenuButton4 = (0, mobx_react_1.observer)(function CascadingMenuButton5({ children, menuItems, closeAfterItemClick = true, stopPropagation, setOpen, onClick: onClickExtra, ...rest }) {
        const popupState = (0, hooks_1.usePopupState)();
        const { onClick, ...rest2 } = (0, hooks_1.bindTrigger)(popupState);
        const { isOpen } = popupState;
        (0, react_1.useEffect)(() => {
          setOpen === null || setOpen === void 0 ? void 0 : setOpen(isOpen);
        }, [isOpen, setOpen]);
        return (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(material_1.IconButton, { onClick: (event) => {
          if (stopPropagation) {
            event.stopPropagation();
          }
          onClick(event);
          onClickExtra === null || onClickExtra === void 0 ? void 0 : onClickExtra();
        }, ...rest2, ...rest, disabled: menuItems.length === 0, children }), (0, jsx_runtime_1.jsx)(CascadingMenu_1.default, { ...(0, hooks_1.bindPopover)(popupState), onMenuItemClick: (_, callback) => {
          callback();
        }, menuItems, closeAfterItemClick, popupState })] });
      });
      exports.default = CascadingMenuButton4;
    }
  });

  // node_modules/@mui/icons-material/esm/AccountTree.js
  var import_jsx_runtime7, AccountTree_default;
  var init_AccountTree = __esm({
    "node_modules/@mui/icons-material/esm/AccountTree.js"() {
      "use client";
      init_createSvgIcon();
      import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
      AccountTree_default = (0, import_utils.createSvgIcon)(/* @__PURE__ */ (0, import_jsx_runtime7.jsx)("path", {
        d: "M22 11V3h-7v3H9V3H2v8h7V8h2v10h4v3h7v-8h-7v3h-2V8h2v3z"
      }), "AccountTree");
    }
  });

  // node_modules/@mui/icons-material/esm/Assignment.js
  var import_jsx_runtime8, Assignment_default;
  var init_Assignment = __esm({
    "node_modules/@mui/icons-material/esm/Assignment.js"() {
      "use client";
      init_createSvgIcon();
      import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
      Assignment_default = (0, import_utils.createSvgIcon)(/* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", {
        d: "M19 3h-4.18C14.4 1.84 13.3 1 12 1s-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1m2 14H7v-2h7zm3-4H7v-2h10zm0-4H7V7h10z"
      }), "Assignment");
    }
  });

  // node_modules/@mui/icons-material/esm/FilterAlt.js
  var import_jsx_runtime9, FilterAlt_default;
  var init_FilterAlt = __esm({
    "node_modules/@mui/icons-material/esm/FilterAlt.js"() {
      "use client";
      init_createSvgIcon();
      import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
      FilterAlt_default = (0, import_utils.createSvgIcon)(/* @__PURE__ */ (0, import_jsx_runtime9.jsx)("path", {
        d: "M4.25 5.61C6.27 8.2 10 13 10 13v6c0 .55.45 1 1 1h2c.55 0 1-.45 1-1v-6s3.72-4.8 5.74-7.39c.51-.66.04-1.61-.79-1.61H5.04c-.83 0-1.3.95-.79 1.61"
      }), "FilterAlt");
    }
  });

  // node_modules/@mui/icons-material/esm/FolderOpen.js
  var import_jsx_runtime10, FolderOpen_default;
  var init_FolderOpen = __esm({
    "node_modules/@mui/icons-material/esm/FolderOpen.js"() {
      "use client";
      init_createSvgIcon();
      import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
      FolderOpen_default = (0, import_utils.createSvgIcon)(/* @__PURE__ */ (0, import_jsx_runtime10.jsx)("path", {
        d: "M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2m0 12H4V8h16z"
      }), "FolderOpen");
    }
  });

  // node_modules/@mui/icons-material/esm/Menu.js
  var import_jsx_runtime11, Menu_default;
  var init_Menu = __esm({
    "node_modules/@mui/icons-material/esm/Menu.js"() {
      "use client";
      init_createSvgIcon();
      import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
      Menu_default = (0, import_utils.createSvgIcon)(/* @__PURE__ */ (0, import_jsx_runtime11.jsx)("path", {
        d: "M3 18h18v-2H3zm0-5h18v-2H3zm0-7v2h18V6z"
      }), "Menu");
    }
  });

  // node_modules/@mui/icons-material/esm/PhotoCamera.js
  var import_jsx_runtime12, PhotoCamera_default;
  var init_PhotoCamera = __esm({
    "node_modules/@mui/icons-material/esm/PhotoCamera.js"() {
      "use client";
      init_createSvgIcon();
      import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
      PhotoCamera_default = (0, import_utils.createSvgIcon)([/* @__PURE__ */ (0, import_jsx_runtime12.jsx)("circle", {
        cx: "12",
        cy: "12",
        r: "3.2"
      }, "0"), /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("path", {
        d: "M9 2 7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-3.17L15 2zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5"
      }, "1")], "PhotoCamera");
    }
  });

  // node_modules/@mui/icons-material/esm/Search.js
  var import_jsx_runtime13, Search_default;
  var init_Search = __esm({
    "node_modules/@mui/icons-material/esm/Search.js"() {
      "use client";
      init_createSvgIcon();
      import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
      Search_default = (0, import_utils.createSvgIcon)(/* @__PURE__ */ (0, import_jsx_runtime13.jsx)("path", {
        d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"
      }), "Search");
    }
  });

  // node_modules/@mui/icons-material/esm/Sort.js
  var import_jsx_runtime14, Sort_default;
  var init_Sort = __esm({
    "node_modules/@mui/icons-material/esm/Sort.js"() {
      "use client";
      init_createSvgIcon();
      import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
      Sort_default = (0, import_utils.createSvgIcon)(/* @__PURE__ */ (0, import_jsx_runtime14.jsx)("path", {
        d: "M3 18h6v-2H3zM3 6v2h18V6zm0 7h12v-2H3z"
      }), "Sort");
    }
  });

  // node_modules/@mui/icons-material/esm/Visibility.js
  var import_jsx_runtime15, Visibility_default;
  var init_Visibility = __esm({
    "node_modules/@mui/icons-material/esm/Visibility.js"() {
      "use client";
      init_createSvgIcon();
      import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
      Visibility_default = (0, import_utils.createSvgIcon)(/* @__PURE__ */ (0, import_jsx_runtime15.jsx)("path", {
        d: "M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5M12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5m0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"
      }), "Visibility");
    }
  });

  // node_modules/@mui/material/colors/common.js
  var require_common2 = __commonJS({
    "node_modules/@mui/material/colors/common.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var common2 = {
        black: "#000",
        white: "#fff"
      };
      var _default = exports.default = common2;
    }
  });

  // node_modules/@mui/material/colors/red.js
  var require_red = __commonJS({
    "node_modules/@mui/material/colors/red.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var red2 = {
        50: "#ffebee",
        100: "#ffcdd2",
        200: "#ef9a9a",
        300: "#e57373",
        400: "#ef5350",
        500: "#f44336",
        600: "#e53935",
        700: "#d32f2f",
        800: "#c62828",
        900: "#b71c1c",
        A100: "#ff8a80",
        A200: "#ff5252",
        A400: "#ff1744",
        A700: "#d50000"
      };
      var _default = exports.default = red2;
    }
  });

  // node_modules/@mui/material/colors/pink.js
  var require_pink = __commonJS({
    "node_modules/@mui/material/colors/pink.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var pink = {
        50: "#fce4ec",
        100: "#f8bbd0",
        200: "#f48fb1",
        300: "#f06292",
        400: "#ec407a",
        500: "#e91e63",
        600: "#d81b60",
        700: "#c2185b",
        800: "#ad1457",
        900: "#880e4f",
        A100: "#ff80ab",
        A200: "#ff4081",
        A400: "#f50057",
        A700: "#c51162"
      };
      var _default = exports.default = pink;
    }
  });

  // node_modules/@mui/material/colors/purple.js
  var require_purple = __commonJS({
    "node_modules/@mui/material/colors/purple.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var purple = {
        50: "#f3e5f5",
        100: "#e1bee7",
        200: "#ce93d8",
        300: "#ba68c8",
        400: "#ab47bc",
        500: "#9c27b0",
        600: "#8e24aa",
        700: "#7b1fa2",
        800: "#6a1b9a",
        900: "#4a148c",
        A100: "#ea80fc",
        A200: "#e040fb",
        A400: "#d500f9",
        A700: "#aa00ff"
      };
      var _default = exports.default = purple;
    }
  });

  // node_modules/@mui/material/colors/deepPurple.js
  var require_deepPurple = __commonJS({
    "node_modules/@mui/material/colors/deepPurple.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var deepPurple = {
        50: "#ede7f6",
        100: "#d1c4e9",
        200: "#b39ddb",
        300: "#9575cd",
        400: "#7e57c2",
        500: "#673ab7",
        600: "#5e35b1",
        700: "#512da8",
        800: "#4527a0",
        900: "#311b92",
        A100: "#b388ff",
        A200: "#7c4dff",
        A400: "#651fff",
        A700: "#6200ea"
      };
      var _default = exports.default = deepPurple;
    }
  });

  // node_modules/@mui/material/colors/indigo.js
  var require_indigo = __commonJS({
    "node_modules/@mui/material/colors/indigo.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var indigo = {
        50: "#e8eaf6",
        100: "#c5cae9",
        200: "#9fa8da",
        300: "#7986cb",
        400: "#5c6bc0",
        500: "#3f51b5",
        600: "#3949ab",
        700: "#303f9f",
        800: "#283593",
        900: "#1a237e",
        A100: "#8c9eff",
        A200: "#536dfe",
        A400: "#3d5afe",
        A700: "#304ffe"
      };
      var _default = exports.default = indigo;
    }
  });

  // node_modules/@mui/material/colors/blue.js
  var require_blue = __commonJS({
    "node_modules/@mui/material/colors/blue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var blue2 = {
        50: "#e3f2fd",
        100: "#bbdefb",
        200: "#90caf9",
        300: "#64b5f6",
        400: "#42a5f5",
        500: "#2196f3",
        600: "#1e88e5",
        700: "#1976d2",
        800: "#1565c0",
        900: "#0d47a1",
        A100: "#82b1ff",
        A200: "#448aff",
        A400: "#2979ff",
        A700: "#2962ff"
      };
      var _default = exports.default = blue2;
    }
  });

  // node_modules/@mui/material/colors/lightBlue.js
  var require_lightBlue = __commonJS({
    "node_modules/@mui/material/colors/lightBlue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var lightBlue = {
        50: "#e1f5fe",
        100: "#b3e5fc",
        200: "#81d4fa",
        300: "#4fc3f7",
        400: "#29b6f6",
        500: "#03a9f4",
        600: "#039be5",
        700: "#0288d1",
        800: "#0277bd",
        900: "#01579b",
        A100: "#80d8ff",
        A200: "#40c4ff",
        A400: "#00b0ff",
        A700: "#0091ea"
      };
      var _default = exports.default = lightBlue;
    }
  });

  // node_modules/@mui/material/colors/cyan.js
  var require_cyan = __commonJS({
    "node_modules/@mui/material/colors/cyan.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var cyan = {
        50: "#e0f7fa",
        100: "#b2ebf2",
        200: "#80deea",
        300: "#4dd0e1",
        400: "#26c6da",
        500: "#00bcd4",
        600: "#00acc1",
        700: "#0097a7",
        800: "#00838f",
        900: "#006064",
        A100: "#84ffff",
        A200: "#18ffff",
        A400: "#00e5ff",
        A700: "#00b8d4"
      };
      var _default = exports.default = cyan;
    }
  });

  // node_modules/@mui/material/colors/teal.js
  var require_teal = __commonJS({
    "node_modules/@mui/material/colors/teal.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var teal = {
        50: "#e0f2f1",
        100: "#b2dfdb",
        200: "#80cbc4",
        300: "#4db6ac",
        400: "#26a69a",
        500: "#009688",
        600: "#00897b",
        700: "#00796b",
        800: "#00695c",
        900: "#004d40",
        A100: "#a7ffeb",
        A200: "#64ffda",
        A400: "#1de9b6",
        A700: "#00bfa5"
      };
      var _default = exports.default = teal;
    }
  });

  // node_modules/@mui/material/colors/green.js
  var require_green = __commonJS({
    "node_modules/@mui/material/colors/green.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var green2 = {
        50: "#e8f5e9",
        100: "#c8e6c9",
        200: "#a5d6a7",
        300: "#81c784",
        400: "#66bb6a",
        500: "#4caf50",
        600: "#43a047",
        700: "#388e3c",
        800: "#2e7d32",
        900: "#1b5e20",
        A100: "#b9f6ca",
        A200: "#69f0ae",
        A400: "#00e676",
        A700: "#00c853"
      };
      var _default = exports.default = green2;
    }
  });

  // node_modules/@mui/material/colors/lightGreen.js
  var require_lightGreen = __commonJS({
    "node_modules/@mui/material/colors/lightGreen.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var lightGreen = {
        50: "#f1f8e9",
        100: "#dcedc8",
        200: "#c5e1a5",
        300: "#aed581",
        400: "#9ccc65",
        500: "#8bc34a",
        600: "#7cb342",
        700: "#689f38",
        800: "#558b2f",
        900: "#33691e",
        A100: "#ccff90",
        A200: "#b2ff59",
        A400: "#76ff03",
        A700: "#64dd17"
      };
      var _default = exports.default = lightGreen;
    }
  });

  // node_modules/@mui/material/colors/lime.js
  var require_lime = __commonJS({
    "node_modules/@mui/material/colors/lime.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var lime = {
        50: "#f9fbe7",
        100: "#f0f4c3",
        200: "#e6ee9c",
        300: "#dce775",
        400: "#d4e157",
        500: "#cddc39",
        600: "#c0ca33",
        700: "#afb42b",
        800: "#9e9d24",
        900: "#827717",
        A100: "#f4ff81",
        A200: "#eeff41",
        A400: "#c6ff00",
        A700: "#aeea00"
      };
      var _default = exports.default = lime;
    }
  });

  // node_modules/@mui/material/colors/yellow.js
  var require_yellow = __commonJS({
    "node_modules/@mui/material/colors/yellow.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var yellow = {
        50: "#fffde7",
        100: "#fff9c4",
        200: "#fff59d",
        300: "#fff176",
        400: "#ffee58",
        500: "#ffeb3b",
        600: "#fdd835",
        700: "#fbc02d",
        800: "#f9a825",
        900: "#f57f17",
        A100: "#ffff8d",
        A200: "#ffff00",
        A400: "#ffea00",
        A700: "#ffd600"
      };
      var _default = exports.default = yellow;
    }
  });

  // node_modules/@mui/material/colors/amber.js
  var require_amber = __commonJS({
    "node_modules/@mui/material/colors/amber.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var amber = {
        50: "#fff8e1",
        100: "#ffecb3",
        200: "#ffe082",
        300: "#ffd54f",
        400: "#ffca28",
        500: "#ffc107",
        600: "#ffb300",
        700: "#ffa000",
        800: "#ff8f00",
        900: "#ff6f00",
        A100: "#ffe57f",
        A200: "#ffd740",
        A400: "#ffc400",
        A700: "#ffab00"
      };
      var _default = exports.default = amber;
    }
  });

  // node_modules/@mui/material/colors/orange.js
  var require_orange = __commonJS({
    "node_modules/@mui/material/colors/orange.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var orange2 = {
        50: "#fff3e0",
        100: "#ffe0b2",
        200: "#ffcc80",
        300: "#ffb74d",
        400: "#ffa726",
        500: "#ff9800",
        600: "#fb8c00",
        700: "#f57c00",
        800: "#ef6c00",
        900: "#e65100",
        A100: "#ffd180",
        A200: "#ffab40",
        A400: "#ff9100",
        A700: "#ff6d00"
      };
      var _default = exports.default = orange2;
    }
  });

  // node_modules/@mui/material/colors/deepOrange.js
  var require_deepOrange = __commonJS({
    "node_modules/@mui/material/colors/deepOrange.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var deepOrange = {
        50: "#fbe9e7",
        100: "#ffccbc",
        200: "#ffab91",
        300: "#ff8a65",
        400: "#ff7043",
        500: "#ff5722",
        600: "#f4511e",
        700: "#e64a19",
        800: "#d84315",
        900: "#bf360c",
        A100: "#ff9e80",
        A200: "#ff6e40",
        A400: "#ff3d00",
        A700: "#dd2c00"
      };
      var _default = exports.default = deepOrange;
    }
  });

  // node_modules/@mui/material/colors/brown.js
  var require_brown = __commonJS({
    "node_modules/@mui/material/colors/brown.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var brown = {
        50: "#efebe9",
        100: "#d7ccc8",
        200: "#bcaaa4",
        300: "#a1887f",
        400: "#8d6e63",
        500: "#795548",
        600: "#6d4c41",
        700: "#5d4037",
        800: "#4e342e",
        900: "#3e2723",
        A100: "#d7ccc8",
        A200: "#bcaaa4",
        A400: "#8d6e63",
        A700: "#5d4037"
      };
      var _default = exports.default = brown;
    }
  });

  // node_modules/@mui/material/colors/grey.js
  var require_grey = __commonJS({
    "node_modules/@mui/material/colors/grey.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var grey = {
        50: "#fafafa",
        100: "#f5f5f5",
        200: "#eeeeee",
        300: "#e0e0e0",
        400: "#bdbdbd",
        500: "#9e9e9e",
        600: "#757575",
        700: "#616161",
        800: "#424242",
        900: "#212121",
        A100: "#f5f5f5",
        A200: "#eeeeee",
        A400: "#bdbdbd",
        A700: "#616161"
      };
      var _default = exports.default = grey;
    }
  });

  // node_modules/@mui/material/colors/blueGrey.js
  var require_blueGrey = __commonJS({
    "node_modules/@mui/material/colors/blueGrey.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var blueGrey = {
        50: "#eceff1",
        100: "#cfd8dc",
        200: "#b0bec5",
        300: "#90a4ae",
        400: "#78909c",
        500: "#607d8b",
        600: "#546e7a",
        700: "#455a64",
        800: "#37474f",
        900: "#263238",
        A100: "#cfd8dc",
        A200: "#b0bec5",
        A400: "#78909c",
        A700: "#455a64"
      };
      var _default = exports.default = blueGrey;
    }
  });

  // node_modules/@mui/material/colors/index.js
  var require_colors = __commonJS({
    "node_modules/@mui/material/colors/index.js"(exports) {
      "use strict";
      var _interopRequireDefault = require_interopRequireDefault().default;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      Object.defineProperty(exports, "amber", {
        enumerable: true,
        get: function() {
          return _amber.default;
        }
      });
      Object.defineProperty(exports, "blue", {
        enumerable: true,
        get: function() {
          return _blue.default;
        }
      });
      Object.defineProperty(exports, "blueGrey", {
        enumerable: true,
        get: function() {
          return _blueGrey.default;
        }
      });
      Object.defineProperty(exports, "brown", {
        enumerable: true,
        get: function() {
          return _brown.default;
        }
      });
      Object.defineProperty(exports, "common", {
        enumerable: true,
        get: function() {
          return _common.default;
        }
      });
      Object.defineProperty(exports, "cyan", {
        enumerable: true,
        get: function() {
          return _cyan.default;
        }
      });
      Object.defineProperty(exports, "deepOrange", {
        enumerable: true,
        get: function() {
          return _deepOrange.default;
        }
      });
      Object.defineProperty(exports, "deepPurple", {
        enumerable: true,
        get: function() {
          return _deepPurple.default;
        }
      });
      Object.defineProperty(exports, "green", {
        enumerable: true,
        get: function() {
          return _green.default;
        }
      });
      Object.defineProperty(exports, "grey", {
        enumerable: true,
        get: function() {
          return _grey.default;
        }
      });
      Object.defineProperty(exports, "indigo", {
        enumerable: true,
        get: function() {
          return _indigo.default;
        }
      });
      Object.defineProperty(exports, "lightBlue", {
        enumerable: true,
        get: function() {
          return _lightBlue.default;
        }
      });
      Object.defineProperty(exports, "lightGreen", {
        enumerable: true,
        get: function() {
          return _lightGreen.default;
        }
      });
      Object.defineProperty(exports, "lime", {
        enumerable: true,
        get: function() {
          return _lime.default;
        }
      });
      Object.defineProperty(exports, "orange", {
        enumerable: true,
        get: function() {
          return _orange.default;
        }
      });
      Object.defineProperty(exports, "pink", {
        enumerable: true,
        get: function() {
          return _pink.default;
        }
      });
      Object.defineProperty(exports, "purple", {
        enumerable: true,
        get: function() {
          return _purple.default;
        }
      });
      Object.defineProperty(exports, "red", {
        enumerable: true,
        get: function() {
          return _red.default;
        }
      });
      Object.defineProperty(exports, "teal", {
        enumerable: true,
        get: function() {
          return _teal.default;
        }
      });
      Object.defineProperty(exports, "yellow", {
        enumerable: true,
        get: function() {
          return _yellow.default;
        }
      });
      var _common = _interopRequireDefault(require_common2());
      var _red = _interopRequireDefault(require_red());
      var _pink = _interopRequireDefault(require_pink());
      var _purple = _interopRequireDefault(require_purple());
      var _deepPurple = _interopRequireDefault(require_deepPurple());
      var _indigo = _interopRequireDefault(require_indigo());
      var _blue = _interopRequireDefault(require_blue());
      var _lightBlue = _interopRequireDefault(require_lightBlue());
      var _cyan = _interopRequireDefault(require_cyan());
      var _teal = _interopRequireDefault(require_teal());
      var _green = _interopRequireDefault(require_green());
      var _lightGreen = _interopRequireDefault(require_lightGreen());
      var _lime = _interopRequireDefault(require_lime());
      var _yellow = _interopRequireDefault(require_yellow());
      var _amber = _interopRequireDefault(require_amber());
      var _orange = _interopRequireDefault(require_orange());
      var _deepOrange = _interopRequireDefault(require_deepOrange());
      var _brown = _interopRequireDefault(require_brown());
      var _grey = _interopRequireDefault(require_grey());
      var _blueGrey = _interopRequireDefault(require_blueGrey());
    }
  });

  // node_modules/deepmerge/dist/cjs.js
  var require_cjs2 = __commonJS({
    "node_modules/deepmerge/dist/cjs.js"(exports, module) {
      "use strict";
      var isMergeableObject = function isMergeableObject2(value) {
        return isNonNullObject(value) && !isSpecial(value);
      };
      function isNonNullObject(value) {
        return !!value && typeof value === "object";
      }
      function isSpecial(value) {
        var stringValue = Object.prototype.toString.call(value);
        return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
      }
      var canUseSymbol = typeof Symbol === "function" && Symbol.for;
      var REACT_ELEMENT_TYPE = canUseSymbol ? /* @__PURE__ */ Symbol.for("react.element") : 60103;
      function isReactElement(value) {
        return value.$$typeof === REACT_ELEMENT_TYPE;
      }
      function emptyTarget(val) {
        return Array.isArray(val) ? [] : {};
      }
      function cloneUnlessOtherwiseSpecified(value, options) {
        return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
      }
      function defaultArrayMerge(target, source, options) {
        return target.concat(source).map(function(element) {
          return cloneUnlessOtherwiseSpecified(element, options);
        });
      }
      function getMergeFunction(key, options) {
        if (!options.customMerge) {
          return deepmerge;
        }
        var customMerge = options.customMerge(key);
        return typeof customMerge === "function" ? customMerge : deepmerge;
      }
      function getEnumerableOwnPropertySymbols(target) {
        return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
          return Object.propertyIsEnumerable.call(target, symbol);
        }) : [];
      }
      function getKeys(target) {
        return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
      }
      function propertyIsOnObject(object, property) {
        try {
          return property in object;
        } catch (_) {
          return false;
        }
      }
      function propertyIsUnsafe(target, key) {
        return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
      }
      function mergeObject(target, source, options) {
        var destination = {};
        if (options.isMergeableObject(target)) {
          getKeys(target).forEach(function(key) {
            destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
          });
        }
        getKeys(source).forEach(function(key) {
          if (propertyIsUnsafe(target, key)) {
            return;
          }
          if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
            destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
          } else {
            destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
          }
        });
        return destination;
      }
      function deepmerge(target, source, options) {
        options = options || {};
        options.arrayMerge = options.arrayMerge || defaultArrayMerge;
        options.isMergeableObject = options.isMergeableObject || isMergeableObject;
        options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
        var sourceIsArray = Array.isArray(source);
        var targetIsArray = Array.isArray(target);
        var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
        if (!sourceAndTargetTypesMatch) {
          return cloneUnlessOtherwiseSpecified(source, options);
        } else if (sourceIsArray) {
          return options.arrayMerge(target, source, options);
        } else {
          return mergeObject(target, source, options);
        }
      }
      deepmerge.all = function deepmergeAll(array, options) {
        if (!Array.isArray(array)) {
          throw new Error("first argument should be an array");
        }
        return array.reduce(function(prev2, next2) {
          return deepmerge(prev2, next2, options);
        }, {});
      };
      var deepmerge_1 = deepmerge;
      module.exports = deepmerge_1;
    }
  });

  // node_modules/@jbrowse/core/ui/theme.js
  var require_theme = __commonJS({
    "node_modules/@jbrowse/core/ui/theme.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.defaultThemes = void 0;
      exports.createJBrowseBaseTheme = createJBrowseBaseTheme;
      exports.createJBrowseTheme = createJBrowseTheme;
      var material_1 = require_material();
      var colors_1 = require_colors();
      var deepmerge_1 = __importDefault(require_cjs2());
      var refTheme = (0, material_1.createTheme)();
      var midnight = refTheme.palette.augmentColor({ color: { main: "#0D233F" } });
      var grape = refTheme.palette.augmentColor({ color: { main: "#721E63" } });
      var forest = refTheme.palette.augmentColor({ color: { main: "#135560" } });
      var mandarin = refTheme.palette.augmentColor({ color: { main: "#FFB11D" } });
      var lightgrey = refTheme.palette.augmentColor({ color: { main: "#aaa" } });
      var bases = {
        A: refTheme.palette.augmentColor({ color: colors_1.green }),
        C: refTheme.palette.augmentColor({ color: colors_1.blue }),
        G: refTheme.palette.augmentColor({ color: colors_1.orange }),
        T: refTheme.palette.augmentColor({ color: colors_1.red })
      };
      var framesCDS = [
        null,
        refTheme.palette.augmentColor({ color: { main: "#FF8080" } }),
        refTheme.palette.augmentColor({ color: { main: "#80FF80" } }),
        refTheme.palette.augmentColor({ color: { main: "#8080FF" } }),
        refTheme.palette.augmentColor({ color: { main: "#8080FF" } }),
        refTheme.palette.augmentColor({ color: { main: "#80FF80" } }),
        refTheme.palette.augmentColor({ color: { main: "#FF8080" } })
      ];
      var frames = [
        null,
        refTheme.palette.augmentColor({ color: { main: "#8f8f8f" } }),
        refTheme.palette.augmentColor({ color: { main: "#adadad" } }),
        refTheme.palette.augmentColor({ color: { main: "#d8d8d8" } }),
        refTheme.palette.augmentColor({ color: { main: "#d8d8d8" } }),
        refTheme.palette.augmentColor({ color: { main: "#adadad" } }),
        refTheme.palette.augmentColor({ color: { main: "#8f8f8f" } })
      ];
      var stopCodon = "#e22";
      var startCodon = "#3e3";
      var insertion = "#800080";
      var deletion = "#808080";
      var hardclip = "#f00";
      var softclip = "#00f";
      var skip = "#97b8c9";
      var defaults = {
        primary: midnight,
        secondary: grape,
        tertiary: forest,
        quaternary: mandarin,
        highlight: mandarin,
        stopCodon,
        startCodon,
        insertion,
        deletion,
        softclip,
        hardclip,
        bases,
        frames,
        framesCDS,
        skip
      };
      function stockTheme() {
        return {
          palette: {
            ...defaults,
            mode: void 0
          },
          components: {
            MuiLink: {
              styleOverrides: {
                root: ({ theme }) => ({
                  color: theme.palette.tertiary.main
                })
              }
            }
          }
        };
      }
      function getDefaultTheme() {
        return {
          ...stockTheme(),
          name: "Default (from config)"
        };
      }
      function getLightStockTheme() {
        return {
          ...stockTheme(),
          name: "Light (stock)"
        };
      }
      function getDarkStockTheme() {
        return {
          name: "Dark (stock)",
          palette: {
            ...defaults,
            mode: "dark"
          },
          components: {
            MuiAppBar: {
              defaultProps: {
                enableColorOnDark: true
              },
              styleOverrides: {
                root: ({ theme }) => theme.palette.primary.main
              }
            }
          }
        };
      }
      function getDarkMinimalTheme() {
        return {
          name: "Dark (minimal)",
          palette: {
            ...defaults,
            mode: "dark",
            primary: { main: colors_1.grey[700] },
            secondary: { main: colors_1.grey[800] },
            tertiary: refTheme.palette.augmentColor({ color: { main: colors_1.grey[900] } })
          }
        };
      }
      function getMinimalTheme() {
        return {
          name: "Light (minimal)",
          palette: {
            ...defaults,
            primary: { main: colors_1.grey[900] },
            secondary: { main: colors_1.grey[800] },
            tertiary: refTheme.palette.augmentColor({ color: { main: colors_1.grey[900] } })
          }
        };
      }
      exports.defaultThemes = {
        default: getDefaultTheme(),
        lightStock: getLightStockTheme(),
        lightMinimal: getMinimalTheme(),
        darkMinimal: getDarkMinimalTheme(),
        darkStock: getDarkStockTheme()
      };
      function overwriteArrayMerge(_, sourceArray) {
        return sourceArray;
      }
      function createJBrowseBaseTheme(theme) {
        var _a, _b, _c, _d, _e, _f;
        const themeP = {
          palette: theme === null || theme === void 0 ? void 0 : theme.palette,
          typography: {
            fontSize: 12
          },
          spacing: 4,
          components: {
            MuiTooltip: {
              styleOverrides: {
                tooltip: {
                  fontSize: 12
                }
              }
            },
            MuiButton: {
              defaultProps: {
                size: "small"
              },
              styleOverrides: {
                root: ({ theme: theme2 }) => theme2.palette.mode === "dark" ? {
                  color: theme2.palette.text.primary
                } : void 0
              }
            },
            MuiAccordion: {
              defaultProps: {
                disableGutters: true,
                slotProps: {
                  transition: {
                    timeout: 150,
                    unmountOnExit: true
                  }
                }
              }
            },
            MuiFilledInput: {
              defaultProps: {
                margin: "dense"
              }
            },
            MuiFormControl: {
              defaultProps: {
                margin: "dense",
                size: "small"
              }
            },
            MuiFormHelperText: {
              defaultProps: {
                margin: "dense"
              }
            },
            MuiIconButton: {
              defaultProps: {
                size: "small"
              }
            },
            MuiInputBase: {
              defaultProps: {
                margin: "dense"
              }
            },
            MuiAutocomplete: {
              defaultProps: {
                size: "small"
              }
            },
            MuiInputLabel: {
              defaultProps: {
                margin: "dense"
              }
            },
            MuiToolbar: {
              defaultProps: {
                variant: "dense"
              }
            },
            MuiListItem: {
              defaultProps: {
                dense: true
              }
            },
            MuiOutlinedInput: {
              defaultProps: {
                margin: "dense"
              }
            },
            MuiFab: {
              defaultProps: {
                size: "small"
              },
              styleOverrides: {
                secondary: {
                  backgroundColor: (_b = (_a = theme === null || theme === void 0 ? void 0 : theme.palette) === null || _a === void 0 ? void 0 : _a.quaternary) === null || _b === void 0 ? void 0 : _b.main
                }
              }
            },
            MuiTable: {
              defaultProps: {
                size: "small"
              }
            },
            MuiPopover: {
              defaultProps: {
                transitionDuration: 0
              }
            },
            MuiMenu: {
              defaultProps: {
                transitionDuration: 0
              }
            },
            MuiMenuItem: {
              defaultProps: {
                dense: true
              }
            },
            MuiTextField: {
              defaultProps: {
                margin: "dense",
                variant: "standard"
              }
            },
            MuiLink: {
              styleOverrides: {
                root: ({ theme: theme2 }) => ({
                  color: theme2.palette.text.secondary
                })
              }
            },
            MuiCheckbox: {
              styleOverrides: {
                root: ({ theme: theme2 }) => theme2.palette.mode === "dark" ? {
                  color: theme2.palette.text.secondary,
                  "&.Mui-checked": {
                    color: theme2.palette.text.secondary
                  }
                } : void 0
              }
            },
            MuiRadio: {
              styleOverrides: {
                root: ({ theme: theme2 }) => theme2.palette.mode === "dark" ? {
                  color: theme2.palette.text.secondary,
                  "&.Mui-checked": {
                    color: theme2.palette.text.secondary
                  }
                } : void 0
              }
            },
            MuiFormLabel: {
              styleOverrides: {
                root: ({ theme: theme2 }) => theme2.palette.mode === "dark" ? {
                  color: theme2.palette.text.secondary,
                  "&.Mui-focused": {
                    color: theme2.palette.text.secondary
                  }
                } : void 0
              }
            },
            MuiAccordionSummary: {
              styleOverrides: {
                root: {
                  backgroundColor: (_d = (_c = theme === null || theme === void 0 ? void 0 : theme.palette) === null || _c === void 0 ? void 0 : _c.tertiary) === null || _d === void 0 ? void 0 : _d.main
                },
                content: {
                  color: (_f = (_e = theme === null || theme === void 0 ? void 0 : theme.palette) === null || _e === void 0 ? void 0 : _e.tertiary) === null || _f === void 0 ? void 0 : _f.contrastText
                }
              }
            },
            MuiToggleButtonGroup: {
              defaultProps: {
                size: "small"
              }
            }
          }
        };
        return (0, deepmerge_1.default)(themeP, theme || {}, { arrayMerge: overwriteArrayMerge });
      }
      function createJBrowseTheme(configTheme = {}, themes = exports.defaultThemes, themeName = "default") {
        return (0, material_1.createTheme)(createJBrowseBaseTheme(themeName === "default" ? (0, deepmerge_1.default)(themes.default, augmentThemeColors(configTheme), {
          arrayMerge: overwriteArrayMerge
        }) : addMissingColors(themes[themeName])));
      }
      function augmentThemeColors(theme = {}) {
        var _a;
        for (const entry of [
          "primary",
          "secondary",
          "tertiary",
          "quaternary",
          "highlight"
        ]) {
          if ((_a = theme.palette) === null || _a === void 0 ? void 0 : _a[entry]) {
            theme = (0, deepmerge_1.default)(theme, {
              palette: {
                [entry]: refTheme.palette.augmentColor("color" in theme.palette[entry] ? theme.palette[entry] : {
                  color: theme.palette[entry]
                })
              }
            });
          }
        }
        return theme;
      }
      function addMissingColors(theme = {}) {
        const { palette } = theme;
        return augmentThemeColors((0, deepmerge_1.default)(theme, {
          palette: {
            quaternary: (palette === null || palette === void 0 ? void 0 : palette.quaternary) || lightgrey,
            tertiary: (palette === null || palette === void 0 ? void 0 : palette.tertiary) || lightgrey,
            highlight: (palette === null || palette === void 0 ? void 0 : palette.highlight) || mandarin,
            insertion: (palette === null || palette === void 0 ? void 0 : palette.insertion) || insertion,
            softclip: (palette === null || palette === void 0 ? void 0 : palette.softclip) || softclip,
            skip: (palette === null || palette === void 0 ? void 0 : palette.skip) || skip,
            hardclip: (palette === null || palette === void 0 ? void 0 : palette.hardclip) || hardclip,
            deletion: (palette === null || palette === void 0 ? void 0 : palette.deletion) || deletion,
            startCodon: (palette === null || palette === void 0 ? void 0 : palette.startCodon) || startCodon,
            stopCodon: (palette === null || palette === void 0 ? void 0 : palette.stopCodon) || stopCodon
          }
        }));
      }
    }
  });

  // node_modules/@jbrowse/core/ui/Logo.js
  var require_Logo = __commonJS({
    "node_modules/@jbrowse/core/ui/Logo.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Logomark = Logomark;
      exports.LogoFull = LogoFull;
      var jsx_runtime_1 = require_jsx_runtime();
      function getColors(variant) {
        if (variant === "black") {
          return {
            midnight: "#808080",
            forrest: "#666666",
            grape: "#4d4d4d",
            mandarin: "#333333",
            gray: "#1a1a1a"
          };
        }
        if (variant === "white") {
          return {
            midnight: "#ffffff",
            forrest: "#e6e6e6",
            grape: "#cccccc",
            mandarin: "#b3b3b3",
            gray: "#999999"
          };
        }
        return {
          midnight: "#0d233f",
          forrest: "#135560",
          grape: "#721e63",
          mandarin: "#ffb11d",
          gray: "#dadada"
        };
      }
      function Logomark({ variant }) {
        return (0, jsx_runtime_1.jsx)("svg", { viewBox: "0 0 175 175", children: (0, jsx_runtime_1.jsx)(Icon, { variant }) });
      }
      function LogoFull({ variant }) {
        return (0, jsx_runtime_1.jsxs)("svg", { viewBox: "0 0 641 175", children: [(0, jsx_runtime_1.jsx)(Text, { variant }), (0, jsx_runtime_1.jsx)(Icon, { variant })] });
      }
      function Icon({ variant }) {
        const colors = getColors(variant);
        return (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)("path", { style: { fill: colors.midnight }, d: "M120.5,57.5c.168,0,.333.012.5.013V40.506c-.167,0-.333-.006-.5-.006a98.325,98.325,0,0,0-77.4,37.565q-2.664,3.378-5.023,6.994l14.206,9.327Q54.043,91.709,56,89.179A81.363,81.363,0,0,1,120.5,57.5Z" }), (0, jsx_runtime_1.jsx)("path", { style: { fill: colors.forrest }, d: "M148.668,86.223c.308.133.6.283.908.42l6.746-15.618c-.153-.067-.3-.143-.454-.21a81.36,81.36,0,0,0-71.777,3.5q-2.8,1.544-5.469,3.309l9.249,14.054A63.93,63.93,0,0,1,148.668,86.223Z" }), (0, jsx_runtime_1.jsx)("path", { style: { fill: colors.grape }, d: "M170.894,109.37A63.929,63.929,0,0,0,113.4,88.861l2.336,15.474a48.456,48.456,0,0,1,44.322,15.42c.111.125.214.255.324.381l11.16-10C171.323,109.879,171.118,109.62,170.894,109.37Z" }), (0, jsx_runtime_1.jsx)("path", { style: { fill: colors.mandarin }, d: "M150.921,150.314c.04.163.07.326.107.489l16.509-4.058c-.039-.163-.067-.326-.107-.489A48.457,48.457,0,0,0,135.575,111.8l-5.515,15.591A32.466,32.466,0,0,1,150.921,150.314Z" }), (0, jsx_runtime_1.jsx)("path", { style: { fill: colors.gray }, d: "M134.1,138.129l-9.779,13.213a32.486,32.486,0,0,1,7.823,14.463l15.147.852c.012-.166.032-.331.041-.5A32.464,32.464,0,0,0,134.1,138.129Z" })] });
      }
      function Text({ variant }) {
        const colors = getColors(variant);
        return (0, jsx_runtime_1.jsxs)("g", { "aria-label": "JBrowse", transform: "translate(213.084 144.241)", style: { fill: colors.midnight }, children: [(0, jsx_runtime_1.jsx)("path", { d: "m 26.355,-71.505 v 54.075 2.835 q 0,6.825 -0.42,10.185 -0.735,5.67 -2.835,9.135 -3.255,5.355 -8.505,8.4 -4.83,2.73 -11.55,3.57 L 1.47,11.76 Q 7.35,10.185 9.24,4.2 10.605,-0.105 10.605,-9.975 v -5.565 -55.965 q 1.785,0 4.62,0.315 2.835,0.21 3.255,0.21 1.785,0 2.94,-0.105 4.515,-0.42 4.935,-0.42 z" }), (0, jsx_runtime_1.jsx)("path", { d: "m 60.68836,-65.415 v 24.78 h 3.255 q 2.94,0 4.935,-0.525 2.1,-0.525 3.885,-2.1 2.31,-1.995 3.36,-4.83 1.155,-2.835 1.155,-6.09 0,-5.565 -2.94,-8.61 -2.94,-3.045 -8.295,-3.045 -2.52,0 -5.355,0.42 z m 0,30.87 V -6.09 h 5.25 q 4.725,0 8.505,-3.675 3.885,-3.78 3.885,-10.08 0,-8.19 -4.62,-11.655 -4.095,-3.045 -13.02,-3.045 z M 44.93836,0 v -71.505 h 27.09 q 9.135,0 14.385,3.255 6.51,3.99 6.51,12.6 0,7.035 -5.25,11.655 -4.62,4.095 -11.97,5.145 v 0.945 q 7.56,0.735 12.285,3.99 6.615,4.62 6.615,13.335 0,10.185 -7.98,15.75 -6.93,4.83 -17.43,4.83 z" }), (0, jsx_runtime_1.jsx)("path", { d: "M 109.44281,0.525 V -50.4 q 1.785,0.21 3.99,0.42 2.31,0.105 3.255,0.105 2.31,0 4.2,-0.21 1.89,-0.21 3.045,-0.315 v 13.02 q 1.89,-6.51 5.46,-9.87 4.41,-4.095 11.655,-4.095 -0.315,2.73 -0.42,6.825 -0.105,3.99 -0.105,7.455 l -0.945,0.84 q -0.945,-0.735 -2.415,-1.05 -1.47,-0.315 -2.94,-0.315 -3.57,0 -6.195,1.89 -2.52,1.785 -3.465,5.04 -0.42,1.155 -0.525,3.15 -0.105,1.89 -0.105,4.515 v 4.515 19.005 q -1.785,-0.21 -2.625,-0.21 -3.675,-0.315 -4.62,-0.315 -2.31,0 -4.2,0.21 -1.89,0.21 -3.045,0.315 z" }), (0, jsx_runtime_1.jsx)("path", { d: "m 173.77337,1.47 q -11.655,0 -18.585,-6.825 -6.93,-6.825 -6.93,-18.48 0,-12.6 6.72,-20.055 6.825,-7.455 18.9,-7.455 11.97,0 18.9,6.72 6.93,6.72 6.93,18.48 0,12.285 -6.72,19.74 -7.14,7.875 -19.215,7.875 z m 0.735,-48.09 q -5.88,0 -8.505,6.51 -2.205,5.565 -2.205,15.96 0,8.19 1.47,12.915 2.415,7.98 8.505,7.98 5.565,0 8.19,-7.875 2.205,-6.51 2.205,-16.695 0,-8.505 -2.1,-13.23 -2.52,-5.565 -7.56,-5.565 z" }), (0, jsx_runtime_1.jsx)("path", { d: "m 222.03563,-50.4 10.5,36.015 q 3.675,-11.235 5.67,-17.85 2.415,-8.085 5.04,-18.165 1.05,0.105 3.045,0.315 2.1,0.21 2.835,0.21 1.995,0 3.15,-0.105 1.26,-0.21 2.73,-0.42 l 10.71,36.015 q 5.88,-17.43 10.71,-36.015 l 4.2,0.315 4.095,-0.315 q -5.145,13.125 -9.135,24.57 -5.04,14.28 -8.505,26.355 -1.89,-0.21 -3.36,-0.42 -1.365,-0.105 -2.205,-0.105 -1.89,0 -3.36,0.21 -1.365,0.21 -2.31,0.315 l -10.605,-34.755 q -4.41,13.65 -6.72,21.105 -2.31,7.35 -4.095,13.65 -1.89,-0.21 -3.36,-0.42 -1.365,-0.105 -2.31,-0.105 -1.995,0 -3.465,0.21 -1.365,0.21 -2.31,0.315 -3.78,-12.81 -5.04,-17.01 -2.205,-7.245 -5.46,-17.01 -2.835,-8.4 -5.88,-16.905 1.575,0 4.305,0.315 2.73,0.21 3.36,0.21 1.47,0 4.305,-0.21 2.835,-0.315 3.465,-0.315 z" }), (0, jsx_runtime_1.jsx)("path", { d: "m 292.84172,-12.81 h 2.625 q 1.47,4.095 4.62,6.51 3.15,2.415 7.35,2.415 2.94,0 5.46,-1.785 2.625,-1.89 2.625,-4.62 0,-3.885 -6.195,-6.615 -10.395,-4.62 -11.655,-5.46 -6.405,-4.515 -6.405,-12.285 0,-7.77 5.25,-12.18 5.25,-4.515 12.81,-4.515 3.99,0 8.085,1.365 4.095,1.26 7.14,3.57 l -2.52,9.24 h -2.94 q -0.63,-3.57 -3.57,-6.195 -2.835,-2.625 -6.405,-2.625 -3.15,0 -5.46,1.575 -2.31,1.47 -2.31,4.515 0,3.885 6.405,6.51 10.185,4.095 11.865,5.25 6.405,4.41 6.405,12.81 0,7.455 -5.46,12.18 -5.355,4.62 -14.805,4.62 -8.19,0 -14.49,-4.305 z" }), (0, jsx_runtime_1.jsx)("path", { d: "m 349.61228,-29.925 h 15.54 q 0,-6.51 -1.05,-10.395 -1.68,-6.3 -5.88,-6.3 -5.04,0 -7.14,6.195 -1.47,4.305 -1.47,10.5 z m 30.03,5.04 h -30.03 q 0,9.135 3.045,13.86 3.57,5.67 11.55,5.67 3.255,0 6.405,-1.26 3.15,-1.26 5.88,-3.465 l 1.26,0.945 -2.31,5.88 q -6.72,4.725 -15.015,4.725 -12.915,0 -19.635,-7.245 -6.72,-7.245 -6.72,-20.37 0,-11.235 6.405,-18.165 6.51,-7.035 17.64,-7.035 11.655,0 16.905,7.56 4.62,6.615 4.62,18.9 z" })] });
      }
    }
  });

  // node_modules/@jbrowse/core/ui/AssemblySelector.js
  var require_AssemblySelector = __commonJS({
    "node_modules/@jbrowse/core/ui/AssemblySelector.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var jsx_runtime_1 = require_jsx_runtime();
      var react_1 = require_react();
      var material_1 = require_material();
      var mobx_react_1 = require_mobx_react();
      var mui_1 = require_mui();
      var util_1 = require_util5();
      var useStyles18 = (0, mui_1.makeStyles)()({
        importFormEntry: {
          minWidth: 180
        }
      });
      var AssemblySelector = (0, mobx_react_1.observer)(function({ session, onChange, label = "Assembly", selected, InputProps, TextFieldProps, localStorageKey, helperText = "Select assembly to view" }) {
        const { classes } = useStyles18();
        const { assemblyNames, assemblyManager } = session;
        const config2 = new URLSearchParams(window.location.search).get("config");
        const [lastSelected, setLastSelected] = typeof jest === "undefined" && localStorageKey ? (0, util_1.useLocalStorage)(`lastAssembly-${[
          window.location.host + window.location.pathname,
          config2,
          localStorageKey
        ].join("-")}`, selected) : (0, react_1.useState)(selected);
        const selection = assemblyNames.includes(lastSelected || "") ? lastSelected : selected;
        (0, react_1.useEffect)(() => {
          if (selection && selection !== selected) {
            onChange(selection);
          }
        }, [selection, onChange, selected]);
        const error2 = assemblyNames.length ? "" : "No configured assemblies";
        return (0, jsx_runtime_1.jsx)(material_1.TextField, { select: true, "data-testid": "assembly-selector-textfield", label, variant: "outlined", helperText: error2 || helperText, value: selection || "", onChange: (event) => {
          setLastSelected(event.target.value);
        }, error: !!error2, disabled: !!error2, className: classes.importFormEntry, ...TextFieldProps, slotProps: {
          input: InputProps,
          htmlInput: {
            "data-testid": "assembly-selector"
          }
        }, children: assemblyNames.map((name) => {
          var _a;
          return (0, jsx_runtime_1.jsx)(material_1.MenuItem, { value: name, children: ((_a = assemblyManager.get(name)) === null || _a === void 0 ? void 0 : _a.displayName) || name }, name);
        }) });
      });
      exports.default = AssemblySelector;
    }
  });

  // node_modules/@jbrowse/core/ui/EditableTypography.js
  var require_EditableTypography = __commonJS({
    "node_modules/@jbrowse/core/ui/EditableTypography.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var jsx_runtime_1 = require_jsx_runtime();
      var react_1 = require_react();
      var useMeasure_1 = __importDefault(require_useMeasure());
      var material_1 = require_material();
      var mui_1 = require_mui();
      var useStyles18 = (0, mui_1.makeStyles)()((theme) => ({
        input: {},
        inputBase: {},
        typography: {
          top: 6,
          left: 2,
          position: "absolute",
          whiteSpace: "nowrap",
          visibility: "hidden"
        },
        inputRoot: {
          padding: theme.spacing(0.5)
        },
        inputFocused: {
          borderStyle: "solid",
          borderWidth: 2
        }
      }));
      var EditableTypography = (0, react_1.forwardRef)(function EditableTypography2(props, ref) {
        const { value, setValue, variant, ...other } = props;
        const [ref2, { width }] = (0, useMeasure_1.default)();
        const [editedValue, setEditedValue] = (0, react_1.useState)();
        const [inputNode, setInputNode] = (0, react_1.useState)(null);
        const { classes } = useStyles18(props, { props });
        const theme = (0, material_1.useTheme)();
        const val = editedValue === void 0 ? value : editedValue;
        return (0, jsx_runtime_1.jsxs)("div", { ...other, ref, children: [(0, jsx_runtime_1.jsx)("div", { style: { position: "relative" }, children: (0, jsx_runtime_1.jsx)(material_1.Typography, { ref: ref2, component: "span", variant, className: classes.typography, children: val }) }), (0, jsx_runtime_1.jsx)(material_1.InputBase, { inputRef: (node2) => {
          setInputNode(node2);
        }, className: classes.inputBase, inputProps: {
          style: {
            width,
            ...variant && variant !== "inherit" ? theme.typography[variant] : {}
          }
        }, classes: {
          input: classes.input,
          root: classes.inputRoot,
          focused: classes.inputFocused
        }, value: val, onChange: (event) => {
          setEditedValue(event.target.value);
        }, onKeyDown: (event) => {
          if (event.key === "Enter") {
            inputNode === null || inputNode === void 0 ? void 0 : inputNode.blur();
          } else if (event.key === "Escape") {
            setEditedValue(void 0);
            inputNode === null || inputNode === void 0 ? void 0 : inputNode.blur();
          }
        }, onBlur: () => {
          setValue(editedValue || value || "");
          setEditedValue(void 0);
        } })] });
      });
      exports.default = EditableTypography;
    }
  });

  // node_modules/@jbrowse/core/ui/FactoryResetDialog.js
  var require_FactoryResetDialog = __commonJS({
    "node_modules/@jbrowse/core/ui/FactoryResetDialog.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = FactoryResetDialog;
      var jsx_runtime_1 = require_jsx_runtime();
      var Dialog_1 = __importDefault(require_Dialog());
      var material_1 = require_material();
      function FactoryResetDialog({ onClose, open: open2, onFactoryReset }) {
        function handleDialogClose(action) {
          if (action === "reset") {
            onFactoryReset();
          }
          onClose();
        }
        return (0, jsx_runtime_1.jsxs)(Dialog_1.default, { title: "Reset", onClose: () => {
          handleDialogClose();
        }, open: open2, children: [(0, jsx_runtime_1.jsx)(material_1.DialogContent, { children: (0, jsx_runtime_1.jsx)(material_1.DialogContentText, { children: "Are you sure you want to reset? This will restore the default configuration." }) }), (0, jsx_runtime_1.jsxs)(material_1.DialogActions, { children: [(0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => {
          handleDialogClose();
        }, color: "primary", children: "Cancel" }), (0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => {
          handleDialogClose("reset");
        }, color: "primary", variant: "contained", children: "OK" })] })] });
      }
    }
  });

  // node_modules/@jbrowse/core/ui/FatalErrorDialog.js
  var require_FatalErrorDialog = __commonJS({
    "node_modules/@jbrowse/core/ui/FatalErrorDialog.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = FatalErrorDialog;
      var jsx_runtime_1 = require_jsx_runtime();
      var react_1 = require_react();
      var material_1 = require_material();
      var ErrorMessage_1 = __importDefault(require_ErrorMessage());
      var FactoryResetDialog_1 = __importDefault(require_FactoryResetDialog());
      var ResetComponent = ({ onFactoryReset, resetButtonText }) => {
        const [dialogOpen, setDialogOpen] = (0, react_1.useState)(false);
        return (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(material_1.Button, { "data-testid": "fatal-error", color: "primary", variant: "contained", onClick: () => {
          setDialogOpen(true);
        }, children: resetButtonText }), (0, jsx_runtime_1.jsx)(FactoryResetDialog_1.default, { onClose: () => {
          setDialogOpen(false);
        }, open: dialogOpen, onFactoryReset })] });
      };
      function FatalErrorDialog({ componentStack, error: error2 = "No error message provided", onFactoryReset, resetButtonText = "Factory Reset" }) {
        return (0, jsx_runtime_1.jsxs)(material_1.Dialog, { maxWidth: "xl", open: true, children: [(0, jsx_runtime_1.jsx)(material_1.DialogTitle, { children: "Fatal error" }), (0, jsx_runtime_1.jsxs)(material_1.DialogContent, { children: [(0, jsx_runtime_1.jsx)(ErrorMessage_1.default, { error: error2 }), (0, jsx_runtime_1.jsx)("pre", { children: componentStack })] }), (0, jsx_runtime_1.jsxs)(material_1.DialogActions, { children: [(0, jsx_runtime_1.jsx)(material_1.Button, { color: "secondary", variant: "contained", onClick: () => {
          window.location.reload();
        }, children: "Refresh" }), (0, jsx_runtime_1.jsx)(ResetComponent, { onFactoryReset, resetButtonText })] })] });
      }
    }
  });

  // node_modules/@mui/icons-material/ArrowDropDown.js
  var require_ArrowDropDown = __commonJS({
    "node_modules/@mui/icons-material/ArrowDropDown.js"(exports) {
      "use strict";
      "use client";
      var _interopRequireDefault = require_interopRequireDefault().default;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
      var _jsxRuntime = require_jsx_runtime();
      var _default = exports.default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
        d: "m7 10 5 5 5-5z"
      }), "ArrowDropDown");
    }
  });

  // node_modules/@jbrowse/core/util/tracks.js
  var require_tracks = __commonJS({
    "node_modules/@jbrowse/core/util/tracks.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.UNSUPPORTED = exports.UNKNOWN = void 0;
      exports.getTrackAssemblyNames = getTrackAssemblyNames;
      exports.getConfAssemblyNames = getConfAssemblyNames;
      exports.getRpcSessionId = getRpcSessionId;
      exports.getParentRenderProps = getParentRenderProps;
      exports.getBlob = getBlob;
      exports.getBlobMap = getBlobMap;
      exports.setBlobMap = setBlobMap;
      exports.storeBlobLocation = storeBlobLocation;
      exports.makeIndex = makeIndex;
      exports.makeIndexType = makeIndexType;
      exports.getFileName = getFileName;
      exports.guessAdapter = guessAdapter;
      exports.guessTrackType = guessTrackType;
      exports.generateUnsupportedTrackConf = generateUnsupportedTrackConf;
      exports.generateUnknownTrackConf = generateUnknownTrackConf;
      exports.getTrackName = getTrackName;
      var mobx_state_tree_1 = require_mobx_state_tree();
      var index_1 = require_util5();
      var configuration_1 = require_configuration2();
      function getTrackAssemblyNames(track) {
        return getConfAssemblyNames(track.configuration);
      }
      function getConfAssemblyNames(conf) {
        const trackAssemblyNames = (0, configuration_1.readConfObject)(conf, "assemblyNames");
        if (!trackAssemblyNames) {
          const parent = (0, mobx_state_tree_1.getParent)(conf);
          if ("sequence" in parent) {
            return [(0, configuration_1.readConfObject)(parent, "name")];
          } else {
            throw new Error("unknown assembly names");
          }
        }
        return trackAssemblyNames;
      }
      function getRpcSessionId(thisNode) {
        let highestRpcSessionId;
        for (let node2 = thisNode; !(0, mobx_state_tree_1.isRoot)(node2); node2 = (0, mobx_state_tree_1.getParent)(node2)) {
          if ("rpcSessionId" in node2) {
            highestRpcSessionId = node2.rpcSessionId;
          }
        }
        if (!highestRpcSessionId) {
          throw new Error("getRpcSessionId failed, no parent node in the state tree has an `rpcSessionId` attribute");
        }
        return highestRpcSessionId;
      }
      function getParentRenderProps(node2) {
        for (let currentNode = (0, mobx_state_tree_1.getParent)(node2); !(0, mobx_state_tree_1.isRoot)(currentNode); currentNode = (0, mobx_state_tree_1.getParent)(currentNode)) {
          if ("renderProps" in currentNode) {
            return currentNode.renderProps();
          }
        }
        return {};
      }
      exports.UNKNOWN = "UNKNOWN";
      exports.UNSUPPORTED = "UNSUPPORTED";
      var blobMap = {};
      function getBlob(id) {
        return blobMap[id];
      }
      function getBlobMap() {
        return blobMap;
      }
      function setBlobMap(map) {
        blobMap = map;
      }
      var counter4 = 0;
      function storeBlobLocation(location2) {
        if ("blob" in location2) {
          const blobId = `b${Date.now()}-${counter4++}`;
          blobMap[blobId] = location2.blob;
          return { name: location2.blob.name, blobId, locationType: "BlobLocation" };
        }
        return location2;
      }
      function makeIndex(location2, suffix) {
        if ("uri" in location2) {
          return {
            uri: location2.uri + suffix,
            locationType: "UriLocation"
          };
        } else if ("localPath" in location2) {
          return {
            localPath: location2.localPath + suffix,
            locationType: "LocalPathLocation"
          };
        } else {
          return location2;
        }
      }
      function makeIndexType(name, typeA, typeB) {
        return (name === null || name === void 0 ? void 0 : name.toUpperCase().endsWith(typeA)) ? typeA : typeB;
      }
      function getFileName(track) {
        const uri = "uri" in track ? track.uri : void 0;
        const localPath = "localPath" in track ? track.localPath : void 0;
        const blob = "blobId" in track ? track : void 0;
        return (blob === null || blob === void 0 ? void 0 : blob.name) || (uri === null || uri === void 0 ? void 0 : uri.slice(uri.lastIndexOf("/") + 1)) || (localPath === null || localPath === void 0 ? void 0 : localPath.slice(localPath.replace(/\\/g, "/").lastIndexOf("/") + 1)) || "";
      }
      function guessAdapter(file, index3, adapterHint, model) {
        if (model) {
          const { pluginManager } = (0, index_1.getEnv)(model);
          const adapterGuesser = pluginManager.evaluateExtensionPoint("Core-guessAdapterForLocation", (_file, _index, _adapterHint) => {
            return void 0;
          });
          const adapter = adapterGuesser(file, index3, adapterHint);
          if (adapter) {
            return adapter;
          }
        }
        return {
          type: exports.UNKNOWN
        };
      }
      function guessTrackType(adapterType, model) {
        if (model) {
          const session = (0, index_1.getSession)(model);
          const trackTypeGuesser = (0, index_1.getEnv)(session).pluginManager.evaluateExtensionPoint("Core-guessTrackTypeForLocation", (_adapterName) => {
            return void 0;
          });
          const trackType = trackTypeGuesser(adapterType);
          if (trackType) {
            return trackType;
          }
        }
        return "FeatureTrack";
      }
      function generateUnsupportedTrackConf(trackName, trackUrl, categories) {
        const conf = {
          type: "FeatureTrack",
          name: `${trackName} (Unsupported)`,
          description: `Support not yet implemented for "${trackUrl}"`,
          category: categories,
          trackId: ""
        };
        conf.trackId = (0, index_1.objectHash)(conf);
        return conf;
      }
      function generateUnknownTrackConf(trackName, trackUrl, categories) {
        const conf = {
          type: "FeatureTrack",
          name: `${trackName} (Unknown)`,
          description: `Could not determine track type for "${trackUrl}"`,
          category: categories,
          trackId: ""
        };
        conf.trackId = (0, index_1.objectHash)(conf);
        return conf;
      }
      function getTrackName(conf, session) {
        const trackName = (0, configuration_1.readConfObject)(conf, "name");
        if (!trackName && (0, configuration_1.readConfObject)(conf, "type") === "ReferenceSequenceTrack") {
          const asm = session.assemblies.find((a2) => a2.sequence === conf);
          return asm ? `Reference sequence (${(0, configuration_1.readConfObject)(asm, "displayName") || (0, configuration_1.readConfObject)(asm, "name")})` : "Reference sequence";
        }
        return trackName;
      }
    }
  });

  // node_modules/@jbrowse/core/ui/FileSelector/LocalFileChooser.js
  var require_LocalFileChooser = __commonJS({
    "node_modules/@jbrowse/core/ui/FileSelector/LocalFileChooser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var jsx_runtime_1 = require_jsx_runtime();
      var material_1 = require_material();
      var mui_1 = require_mui();
      var util_1 = require_util5();
      var tracks_1 = require_tracks();
      function isLocalPathLocation(loc) {
        return "localPath" in loc;
      }
      function isBlobLocation(loc) {
        return "blobId" in loc;
      }
      var useStyles18 = (0, mui_1.makeStyles)()((theme) => ({
        filename: {
          marginLeft: theme.spacing(1)
        }
      }));
      function LocalFileChooser({ location: location2, setLocation }) {
        const { classes } = useStyles18();
        const filename = location2 && (isBlobLocation(location2) && location2.name || isLocalPathLocation(location2) && location2.localPath);
        const needToReload = location2 && isBlobLocation(location2) && !(0, tracks_1.getBlob)(location2.blobId);
        return (0, jsx_runtime_1.jsxs)(material_1.Box, { display: "flex", flexDirection: "row", alignItems: "center", children: [(0, jsx_runtime_1.jsx)(material_1.Box, { children: (0, jsx_runtime_1.jsx)(material_1.FormControl, { fullWidth: true, children: (0, jsx_runtime_1.jsxs)(material_1.Button, { variant: "outlined", component: "label", children: ["Choose File", (0, jsx_runtime_1.jsx)("input", { type: "file", hidden: true, onChange: ({ target }) => {
          var _a;
          const file = (_a = target.files) === null || _a === void 0 ? void 0 : _a[0];
          if (file) {
            if (util_1.isElectron) {
              const { webUtils } = window.require("electron");
              setLocation({
                localPath: webUtils.getPathForFile(file),
                locationType: "LocalPathLocation"
              });
            } else {
              setLocation((0, tracks_1.storeBlobLocation)({ blob: file }));
            }
          }
        } })] }) }) }), (0, jsx_runtime_1.jsxs)(material_1.Box, { children: [(0, jsx_runtime_1.jsx)(material_1.Typography, { component: "span", className: classes.filename, color: filename ? "initial" : "textSecondary", children: filename || "No file chosen" }), needToReload ? (0, jsx_runtime_1.jsx)(material_1.Typography, { color: "error", children: "(need to reload)" }) : null] })] });
      }
      exports.default = LocalFileChooser;
    }
  });

  // node_modules/@jbrowse/core/ui/FileSelector/UrlChooser.js
  var require_UrlChooser = __commonJS({
    "node_modules/@jbrowse/core/ui/FileSelector/UrlChooser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var jsx_runtime_1 = require_jsx_runtime();
      var material_1 = require_material();
      var mobx_react_1 = require_mobx_react();
      var types_1 = require_types();
      var UrlChooser = (0, mobx_react_1.observer)(function({ location: location2, label, style, setLocation }) {
        return (0, jsx_runtime_1.jsx)(material_1.TextField, { variant: "outlined", fullWidth: true, defaultValue: location2 && (0, types_1.isUriLocation)(location2) ? location2.uri : "", label: label || "Enter URL", style, onChange: (event) => {
          setLocation({
            uri: event.target.value.trim(),
            locationType: "UriLocation"
          });
        }, slotProps: {
          htmlInput: {
            "data-testid": "urlInput"
          }
        } });
      });
      exports.default = UrlChooser;
    }
  });

  // node_modules/@jbrowse/core/ui/FileSelector/FileSelector.js
  var require_FileSelector = __commonJS({
    "node_modules/@jbrowse/core/ui/FileSelector/FileSelector.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var jsx_runtime_1 = require_jsx_runtime();
      var react_1 = require_react();
      var ArrowDropDown_1 = __importDefault(require_ArrowDropDown());
      var material_1 = require_material();
      var mobx_react_1 = require_mobx_react();
      var LocalFileChooser_1 = __importDefault(require_LocalFileChooser());
      var UrlChooser_1 = __importDefault(require_UrlChooser());
      var util_1 = require_util5();
      var types_1 = require_types();
      var NUM_SHOWN = 2;
      function ToggleButtonWithTooltip(props) {
        const { title, children, ...other } = props;
        return (0, jsx_runtime_1.jsx)(material_1.Tooltip, { title: title || "", children: (0, jsx_runtime_1.jsx)(material_1.ToggleButton, { ...other, children }) });
      }
      function shorten(str, len2) {
        if (typeof str === "string" && str.length > len2) {
          return `${str.slice(0, Math.max(0, len2))}\u2026`;
        }
        return str;
      }
      function Inline({ children }) {
        return (0, jsx_runtime_1.jsx)("div", { style: { display: "flex", gap: 4 }, children });
      }
      function Box2({ children }) {
        return (0, jsx_runtime_1.jsx)(material_1.Box, { display: "flex", flexDirection: "row", children: (0, jsx_runtime_1.jsx)(material_1.Box, { children }) });
      }
      function Input(props) {
        const { setLocation, inline: inline4, toggleButtonValue, selectedAccount } = props;
        return (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: (selectedAccount === null || selectedAccount === void 0 ? void 0 : selectedAccount.SelectorComponent) ? (0, jsx_runtime_1.jsx)(selectedAccount.SelectorComponent, { ...props, setLocation }) : toggleButtonValue === "url" ? (0, jsx_runtime_1.jsx)(UrlChooser_1.default, { ...props, setLocation, label: selectedAccount === null || selectedAccount === void 0 ? void 0 : selectedAccount.selectorLabel, style: inline4 ? { margin: 0 } : void 0 }) : toggleButtonValue === "file" ? (0, jsx_runtime_1.jsx)(LocalFileChooser_1.default, { ...props }) : null });
      }
      var FileSelector3 = (0, mobx_react_1.observer)(function(props) {
        const { inline: inline4, location: location2, name, description, rootModel, setLocation } = props;
        const fileOrUrl = !location2 || (0, types_1.isUriLocation)(location2) ? "url" : "file";
        const [toggleButtonValue, setToggleButtonValue] = (0, react_1.useState)(location2 && "internetAccountId" in location2 && location2.internetAccountId ? location2.internetAccountId : fileOrUrl);
        const accounts = (0, types_1.isAppRootModel)(rootModel) ? rootModel.internetAccounts.filter((f2) => f2.type !== "HTTPBasicInternetAccount") : [];
        const [recentlyUsedInternetAccounts, setRecentlyUsedInternetAccounts] = (0, util_1.useLocalStorage)("fileSelector-recentlyUsedInternetAccounts", []);
        const map = Object.fromEntries(accounts.map((a2) => [a2.internetAccountId, a2]));
        const arr = [...new Set(accounts.map((s2) => s2.internetAccountId))].sort((a2, b2) => recentlyUsedInternetAccounts.indexOf(a2) - recentlyUsedInternetAccounts.indexOf(b2));
        const shownAccounts = arr.slice(0, NUM_SHOWN);
        const hiddenAccounts = arr.slice(NUM_SHOWN);
        const [anchorEl, setAnchorEl] = (0, react_1.useState)(null);
        const selectedAccount = map[toggleButtonValue];
        const setLocationWithAccount = (0, react_1.useCallback)((location3) => {
          setLocation({
            ...location3,
            ...selectedAccount && (0, types_1.isUriLocation)(location3) ? { internetAccountId: selectedAccount.internetAccountId } : {}
          });
        }, [setLocation, selectedAccount]);
        (0, react_1.useEffect)(() => {
          if (selectedAccount && (0, types_1.isUriLocation)(location2) && location2.internetAccountId !== selectedAccount.internetAccountId) {
            setLocationWithAccount(location2);
          }
        }, [location2, selectedAccount, setLocationWithAccount]);
        const Wrapper = inline4 ? Inline : Box2;
        return (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(material_1.Box, { display: "flex", children: (0, jsx_runtime_1.jsx)(material_1.InputLabel, { shrink: true, children: name }) }), (0, jsx_runtime_1.jsxs)(material_1.FormGroup, { children: [(0, jsx_runtime_1.jsxs)(Wrapper, { children: [(0, jsx_runtime_1.jsxs)(material_1.ToggleButtonGroup, { value: toggleButtonValue, exclusive: true, size: "small", onChange: (_event, newState) => {
          setRecentlyUsedInternetAccounts([
            ...new Set([newState, ...recentlyUsedInternetAccounts].filter(util_1.notEmpty))
          ]);
          if (newState) {
            setToggleButtonValue(newState);
          }
          if ((0, types_1.isUriLocation)(location2)) {
            setLocationWithAccount(location2);
          }
        }, "aria-label": "file, url, or account picker", children: [new URLSearchParams(window.location.search).get("adminKey") ? null : (0, jsx_runtime_1.jsx)(material_1.ToggleButton, { size: "small", value: "file", "aria-label": "local file", children: "File" }), (0, jsx_runtime_1.jsx)(material_1.ToggleButton, { size: "small", value: "url", "aria-label": "url", children: "URL" }), shownAccounts.map((id) => {
          const { internetAccountId, name: name2, toggleContents } = map[id];
          return (0, jsx_runtime_1.jsx)(ToggleButtonWithTooltip, { value: internetAccountId, title: name2, children: typeof toggleContents === "string" ? shorten(toggleContents, 5) : toggleContents || shorten(name2, 5) }, id);
        }), hiddenAccounts.length > 0 ? (0, jsx_runtime_1.jsxs)(material_1.ToggleButton, { onClick: (event) => {
          setAnchorEl(event.target);
        }, selected: false, children: ["More", (0, jsx_runtime_1.jsx)(ArrowDropDown_1.default, {})] }) : null] }), inline4 ? (0, jsx_runtime_1.jsx)(Input, { ...props, toggleButtonValue, selectedAccount, setLocation: setLocationWithAccount }) : null] }), !inline4 ? (0, jsx_runtime_1.jsx)(Input, { ...props, toggleButtonValue, selectedAccount, setLocation: setLocationWithAccount }) : null] }), (0, jsx_runtime_1.jsx)(material_1.FormHelperText, { children: description }), anchorEl ? (0, jsx_runtime_1.jsx)(material_1.Menu, { open: true, anchorEl, anchorOrigin: { vertical: "bottom", horizontal: "center" }, transformOrigin: { vertical: "top", horizontal: "center" }, onClose: () => {
          setAnchorEl(null);
        }, children: hiddenAccounts.map((id) => {
          const { internetAccountId, name: name2 } = map[id];
          return (0, jsx_runtime_1.jsx)(material_1.MenuItem, { value: internetAccountId, onClick: () => {
            setRecentlyUsedInternetAccounts([
              ...new Set([
                internetAccountId,
                ...recentlyUsedInternetAccounts
              ].filter(util_1.notEmpty))
            ]);
            setToggleButtonValue(internetAccountId);
            setAnchorEl(null);
          }, children: name2 }, id);
        }) }) : null] });
      });
      exports.default = FileSelector3;
    }
  });

  // node_modules/@jbrowse/core/ui/FileSelector/index.js
  var require_FileSelector2 = __commonJS({
    "node_modules/@jbrowse/core/ui/FileSelector/index.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = void 0;
      var FileSelector_1 = require_FileSelector();
      Object.defineProperty(exports, "default", { enumerable: true, get: function() {
        return __importDefault(FileSelector_1).default;
      } });
    }
  });

  // node_modules/@jbrowse/core/ui/PrerenderedCanvas.js
  var require_PrerenderedCanvas = __commonJS({
    "node_modules/@jbrowse/core/ui/PrerenderedCanvas.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var jsx_runtime_1 = require_jsx_runtime();
      var react_1 = require_react();
      var offscreenCanvasPonyfill_1 = require_offscreenCanvasPonyfill();
      function PrerenderedCanvas(props) {
        const { width, height, highResolutionScaling = 1, style = {}, imageData, blockKey, showSoftClip } = props;
        const [done, setDone] = (0, react_1.useState)(false);
        const featureCanvas = (0, react_1.useRef)(null);
        (0, react_1.useEffect)(() => {
          if (!imageData) {
            return;
          }
          const canvas = featureCanvas.current;
          if (!canvas) {
            return;
          }
          const context2 = canvas.getContext("2d");
          if (!context2) {
            return;
          }
          (0, offscreenCanvasPonyfill_1.drawImageOntoCanvasContext)(imageData, context2);
          setDone(true);
        }, [imageData]);
        return (0, jsx_runtime_1.jsx)("canvas", { "data-testid": [
          "prerendered_canvas",
          showSoftClip ? "softclipped" : "",
          blockKey,
          done ? "done" : ""
        ].filter((f2) => !!f2).join("_"), ref: featureCanvas, width: width * highResolutionScaling, height: height * highResolutionScaling, style: { width, height, ...style } });
      }
      exports.default = PrerenderedCanvas;
    }
  });

  // node_modules/@jbrowse/core/ui/ResizeHandle.js
  var require_ResizeHandle = __commonJS({
    "node_modules/@jbrowse/core/ui/ResizeHandle.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var jsx_runtime_1 = require_jsx_runtime();
      var react_1 = require_react();
      var mui_1 = require_mui();
      var useStyles18 = (0, mui_1.makeStyles)()({
        horizontalHandle: {
          cursor: "row-resize",
          width: "100%"
        },
        verticalHandle: {
          cursor: "col-resize",
          height: "100%"
        },
        flexbox_verticalHandle: {
          cursor: "col-resize",
          alignSelf: "stretch"
        },
        flexbox_horizontalHandle: {
          cursor: "row-resize",
          alignSelf: "stretch"
        }
      });
      function ResizeHandle({ onDrag, vertical = false, flexbox = false, className: originalClassName, onMouseDown, ...props }) {
        const [mouseDragging, setMouseDragging] = (0, react_1.useState)(false);
        const initialPosition = (0, react_1.useRef)(0);
        const prevPos = (0, react_1.useRef)(0);
        const { classes, cx } = useStyles18();
        (0, react_1.useEffect)(() => {
          function mouseMove(event) {
            event.preventDefault();
            const pos = vertical ? event.clientX : event.clientY;
            const totalDistance = initialPosition.current - pos;
            const lastFrameDistance = pos - prevPos.current;
            prevPos.current = pos;
            onDrag(lastFrameDistance, totalDistance);
          }
          function mouseUp() {
            setMouseDragging(false);
          }
          if (mouseDragging) {
            window.addEventListener("mousemove", mouseMove, true);
            window.addEventListener("mouseup", mouseUp, true);
            return () => {
              window.removeEventListener("mousemove", mouseMove, true);
              window.removeEventListener("mouseup", mouseUp, true);
            };
          }
          return () => {
          };
        }, [mouseDragging, onDrag, vertical]);
        let className;
        if (flexbox) {
          className = vertical ? classes.flexbox_verticalHandle : classes.flexbox_horizontalHandle;
        } else if (vertical) {
          className = classes.verticalHandle;
        } else {
          className = classes.horizontalHandle;
        }
        return (0, jsx_runtime_1.jsx)("div", { "data-resizer": "true", onMouseDown: (event) => {
          event.preventDefault();
          const pos = vertical ? event.clientX : event.clientY;
          initialPosition.current = pos;
          prevPos.current = pos;
          setMouseDragging(true);
          onMouseDown === null || onMouseDown === void 0 ? void 0 : onMouseDown(event);
        }, className: cx(className, originalClassName), ...props });
      }
      exports.default = ResizeHandle;
    }
  });

  // node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
  function hasWindow() {
    return typeof window !== "undefined";
  }
  function getNodeName(node2) {
    if (isNode(node2)) {
      return (node2.nodeName || "").toLowerCase();
    }
    return "#document";
  }
  function getWindow(node2) {
    var _node$ownerDocument;
    return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
  }
  function getDocumentElement(node2) {
    var _ref;
    return (_ref = (isNode(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref.documentElement;
  }
  function isNode(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Node || value instanceof getWindow(value).Node;
  }
  function isElement(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof Element || value instanceof getWindow(value).Element;
  }
  function isHTMLElement(value) {
    if (!hasWindow()) {
      return false;
    }
    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
  }
  function isShadowRoot(value) {
    if (!hasWindow() || typeof ShadowRoot === "undefined") {
      return false;
    }
    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
  }
  function isOverflowElement(element) {
    const {
      overflow,
      overflowX,
      overflowY,
      display
    } = getComputedStyle2(element);
    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
  }
  function isTableElement(element) {
    return tableElements.has(getNodeName(element));
  }
  function isTopLayer(element) {
    return topLayerSelectors.some((selector) => {
      try {
        return element.matches(selector);
      } catch (_e) {
        return false;
      }
    });
  }
  function isContainingBlock(elementOrCss) {
    const webkit = isWebKit();
    const css2 = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
    return transformProperties.some((value) => css2[value] ? css2[value] !== "none" : false) || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || willChangeValues.some((value) => (css2.willChange || "").includes(value)) || containValues.some((value) => (css2.contain || "").includes(value));
  }
  function getContainingBlock(element) {
    let currentNode = getParentNode(element);
    while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
      if (isContainingBlock(currentNode)) {
        return currentNode;
      } else if (isTopLayer(currentNode)) {
        return null;
      }
      currentNode = getParentNode(currentNode);
    }
    return null;
  }
  function isWebKit() {
    if (typeof CSS === "undefined" || !CSS.supports) return false;
    return CSS.supports("-webkit-backdrop-filter", "none");
  }
  function isLastTraversableNode(node2) {
    return lastTraversableNodeNames.has(getNodeName(node2));
  }
  function getComputedStyle2(element) {
    return getWindow(element).getComputedStyle(element);
  }
  function getNodeScroll(element) {
    if (isElement(element)) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    return {
      scrollLeft: element.scrollX,
      scrollTop: element.scrollY
    };
  }
  function getParentNode(node2) {
    if (getNodeName(node2) === "html") {
      return node2;
    }
    const result = (
      // Step into the shadow DOM of the parent of a slotted node.
      node2.assignedSlot || // DOM Element detected.
      node2.parentNode || // ShadowRoot detected.
      isShadowRoot(node2) && node2.host || // Fallback.
      getDocumentElement(node2)
    );
    return isShadowRoot(result) ? result.host : result;
  }
  function getNearestOverflowAncestor(node2) {
    const parentNode = getParentNode(node2);
    if (isLastTraversableNode(parentNode)) {
      return node2.ownerDocument ? node2.ownerDocument.body : node2.body;
    }
    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
      return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
  }
  function getOverflowAncestors(node2, list, traverseIframes) {
    var _node$ownerDocument2;
    if (list === void 0) {
      list = [];
    }
    if (traverseIframes === void 0) {
      traverseIframes = true;
    }
    const scrollableAncestor = getNearestOverflowAncestor(node2);
    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
    const win = getWindow(scrollableAncestor);
    if (isBody) {
      const frameElement = getFrameElement(win);
      return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
    }
    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
  }
  function getFrameElement(win) {
    return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
  }
  var invalidOverflowDisplayValues, tableElements, topLayerSelectors, transformProperties, willChangeValues, containValues, lastTraversableNodeNames;
  var init_floating_ui_utils_dom = __esm({
    "node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs"() {
      invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
      tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
      topLayerSelectors = [":popover-open", ":modal"];
      transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
      willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
      containValues = ["paint", "layout", "strict", "content"];
      lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
    }
  });

  // node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
  function clamp2(start, value, end) {
    return max(start, min(value, end));
  }
  function evaluate(value, param) {
    return typeof value === "function" ? value(param) : value;
  }
  function getSide(placement) {
    return placement.split("-")[0];
  }
  function getAlignment(placement) {
    return placement.split("-")[1];
  }
  function getOppositeAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function getAxisLength(axis) {
    return axis === "y" ? "height" : "width";
  }
  function getSideAxis(placement) {
    return yAxisSides.has(getSide(placement)) ? "y" : "x";
  }
  function getAlignmentAxis(placement) {
    return getOppositeAxis(getSideAxis(placement));
  }
  function getAlignmentSides(placement, rects, rtl) {
    if (rtl === void 0) {
      rtl = false;
    }
    const alignment = getAlignment(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const length2 = getAxisLength(alignmentAxis);
    let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
    if (rects.reference[length2] > rects.floating[length2]) {
      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    }
    return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
  }
  function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
  }
  function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
  }
  function getSideList(side, isStart, rtl) {
    switch (side) {
      case "top":
      case "bottom":
        if (rtl) return isStart ? rlPlacement : lrPlacement;
        return isStart ? lrPlacement : rlPlacement;
      case "left":
      case "right":
        return isStart ? tbPlacement : btPlacement;
      default:
        return [];
    }
  }
  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = getAlignment(placement);
    let list = getSideList(getSide(placement), direction === "start", rtl);
    if (alignment) {
      list = list.map((side) => side + "-" + alignment);
      if (flipAlignment) {
        list = list.concat(list.map(getOppositeAlignmentPlacement));
      }
    }
    return list;
  }
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
  }
  function expandPaddingObject(padding2) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...padding2
    };
  }
  function getPaddingObject(padding2) {
    return typeof padding2 !== "number" ? expandPaddingObject(padding2) : {
      top: padding2,
      right: padding2,
      bottom: padding2,
      left: padding2
    };
  }
  function rectToClientRect(rect) {
    const {
      x: x2,
      y: y2,
      width,
      height
    } = rect;
    return {
      width,
      height,
      top: y2,
      left: x2,
      right: x2 + width,
      bottom: y2 + height,
      x: x2,
      y: y2
    };
  }
  var sides, alignments, placements, min, max, round, floor, createCoords, oppositeSideMap, oppositeAlignmentMap, yAxisSides, lrPlacement, rlPlacement, tbPlacement, btPlacement;
  var init_floating_ui_utils = __esm({
    "node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs"() {
      sides = ["top", "right", "bottom", "left"];
      alignments = ["start", "end"];
      placements = /* @__PURE__ */ sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
      min = Math.min;
      max = Math.max;
      round = Math.round;
      floor = Math.floor;
      createCoords = (v2) => ({
        x: v2,
        y: v2
      });
      oppositeSideMap = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
      };
      oppositeAlignmentMap = {
        start: "end",
        end: "start"
      };
      yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
      lrPlacement = ["left", "right"];
      rlPlacement = ["right", "left"];
      tbPlacement = ["top", "bottom"];
      btPlacement = ["bottom", "top"];
    }
  });

  // node_modules/tabbable/dist/index.esm.js
  var candidateSelectors, candidateSelector, NoElement, matches, getRootNode, _isInert, isContentEditable, getCandidates, _getCandidatesIteratively, hasTabIndex, getTabIndex, getSortOrderTabIndex, sortOrderedTabbables, isInput, isHiddenInput, isDetailsWithSummary, getCheckedRadio, isTabbableRadio, isRadio, isNonTabbableRadio, isNodeAttached, isZeroArea, isHidden, isDisabledFromFieldset, isNodeMatchingSelectorFocusable, isNodeMatchingSelectorTabbable, isShadowRootTabbable, _sortByOrder, tabbable, focusable, isTabbable;
  var init_index_esm = __esm({
    "node_modules/tabbable/dist/index.esm.js"() {
      candidateSelectors = ["input:not([inert]):not([inert] *)", "select:not([inert]):not([inert] *)", "textarea:not([inert]):not([inert] *)", "a[href]:not([inert]):not([inert] *)", "button:not([inert]):not([inert] *)", "[tabindex]:not(slot):not([inert]):not([inert] *)", "audio[controls]:not([inert]):not([inert] *)", "video[controls]:not([inert]):not([inert] *)", '[contenteditable]:not([contenteditable="false"]):not([inert]):not([inert] *)', "details>summary:first-of-type:not([inert]):not([inert] *)", "details:not([inert]):not([inert] *)"];
      candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
      NoElement = typeof Element === "undefined";
      matches = NoElement ? function() {
      } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
      getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
        var _element$getRootNode;
        return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
      } : function(element) {
        return element === null || element === void 0 ? void 0 : element.ownerDocument;
      };
      _isInert = function isInert(node2, lookUp) {
        var _node$getAttribute;
        if (lookUp === void 0) {
          lookUp = true;
        }
        var inertAtt = node2 === null || node2 === void 0 ? void 0 : (_node$getAttribute = node2.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node2, "inert");
        var inert = inertAtt === "" || inertAtt === "true";
        var result = inert || lookUp && node2 && // closest does not exist on shadow roots, so we fall back to a manual
        // lookup upward, in case it is not defined.
        (typeof node2.closest === "function" ? node2.closest("[inert]") : _isInert(node2.parentNode));
        return result;
      };
      isContentEditable = function isContentEditable2(node2) {
        var _node$getAttribute2;
        var attValue = node2 === null || node2 === void 0 ? void 0 : (_node$getAttribute2 = node2.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node2, "contenteditable");
        return attValue === "" || attValue === "true";
      };
      getCandidates = function getCandidates2(el, includeContainer, filter) {
        if (_isInert(el)) {
          return [];
        }
        var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
        if (includeContainer && matches.call(el, candidateSelector)) {
          candidates.unshift(el);
        }
        candidates = candidates.filter(filter);
        return candidates;
      };
      _getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {
        var candidates = [];
        var elementsToCheck = Array.from(elements);
        while (elementsToCheck.length) {
          var element = elementsToCheck.shift();
          if (_isInert(element, false)) {
            continue;
          }
          if (element.tagName === "SLOT") {
            var assigned = element.assignedElements();
            var content = assigned.length ? assigned : element.children;
            var nestedCandidates = _getCandidatesIteratively(content, true, options);
            if (options.flatten) {
              candidates.push.apply(candidates, nestedCandidates);
            } else {
              candidates.push({
                scopeParent: element,
                candidates: nestedCandidates
              });
            }
          } else {
            var validCandidate = matches.call(element, candidateSelector);
            if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
              candidates.push(element);
            }
            var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
            typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
            var validShadowRoot = !_isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
            if (shadowRoot && validShadowRoot) {
              var _nestedCandidates = _getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);
              if (options.flatten) {
                candidates.push.apply(candidates, _nestedCandidates);
              } else {
                candidates.push({
                  scopeParent: element,
                  candidates: _nestedCandidates
                });
              }
            } else {
              elementsToCheck.unshift.apply(elementsToCheck, element.children);
            }
          }
        }
        return candidates;
      };
      hasTabIndex = function hasTabIndex2(node2) {
        return !isNaN(parseInt(node2.getAttribute("tabindex"), 10));
      };
      getTabIndex = function getTabIndex2(node2) {
        if (!node2) {
          throw new Error("No node provided");
        }
        if (node2.tabIndex < 0) {
          if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node2.tagName) || isContentEditable(node2)) && !hasTabIndex(node2)) {
            return 0;
          }
        }
        return node2.tabIndex;
      };
      getSortOrderTabIndex = function getSortOrderTabIndex2(node2, isScope) {
        var tabIndex = getTabIndex(node2);
        if (tabIndex < 0 && isScope && !hasTabIndex(node2)) {
          return 0;
        }
        return tabIndex;
      };
      sortOrderedTabbables = function sortOrderedTabbables2(a2, b2) {
        return a2.tabIndex === b2.tabIndex ? a2.documentOrder - b2.documentOrder : a2.tabIndex - b2.tabIndex;
      };
      isInput = function isInput2(node2) {
        return node2.tagName === "INPUT";
      };
      isHiddenInput = function isHiddenInput2(node2) {
        return isInput(node2) && node2.type === "hidden";
      };
      isDetailsWithSummary = function isDetailsWithSummary2(node2) {
        var r2 = node2.tagName === "DETAILS" && Array.prototype.slice.apply(node2.children).some(function(child) {
          return child.tagName === "SUMMARY";
        });
        return r2;
      };
      getCheckedRadio = function getCheckedRadio2(nodes, form) {
        for (var i2 = 0; i2 < nodes.length; i2++) {
          if (nodes[i2].checked && nodes[i2].form === form) {
            return nodes[i2];
          }
        }
      };
      isTabbableRadio = function isTabbableRadio2(node2) {
        if (!node2.name) {
          return true;
        }
        var radioScope = node2.form || getRootNode(node2);
        var queryRadios = function queryRadios2(name) {
          return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
        };
        var radioSet;
        if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
          radioSet = queryRadios(window.CSS.escape(node2.name));
        } else {
          try {
            radioSet = queryRadios(node2.name);
          } catch (err2) {
            console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err2.message);
            return false;
          }
        }
        var checked = getCheckedRadio(radioSet, node2.form);
        return !checked || checked === node2;
      };
      isRadio = function isRadio2(node2) {
        return isInput(node2) && node2.type === "radio";
      };
      isNonTabbableRadio = function isNonTabbableRadio2(node2) {
        return isRadio(node2) && !isTabbableRadio(node2);
      };
      isNodeAttached = function isNodeAttached2(node2) {
        var _nodeRoot;
        var nodeRoot = node2 && getRootNode(node2);
        var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
        var attached = false;
        if (nodeRoot && nodeRoot !== node2) {
          var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
          attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node2 !== null && node2 !== void 0 && (_node$ownerDocument = node2.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node2));
          while (!attached && nodeRootHost) {
            var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
            nodeRoot = getRootNode(nodeRootHost);
            nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
            attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
          }
        }
        return attached;
      };
      isZeroArea = function isZeroArea2(node2) {
        var _node$getBoundingClie = node2.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
        return width === 0 && height === 0;
      };
      isHidden = function isHidden2(node2, _ref) {
        var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
        if (displayCheck === "full-native") {
          if ("checkVisibility" in node2) {
            var visible = node2.checkVisibility({
              // Checking opacity might be desirable for some use cases, but natively,
              // opacity zero elements _are_ focusable and tabbable.
              checkOpacity: false,
              opacityProperty: false,
              contentVisibilityAuto: true,
              visibilityProperty: true,
              // This is an alias for `visibilityProperty`. Contemporary browsers
              // support both. However, this alias has wider browser support (Chrome
              // >= 105 and Firefox >= 106, vs. Chrome >= 121 and Firefox >= 122), so
              // we include it anyway.
              checkVisibilityCSS: true
            });
            return !visible;
          }
        }
        if (getComputedStyle(node2).visibility === "hidden") {
          return true;
        }
        var isDirectSummary = matches.call(node2, "details>summary:first-of-type");
        var nodeUnderDetails = isDirectSummary ? node2.parentElement : node2;
        if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
          return true;
        }
        if (!displayCheck || displayCheck === "full" || // full-native can run this branch when it falls through in case
        // Element#checkVisibility is unsupported
        displayCheck === "full-native" || displayCheck === "legacy-full") {
          if (typeof getShadowRoot === "function") {
            var originalNode = node2;
            while (node2) {
              var parentElement = node2.parentElement;
              var rootNode = getRootNode(node2);
              if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
                return isZeroArea(node2);
              } else if (node2.assignedSlot) {
                node2 = node2.assignedSlot;
              } else if (!parentElement && rootNode !== node2.ownerDocument) {
                node2 = rootNode.host;
              } else {
                node2 = parentElement;
              }
            }
            node2 = originalNode;
          }
          if (isNodeAttached(node2)) {
            return !node2.getClientRects().length;
          }
          if (displayCheck !== "legacy-full") {
            return true;
          }
        } else if (displayCheck === "non-zero-area") {
          return isZeroArea(node2);
        }
        return false;
      };
      isDisabledFromFieldset = function isDisabledFromFieldset2(node2) {
        if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node2.tagName)) {
          var parentNode = node2.parentElement;
          while (parentNode) {
            if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
              for (var i2 = 0; i2 < parentNode.children.length; i2++) {
                var child = parentNode.children.item(i2);
                if (child.tagName === "LEGEND") {
                  return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node2);
                }
              }
              return true;
            }
            parentNode = parentNode.parentElement;
          }
        }
        return false;
      };
      isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node2) {
        if (node2.disabled || isHiddenInput(node2) || isHidden(node2, options) || // For a details element with a summary, the summary element gets the focus
        isDetailsWithSummary(node2) || isDisabledFromFieldset(node2)) {
          return false;
        }
        return true;
      };
      isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node2) {
        if (isNonTabbableRadio(node2) || getTabIndex(node2) < 0 || !isNodeMatchingSelectorFocusable(options, node2)) {
          return false;
        }
        return true;
      };
      isShadowRootTabbable = function isShadowRootTabbable2(shadowHostNode) {
        var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
        if (isNaN(tabIndex) || tabIndex >= 0) {
          return true;
        }
        return false;
      };
      _sortByOrder = function sortByOrder(candidates) {
        var regularTabbables = [];
        var orderedTabbables = [];
        candidates.forEach(function(item, i2) {
          var isScope = !!item.scopeParent;
          var element = isScope ? item.scopeParent : item;
          var candidateTabindex = getSortOrderTabIndex(element, isScope);
          var elements = isScope ? _sortByOrder(item.candidates) : element;
          if (candidateTabindex === 0) {
            isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
          } else {
            orderedTabbables.push({
              documentOrder: i2,
              tabIndex: candidateTabindex,
              item,
              isScope,
              content: elements
            });
          }
        });
        return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
          sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
          return acc;
        }, []).concat(regularTabbables);
      };
      tabbable = function tabbable2(container, options) {
        options = options || {};
        var candidates;
        if (options.getShadowRoot) {
          candidates = _getCandidatesIteratively([container], options.includeContainer, {
            filter: isNodeMatchingSelectorTabbable.bind(null, options),
            flatten: false,
            getShadowRoot: options.getShadowRoot,
            shadowRootFilter: isShadowRootTabbable
          });
        } else {
          candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
        }
        return _sortByOrder(candidates);
      };
      focusable = function focusable2(container, options) {
        options = options || {};
        var candidates;
        if (options.getShadowRoot) {
          candidates = _getCandidatesIteratively([container], options.includeContainer, {
            filter: isNodeMatchingSelectorFocusable.bind(null, options),
            flatten: true,
            getShadowRoot: options.getShadowRoot
          });
        } else {
          candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
        }
        return candidates;
      };
      isTabbable = function isTabbable2(node2, options) {
        options = options || {};
        if (!node2) {
          throw new Error("No node provided");
        }
        if (matches.call(node2, candidateSelector) === false) {
          return false;
        }
        return isNodeMatchingSelectorTabbable(options, node2);
      };
    }
  });

  // node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs
  function getPlatform() {
    const uaData = navigator.userAgentData;
    if (uaData != null && uaData.platform) {
      return uaData.platform;
    }
    return navigator.platform;
  }
  function getUserAgent() {
    const uaData = navigator.userAgentData;
    if (uaData && Array.isArray(uaData.brands)) {
      return uaData.brands.map((_ref) => {
        let {
          brand,
          version: version3
        } = _ref;
        return brand + "/" + version3;
      }).join(" ");
    }
    return navigator.userAgent;
  }
  function isSafari() {
    return /apple/i.test(navigator.vendor);
  }
  function isAndroid() {
    const re = /android/i;
    return re.test(getPlatform()) || re.test(getUserAgent());
  }
  function isMac() {
    return getPlatform().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
  }
  function isJSDOM() {
    return getUserAgent().includes("jsdom/");
  }
  function activeElement(doc) {
    let activeElement2 = doc.activeElement;
    while (((_activeElement = activeElement2) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null) {
      var _activeElement;
      activeElement2 = activeElement2.shadowRoot.activeElement;
    }
    return activeElement2;
  }
  function contains(parent, child) {
    if (!parent || !child) {
      return false;
    }
    const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
    if (parent.contains(child)) {
      return true;
    }
    if (rootNode && isShadowRoot(rootNode)) {
      let next2 = child;
      while (next2) {
        if (parent === next2) {
          return true;
        }
        next2 = next2.parentNode || next2.host;
      }
    }
    return false;
  }
  function getTarget(event) {
    if ("composedPath" in event) {
      return event.composedPath()[0];
    }
    return event.target;
  }
  function isEventTargetWithin(event, node2) {
    if (node2 == null) {
      return false;
    }
    if ("composedPath" in event) {
      return event.composedPath().includes(node2);
    }
    const e2 = event;
    return e2.target != null && node2.contains(e2.target);
  }
  function isRootElement(element) {
    return element.matches("html,body");
  }
  function getDocument(node2) {
    return (node2 == null ? void 0 : node2.ownerDocument) || document;
  }
  function isTypeableElement(element) {
    return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);
  }
  function isTypeableCombobox(element) {
    if (!element) return false;
    return element.getAttribute("role") === "combobox" && isTypeableElement(element);
  }
  function matchesFocusVisible(element) {
    if (!element || isJSDOM()) return true;
    try {
      return element.matches(":focus-visible");
    } catch (_e) {
      return true;
    }
  }
  function getFloatingFocusElement(floatingElement) {
    if (!floatingElement) {
      return null;
    }
    return floatingElement.hasAttribute(FOCUSABLE_ATTRIBUTE) ? floatingElement : floatingElement.querySelector("[" + FOCUSABLE_ATTRIBUTE + "]") || floatingElement;
  }
  function getNodeChildren(nodes, id, onlyOpenChildren) {
    if (onlyOpenChildren === void 0) {
      onlyOpenChildren = true;
    }
    const directChildren = nodes.filter((node2) => {
      var _node$context;
      return node2.parentId === id && (!onlyOpenChildren || ((_node$context = node2.context) == null ? void 0 : _node$context.open));
    });
    return directChildren.flatMap((child) => [child, ...getNodeChildren(nodes, child.id, onlyOpenChildren)]);
  }
  function getDeepestNode(nodes, id) {
    let deepestNodeId;
    let maxDepth = -1;
    function findDeepest(nodeId, depth) {
      if (depth > maxDepth) {
        deepestNodeId = nodeId;
        maxDepth = depth;
      }
      const children = getNodeChildren(nodes, nodeId);
      children.forEach((child) => {
        findDeepest(child.id, depth + 1);
      });
    }
    findDeepest(id, 0);
    return nodes.find((node2) => node2.id === deepestNodeId);
  }
  function getNodeAncestors(nodes, id) {
    var _nodes$find;
    let allAncestors = [];
    let currentParentId = (_nodes$find = nodes.find((node2) => node2.id === id)) == null ? void 0 : _nodes$find.parentId;
    while (currentParentId) {
      const currentNode = nodes.find((node2) => node2.id === currentParentId);
      currentParentId = currentNode == null ? void 0 : currentNode.parentId;
      if (currentNode) {
        allAncestors = allAncestors.concat(currentNode);
      }
    }
    return allAncestors;
  }
  function stopEvent(event) {
    event.preventDefault();
    event.stopPropagation();
  }
  function isReactEvent(event) {
    return "nativeEvent" in event;
  }
  function isVirtualClick(event) {
    if (event.mozInputSource === 0 && event.isTrusted) {
      return true;
    }
    if (isAndroid() && event.pointerType) {
      return event.type === "click" && event.buttons === 1;
    }
    return event.detail === 0 && !event.pointerType;
  }
  function isVirtualPointerEvent(event) {
    if (isJSDOM()) return false;
    return !isAndroid() && event.width === 0 && event.height === 0 || isAndroid() && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse" || // iOS VoiceOver returns 0.333 for width/height.
    event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "touch";
  }
  function isMouseLikePointerType(pointerType, strict) {
    const values = ["mouse", "pen"];
    if (!strict) {
      values.push("", void 0);
    }
    return values.includes(pointerType);
  }
  function useLatestRef(value) {
    const ref = React34.useRef(value);
    index(() => {
      ref.current = value;
    });
    return ref;
  }
  function useEffectEvent(callback) {
    const ref = React34.useRef(() => {
      if (true) {
        throw new Error("Cannot call an event handler while rendering.");
      }
    });
    useSafeInsertionEffect(() => {
      ref.current = callback;
    });
    return React34.useCallback(function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return ref.current == null ? void 0 : ref.current(...args);
    }, []);
  }
  function isDifferentGridRow(index3, cols, prevRow) {
    return Math.floor(index3 / cols) !== prevRow;
  }
  function isIndexOutOfListBounds(listRef, index3) {
    return index3 < 0 || index3 >= listRef.current.length;
  }
  function getMinListIndex(listRef, disabledIndices) {
    return findNonDisabledListIndex(listRef, {
      disabledIndices
    });
  }
  function getMaxListIndex(listRef, disabledIndices) {
    return findNonDisabledListIndex(listRef, {
      decrement: true,
      startingIndex: listRef.current.length,
      disabledIndices
    });
  }
  function findNonDisabledListIndex(listRef, _temp) {
    let {
      startingIndex = -1,
      decrement = false,
      disabledIndices,
      amount = 1
    } = _temp === void 0 ? {} : _temp;
    let index3 = startingIndex;
    do {
      index3 += decrement ? -amount : amount;
    } while (index3 >= 0 && index3 <= listRef.current.length - 1 && isListIndexDisabled(listRef, index3, disabledIndices));
    return index3;
  }
  function getGridNavigatedIndex(listRef, _ref) {
    let {
      event,
      orientation,
      loop,
      rtl,
      cols,
      disabledIndices,
      minIndex,
      maxIndex,
      prevIndex,
      stopEvent: stop = false
    } = _ref;
    let nextIndex = prevIndex;
    if (event.key === ARROW_UP) {
      stop && stopEvent(event);
      if (prevIndex === -1) {
        nextIndex = maxIndex;
      } else {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: nextIndex,
          amount: cols,
          decrement: true,
          disabledIndices
        });
        if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {
          const col = prevIndex % cols;
          const maxCol = maxIndex % cols;
          const offset4 = maxIndex - (maxCol - col);
          if (maxCol === col) {
            nextIndex = maxIndex;
          } else {
            nextIndex = maxCol > col ? offset4 : offset4 - cols;
          }
        }
      }
      if (isIndexOutOfListBounds(listRef, nextIndex)) {
        nextIndex = prevIndex;
      }
    }
    if (event.key === ARROW_DOWN) {
      stop && stopEvent(event);
      if (prevIndex === -1) {
        nextIndex = minIndex;
      } else {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex,
          amount: cols,
          disabledIndices
        });
        if (loop && prevIndex + cols > maxIndex) {
          nextIndex = findNonDisabledListIndex(listRef, {
            startingIndex: prevIndex % cols - cols,
            amount: cols,
            disabledIndices
          });
        }
      }
      if (isIndexOutOfListBounds(listRef, nextIndex)) {
        nextIndex = prevIndex;
      }
    }
    if (orientation === "both") {
      const prevRow = floor(prevIndex / cols);
      if (event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT)) {
        stop && stopEvent(event);
        if (prevIndex % cols !== cols - 1) {
          nextIndex = findNonDisabledListIndex(listRef, {
            startingIndex: prevIndex,
            disabledIndices
          });
          if (loop && isDifferentGridRow(nextIndex, cols, prevRow)) {
            nextIndex = findNonDisabledListIndex(listRef, {
              startingIndex: prevIndex - prevIndex % cols - 1,
              disabledIndices
            });
          }
        } else if (loop) {
          nextIndex = findNonDisabledListIndex(listRef, {
            startingIndex: prevIndex - prevIndex % cols - 1,
            disabledIndices
          });
        }
        if (isDifferentGridRow(nextIndex, cols, prevRow)) {
          nextIndex = prevIndex;
        }
      }
      if (event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT)) {
        stop && stopEvent(event);
        if (prevIndex % cols !== 0) {
          nextIndex = findNonDisabledListIndex(listRef, {
            startingIndex: prevIndex,
            decrement: true,
            disabledIndices
          });
          if (loop && isDifferentGridRow(nextIndex, cols, prevRow)) {
            nextIndex = findNonDisabledListIndex(listRef, {
              startingIndex: prevIndex + (cols - prevIndex % cols),
              decrement: true,
              disabledIndices
            });
          }
        } else if (loop) {
          nextIndex = findNonDisabledListIndex(listRef, {
            startingIndex: prevIndex + (cols - prevIndex % cols),
            decrement: true,
            disabledIndices
          });
        }
        if (isDifferentGridRow(nextIndex, cols, prevRow)) {
          nextIndex = prevIndex;
        }
      }
      const lastRow = floor(maxIndex / cols) === prevRow;
      if (isIndexOutOfListBounds(listRef, nextIndex)) {
        if (loop && lastRow) {
          nextIndex = event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT) ? maxIndex : findNonDisabledListIndex(listRef, {
            startingIndex: prevIndex - prevIndex % cols - 1,
            disabledIndices
          });
        } else {
          nextIndex = prevIndex;
        }
      }
    }
    return nextIndex;
  }
  function createGridCellMap(sizes, cols, dense) {
    const cellMap = [];
    let startIndex = 0;
    sizes.forEach((_ref2, index3) => {
      let {
        width,
        height
      } = _ref2;
      if (width > cols) {
        if (true) {
          throw new Error("[Floating UI]: Invalid grid - item width at index " + index3 + " is greater than grid columns");
        }
      }
      let itemPlaced = false;
      if (dense) {
        startIndex = 0;
      }
      while (!itemPlaced) {
        const targetCells = [];
        for (let i2 = 0; i2 < width; i2++) {
          for (let j2 = 0; j2 < height; j2++) {
            targetCells.push(startIndex + i2 + j2 * cols);
          }
        }
        if (startIndex % cols + width <= cols && targetCells.every((cell) => cellMap[cell] == null)) {
          targetCells.forEach((cell) => {
            cellMap[cell] = index3;
          });
          itemPlaced = true;
        } else {
          startIndex++;
        }
      }
    });
    return [...cellMap];
  }
  function getGridCellIndexOfCorner(index3, sizes, cellMap, cols, corner) {
    if (index3 === -1) return -1;
    const firstCellIndex = cellMap.indexOf(index3);
    const sizeItem = sizes[index3];
    switch (corner) {
      case "tl":
        return firstCellIndex;
      case "tr":
        if (!sizeItem) {
          return firstCellIndex;
        }
        return firstCellIndex + sizeItem.width - 1;
      case "bl":
        if (!sizeItem) {
          return firstCellIndex;
        }
        return firstCellIndex + (sizeItem.height - 1) * cols;
      case "br":
        return cellMap.lastIndexOf(index3);
    }
  }
  function getGridCellIndices(indices, cellMap) {
    return cellMap.flatMap((index3, cellIndex) => indices.includes(index3) ? [cellIndex] : []);
  }
  function isListIndexDisabled(listRef, index3, disabledIndices) {
    if (typeof disabledIndices === "function") {
      return disabledIndices(index3);
    } else if (disabledIndices) {
      return disabledIndices.includes(index3);
    }
    const element = listRef.current[index3];
    return element == null || element.hasAttribute("disabled") || element.getAttribute("aria-disabled") === "true";
  }
  function getTabbableIn(container, dir) {
    const list = tabbable(container, getTabbableOptions());
    const len2 = list.length;
    if (len2 === 0) return;
    const active = activeElement(getDocument(container));
    const index3 = list.indexOf(active);
    const nextIndex = index3 === -1 ? dir === 1 ? 0 : len2 - 1 : index3 + dir;
    return list[nextIndex];
  }
  function getNextTabbable(referenceElement) {
    return getTabbableIn(getDocument(referenceElement).body, 1) || referenceElement;
  }
  function getPreviousTabbable(referenceElement) {
    return getTabbableIn(getDocument(referenceElement).body, -1) || referenceElement;
  }
  function isOutsideEvent(event, container) {
    const containerElement = container || event.currentTarget;
    const relatedTarget = event.relatedTarget;
    return !relatedTarget || !contains(containerElement, relatedTarget);
  }
  function disableFocusInside(container) {
    const tabbableElements = tabbable(container, getTabbableOptions());
    tabbableElements.forEach((element) => {
      element.dataset.tabindex = element.getAttribute("tabindex") || "";
      element.setAttribute("tabindex", "-1");
    });
  }
  function enableFocusInside(container) {
    const elements = container.querySelectorAll("[data-tabindex]");
    elements.forEach((element) => {
      const tabindex = element.dataset.tabindex;
      delete element.dataset.tabindex;
      if (tabindex) {
        element.setAttribute("tabindex", tabindex);
      } else {
        element.removeAttribute("tabindex");
      }
    });
  }
  var React34, import_react38, FOCUSABLE_ATTRIBUTE, TYPEABLE_SELECTOR, ARROW_LEFT, ARROW_RIGHT, ARROW_UP, ARROW_DOWN, isClient, noop4, index, SafeReact, useInsertionEffect3, useSafeInsertionEffect, getTabbableOptions;
  var init_floating_ui_react_utils = __esm({
    "node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs"() {
      init_floating_ui_utils_dom();
      React34 = __toESM(require_react(), 1);
      import_react38 = __toESM(require_react(), 1);
      init_floating_ui_utils();
      init_index_esm();
      FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
      TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
      ARROW_LEFT = "ArrowLeft";
      ARROW_RIGHT = "ArrowRight";
      ARROW_UP = "ArrowUp";
      ARROW_DOWN = "ArrowDown";
      isClient = typeof document !== "undefined";
      noop4 = function noop5() {
      };
      index = isClient ? import_react38.useLayoutEffect : noop4;
      SafeReact = {
        ...React34
      };
      useInsertionEffect3 = SafeReact.useInsertionEffect;
      useSafeInsertionEffect = useInsertionEffect3 || ((fn) => fn());
      getTabbableOptions = () => ({
        getShadowRoot: true,
        displayCheck: (
          // JSDOM does not support the `tabbable` library. To solve this we can
          // check if `ResizeObserver` is a real function (not polyfilled), which
          // determines if the current environment is JSDOM-like.
          typeof ResizeObserver === "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
        )
      });
    }
  });

  // node_modules/@floating-ui/core/dist/floating-ui.core.mjs
  function computeCoordsFromPlacement(_ref, placement, rtl) {
    let {
      reference,
      floating
    } = _ref;
    const sideAxis = getSideAxis(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const alignLength = getAxisLength(alignmentAxis);
    const side = getSide(placement);
    const isVertical = sideAxis === "y";
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
    let coords;
    switch (side) {
      case "top":
        coords = {
          x: commonX,
          y: reference.y - floating.height
        };
        break;
      case "bottom":
        coords = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;
      case "right":
        coords = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;
      case "left":
        coords = {
          x: reference.x - floating.width,
          y: commonY
        };
        break;
      default:
        coords = {
          x: reference.x,
          y: reference.y
        };
    }
    switch (getAlignment(placement)) {
      case "start":
        coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
        break;
      case "end":
        coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
        break;
    }
    return coords;
  }
  async function detectOverflow(state, options) {
    var _await$platform$isEle;
    if (options === void 0) {
      options = {};
    }
    const {
      x: x2,
      y: y2,
      platform: platform2,
      rects,
      elements,
      strategy
    } = state;
    const {
      boundary = "clippingAncestors",
      rootBoundary = "viewport",
      elementContext = "floating",
      altBoundary = false,
      padding: padding2 = 0
    } = evaluate(options, state);
    const paddingObject = getPaddingObject(padding2);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
      element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === "floating" ? {
      x: x2,
      y: y2,
      width: rects.floating.width,
      height: rects.floating.height
    } : rects.reference;
    const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
    const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements,
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  }
  function getPlacementList(alignment, autoAlignment, allowedPlacements) {
    const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement);
    return allowedPlacementsSortedByAlignment.filter((placement) => {
      if (alignment) {
        return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
      }
      return true;
    });
  }
  function getSideOffsets(overflow, rect) {
    return {
      top: overflow.top - rect.height,
      right: overflow.right - rect.width,
      bottom: overflow.bottom - rect.height,
      left: overflow.left - rect.width
    };
  }
  function isAnySideFullyClipped(overflow) {
    return sides.some((side) => overflow[side] >= 0);
  }
  function getBoundingRect(rects) {
    const minX = min(...rects.map((rect) => rect.left));
    const minY = min(...rects.map((rect) => rect.top));
    const maxX = max(...rects.map((rect) => rect.right));
    const maxY2 = max(...rects.map((rect) => rect.bottom));
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY2 - minY
    };
  }
  function getRectsByLine(rects) {
    const sortedRects = rects.slice().sort((a2, b2) => a2.y - b2.y);
    const groups = [];
    let prevRect = null;
    for (let i2 = 0; i2 < sortedRects.length; i2++) {
      const rect = sortedRects[i2];
      if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {
        groups.push([rect]);
      } else {
        groups[groups.length - 1].push(rect);
      }
      prevRect = rect;
    }
    return groups.map((rect) => rectToClientRect(getBoundingRect(rect)));
  }
  async function convertValueToCoords(state, options) {
    const {
      placement,
      platform: platform2,
      elements
    } = state;
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
    const side = getSide(placement);
    const alignment = getAlignment(placement);
    const isVertical = getSideAxis(placement) === "y";
    const mainAxisMulti = originSides.has(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = evaluate(options, state);
    let {
      mainAxis,
      crossAxis,
      alignmentAxis
    } = typeof rawValue === "number" ? {
      mainAxis: rawValue,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: rawValue.mainAxis || 0,
      crossAxis: rawValue.crossAxis || 0,
      alignmentAxis: rawValue.alignmentAxis
    };
    if (alignment && typeof alignmentAxis === "number") {
      crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
      x: crossAxis * crossAxisMulti,
      y: mainAxis * mainAxisMulti
    } : {
      x: mainAxis * mainAxisMulti,
      y: crossAxis * crossAxisMulti
    };
  }
  var computePosition, arrow, autoPlacement, flip, hide, inline, originSides, offset, shift, limitShift, size;
  var init_floating_ui_core = __esm({
    "node_modules/@floating-ui/core/dist/floating-ui.core.mjs"() {
      init_floating_ui_utils();
      init_floating_ui_utils();
      computePosition = async (reference, floating, config2) => {
        const {
          placement = "bottom",
          strategy = "absolute",
          middleware: middleware3 = [],
          platform: platform2
        } = config2;
        const validMiddleware = middleware3.filter(Boolean);
        const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
        let rects = await platform2.getElementRects({
          reference,
          floating,
          strategy
        });
        let {
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, placement, rtl);
        let statefulPlacement = placement;
        let middlewareData = {};
        let resetCount = 0;
        for (let i2 = 0; i2 < validMiddleware.length; i2++) {
          const {
            name,
            fn
          } = validMiddleware[i2];
          const {
            x: nextX,
            y: nextY,
            data,
            reset
          } = await fn({
            x: x2,
            y: y2,
            initialPlacement: placement,
            placement: statefulPlacement,
            strategy,
            middlewareData,
            rects,
            platform: platform2,
            elements: {
              reference,
              floating
            }
          });
          x2 = nextX != null ? nextX : x2;
          y2 = nextY != null ? nextY : y2;
          middlewareData = {
            ...middlewareData,
            [name]: {
              ...middlewareData[name],
              ...data
            }
          };
          if (reset && resetCount <= 50) {
            resetCount++;
            if (typeof reset === "object") {
              if (reset.placement) {
                statefulPlacement = reset.placement;
              }
              if (reset.rects) {
                rects = reset.rects === true ? await platform2.getElementRects({
                  reference,
                  floating,
                  strategy
                }) : reset.rects;
              }
              ({
                x: x2,
                y: y2
              } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
            }
            i2 = -1;
          }
        }
        return {
          x: x2,
          y: y2,
          placement: statefulPlacement,
          strategy,
          middlewareData
        };
      };
      arrow = (options) => ({
        name: "arrow",
        options,
        async fn(state) {
          const {
            x: x2,
            y: y2,
            placement,
            rects,
            platform: platform2,
            elements,
            middlewareData
          } = state;
          const {
            element,
            padding: padding2 = 0
          } = evaluate(options, state) || {};
          if (element == null) {
            return {};
          }
          const paddingObject = getPaddingObject(padding2);
          const coords = {
            x: x2,
            y: y2
          };
          const axis = getAlignmentAxis(placement);
          const length2 = getAxisLength(axis);
          const arrowDimensions = await platform2.getDimensions(element);
          const isYAxis = axis === "y";
          const minProp = isYAxis ? "top" : "left";
          const maxProp = isYAxis ? "bottom" : "right";
          const clientProp = isYAxis ? "clientHeight" : "clientWidth";
          const endDiff = rects.reference[length2] + rects.reference[axis] - coords[axis] - rects.floating[length2];
          const startDiff = coords[axis] - rects.reference[axis];
          const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
          let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
          if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
            clientSize = elements.floating[clientProp] || rects.floating[length2];
          }
          const centerToReference = endDiff / 2 - startDiff / 2;
          const largestPossiblePadding = clientSize / 2 - arrowDimensions[length2] / 2 - 1;
          const minPadding = min(paddingObject[minProp], largestPossiblePadding);
          const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
          const min$1 = minPadding;
          const max3 = clientSize - arrowDimensions[length2] - maxPadding;
          const center = clientSize / 2 - arrowDimensions[length2] / 2 + centerToReference;
          const offset4 = clamp2(min$1, center, max3);
          const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length2] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length2] / 2 < 0;
          const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max3 : 0;
          return {
            [axis]: coords[axis] + alignmentOffset,
            data: {
              [axis]: offset4,
              centerOffset: center - offset4 - alignmentOffset,
              ...shouldAddOffset && {
                alignmentOffset
              }
            },
            reset: shouldAddOffset
          };
        }
      });
      autoPlacement = function(options) {
        if (options === void 0) {
          options = {};
        }
        return {
          name: "autoPlacement",
          options,
          async fn(state) {
            var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
            const {
              rects,
              middlewareData,
              placement,
              platform: platform2,
              elements
            } = state;
            const {
              crossAxis = false,
              alignment,
              allowedPlacements = placements,
              autoAlignment = true,
              ...detectOverflowOptions
            } = evaluate(options, state);
            const placements$1 = alignment !== void 0 || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
            const currentPlacement = placements$1[currentIndex];
            if (currentPlacement == null) {
              return {};
            }
            const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
            if (placement !== currentPlacement) {
              return {
                reset: {
                  placement: placements$1[0]
                }
              };
            }
            const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];
            const allOverflows = [...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [], {
              placement: currentPlacement,
              overflows: currentOverflows
            }];
            const nextPlacement = placements$1[currentIndex + 1];
            if (nextPlacement) {
              return {
                data: {
                  index: currentIndex + 1,
                  overflows: allOverflows
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }
            const placementsSortedByMostSpace = allOverflows.map((d3) => {
              const alignment2 = getAlignment(d3.placement);
              return [d3.placement, alignment2 && crossAxis ? (
                // Check along the mainAxis and main crossAxis side.
                d3.overflows.slice(0, 2).reduce((acc, v2) => acc + v2, 0)
              ) : (
                // Check only the mainAxis.
                d3.overflows[0]
              ), d3.overflows];
            }).sort((a2, b2) => a2[1] - b2[1]);
            const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d3) => d3[2].slice(
              0,
              // Aligned placements should not check their opposite crossAxis
              // side.
              getAlignment(d3[0]) ? 2 : 3
            ).every((v2) => v2 <= 0));
            const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
            if (resetPlacement !== placement) {
              return {
                data: {
                  index: currentIndex + 1,
                  overflows: allOverflows
                },
                reset: {
                  placement: resetPlacement
                }
              };
            }
            return {};
          }
        };
      };
      flip = function(options) {
        if (options === void 0) {
          options = {};
        }
        return {
          name: "flip",
          options,
          async fn(state) {
            var _middlewareData$arrow, _middlewareData$flip;
            const {
              placement,
              middlewareData,
              rects,
              initialPlacement,
              platform: platform2,
              elements
            } = state;
            const {
              mainAxis: checkMainAxis = true,
              crossAxis: checkCrossAxis = true,
              fallbackPlacements: specifiedFallbackPlacements,
              fallbackStrategy = "bestFit",
              fallbackAxisSideDirection = "none",
              flipAlignment = true,
              ...detectOverflowOptions
            } = evaluate(options, state);
            if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
              return {};
            }
            const side = getSide(placement);
            const initialSideAxis = getSideAxis(initialPlacement);
            const isBasePlacement = getSide(initialPlacement) === initialPlacement;
            const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
            const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
            const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
            if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
              fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
            }
            const placements2 = [initialPlacement, ...fallbackPlacements];
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const overflows = [];
            let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
            if (checkMainAxis) {
              overflows.push(overflow[side]);
            }
            if (checkCrossAxis) {
              const sides2 = getAlignmentSides(placement, rects, rtl);
              overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
            }
            overflowsData = [...overflowsData, {
              placement,
              overflows
            }];
            if (!overflows.every((side2) => side2 <= 0)) {
              var _middlewareData$flip2, _overflowsData$filter;
              const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
              const nextPlacement = placements2[nextIndex];
              if (nextPlacement) {
                const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
                if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
                // overflows the main axis.
                overflowsData.every((d3) => getSideAxis(d3.placement) === initialSideAxis ? d3.overflows[0] > 0 : true)) {
                  return {
                    data: {
                      index: nextIndex,
                      overflows: overflowsData
                    },
                    reset: {
                      placement: nextPlacement
                    }
                  };
                }
              }
              let resetPlacement = (_overflowsData$filter = overflowsData.filter((d3) => d3.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
              if (!resetPlacement) {
                switch (fallbackStrategy) {
                  case "bestFit": {
                    var _overflowsData$filter2;
                    const placement2 = (_overflowsData$filter2 = overflowsData.filter((d3) => {
                      if (hasFallbackAxisSideDirection) {
                        const currentSideAxis = getSideAxis(d3.placement);
                        return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                        // reading directions favoring greater width.
                        currentSideAxis === "y";
                      }
                      return true;
                    }).map((d3) => [d3.placement, d3.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
                    if (placement2) {
                      resetPlacement = placement2;
                    }
                    break;
                  }
                  case "initialPlacement":
                    resetPlacement = initialPlacement;
                    break;
                }
              }
              if (placement !== resetPlacement) {
                return {
                  reset: {
                    placement: resetPlacement
                  }
                };
              }
            }
            return {};
          }
        };
      };
      hide = function(options) {
        if (options === void 0) {
          options = {};
        }
        return {
          name: "hide",
          options,
          async fn(state) {
            const {
              rects
            } = state;
            const {
              strategy = "referenceHidden",
              ...detectOverflowOptions
            } = evaluate(options, state);
            switch (strategy) {
              case "referenceHidden": {
                const overflow = await detectOverflow(state, {
                  ...detectOverflowOptions,
                  elementContext: "reference"
                });
                const offsets = getSideOffsets(overflow, rects.reference);
                return {
                  data: {
                    referenceHiddenOffsets: offsets,
                    referenceHidden: isAnySideFullyClipped(offsets)
                  }
                };
              }
              case "escaped": {
                const overflow = await detectOverflow(state, {
                  ...detectOverflowOptions,
                  altBoundary: true
                });
                const offsets = getSideOffsets(overflow, rects.floating);
                return {
                  data: {
                    escapedOffsets: offsets,
                    escaped: isAnySideFullyClipped(offsets)
                  }
                };
              }
              default: {
                return {};
              }
            }
          }
        };
      };
      inline = function(options) {
        if (options === void 0) {
          options = {};
        }
        return {
          name: "inline",
          options,
          async fn(state) {
            const {
              placement,
              elements,
              rects,
              platform: platform2,
              strategy
            } = state;
            const {
              padding: padding2 = 2,
              x: x2,
              y: y2
            } = evaluate(options, state);
            const nativeClientRects = Array.from(await (platform2.getClientRects == null ? void 0 : platform2.getClientRects(elements.reference)) || []);
            const clientRects = getRectsByLine(nativeClientRects);
            const fallback = rectToClientRect(getBoundingRect(nativeClientRects));
            const paddingObject = getPaddingObject(padding2);
            function getBoundingClientRect2() {
              if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x2 != null && y2 != null) {
                return clientRects.find((rect) => x2 > rect.left - paddingObject.left && x2 < rect.right + paddingObject.right && y2 > rect.top - paddingObject.top && y2 < rect.bottom + paddingObject.bottom) || fallback;
              }
              if (clientRects.length >= 2) {
                if (getSideAxis(placement) === "y") {
                  const firstRect = clientRects[0];
                  const lastRect = clientRects[clientRects.length - 1];
                  const isTop = getSide(placement) === "top";
                  const top2 = firstRect.top;
                  const bottom2 = lastRect.bottom;
                  const left2 = isTop ? firstRect.left : lastRect.left;
                  const right2 = isTop ? firstRect.right : lastRect.right;
                  const width2 = right2 - left2;
                  const height2 = bottom2 - top2;
                  return {
                    top: top2,
                    bottom: bottom2,
                    left: left2,
                    right: right2,
                    width: width2,
                    height: height2,
                    x: left2,
                    y: top2
                  };
                }
                const isLeftSide = getSide(placement) === "left";
                const maxRight = max(...clientRects.map((rect) => rect.right));
                const minLeft = min(...clientRects.map((rect) => rect.left));
                const measureRects = clientRects.filter((rect) => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
                const top = measureRects[0].top;
                const bottom = measureRects[measureRects.length - 1].bottom;
                const left = minLeft;
                const right = maxRight;
                const width = right - left;
                const height = bottom - top;
                return {
                  top,
                  bottom,
                  left,
                  right,
                  width,
                  height,
                  x: left,
                  y: top
                };
              }
              return fallback;
            }
            const resetRects = await platform2.getElementRects({
              reference: {
                getBoundingClientRect: getBoundingClientRect2
              },
              floating: elements.floating,
              strategy
            });
            if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
              return {
                reset: {
                  rects: resetRects
                }
              };
            }
            return {};
          }
        };
      };
      originSides = /* @__PURE__ */ new Set(["left", "top"]);
      offset = function(options) {
        if (options === void 0) {
          options = 0;
        }
        return {
          name: "offset",
          options,
          async fn(state) {
            var _middlewareData$offse, _middlewareData$arrow;
            const {
              x: x2,
              y: y2,
              placement,
              middlewareData
            } = state;
            const diffCoords = await convertValueToCoords(state, options);
            if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
              return {};
            }
            return {
              x: x2 + diffCoords.x,
              y: y2 + diffCoords.y,
              data: {
                ...diffCoords,
                placement
              }
            };
          }
        };
      };
      shift = function(options) {
        if (options === void 0) {
          options = {};
        }
        return {
          name: "shift",
          options,
          async fn(state) {
            const {
              x: x2,
              y: y2,
              placement
            } = state;
            const {
              mainAxis: checkMainAxis = true,
              crossAxis: checkCrossAxis = false,
              limiter = {
                fn: (_ref) => {
                  let {
                    x: x3,
                    y: y3
                  } = _ref;
                  return {
                    x: x3,
                    y: y3
                  };
                }
              },
              ...detectOverflowOptions
            } = evaluate(options, state);
            const coords = {
              x: x2,
              y: y2
            };
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const crossAxis = getSideAxis(getSide(placement));
            const mainAxis = getOppositeAxis(crossAxis);
            let mainAxisCoord = coords[mainAxis];
            let crossAxisCoord = coords[crossAxis];
            if (checkMainAxis) {
              const minSide = mainAxis === "y" ? "top" : "left";
              const maxSide = mainAxis === "y" ? "bottom" : "right";
              const min2 = mainAxisCoord + overflow[minSide];
              const max3 = mainAxisCoord - overflow[maxSide];
              mainAxisCoord = clamp2(min2, mainAxisCoord, max3);
            }
            if (checkCrossAxis) {
              const minSide = crossAxis === "y" ? "top" : "left";
              const maxSide = crossAxis === "y" ? "bottom" : "right";
              const min2 = crossAxisCoord + overflow[minSide];
              const max3 = crossAxisCoord - overflow[maxSide];
              crossAxisCoord = clamp2(min2, crossAxisCoord, max3);
            }
            const limitedCoords = limiter.fn({
              ...state,
              [mainAxis]: mainAxisCoord,
              [crossAxis]: crossAxisCoord
            });
            return {
              ...limitedCoords,
              data: {
                x: limitedCoords.x - x2,
                y: limitedCoords.y - y2,
                enabled: {
                  [mainAxis]: checkMainAxis,
                  [crossAxis]: checkCrossAxis
                }
              }
            };
          }
        };
      };
      limitShift = function(options) {
        if (options === void 0) {
          options = {};
        }
        return {
          options,
          fn(state) {
            const {
              x: x2,
              y: y2,
              placement,
              rects,
              middlewareData
            } = state;
            const {
              offset: offset4 = 0,
              mainAxis: checkMainAxis = true,
              crossAxis: checkCrossAxis = true
            } = evaluate(options, state);
            const coords = {
              x: x2,
              y: y2
            };
            const crossAxis = getSideAxis(placement);
            const mainAxis = getOppositeAxis(crossAxis);
            let mainAxisCoord = coords[mainAxis];
            let crossAxisCoord = coords[crossAxis];
            const rawOffset = evaluate(offset4, state);
            const computedOffset = typeof rawOffset === "number" ? {
              mainAxis: rawOffset,
              crossAxis: 0
            } : {
              mainAxis: 0,
              crossAxis: 0,
              ...rawOffset
            };
            if (checkMainAxis) {
              const len2 = mainAxis === "y" ? "height" : "width";
              const limitMin = rects.reference[mainAxis] - rects.floating[len2] + computedOffset.mainAxis;
              const limitMax = rects.reference[mainAxis] + rects.reference[len2] - computedOffset.mainAxis;
              if (mainAxisCoord < limitMin) {
                mainAxisCoord = limitMin;
              } else if (mainAxisCoord > limitMax) {
                mainAxisCoord = limitMax;
              }
            }
            if (checkCrossAxis) {
              var _middlewareData$offse, _middlewareData$offse2;
              const len2 = mainAxis === "y" ? "width" : "height";
              const isOriginSide = originSides.has(getSide(placement));
              const limitMin = rects.reference[crossAxis] - rects.floating[len2] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
              const limitMax = rects.reference[crossAxis] + rects.reference[len2] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
              if (crossAxisCoord < limitMin) {
                crossAxisCoord = limitMin;
              } else if (crossAxisCoord > limitMax) {
                crossAxisCoord = limitMax;
              }
            }
            return {
              [mainAxis]: mainAxisCoord,
              [crossAxis]: crossAxisCoord
            };
          }
        };
      };
      size = function(options) {
        if (options === void 0) {
          options = {};
        }
        return {
          name: "size",
          options,
          async fn(state) {
            var _state$middlewareData, _state$middlewareData2;
            const {
              placement,
              rects,
              platform: platform2,
              elements
            } = state;
            const {
              apply = () => {
              },
              ...detectOverflowOptions
            } = evaluate(options, state);
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const side = getSide(placement);
            const alignment = getAlignment(placement);
            const isYAxis = getSideAxis(placement) === "y";
            const {
              width,
              height
            } = rects.floating;
            let heightSide;
            let widthSide;
            if (side === "top" || side === "bottom") {
              heightSide = side;
              widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
            } else {
              widthSide = side;
              heightSide = alignment === "end" ? "top" : "bottom";
            }
            const maximumClippingHeight = height - overflow.top - overflow.bottom;
            const maximumClippingWidth = width - overflow.left - overflow.right;
            const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
            const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
            const noShift = !state.middlewareData.shift;
            let availableHeight = overflowAvailableHeight;
            let availableWidth = overflowAvailableWidth;
            if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
              availableWidth = maximumClippingWidth;
            }
            if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
              availableHeight = maximumClippingHeight;
            }
            if (noShift && !alignment) {
              const xMin = max(overflow.left, 0);
              const xMax = max(overflow.right, 0);
              const yMin = max(overflow.top, 0);
              const yMax = max(overflow.bottom, 0);
              if (isYAxis) {
                availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
              } else {
                availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
              }
            }
            await apply({
              ...state,
              availableWidth,
              availableHeight
            });
            const nextDimensions = await platform2.getDimensions(elements.floating);
            if (width !== nextDimensions.width || height !== nextDimensions.height) {
              return {
                reset: {
                  rects: true
                }
              };
            }
            return {};
          }
        };
      };
    }
  });

  // node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
  function getCssDimensions(element) {
    const css2 = getComputedStyle2(element);
    let width = parseFloat(css2.width) || 0;
    let height = parseFloat(css2.height) || 0;
    const hasOffset = isHTMLElement(element);
    const offsetWidth = hasOffset ? element.offsetWidth : width;
    const offsetHeight = hasOffset ? element.offsetHeight : height;
    const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
    if (shouldFallback) {
      width = offsetWidth;
      height = offsetHeight;
    }
    return {
      width,
      height,
      $: shouldFallback
    };
  }
  function unwrapElement(element) {
    return !isElement(element) ? element.contextElement : element;
  }
  function getScale(element) {
    const domElement = unwrapElement(element);
    if (!isHTMLElement(domElement)) {
      return createCoords(1);
    }
    const rect = domElement.getBoundingClientRect();
    const {
      width,
      height,
      $: $2
    } = getCssDimensions(domElement);
    let x2 = ($2 ? round(rect.width) : rect.width) / width;
    let y2 = ($2 ? round(rect.height) : rect.height) / height;
    if (!x2 || !Number.isFinite(x2)) {
      x2 = 1;
    }
    if (!y2 || !Number.isFinite(y2)) {
      y2 = 1;
    }
    return {
      x: x2,
      y: y2
    };
  }
  function getVisualOffsets(element) {
    const win = getWindow(element);
    if (!isWebKit() || !win.visualViewport) {
      return noOffsets;
    }
    return {
      x: win.visualViewport.offsetLeft,
      y: win.visualViewport.offsetTop
    };
  }
  function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
      return false;
    }
    return isFixed;
  }
  function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    const clientRect = element.getBoundingClientRect();
    const domElement = unwrapElement(element);
    let scale = createCoords(1);
    if (includeScale) {
      if (offsetParent) {
        if (isElement(offsetParent)) {
          scale = getScale(offsetParent);
        }
      } else {
        scale = getScale(element);
      }
    }
    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
    let x2 = (clientRect.left + visualOffsets.x) / scale.x;
    let y2 = (clientRect.top + visualOffsets.y) / scale.y;
    let width = clientRect.width / scale.x;
    let height = clientRect.height / scale.y;
    if (domElement) {
      const win = getWindow(domElement);
      const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
      let currentWin = win;
      let currentIFrame = getFrameElement(currentWin);
      while (currentIFrame && offsetParent && offsetWin !== currentWin) {
        const iframeScale = getScale(currentIFrame);
        const iframeRect = currentIFrame.getBoundingClientRect();
        const css2 = getComputedStyle2(currentIFrame);
        const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
        const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
        x2 *= iframeScale.x;
        y2 *= iframeScale.y;
        width *= iframeScale.x;
        height *= iframeScale.y;
        x2 += left;
        y2 += top;
        currentWin = getWindow(currentIFrame);
        currentIFrame = getFrameElement(currentWin);
      }
    }
    return rectToClientRect({
      width,
      height,
      x: x2,
      y: y2
    });
  }
  function getWindowScrollBarX(element, rect) {
    const leftScroll = getNodeScroll(element).scrollLeft;
    if (!rect) {
      return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
    }
    return rect.left + leftScroll;
  }
  function getHTMLOffset(documentElement, scroll) {
    const htmlRect = documentElement.getBoundingClientRect();
    const x2 = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
    const y2 = htmlRect.top + scroll.scrollTop;
    return {
      x: x2,
      y: y2
    };
  }
  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
    let {
      elements,
      rect,
      offsetParent,
      strategy
    } = _ref;
    const isFixed = strategy === "fixed";
    const documentElement = getDocumentElement(offsetParent);
    const topLayer = elements ? isTopLayer(elements.floating) : false;
    if (offsetParent === documentElement || topLayer && isFixed) {
      return rect;
    }
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    let scale = createCoords(1);
    const offsets = createCoords(0);
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        const offsetRect = getBoundingClientRect(offsetParent);
        scale = getScale(offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      }
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
    return {
      width: rect.width * scale.x,
      height: rect.height * scale.y,
      x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
      y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
    };
  }
  function getClientRects(element) {
    return Array.from(element.getClientRects());
  }
  function getDocumentRect(element) {
    const html = getDocumentElement(element);
    const scroll = getNodeScroll(element);
    const body = element.ownerDocument.body;
    const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
    const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
    let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
    const y2 = -scroll.scrollTop;
    if (getComputedStyle2(body).direction === "rtl") {
      x2 += max(html.clientWidth, body.clientWidth) - width;
    }
    return {
      width,
      height,
      x: x2,
      y: y2
    };
  }
  function getViewportRect(element, strategy) {
    const win = getWindow(element);
    const html = getDocumentElement(element);
    const visualViewport = win.visualViewport;
    let width = html.clientWidth;
    let height = html.clientHeight;
    let x2 = 0;
    let y2 = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      const visualViewportBased = isWebKit();
      if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
        x2 = visualViewport.offsetLeft;
        y2 = visualViewport.offsetTop;
      }
    }
    const windowScrollbarX = getWindowScrollBarX(html);
    if (windowScrollbarX <= 0) {
      const doc = html.ownerDocument;
      const body = doc.body;
      const bodyStyles = getComputedStyle(body);
      const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
      const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
      if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
        width -= clippingStableScrollbarWidth;
      }
    } else if (windowScrollbarX <= SCROLLBAR_MAX) {
      width += windowScrollbarX;
    }
    return {
      width,
      height,
      x: x2,
      y: y2
    };
  }
  function getInnerBoundingClientRect(element, strategy) {
    const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
    const top = clientRect.top + element.clientTop;
    const left = clientRect.left + element.clientLeft;
    const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
    const width = element.clientWidth * scale.x;
    const height = element.clientHeight * scale.y;
    const x2 = left * scale.x;
    const y2 = top * scale.y;
    return {
      width,
      height,
      x: x2,
      y: y2
    };
  }
  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
    let rect;
    if (clippingAncestor === "viewport") {
      rect = getViewportRect(element, strategy);
    } else if (clippingAncestor === "document") {
      rect = getDocumentRect(getDocumentElement(element));
    } else if (isElement(clippingAncestor)) {
      rect = getInnerBoundingClientRect(clippingAncestor, strategy);
    } else {
      const visualOffsets = getVisualOffsets(element);
      rect = {
        x: clippingAncestor.x - visualOffsets.x,
        y: clippingAncestor.y - visualOffsets.y,
        width: clippingAncestor.width,
        height: clippingAncestor.height
      };
    }
    return rectToClientRect(rect);
  }
  function hasFixedPositionAncestor(element, stopNode) {
    const parentNode = getParentNode(element);
    if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
      return false;
    }
    return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
  }
  function getClippingElementAncestors(element, cache2) {
    const cachedResult = cache2.get(element);
    if (cachedResult) {
      return cachedResult;
    }
    let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = getComputedStyle2(element).position === "fixed";
    let currentNode = elementIsFixed ? getParentNode(element) : element;
    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
      const computedStyle = getComputedStyle2(currentNode);
      const currentNodeIsContaining = isContainingBlock(currentNode);
      if (!currentNodeIsContaining && computedStyle.position === "fixed") {
        currentContainingBlockComputedStyle = null;
      }
      const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
      if (shouldDropCurrentNode) {
        result = result.filter((ancestor) => ancestor !== currentNode);
      } else {
        currentContainingBlockComputedStyle = computedStyle;
      }
      currentNode = getParentNode(currentNode);
    }
    cache2.set(element, result);
    return result;
  }
  function getClippingRect(_ref) {
    let {
      element,
      boundary,
      rootBoundary,
      strategy
    } = _ref;
    const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
    const clippingAncestors = [...elementClippingAncestors, rootBoundary];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
      const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
    return {
      width: clippingRect.right - clippingRect.left,
      height: clippingRect.bottom - clippingRect.top,
      x: clippingRect.left,
      y: clippingRect.top
    };
  }
  function getDimensions(element) {
    const {
      width,
      height
    } = getCssDimensions(element);
    return {
      width,
      height
    };
  }
  function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    const isFixed = strategy === "fixed";
    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const offsets = createCoords(0);
    function setLeftRTLScrollbarOffset() {
      offsets.x = getWindowScrollBarX(documentElement);
    }
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isOffsetParentAnElement) {
        const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      } else if (documentElement) {
        setLeftRTLScrollbarOffset();
      }
    }
    if (isFixed && !isOffsetParentAnElement && documentElement) {
      setLeftRTLScrollbarOffset();
    }
    const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
    const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
    const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
    return {
      x: x2,
      y: y2,
      width: rect.width,
      height: rect.height
    };
  }
  function isStaticPositioned(element) {
    return getComputedStyle2(element).position === "static";
  }
  function getTrueOffsetParent(element, polyfill) {
    if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
      return null;
    }
    if (polyfill) {
      return polyfill(element);
    }
    let rawOffsetParent = element.offsetParent;
    if (getDocumentElement(element) === rawOffsetParent) {
      rawOffsetParent = rawOffsetParent.ownerDocument.body;
    }
    return rawOffsetParent;
  }
  function getOffsetParent(element, polyfill) {
    const win = getWindow(element);
    if (isTopLayer(element)) {
      return win;
    }
    if (!isHTMLElement(element)) {
      let svgOffsetParent = getParentNode(element);
      while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
        if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
          return svgOffsetParent;
        }
        svgOffsetParent = getParentNode(svgOffsetParent);
      }
      return win;
    }
    let offsetParent = getTrueOffsetParent(element, polyfill);
    while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
      offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    }
    if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
      return win;
    }
    return offsetParent || getContainingBlock(element) || win;
  }
  function isRTL(element) {
    return getComputedStyle2(element).direction === "rtl";
  }
  function rectsAreEqual(a2, b2) {
    return a2.x === b2.x && a2.y === b2.y && a2.width === b2.width && a2.height === b2.height;
  }
  function observeMove(element, onMove) {
    let io = null;
    let timeoutId;
    const root = getDocumentElement(element);
    function cleanup2() {
      var _io;
      clearTimeout(timeoutId);
      (_io = io) == null || _io.disconnect();
      io = null;
    }
    function refresh(skip, threshold) {
      if (skip === void 0) {
        skip = false;
      }
      if (threshold === void 0) {
        threshold = 1;
      }
      cleanup2();
      const elementRectForRootMargin = element.getBoundingClientRect();
      const {
        left,
        top,
        width,
        height
      } = elementRectForRootMargin;
      if (!skip) {
        onMove();
      }
      if (!width || !height) {
        return;
      }
      const insetTop = floor(top);
      const insetRight = floor(root.clientWidth - (left + width));
      const insetBottom = floor(root.clientHeight - (top + height));
      const insetLeft = floor(left);
      const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
      const options = {
        rootMargin,
        threshold: max(0, min(1, threshold)) || 1
      };
      let isFirstUpdate = true;
      function handleObserve(entries) {
        const ratio = entries[0].intersectionRatio;
        if (ratio !== threshold) {
          if (!isFirstUpdate) {
            return refresh();
          }
          if (!ratio) {
            timeoutId = setTimeout(() => {
              refresh(false, 1e-7);
            }, 1e3);
          } else {
            refresh(false, ratio);
          }
        }
        if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
          refresh();
        }
        isFirstUpdate = false;
      }
      try {
        io = new IntersectionObserver(handleObserve, {
          ...options,
          // Handle <iframe>s
          root: root.ownerDocument
        });
      } catch (_e) {
        io = new IntersectionObserver(handleObserve, options);
      }
      io.observe(element);
    }
    refresh(true);
    return cleanup2;
  }
  function autoUpdate(reference, floating, update, options) {
    if (options === void 0) {
      options = {};
    }
    const {
      ancestorScroll = true,
      ancestorResize = true,
      elementResize = typeof ResizeObserver === "function",
      layoutShift = typeof IntersectionObserver === "function",
      animationFrame = false
    } = options;
    const referenceEl = unwrapElement(reference);
    const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.addEventListener("scroll", update, {
        passive: true
      });
      ancestorResize && ancestor.addEventListener("resize", update);
    });
    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
    let reobserveFrame = -1;
    let resizeObserver = null;
    if (elementResize) {
      resizeObserver = new ResizeObserver((_ref) => {
        let [firstEntry] = _ref;
        if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
          resizeObserver.unobserve(floating);
          cancelAnimationFrame(reobserveFrame);
          reobserveFrame = requestAnimationFrame(() => {
            var _resizeObserver;
            (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
          });
        }
        update();
      });
      if (referenceEl && !animationFrame) {
        resizeObserver.observe(referenceEl);
      }
      resizeObserver.observe(floating);
    }
    let frameId;
    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
    if (animationFrame) {
      frameLoop();
    }
    function frameLoop() {
      const nextRefRect = getBoundingClientRect(reference);
      if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
        update();
      }
      prevRefRect = nextRefRect;
      frameId = requestAnimationFrame(frameLoop);
    }
    update();
    return () => {
      var _resizeObserver2;
      ancestors.forEach((ancestor) => {
        ancestorScroll && ancestor.removeEventListener("scroll", update);
        ancestorResize && ancestor.removeEventListener("resize", update);
      });
      cleanupIo == null || cleanupIo();
      (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
      resizeObserver = null;
      if (animationFrame) {
        cancelAnimationFrame(frameId);
      }
    };
  }
  var noOffsets, SCROLLBAR_MAX, absoluteOrFixed, getElementRects, platform, detectOverflow2, offset2, autoPlacement2, shift2, flip2, size2, hide2, arrow2, inline2, limitShift2, computePosition2;
  var init_floating_ui_dom = __esm({
    "node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs"() {
      init_floating_ui_core();
      init_floating_ui_utils();
      init_floating_ui_utils_dom();
      init_floating_ui_utils_dom();
      noOffsets = /* @__PURE__ */ createCoords(0);
      SCROLLBAR_MAX = 25;
      absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
      getElementRects = async function(data) {
        const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
        const getDimensionsFn = this.getDimensions;
        const floatingDimensions = await getDimensionsFn(data.floating);
        return {
          reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
          floating: {
            x: 0,
            y: 0,
            width: floatingDimensions.width,
            height: floatingDimensions.height
          }
        };
      };
      platform = {
        convertOffsetParentRelativeRectToViewportRelativeRect,
        getDocumentElement,
        getClippingRect,
        getOffsetParent,
        getElementRects,
        getClientRects,
        getDimensions,
        getScale,
        isElement,
        isRTL
      };
      detectOverflow2 = detectOverflow;
      offset2 = offset;
      autoPlacement2 = autoPlacement;
      shift2 = shift;
      flip2 = flip;
      size2 = size;
      hide2 = hide;
      arrow2 = arrow;
      inline2 = inline;
      limitShift2 = limitShift;
      computePosition2 = (reference, floating, options) => {
        const cache2 = /* @__PURE__ */ new Map();
        const mergedOptions = {
          platform,
          ...options
        };
        const platformWithCache = {
          ...mergedOptions.platform,
          _c: cache2
        };
        return computePosition(reference, floating, {
          ...mergedOptions,
          platform: platformWithCache
        });
      };
    }
  });

  // node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
  function deepEqual(a2, b2) {
    if (a2 === b2) {
      return true;
    }
    if (typeof a2 !== typeof b2) {
      return false;
    }
    if (typeof a2 === "function" && a2.toString() === b2.toString()) {
      return true;
    }
    let length2;
    let i2;
    let keys;
    if (a2 && b2 && typeof a2 === "object") {
      if (Array.isArray(a2)) {
        length2 = a2.length;
        if (length2 !== b2.length) return false;
        for (i2 = length2; i2-- !== 0; ) {
          if (!deepEqual(a2[i2], b2[i2])) {
            return false;
          }
        }
        return true;
      }
      keys = Object.keys(a2);
      length2 = keys.length;
      if (length2 !== Object.keys(b2).length) {
        return false;
      }
      for (i2 = length2; i2-- !== 0; ) {
        if (!{}.hasOwnProperty.call(b2, keys[i2])) {
          return false;
        }
      }
      for (i2 = length2; i2-- !== 0; ) {
        const key = keys[i2];
        if (key === "_owner" && a2.$$typeof) {
          continue;
        }
        if (!deepEqual(a2[key], b2[key])) {
          return false;
        }
      }
      return true;
    }
    return a2 !== a2 && b2 !== b2;
  }
  function getDPR(element) {
    if (typeof window === "undefined") {
      return 1;
    }
    const win = element.ownerDocument.defaultView || window;
    return win.devicePixelRatio || 1;
  }
  function roundByDPR(element, value) {
    const dpr = getDPR(element);
    return Math.round(value * dpr) / dpr;
  }
  function useLatestRef2(value) {
    const ref = React35.useRef(value);
    index2(() => {
      ref.current = value;
    });
    return ref;
  }
  function useFloating(options) {
    if (options === void 0) {
      options = {};
    }
    const {
      placement = "bottom",
      strategy = "absolute",
      middleware: middleware3 = [],
      platform: platform2,
      elements: {
        reference: externalReference,
        floating: externalFloating
      } = {},
      transform: transform2 = true,
      whileElementsMounted,
      open: open2
    } = options;
    const [data, setData] = React35.useState({
      x: 0,
      y: 0,
      strategy,
      placement,
      middlewareData: {},
      isPositioned: false
    });
    const [latestMiddleware, setLatestMiddleware] = React35.useState(middleware3);
    if (!deepEqual(latestMiddleware, middleware3)) {
      setLatestMiddleware(middleware3);
    }
    const [_reference, _setReference] = React35.useState(null);
    const [_floating, _setFloating] = React35.useState(null);
    const setReference = React35.useCallback((node2) => {
      if (node2 !== referenceRef.current) {
        referenceRef.current = node2;
        _setReference(node2);
      }
    }, []);
    const setFloating = React35.useCallback((node2) => {
      if (node2 !== floatingRef.current) {
        floatingRef.current = node2;
        _setFloating(node2);
      }
    }, []);
    const referenceEl = externalReference || _reference;
    const floatingEl = externalFloating || _floating;
    const referenceRef = React35.useRef(null);
    const floatingRef = React35.useRef(null);
    const dataRef = React35.useRef(data);
    const hasWhileElementsMounted = whileElementsMounted != null;
    const whileElementsMountedRef = useLatestRef2(whileElementsMounted);
    const platformRef = useLatestRef2(platform2);
    const openRef = useLatestRef2(open2);
    const update = React35.useCallback(() => {
      if (!referenceRef.current || !floatingRef.current) {
        return;
      }
      const config2 = {
        placement,
        strategy,
        middleware: latestMiddleware
      };
      if (platformRef.current) {
        config2.platform = platformRef.current;
      }
      computePosition2(referenceRef.current, floatingRef.current, config2).then((data2) => {
        const fullData = {
          ...data2,
          // The floating element's position may be recomputed while it's closed
          // but still mounted (such as when transitioning out). To ensure
          // `isPositioned` will be `false` initially on the next open, avoid
          // setting it to `true` when `open === false` (must be specified).
          isPositioned: openRef.current !== false
        };
        if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
          dataRef.current = fullData;
          ReactDOM.flushSync(() => {
            setData(fullData);
          });
        }
      });
    }, [latestMiddleware, placement, strategy, platformRef, openRef]);
    index2(() => {
      if (open2 === false && dataRef.current.isPositioned) {
        dataRef.current.isPositioned = false;
        setData((data2) => ({
          ...data2,
          isPositioned: false
        }));
      }
    }, [open2]);
    const isMountedRef = React35.useRef(false);
    index2(() => {
      isMountedRef.current = true;
      return () => {
        isMountedRef.current = false;
      };
    }, []);
    index2(() => {
      if (referenceEl) referenceRef.current = referenceEl;
      if (floatingEl) floatingRef.current = floatingEl;
      if (referenceEl && floatingEl) {
        if (whileElementsMountedRef.current) {
          return whileElementsMountedRef.current(referenceEl, floatingEl, update);
        }
        update();
      }
    }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
    const refs = React35.useMemo(() => ({
      reference: referenceRef,
      floating: floatingRef,
      setReference,
      setFloating
    }), [setReference, setFloating]);
    const elements = React35.useMemo(() => ({
      reference: referenceEl,
      floating: floatingEl
    }), [referenceEl, floatingEl]);
    const floatingStyles = React35.useMemo(() => {
      const initialStyles = {
        position: strategy,
        left: 0,
        top: 0
      };
      if (!elements.floating) {
        return initialStyles;
      }
      const x2 = roundByDPR(elements.floating, data.x);
      const y2 = roundByDPR(elements.floating, data.y);
      if (transform2) {
        return {
          ...initialStyles,
          transform: "translate(" + x2 + "px, " + y2 + "px)",
          ...getDPR(elements.floating) >= 1.5 && {
            willChange: "transform"
          }
        };
      }
      return {
        position: strategy,
        left: x2,
        top: y2
      };
    }, [strategy, transform2, elements.floating, data.x, data.y]);
    return React35.useMemo(() => ({
      ...data,
      update,
      refs,
      elements,
      floatingStyles
    }), [data, update, refs, elements, floatingStyles]);
  }
  var React35, import_react39, ReactDOM, isClient2, noop6, index2, arrow$1, offset3, shift3, limitShift3, flip3, size3, autoPlacement3, hide3, inline3, arrow3;
  var init_floating_ui_react_dom = __esm({
    "node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs"() {
      init_floating_ui_dom();
      init_floating_ui_dom();
      React35 = __toESM(require_react(), 1);
      import_react39 = __toESM(require_react(), 1);
      ReactDOM = __toESM(require_react_dom(), 1);
      isClient2 = typeof document !== "undefined";
      noop6 = function noop7() {
      };
      index2 = isClient2 ? import_react39.useLayoutEffect : noop6;
      arrow$1 = (options) => {
        function isRef(value) {
          return {}.hasOwnProperty.call(value, "current");
        }
        return {
          name: "arrow",
          options,
          fn(state) {
            const {
              element,
              padding: padding2
            } = typeof options === "function" ? options(state) : options;
            if (element && isRef(element)) {
              if (element.current != null) {
                return arrow2({
                  element: element.current,
                  padding: padding2
                }).fn(state);
              }
              return {};
            }
            if (element) {
              return arrow2({
                element,
                padding: padding2
              }).fn(state);
            }
            return {};
          }
        };
      };
      offset3 = (options, deps) => ({
        ...offset2(options),
        options: [options, deps]
      });
      shift3 = (options, deps) => ({
        ...shift2(options),
        options: [options, deps]
      });
      limitShift3 = (options, deps) => ({
        ...limitShift2(options),
        options: [options, deps]
      });
      flip3 = (options, deps) => ({
        ...flip2(options),
        options: [options, deps]
      });
      size3 = (options, deps) => ({
        ...size2(options),
        options: [options, deps]
      });
      autoPlacement3 = (options, deps) => ({
        ...autoPlacement2(options),
        options: [options, deps]
      });
      hide3 = (options, deps) => ({
        ...hide2(options),
        options: [options, deps]
      });
      inline3 = (options, deps) => ({
        ...inline2(options),
        options: [options, deps]
      });
      arrow3 = (options, deps) => ({
        ...arrow$1(options),
        options: [options, deps]
      });
    }
  });

  // node_modules/@floating-ui/react/dist/floating-ui.react.esm.js
  var floating_ui_react_esm_exports = {};
  __export(floating_ui_react_esm_exports, {
    Composite: () => Composite,
    CompositeItem: () => CompositeItem,
    FloatingArrow: () => FloatingArrow,
    FloatingDelayGroup: () => FloatingDelayGroup,
    FloatingFocusManager: () => FloatingFocusManager,
    FloatingList: () => FloatingList,
    FloatingNode: () => FloatingNode,
    FloatingOverlay: () => FloatingOverlay,
    FloatingPortal: () => FloatingPortal,
    FloatingTree: () => FloatingTree,
    NextFloatingDelayGroup: () => NextFloatingDelayGroup,
    arrow: () => arrow3,
    autoPlacement: () => autoPlacement3,
    autoUpdate: () => autoUpdate,
    computePosition: () => computePosition2,
    detectOverflow: () => detectOverflow2,
    flip: () => flip3,
    getOverflowAncestors: () => getOverflowAncestors,
    hide: () => hide3,
    inline: () => inline3,
    inner: () => inner,
    limitShift: () => limitShift3,
    offset: () => offset3,
    platform: () => platform,
    safePolygon: () => safePolygon,
    shift: () => shift3,
    size: () => size3,
    useClick: () => useClick,
    useClientPoint: () => useClientPoint,
    useDelayGroup: () => useDelayGroup,
    useDelayGroupContext: () => useDelayGroupContext,
    useDismiss: () => useDismiss,
    useFloating: () => useFloating2,
    useFloatingNodeId: () => useFloatingNodeId,
    useFloatingParentNodeId: () => useFloatingParentNodeId,
    useFloatingPortalNode: () => useFloatingPortalNode,
    useFloatingRootContext: () => useFloatingRootContext,
    useFloatingTree: () => useFloatingTree,
    useFocus: () => useFocus,
    useHover: () => useHover,
    useId: () => useId,
    useInnerOffset: () => useInnerOffset,
    useInteractions: () => useInteractions,
    useListItem: () => useListItem,
    useListNavigation: () => useListNavigation,
    useMergeRefs: () => useMergeRefs,
    useNextDelayGroup: () => useNextDelayGroup,
    useRole: () => useRole,
    useTransitionStatus: () => useTransitionStatus,
    useTransitionStyles: () => useTransitionStyles,
    useTypeahead: () => useTypeahead
  });
  function useMergeRefs(refs) {
    const cleanupRef = React36.useRef(void 0);
    const refEffect = React36.useCallback((instance) => {
      const cleanups = refs.map((ref) => {
        if (ref == null) {
          return;
        }
        if (typeof ref === "function") {
          const refCallback = ref;
          const refCleanup = refCallback(instance);
          return typeof refCleanup === "function" ? refCleanup : () => {
            refCallback(null);
          };
        }
        ref.current = instance;
        return () => {
          ref.current = null;
        };
      });
      return () => {
        cleanups.forEach((refCleanup) => refCleanup == null ? void 0 : refCleanup());
      };
    }, refs);
    return React36.useMemo(() => {
      if (refs.every((ref) => ref == null)) {
        return null;
      }
      return (value) => {
        if (cleanupRef.current) {
          cleanupRef.current();
          cleanupRef.current = void 0;
        }
        if (value != null) {
          cleanupRef.current = refEffect(value);
        }
      };
    }, refs);
  }
  function sortByDocumentPosition(a2, b2) {
    const position2 = a2.compareDocumentPosition(b2);
    if (position2 & Node.DOCUMENT_POSITION_FOLLOWING || position2 & Node.DOCUMENT_POSITION_CONTAINED_BY) {
      return -1;
    }
    if (position2 & Node.DOCUMENT_POSITION_PRECEDING || position2 & Node.DOCUMENT_POSITION_CONTAINS) {
      return 1;
    }
    return 0;
  }
  function FloatingList(props) {
    const {
      children,
      elementsRef,
      labelsRef
    } = props;
    const [nodes, setNodes] = React36.useState(() => /* @__PURE__ */ new Set());
    const register = React36.useCallback((node2) => {
      setNodes((prevSet) => new Set(prevSet).add(node2));
    }, []);
    const unregister = React36.useCallback((node2) => {
      setNodes((prevSet) => {
        const set = new Set(prevSet);
        set.delete(node2);
        return set;
      });
    }, []);
    const map = React36.useMemo(() => {
      const newMap = /* @__PURE__ */ new Map();
      const sortedNodes = Array.from(nodes.keys()).sort(sortByDocumentPosition);
      sortedNodes.forEach((node2, index3) => {
        newMap.set(node2, index3);
      });
      return newMap;
    }, [nodes]);
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(FloatingListContext.Provider, {
      value: React36.useMemo(() => ({
        register,
        unregister,
        map,
        elementsRef,
        labelsRef
      }), [register, unregister, map, elementsRef, labelsRef]),
      children
    });
  }
  function useListItem(props) {
    if (props === void 0) {
      props = {};
    }
    const {
      label
    } = props;
    const {
      register,
      unregister,
      map,
      elementsRef,
      labelsRef
    } = React36.useContext(FloatingListContext);
    const [index3, setIndex] = React36.useState(null);
    const componentRef = React36.useRef(null);
    const ref = React36.useCallback((node2) => {
      componentRef.current = node2;
      if (index3 !== null) {
        elementsRef.current[index3] = node2;
        if (labelsRef) {
          var _node$textContent;
          const isLabelDefined = label !== void 0;
          labelsRef.current[index3] = isLabelDefined ? label : (_node$textContent = node2 == null ? void 0 : node2.textContent) != null ? _node$textContent : null;
        }
      }
    }, [index3, elementsRef, labelsRef, label]);
    index(() => {
      const node2 = componentRef.current;
      if (node2) {
        register(node2);
        return () => {
          unregister(node2);
        };
      }
    }, [register, unregister]);
    index(() => {
      const index4 = componentRef.current ? map.get(componentRef.current) : null;
      if (index4 != null) {
        setIndex(index4);
      }
    }, [map]);
    return React36.useMemo(() => ({
      ref,
      index: index3 == null ? -1 : index3
    }), [index3, ref]);
  }
  function renderJsx(render2, computedProps) {
    if (typeof render2 === "function") {
      return render2(computedProps);
    }
    if (render2) {
      return /* @__PURE__ */ React36.cloneElement(render2, computedProps);
    }
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("div", {
      ...computedProps
    });
  }
  function useFloatingId() {
    const [id, setId] = React36.useState(() => serverHandoffComplete ? genId() : void 0);
    index(() => {
      if (id == null) {
        setId(genId());
      }
    }, []);
    React36.useEffect(() => {
      serverHandoffComplete = true;
    }, []);
    return id;
  }
  function warn() {
    var _devMessageSet;
    for (var _len = arguments.length, messages2 = new Array(_len), _key = 0; _key < _len; _key++) {
      messages2[_key] = arguments[_key];
    }
    const message = "Floating UI: " + messages2.join(" ");
    if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {
      var _devMessageSet2;
      (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message);
      console.warn(message);
    }
  }
  function error() {
    var _devMessageSet3;
    for (var _len2 = arguments.length, messages2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      messages2[_key2] = arguments[_key2];
    }
    const message = "Floating UI: " + messages2.join(" ");
    if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {
      var _devMessageSet4;
      (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message);
      console.error(message);
    }
  }
  function createEventEmitter() {
    const map = /* @__PURE__ */ new Map();
    return {
      emit(event, data) {
        var _map$get;
        (_map$get = map.get(event)) == null || _map$get.forEach((listener) => listener(data));
      },
      on(event, listener) {
        if (!map.has(event)) {
          map.set(event, /* @__PURE__ */ new Set());
        }
        map.get(event).add(listener);
      },
      off(event, listener) {
        var _map$get2;
        (_map$get2 = map.get(event)) == null || _map$get2.delete(listener);
      }
    };
  }
  function useFloatingNodeId(customParentId) {
    const id = useId();
    const tree = useFloatingTree();
    const reactParentId = useFloatingParentNodeId();
    const parentId = customParentId || reactParentId;
    index(() => {
      if (!id) return;
      const node2 = {
        id,
        parentId
      };
      tree == null || tree.addNode(node2);
      return () => {
        tree == null || tree.removeNode(node2);
      };
    }, [tree, id, parentId]);
    return id;
  }
  function FloatingNode(props) {
    const {
      children,
      id
    } = props;
    const parentId = useFloatingParentNodeId();
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(FloatingNodeContext.Provider, {
      value: React36.useMemo(() => ({
        id,
        parentId
      }), [id, parentId]),
      children
    });
  }
  function FloatingTree(props) {
    const {
      children
    } = props;
    const nodesRef = React36.useRef([]);
    const addNode = React36.useCallback((node2) => {
      nodesRef.current = [...nodesRef.current, node2];
    }, []);
    const removeNode = React36.useCallback((node2) => {
      nodesRef.current = nodesRef.current.filter((n2) => n2 !== node2);
    }, []);
    const [events] = React36.useState(() => createEventEmitter());
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(FloatingTreeContext.Provider, {
      value: React36.useMemo(() => ({
        nodesRef,
        addNode,
        removeNode,
        events
      }), [addNode, removeNode, events]),
      children
    });
  }
  function createAttribute(name) {
    return "data-floating-ui-" + name;
  }
  function clearTimeoutIfSet(timeoutRef) {
    if (timeoutRef.current !== -1) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = -1;
    }
  }
  function getDelay(value, prop, pointerType) {
    if (pointerType && !isMouseLikePointerType(pointerType)) {
      return 0;
    }
    if (typeof value === "number") {
      return value;
    }
    if (typeof value === "function") {
      const result = value();
      if (typeof result === "number") {
        return result;
      }
      return result == null ? void 0 : result[prop];
    }
    return value == null ? void 0 : value[prop];
  }
  function getRestMs(value) {
    if (typeof value === "function") {
      return value();
    }
    return value;
  }
  function useHover(context2, props) {
    if (props === void 0) {
      props = {};
    }
    const {
      open: open2,
      onOpenChange,
      dataRef,
      events,
      elements
    } = context2;
    const {
      enabled = true,
      delay = 0,
      handleClose = null,
      mouseOnly = false,
      restMs = 0,
      move = true
    } = props;
    const tree = useFloatingTree();
    const parentId = useFloatingParentNodeId();
    const handleCloseRef = useLatestRef(handleClose);
    const delayRef = useLatestRef(delay);
    const openRef = useLatestRef(open2);
    const restMsRef = useLatestRef(restMs);
    const pointerTypeRef = React36.useRef();
    const timeoutRef = React36.useRef(-1);
    const handlerRef = React36.useRef();
    const restTimeoutRef = React36.useRef(-1);
    const blockMouseMoveRef = React36.useRef(true);
    const performedPointerEventsMutationRef = React36.useRef(false);
    const unbindMouseMoveRef = React36.useRef(() => {
    });
    const restTimeoutPendingRef = React36.useRef(false);
    const isHoverOpen = useEffectEvent(() => {
      var _dataRef$current$open;
      const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;
      return (type == null ? void 0 : type.includes("mouse")) && type !== "mousedown";
    });
    React36.useEffect(() => {
      if (!enabled) return;
      function onOpenChange2(_ref) {
        let {
          open: open3
        } = _ref;
        if (!open3) {
          clearTimeoutIfSet(timeoutRef);
          clearTimeoutIfSet(restTimeoutRef);
          blockMouseMoveRef.current = true;
          restTimeoutPendingRef.current = false;
        }
      }
      events.on("openchange", onOpenChange2);
      return () => {
        events.off("openchange", onOpenChange2);
      };
    }, [enabled, events]);
    React36.useEffect(() => {
      if (!enabled) return;
      if (!handleCloseRef.current) return;
      if (!open2) return;
      function onLeave(event) {
        if (isHoverOpen()) {
          onOpenChange(false, event, "hover");
        }
      }
      const html = getDocument(elements.floating).documentElement;
      html.addEventListener("mouseleave", onLeave);
      return () => {
        html.removeEventListener("mouseleave", onLeave);
      };
    }, [elements.floating, open2, onOpenChange, enabled, handleCloseRef, isHoverOpen]);
    const closeWithDelay = React36.useCallback(function(event, runElseBranch, reason) {
      if (runElseBranch === void 0) {
        runElseBranch = true;
      }
      if (reason === void 0) {
        reason = "hover";
      }
      const closeDelay = getDelay(delayRef.current, "close", pointerTypeRef.current);
      if (closeDelay && !handlerRef.current) {
        clearTimeoutIfSet(timeoutRef);
        timeoutRef.current = window.setTimeout(() => onOpenChange(false, event, reason), closeDelay);
      } else if (runElseBranch) {
        clearTimeoutIfSet(timeoutRef);
        onOpenChange(false, event, reason);
      }
    }, [delayRef, onOpenChange]);
    const cleanupMouseMoveHandler = useEffectEvent(() => {
      unbindMouseMoveRef.current();
      handlerRef.current = void 0;
    });
    const clearPointerEvents = useEffectEvent(() => {
      if (performedPointerEventsMutationRef.current) {
        const body = getDocument(elements.floating).body;
        body.style.pointerEvents = "";
        body.removeAttribute(safePolygonIdentifier);
        performedPointerEventsMutationRef.current = false;
      }
    });
    const isClickLikeOpenEvent = useEffectEvent(() => {
      return dataRef.current.openEvent ? ["click", "mousedown"].includes(dataRef.current.openEvent.type) : false;
    });
    React36.useEffect(() => {
      if (!enabled) return;
      function onReferenceMouseEnter(event) {
        clearTimeoutIfSet(timeoutRef);
        blockMouseMoveRef.current = false;
        if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || getRestMs(restMsRef.current) > 0 && !getDelay(delayRef.current, "open")) {
          return;
        }
        const openDelay = getDelay(delayRef.current, "open", pointerTypeRef.current);
        if (openDelay) {
          timeoutRef.current = window.setTimeout(() => {
            if (!openRef.current) {
              onOpenChange(true, event, "hover");
            }
          }, openDelay);
        } else if (!open2) {
          onOpenChange(true, event, "hover");
        }
      }
      function onReferenceMouseLeave(event) {
        if (isClickLikeOpenEvent()) {
          clearPointerEvents();
          return;
        }
        unbindMouseMoveRef.current();
        const doc = getDocument(elements.floating);
        clearTimeoutIfSet(restTimeoutRef);
        restTimeoutPendingRef.current = false;
        if (handleCloseRef.current && dataRef.current.floatingContext) {
          if (!open2) {
            clearTimeoutIfSet(timeoutRef);
          }
          handlerRef.current = handleCloseRef.current({
            ...dataRef.current.floatingContext,
            tree,
            x: event.clientX,
            y: event.clientY,
            onClose() {
              clearPointerEvents();
              cleanupMouseMoveHandler();
              if (!isClickLikeOpenEvent()) {
                closeWithDelay(event, true, "safe-polygon");
              }
            }
          });
          const handler = handlerRef.current;
          doc.addEventListener("mousemove", handler);
          unbindMouseMoveRef.current = () => {
            doc.removeEventListener("mousemove", handler);
          };
          return;
        }
        const shouldClose = pointerTypeRef.current === "touch" ? !contains(elements.floating, event.relatedTarget) : true;
        if (shouldClose) {
          closeWithDelay(event);
        }
      }
      function onScrollMouseLeave(event) {
        if (isClickLikeOpenEvent()) return;
        if (!dataRef.current.floatingContext) return;
        handleCloseRef.current == null || handleCloseRef.current({
          ...dataRef.current.floatingContext,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents();
            cleanupMouseMoveHandler();
            if (!isClickLikeOpenEvent()) {
              closeWithDelay(event);
            }
          }
        })(event);
      }
      function onFloatingMouseEnter() {
        clearTimeoutIfSet(timeoutRef);
      }
      function onFloatingMouseLeave(event) {
        if (!isClickLikeOpenEvent()) {
          closeWithDelay(event, false);
        }
      }
      if (isElement(elements.domReference)) {
        const reference2 = elements.domReference;
        const floating = elements.floating;
        if (open2) {
          reference2.addEventListener("mouseleave", onScrollMouseLeave);
        }
        if (move) {
          reference2.addEventListener("mousemove", onReferenceMouseEnter, {
            once: true
          });
        }
        reference2.addEventListener("mouseenter", onReferenceMouseEnter);
        reference2.addEventListener("mouseleave", onReferenceMouseLeave);
        if (floating) {
          floating.addEventListener("mouseleave", onScrollMouseLeave);
          floating.addEventListener("mouseenter", onFloatingMouseEnter);
          floating.addEventListener("mouseleave", onFloatingMouseLeave);
        }
        return () => {
          if (open2) {
            reference2.removeEventListener("mouseleave", onScrollMouseLeave);
          }
          if (move) {
            reference2.removeEventListener("mousemove", onReferenceMouseEnter);
          }
          reference2.removeEventListener("mouseenter", onReferenceMouseEnter);
          reference2.removeEventListener("mouseleave", onReferenceMouseLeave);
          if (floating) {
            floating.removeEventListener("mouseleave", onScrollMouseLeave);
            floating.removeEventListener("mouseenter", onFloatingMouseEnter);
            floating.removeEventListener("mouseleave", onFloatingMouseLeave);
          }
        };
      }
    }, [elements, enabled, context2, mouseOnly, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open2, openRef, tree, delayRef, handleCloseRef, dataRef, isClickLikeOpenEvent, restMsRef]);
    index(() => {
      var _handleCloseRef$curre;
      if (!enabled) return;
      if (open2 && (_handleCloseRef$curre = handleCloseRef.current) != null && (_handleCloseRef$curre = _handleCloseRef$curre.__options) != null && _handleCloseRef$curre.blockPointerEvents && isHoverOpen()) {
        performedPointerEventsMutationRef.current = true;
        const floatingEl = elements.floating;
        if (isElement(elements.domReference) && floatingEl) {
          var _tree$nodesRef$curren;
          const body = getDocument(elements.floating).body;
          body.setAttribute(safePolygonIdentifier, "");
          const ref = elements.domReference;
          const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node2) => node2.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;
          if (parentFloating) {
            parentFloating.style.pointerEvents = "";
          }
          body.style.pointerEvents = "none";
          ref.style.pointerEvents = "auto";
          floatingEl.style.pointerEvents = "auto";
          return () => {
            body.style.pointerEvents = "";
            ref.style.pointerEvents = "";
            floatingEl.style.pointerEvents = "";
          };
        }
      }
    }, [enabled, open2, parentId, elements, tree, handleCloseRef, isHoverOpen]);
    index(() => {
      if (!open2) {
        pointerTypeRef.current = void 0;
        restTimeoutPendingRef.current = false;
        cleanupMouseMoveHandler();
        clearPointerEvents();
      }
    }, [open2, cleanupMouseMoveHandler, clearPointerEvents]);
    React36.useEffect(() => {
      return () => {
        cleanupMouseMoveHandler();
        clearTimeoutIfSet(timeoutRef);
        clearTimeoutIfSet(restTimeoutRef);
        clearPointerEvents();
      };
    }, [enabled, elements.domReference, cleanupMouseMoveHandler, clearPointerEvents]);
    const reference = React36.useMemo(() => {
      function setPointerRef(event) {
        pointerTypeRef.current = event.pointerType;
      }
      return {
        onPointerDown: setPointerRef,
        onPointerEnter: setPointerRef,
        onMouseMove(event) {
          const {
            nativeEvent
          } = event;
          function handleMouseMove() {
            if (!blockMouseMoveRef.current && !openRef.current) {
              onOpenChange(true, nativeEvent, "hover");
            }
          }
          if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current)) {
            return;
          }
          if (open2 || getRestMs(restMsRef.current) === 0) {
            return;
          }
          if (restTimeoutPendingRef.current && event.movementX ** 2 + event.movementY ** 2 < 2) {
            return;
          }
          clearTimeoutIfSet(restTimeoutRef);
          if (pointerTypeRef.current === "touch") {
            handleMouseMove();
          } else {
            restTimeoutPendingRef.current = true;
            restTimeoutRef.current = window.setTimeout(handleMouseMove, getRestMs(restMsRef.current));
          }
        }
      };
    }, [mouseOnly, onOpenChange, open2, openRef, restMsRef]);
    return React36.useMemo(() => enabled ? {
      reference
    } : {}, [enabled, reference]);
  }
  function FloatingDelayGroup(props) {
    const {
      children,
      delay,
      timeoutMs = 0
    } = props;
    const [state, setState] = React36.useReducer((prev2, next2) => ({
      ...prev2,
      ...next2
    }), {
      delay,
      timeoutMs,
      initialDelay: delay,
      currentId: null,
      isInstantPhase: false
    });
    const initialCurrentIdRef = React36.useRef(null);
    const setCurrentId = React36.useCallback((currentId) => {
      setState({
        currentId
      });
    }, []);
    index(() => {
      if (state.currentId) {
        if (initialCurrentIdRef.current === null) {
          initialCurrentIdRef.current = state.currentId;
        } else if (!state.isInstantPhase) {
          setState({
            isInstantPhase: true
          });
        }
      } else {
        if (state.isInstantPhase) {
          setState({
            isInstantPhase: false
          });
        }
        initialCurrentIdRef.current = null;
      }
    }, [state.currentId, state.isInstantPhase]);
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(FloatingDelayGroupContext.Provider, {
      value: React36.useMemo(() => ({
        ...state,
        setState,
        setCurrentId
      }), [state, setCurrentId]),
      children
    });
  }
  function useDelayGroup(context2, options) {
    if (options === void 0) {
      options = {};
    }
    const {
      open: open2,
      onOpenChange,
      floatingId
    } = context2;
    const {
      id: optionId,
      enabled = true
    } = options;
    const id = optionId != null ? optionId : floatingId;
    const groupContext = useDelayGroupContext();
    const {
      currentId,
      setCurrentId,
      initialDelay,
      setState,
      timeoutMs
    } = groupContext;
    index(() => {
      if (!enabled) return;
      if (!currentId) return;
      setState({
        delay: {
          open: 1,
          close: getDelay(initialDelay, "close")
        }
      });
      if (currentId !== id) {
        onOpenChange(false);
      }
    }, [enabled, id, onOpenChange, setState, currentId, initialDelay]);
    index(() => {
      function unset() {
        onOpenChange(false);
        setState({
          delay: initialDelay,
          currentId: null
        });
      }
      if (!enabled) return;
      if (!currentId) return;
      if (!open2 && currentId === id) {
        if (timeoutMs) {
          const timeout3 = window.setTimeout(unset, timeoutMs);
          return () => {
            clearTimeout(timeout3);
          };
        }
        unset();
      }
    }, [enabled, open2, setState, currentId, id, onOpenChange, initialDelay, timeoutMs]);
    index(() => {
      if (!enabled) return;
      if (setCurrentId === NOOP || !open2) return;
      setCurrentId(id);
    }, [enabled, open2, setCurrentId, id]);
    return groupContext;
  }
  function NextFloatingDelayGroup(props) {
    const {
      children,
      delay,
      timeoutMs = 0
    } = props;
    const delayRef = React36.useRef(delay);
    const initialDelayRef = React36.useRef(delay);
    const currentIdRef = React36.useRef(null);
    const currentContextRef = React36.useRef(null);
    const timeoutIdRef = React36.useRef(-1);
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(NextFloatingDelayGroupContext.Provider, {
      value: React36.useMemo(() => ({
        hasProvider: true,
        delayRef,
        initialDelayRef,
        currentIdRef,
        timeoutMs,
        currentContextRef,
        timeoutIdRef
      }), [timeoutMs]),
      children
    });
  }
  function useNextDelayGroup(context2, options) {
    if (options === void 0) {
      options = {};
    }
    const {
      open: open2,
      onOpenChange,
      floatingId
    } = context2;
    const {
      enabled = true
    } = options;
    const groupContext = React36.useContext(NextFloatingDelayGroupContext);
    const {
      currentIdRef,
      delayRef,
      timeoutMs,
      initialDelayRef,
      currentContextRef,
      hasProvider,
      timeoutIdRef
    } = groupContext;
    const [isInstantPhase, setIsInstantPhase] = React36.useState(false);
    index(() => {
      function unset() {
        var _currentContextRef$cu;
        setIsInstantPhase(false);
        (_currentContextRef$cu = currentContextRef.current) == null || _currentContextRef$cu.setIsInstantPhase(false);
        currentIdRef.current = null;
        currentContextRef.current = null;
        delayRef.current = initialDelayRef.current;
      }
      if (!enabled) return;
      if (!currentIdRef.current) return;
      if (!open2 && currentIdRef.current === floatingId) {
        setIsInstantPhase(false);
        if (timeoutMs) {
          timeoutIdRef.current = window.setTimeout(unset, timeoutMs);
          return () => {
            clearTimeout(timeoutIdRef.current);
          };
        }
        unset();
      }
    }, [enabled, open2, floatingId, currentIdRef, delayRef, timeoutMs, initialDelayRef, currentContextRef, timeoutIdRef]);
    index(() => {
      if (!enabled) return;
      if (!open2) return;
      const prevContext = currentContextRef.current;
      const prevId = currentIdRef.current;
      currentContextRef.current = {
        onOpenChange,
        setIsInstantPhase
      };
      currentIdRef.current = floatingId;
      delayRef.current = {
        open: 0,
        close: getDelay(initialDelayRef.current, "close")
      };
      if (prevId !== null && prevId !== floatingId) {
        clearTimeoutIfSet(timeoutIdRef);
        setIsInstantPhase(true);
        prevContext == null || prevContext.setIsInstantPhase(true);
        prevContext == null || prevContext.onOpenChange(false);
      } else {
        setIsInstantPhase(false);
        prevContext == null || prevContext.setIsInstantPhase(false);
      }
    }, [enabled, open2, floatingId, onOpenChange, currentIdRef, delayRef, timeoutMs, initialDelayRef, currentContextRef, timeoutIdRef]);
    index(() => {
      return () => {
        currentContextRef.current = null;
      };
    }, [currentContextRef]);
    return React36.useMemo(() => ({
      hasProvider,
      delayRef,
      isInstantPhase
    }), [hasProvider, delayRef, isInstantPhase]);
  }
  function enqueueFocus(el, options) {
    if (options === void 0) {
      options = {};
    }
    const {
      preventScroll = false,
      cancelPrevious = true,
      sync = false
    } = options;
    cancelPrevious && cancelAnimationFrame(rafId);
    const exec = () => el == null ? void 0 : el.focus({
      preventScroll
    });
    if (sync) {
      exec();
    } else {
      rafId = requestAnimationFrame(exec);
    }
  }
  function contains2(parent, child) {
    if (!parent || !child) {
      return false;
    }
    const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
    if (parent.contains(child)) {
      return true;
    }
    if (rootNode && isShadowRoot(rootNode)) {
      let next2 = child;
      while (next2) {
        if (parent === next2) {
          return true;
        }
        next2 = next2.parentNode || next2.host;
      }
    }
    return false;
  }
  function getTarget2(event) {
    if ("composedPath" in event) {
      return event.composedPath()[0];
    }
    return event.target;
  }
  function getDocument2(node2) {
    return (node2 == null ? void 0 : node2.ownerDocument) || document;
  }
  function getCounterMap(control) {
    if (control === "inert") return counters.inert;
    if (control === "aria-hidden") return counters["aria-hidden"];
    return counters.none;
  }
  function applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {
    const markerName = "data-floating-ui-inert";
    const controlAttribute = inert ? "inert" : ariaHidden ? "aria-hidden" : null;
    const avoidElements = correctElements(body, uncorrectedAvoidElements);
    const elementsToKeep = /* @__PURE__ */ new Set();
    const elementsToStop = new Set(avoidElements);
    const hiddenElements = [];
    if (!markerMap[markerName]) {
      markerMap[markerName] = /* @__PURE__ */ new WeakMap();
    }
    const markerCounter = markerMap[markerName];
    avoidElements.forEach(keep);
    deep(body);
    elementsToKeep.clear();
    function keep(el) {
      if (!el || elementsToKeep.has(el)) {
        return;
      }
      elementsToKeep.add(el);
      el.parentNode && keep(el.parentNode);
    }
    function deep(parent) {
      if (!parent || elementsToStop.has(parent)) {
        return;
      }
      [].forEach.call(parent.children, (node2) => {
        if (getNodeName(node2) === "script") return;
        if (elementsToKeep.has(node2)) {
          deep(node2);
        } else {
          const attr2 = controlAttribute ? node2.getAttribute(controlAttribute) : null;
          const alreadyHidden = attr2 !== null && attr2 !== "false";
          const counterMap = getCounterMap(controlAttribute);
          const counterValue = (counterMap.get(node2) || 0) + 1;
          const markerValue = (markerCounter.get(node2) || 0) + 1;
          counterMap.set(node2, counterValue);
          markerCounter.set(node2, markerValue);
          hiddenElements.push(node2);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledElementsSet.add(node2);
          }
          if (markerValue === 1) {
            node2.setAttribute(markerName, "");
          }
          if (!alreadyHidden && controlAttribute) {
            node2.setAttribute(controlAttribute, controlAttribute === "inert" ? "" : "true");
          }
        }
      });
    }
    lockCount$1++;
    return () => {
      hiddenElements.forEach((element) => {
        const counterMap = getCounterMap(controlAttribute);
        const currentCounterValue = counterMap.get(element) || 0;
        const counterValue = currentCounterValue - 1;
        const markerValue = (markerCounter.get(element) || 0) - 1;
        counterMap.set(element, counterValue);
        markerCounter.set(element, markerValue);
        if (!counterValue) {
          if (!uncontrolledElementsSet.has(element) && controlAttribute) {
            element.removeAttribute(controlAttribute);
          }
          uncontrolledElementsSet.delete(element);
        }
        if (!markerValue) {
          element.removeAttribute(markerName);
        }
      });
      lockCount$1--;
      if (!lockCount$1) {
        counters.inert = /* @__PURE__ */ new WeakMap();
        counters["aria-hidden"] = /* @__PURE__ */ new WeakMap();
        counters.none = /* @__PURE__ */ new WeakMap();
        uncontrolledElementsSet = /* @__PURE__ */ new WeakSet();
        markerMap = {};
      }
    };
  }
  function markOthers(avoidElements, ariaHidden, inert) {
    if (ariaHidden === void 0) {
      ariaHidden = false;
    }
    if (inert === void 0) {
      inert = false;
    }
    const body = getDocument2(avoidElements[0]).body;
    return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll('[aria-live],[role="status"],output'))), body, ariaHidden, inert);
  }
  function useFloatingPortalNode(props) {
    if (props === void 0) {
      props = {};
    }
    const {
      id,
      root
    } = props;
    const uniqueId = useId();
    const portalContext = usePortalContext();
    const [portalNode, setPortalNode] = React36.useState(null);
    const portalNodeRef = React36.useRef(null);
    index(() => {
      return () => {
        portalNode == null || portalNode.remove();
        queueMicrotask(() => {
          portalNodeRef.current = null;
        });
      };
    }, [portalNode]);
    index(() => {
      if (!uniqueId) return;
      if (portalNodeRef.current) return;
      const existingIdRoot = id ? document.getElementById(id) : null;
      if (!existingIdRoot) return;
      const subRoot = document.createElement("div");
      subRoot.id = uniqueId;
      subRoot.setAttribute(attr, "");
      existingIdRoot.appendChild(subRoot);
      portalNodeRef.current = subRoot;
      setPortalNode(subRoot);
    }, [id, uniqueId]);
    index(() => {
      if (root === null) return;
      if (!uniqueId) return;
      if (portalNodeRef.current) return;
      let container = root || (portalContext == null ? void 0 : portalContext.portalNode);
      if (container && !isNode(container)) container = container.current;
      container = container || document.body;
      let idWrapper = null;
      if (id) {
        idWrapper = document.createElement("div");
        idWrapper.id = id;
        container.appendChild(idWrapper);
      }
      const subRoot = document.createElement("div");
      subRoot.id = uniqueId;
      subRoot.setAttribute(attr, "");
      container = idWrapper || container;
      container.appendChild(subRoot);
      portalNodeRef.current = subRoot;
      setPortalNode(subRoot);
    }, [id, root, uniqueId, portalContext]);
    return portalNode;
  }
  function FloatingPortal(props) {
    const {
      children,
      id,
      root,
      preserveTabOrder = true
    } = props;
    const portalNode = useFloatingPortalNode({
      id,
      root
    });
    const [focusManagerState, setFocusManagerState] = React36.useState(null);
    const beforeOutsideRef = React36.useRef(null);
    const afterOutsideRef = React36.useRef(null);
    const beforeInsideRef = React36.useRef(null);
    const afterInsideRef = React36.useRef(null);
    const modal = focusManagerState == null ? void 0 : focusManagerState.modal;
    const open2 = focusManagerState == null ? void 0 : focusManagerState.open;
    const shouldRenderGuards = (
      // The FocusManager and therefore floating element are currently open/
      // rendered.
      !!focusManagerState && // Guards are only for non-modal focus management.
      !focusManagerState.modal && // Don't render if unmount is transitioning.
      focusManagerState.open && preserveTabOrder && !!(root || portalNode)
    );
    React36.useEffect(() => {
      if (!portalNode || !preserveTabOrder || modal) {
        return;
      }
      function onFocus(event) {
        if (portalNode && isOutsideEvent(event)) {
          const focusing = event.type === "focusin";
          const manageFocus = focusing ? enableFocusInside : disableFocusInside;
          manageFocus(portalNode);
        }
      }
      portalNode.addEventListener("focusin", onFocus, true);
      portalNode.addEventListener("focusout", onFocus, true);
      return () => {
        portalNode.removeEventListener("focusin", onFocus, true);
        portalNode.removeEventListener("focusout", onFocus, true);
      };
    }, [portalNode, preserveTabOrder, modal]);
    React36.useEffect(() => {
      if (!portalNode) return;
      if (open2) return;
      enableFocusInside(portalNode);
    }, [open2, portalNode]);
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)(PortalContext.Provider, {
      value: React36.useMemo(() => ({
        preserveTabOrder,
        beforeOutsideRef,
        afterOutsideRef,
        beforeInsideRef,
        afterInsideRef,
        portalNode,
        setFocusManagerState
      }), [preserveTabOrder, portalNode]),
      children: [shouldRenderGuards && portalNode && /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(FocusGuard, {
        "data-type": "outside",
        ref: beforeOutsideRef,
        onFocus: (event) => {
          if (isOutsideEvent(event, portalNode)) {
            var _beforeInsideRef$curr;
            (_beforeInsideRef$curr = beforeInsideRef.current) == null || _beforeInsideRef$curr.focus();
          } else {
            const domReference = focusManagerState ? focusManagerState.domReference : null;
            const prevTabbable = getPreviousTabbable(domReference);
            prevTabbable == null || prevTabbable.focus();
          }
        }
      }), shouldRenderGuards && portalNode && /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("span", {
        "aria-owns": portalNode.id,
        style: HIDDEN_STYLES
      }), portalNode && /* @__PURE__ */ ReactDOM2.createPortal(children, portalNode), shouldRenderGuards && portalNode && /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(FocusGuard, {
        "data-type": "outside",
        ref: afterOutsideRef,
        onFocus: (event) => {
          if (isOutsideEvent(event, portalNode)) {
            var _afterInsideRef$curre;
            (_afterInsideRef$curre = afterInsideRef.current) == null || _afterInsideRef$curre.focus();
          } else {
            const domReference = focusManagerState ? focusManagerState.domReference : null;
            const nextTabbable = getNextTabbable(domReference);
            nextTabbable == null || nextTabbable.focus();
            (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent, "focus-out"));
          }
        }
      })]
    });
  }
  function useLiteMergeRefs(refs) {
    return React36.useMemo(() => {
      return (value) => {
        refs.forEach((ref) => {
          if (ref) {
            ref.current = value;
          }
        });
      };
    }, refs);
  }
  function clearDisconnectedPreviouslyFocusedElements() {
    previouslyFocusedElements = previouslyFocusedElements.filter((el) => el.isConnected);
  }
  function addPreviouslyFocusedElement(element) {
    clearDisconnectedPreviouslyFocusedElements();
    if (element && getNodeName(element) !== "body") {
      previouslyFocusedElements.push(element);
      if (previouslyFocusedElements.length > LIST_LIMIT) {
        previouslyFocusedElements = previouslyFocusedElements.slice(-20);
      }
    }
  }
  function getPreviouslyFocusedElement() {
    clearDisconnectedPreviouslyFocusedElements();
    return previouslyFocusedElements[previouslyFocusedElements.length - 1];
  }
  function getFirstTabbableElement(container) {
    const tabbableOptions = getTabbableOptions();
    if (isTabbable(container, tabbableOptions)) {
      return container;
    }
    return tabbable(container, tabbableOptions)[0] || container;
  }
  function handleTabIndex(floatingFocusElement, orderRef) {
    var _floatingFocusElement;
    if (!orderRef.current.includes("floating") && !((_floatingFocusElement = floatingFocusElement.getAttribute("role")) != null && _floatingFocusElement.includes("dialog"))) {
      return;
    }
    const options = getTabbableOptions();
    const focusableElements = focusable(floatingFocusElement, options);
    const tabbableContent = focusableElements.filter((element) => {
      const dataTabIndex = element.getAttribute("data-tabindex") || "";
      return isTabbable(element, options) || element.hasAttribute("data-tabindex") && !dataTabIndex.startsWith("-");
    });
    const tabIndex = floatingFocusElement.getAttribute("tabindex");
    if (orderRef.current.includes("floating") || tabbableContent.length === 0) {
      if (tabIndex !== "0") {
        floatingFocusElement.setAttribute("tabindex", "0");
      }
    } else if (tabIndex !== "-1" || floatingFocusElement.hasAttribute("data-tabindex") && floatingFocusElement.getAttribute("data-tabindex") !== "-1") {
      floatingFocusElement.setAttribute("tabindex", "-1");
      floatingFocusElement.setAttribute("data-tabindex", "-1");
    }
  }
  function FloatingFocusManager(props) {
    const {
      context: context2,
      children,
      disabled = false,
      order = ["content"],
      guards: _guards = true,
      initialFocus = 0,
      returnFocus = true,
      restoreFocus = false,
      modal = true,
      visuallyHiddenDismiss = false,
      closeOnFocusOut = true,
      outsideElementsInert = false,
      getInsideElements: _getInsideElements = () => []
    } = props;
    const {
      open: open2,
      onOpenChange,
      events,
      dataRef,
      elements: {
        domReference,
        floating
      }
    } = context2;
    const getNodeId = useEffectEvent(() => {
      var _dataRef$current$floa;
      return (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId;
    });
    const getInsideElements = useEffectEvent(_getInsideElements);
    const ignoreInitialFocus = typeof initialFocus === "number" && initialFocus < 0;
    const isUntrappedTypeableCombobox = isTypeableCombobox(domReference) && ignoreInitialFocus;
    const inertSupported = supportsInert();
    const guards = inertSupported ? _guards : true;
    const useInert = !guards || inertSupported && outsideElementsInert;
    const orderRef = useLatestRef(order);
    const initialFocusRef = useLatestRef(initialFocus);
    const returnFocusRef = useLatestRef(returnFocus);
    const tree = useFloatingTree();
    const portalContext = usePortalContext();
    const startDismissButtonRef = React36.useRef(null);
    const endDismissButtonRef = React36.useRef(null);
    const preventReturnFocusRef = React36.useRef(false);
    const isPointerDownRef = React36.useRef(false);
    const tabbableIndexRef = React36.useRef(-1);
    const blurTimeoutRef = React36.useRef(-1);
    const isInsidePortal = portalContext != null;
    const floatingFocusElement = getFloatingFocusElement(floating);
    const getTabbableContent = useEffectEvent(function(container) {
      if (container === void 0) {
        container = floatingFocusElement;
      }
      return container ? tabbable(container, getTabbableOptions()) : [];
    });
    const getTabbableElements = useEffectEvent((container) => {
      const content = getTabbableContent(container);
      return orderRef.current.map((type) => {
        if (domReference && type === "reference") {
          return domReference;
        }
        if (floatingFocusElement && type === "floating") {
          return floatingFocusElement;
        }
        return content;
      }).filter(Boolean).flat();
    });
    React36.useEffect(() => {
      if (disabled) return;
      if (!modal) return;
      function onKeyDown(event) {
        if (event.key === "Tab") {
          if (contains(floatingFocusElement, activeElement(getDocument(floatingFocusElement))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {
            stopEvent(event);
          }
          const els = getTabbableElements();
          const target = getTarget(event);
          if (orderRef.current[0] === "reference" && target === domReference) {
            stopEvent(event);
            if (event.shiftKey) {
              enqueueFocus(els[els.length - 1]);
            } else {
              enqueueFocus(els[1]);
            }
          }
          if (orderRef.current[1] === "floating" && target === floatingFocusElement && event.shiftKey) {
            stopEvent(event);
            enqueueFocus(els[0]);
          }
        }
      }
      const doc = getDocument(floatingFocusElement);
      doc.addEventListener("keydown", onKeyDown);
      return () => {
        doc.removeEventListener("keydown", onKeyDown);
      };
    }, [disabled, domReference, floatingFocusElement, modal, orderRef, isUntrappedTypeableCombobox, getTabbableContent, getTabbableElements]);
    React36.useEffect(() => {
      if (disabled) return;
      if (!floating) return;
      function handleFocusIn(event) {
        const target = getTarget(event);
        const tabbableContent = getTabbableContent();
        const tabbableIndex = tabbableContent.indexOf(target);
        if (tabbableIndex !== -1) {
          tabbableIndexRef.current = tabbableIndex;
        }
      }
      floating.addEventListener("focusin", handleFocusIn);
      return () => {
        floating.removeEventListener("focusin", handleFocusIn);
      };
    }, [disabled, floating, getTabbableContent]);
    React36.useEffect(() => {
      if (disabled) return;
      if (!closeOnFocusOut) return;
      function handlePointerDown() {
        isPointerDownRef.current = true;
        setTimeout(() => {
          isPointerDownRef.current = false;
        });
      }
      function handleFocusOutside(event) {
        const relatedTarget = event.relatedTarget;
        const currentTarget = event.currentTarget;
        const target = getTarget(event);
        queueMicrotask(() => {
          const nodeId = getNodeId();
          const movedToUnrelatedNode = !(contains(domReference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute("focus-guard")) || tree && (getNodeChildren(tree.nodesRef.current, nodeId).find((node2) => {
            var _node$context, _node$context2;
            return contains((_node$context = node2.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || contains((_node$context2 = node2.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);
          }) || getNodeAncestors(tree.nodesRef.current, nodeId).find((node2) => {
            var _node$context3, _node$context4, _node$context5;
            return [(_node$context3 = node2.context) == null ? void 0 : _node$context3.elements.floating, getFloatingFocusElement((_node$context4 = node2.context) == null ? void 0 : _node$context4.elements.floating)].includes(relatedTarget) || ((_node$context5 = node2.context) == null ? void 0 : _node$context5.elements.domReference) === relatedTarget;
          })));
          if (currentTarget === domReference && floatingFocusElement) {
            handleTabIndex(floatingFocusElement, orderRef);
          }
          if (restoreFocus && currentTarget !== domReference && !(target != null && target.isConnected) && activeElement(getDocument(floatingFocusElement)) === getDocument(floatingFocusElement).body) {
            if (isHTMLElement(floatingFocusElement)) {
              floatingFocusElement.focus();
            }
            const prevTabbableIndex = tabbableIndexRef.current;
            const tabbableContent = getTabbableContent();
            const nodeToFocus = tabbableContent[prevTabbableIndex] || tabbableContent[tabbableContent.length - 1] || floatingFocusElement;
            if (isHTMLElement(nodeToFocus)) {
              nodeToFocus.focus();
            }
          }
          if (dataRef.current.insideReactTree) {
            dataRef.current.insideReactTree = false;
            return;
          }
          if ((isUntrappedTypeableCombobox ? true : !modal) && relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current && // Fix React 18 Strict Mode returnFocus due to double rendering.
          relatedTarget !== getPreviouslyFocusedElement()) {
            preventReturnFocusRef.current = true;
            onOpenChange(false, event, "focus-out");
          }
        });
      }
      const shouldHandleBlurCapture = Boolean(!tree && portalContext);
      function markInsideReactTree() {
        clearTimeoutIfSet(blurTimeoutRef);
        dataRef.current.insideReactTree = true;
        blurTimeoutRef.current = window.setTimeout(() => {
          dataRef.current.insideReactTree = false;
        });
      }
      if (floating && isHTMLElement(domReference)) {
        domReference.addEventListener("focusout", handleFocusOutside);
        domReference.addEventListener("pointerdown", handlePointerDown);
        floating.addEventListener("focusout", handleFocusOutside);
        if (shouldHandleBlurCapture) {
          floating.addEventListener("focusout", markInsideReactTree, true);
        }
        return () => {
          domReference.removeEventListener("focusout", handleFocusOutside);
          domReference.removeEventListener("pointerdown", handlePointerDown);
          floating.removeEventListener("focusout", handleFocusOutside);
          if (shouldHandleBlurCapture) {
            floating.removeEventListener("focusout", markInsideReactTree, true);
          }
        };
      }
    }, [disabled, domReference, floating, floatingFocusElement, modal, tree, portalContext, onOpenChange, closeOnFocusOut, restoreFocus, getTabbableContent, isUntrappedTypeableCombobox, getNodeId, orderRef, dataRef]);
    const beforeGuardRef = React36.useRef(null);
    const afterGuardRef = React36.useRef(null);
    const mergedBeforeGuardRef = useLiteMergeRefs([beforeGuardRef, portalContext == null ? void 0 : portalContext.beforeInsideRef]);
    const mergedAfterGuardRef = useLiteMergeRefs([afterGuardRef, portalContext == null ? void 0 : portalContext.afterInsideRef]);
    React36.useEffect(() => {
      var _portalContext$portal, _ancestors$find;
      if (disabled) return;
      if (!floating) return;
      const portalNodes = Array.from((portalContext == null || (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll("[" + createAttribute("portal") + "]")) || []);
      const ancestors = tree ? getNodeAncestors(tree.nodesRef.current, getNodeId()) : [];
      const rootAncestorComboboxDomReference = (_ancestors$find = ancestors.find((node2) => {
        var _node$context6;
        return isTypeableCombobox(((_node$context6 = node2.context) == null ? void 0 : _node$context6.elements.domReference) || null);
      })) == null || (_ancestors$find = _ancestors$find.context) == null ? void 0 : _ancestors$find.elements.domReference;
      const insideElements = [floating, rootAncestorComboboxDomReference, ...portalNodes, ...getInsideElements(), startDismissButtonRef.current, endDismissButtonRef.current, beforeGuardRef.current, afterGuardRef.current, portalContext == null ? void 0 : portalContext.beforeOutsideRef.current, portalContext == null ? void 0 : portalContext.afterOutsideRef.current, orderRef.current.includes("reference") || isUntrappedTypeableCombobox ? domReference : null].filter((x2) => x2 != null);
      const cleanup2 = modal || isUntrappedTypeableCombobox ? markOthers(insideElements, !useInert, useInert) : markOthers(insideElements);
      return () => {
        cleanup2();
      };
    }, [disabled, domReference, floating, modal, orderRef, portalContext, isUntrappedTypeableCombobox, guards, useInert, tree, getNodeId, getInsideElements]);
    index(() => {
      if (disabled || !isHTMLElement(floatingFocusElement)) return;
      const doc = getDocument(floatingFocusElement);
      const previouslyFocusedElement = activeElement(doc);
      queueMicrotask(() => {
        const focusableElements = getTabbableElements(floatingFocusElement);
        const initialFocusValue = initialFocusRef.current;
        const elToFocus = (typeof initialFocusValue === "number" ? focusableElements[initialFocusValue] : initialFocusValue.current) || floatingFocusElement;
        const focusAlreadyInsideFloatingEl = contains(floatingFocusElement, previouslyFocusedElement);
        if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open2) {
          enqueueFocus(elToFocus, {
            preventScroll: elToFocus === floatingFocusElement
          });
        }
      });
    }, [disabled, open2, floatingFocusElement, ignoreInitialFocus, getTabbableElements, initialFocusRef]);
    index(() => {
      if (disabled || !floatingFocusElement) return;
      const doc = getDocument(floatingFocusElement);
      const previouslyFocusedElement = activeElement(doc);
      addPreviouslyFocusedElement(previouslyFocusedElement);
      function onOpenChange2(_ref) {
        let {
          reason,
          event,
          nested
        } = _ref;
        if (["hover", "safe-polygon"].includes(reason) && event.type === "mouseleave") {
          preventReturnFocusRef.current = true;
        }
        if (reason !== "outside-press") return;
        if (nested) {
          preventReturnFocusRef.current = false;
        } else if (isVirtualClick(event) || isVirtualPointerEvent(event)) {
          preventReturnFocusRef.current = false;
        } else {
          let isPreventScrollSupported = false;
          document.createElement("div").focus({
            get preventScroll() {
              isPreventScrollSupported = true;
              return false;
            }
          });
          if (isPreventScrollSupported) {
            preventReturnFocusRef.current = false;
          } else {
            preventReturnFocusRef.current = true;
          }
        }
      }
      events.on("openchange", onOpenChange2);
      const fallbackEl = doc.createElement("span");
      fallbackEl.setAttribute("tabindex", "-1");
      fallbackEl.setAttribute("aria-hidden", "true");
      Object.assign(fallbackEl.style, HIDDEN_STYLES);
      if (isInsidePortal && domReference) {
        domReference.insertAdjacentElement("afterend", fallbackEl);
      }
      function getReturnElement() {
        if (typeof returnFocusRef.current === "boolean") {
          const el = domReference || getPreviouslyFocusedElement();
          return el && el.isConnected ? el : fallbackEl;
        }
        return returnFocusRef.current.current || fallbackEl;
      }
      return () => {
        events.off("openchange", onOpenChange2);
        const activeEl = activeElement(doc);
        const isFocusInsideFloatingTree = contains(floating, activeEl) || tree && getNodeChildren(tree.nodesRef.current, getNodeId(), false).some((node2) => {
          var _node$context7;
          return contains((_node$context7 = node2.context) == null ? void 0 : _node$context7.elements.floating, activeEl);
        });
        const returnElement = getReturnElement();
        queueMicrotask(() => {
          const tabbableReturnElement = getFirstTabbableElement(returnElement);
          if (
            // eslint-disable-next-line react-hooks/exhaustive-deps
            returnFocusRef.current && !preventReturnFocusRef.current && isHTMLElement(tabbableReturnElement) && // If the focus moved somewhere else after mount, avoid returning focus
            // since it likely entered a different element which should be
            // respected: https://github.com/floating-ui/floating-ui/issues/2607
            (tabbableReturnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)
          ) {
            tabbableReturnElement.focus({
              preventScroll: true
            });
          }
          fallbackEl.remove();
        });
      };
    }, [disabled, floating, floatingFocusElement, returnFocusRef, dataRef, events, tree, isInsidePortal, domReference, getNodeId]);
    React36.useEffect(() => {
      queueMicrotask(() => {
        preventReturnFocusRef.current = false;
      });
      return () => {
        queueMicrotask(clearDisconnectedPreviouslyFocusedElements);
      };
    }, [disabled]);
    index(() => {
      if (disabled) return;
      if (!portalContext) return;
      portalContext.setFocusManagerState({
        modal,
        closeOnFocusOut,
        open: open2,
        onOpenChange,
        domReference
      });
      return () => {
        portalContext.setFocusManagerState(null);
      };
    }, [disabled, portalContext, modal, open2, onOpenChange, closeOnFocusOut, domReference]);
    index(() => {
      if (disabled) return;
      if (!floatingFocusElement) return;
      handleTabIndex(floatingFocusElement, orderRef);
    }, [disabled, floatingFocusElement, orderRef]);
    function renderDismissButton(location2) {
      if (disabled || !visuallyHiddenDismiss || !modal) {
        return null;
      }
      return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(VisuallyHiddenDismiss, {
        ref: location2 === "start" ? startDismissButtonRef : endDismissButtonRef,
        onClick: (event) => onOpenChange(false, event.nativeEvent),
        children: typeof visuallyHiddenDismiss === "string" ? visuallyHiddenDismiss : "Dismiss"
      });
    }
    const shouldRenderGuards = !disabled && guards && (modal ? !isUntrappedTypeableCombobox : true) && (isInsidePortal || modal);
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)(import_jsx_runtime16.Fragment, {
      children: [shouldRenderGuards && /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(FocusGuard, {
        "data-type": "inside",
        ref: mergedBeforeGuardRef,
        onFocus: (event) => {
          if (modal) {
            const els = getTabbableElements();
            enqueueFocus(order[0] === "reference" ? els[0] : els[els.length - 1]);
          } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {
            preventReturnFocusRef.current = false;
            if (isOutsideEvent(event, portalContext.portalNode)) {
              const nextTabbable = getNextTabbable(domReference);
              nextTabbable == null || nextTabbable.focus();
            } else {
              var _portalContext$before;
              (_portalContext$before = portalContext.beforeOutsideRef.current) == null || _portalContext$before.focus();
            }
          }
        }
      }), !isUntrappedTypeableCombobox && renderDismissButton("start"), children, renderDismissButton("end"), shouldRenderGuards && /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(FocusGuard, {
        "data-type": "inside",
        ref: mergedAfterGuardRef,
        onFocus: (event) => {
          if (modal) {
            enqueueFocus(getTabbableElements()[0]);
          } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {
            if (closeOnFocusOut) {
              preventReturnFocusRef.current = true;
            }
            if (isOutsideEvent(event, portalContext.portalNode)) {
              const prevTabbable = getPreviousTabbable(domReference);
              prevTabbable == null || prevTabbable.focus();
            } else {
              var _portalContext$afterO;
              (_portalContext$afterO = portalContext.afterOutsideRef.current) == null || _portalContext$afterO.focus();
            }
          }
        }
      })]
    });
  }
  function enableScrollLock() {
    const platform2 = getPlatform();
    const isIOS = /iP(hone|ad|od)|iOS/.test(platform2) || // iPads can claim to be MacIntel
    platform2 === "MacIntel" && navigator.maxTouchPoints > 1;
    const bodyStyle = document.body.style;
    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;
    const paddingProp = scrollbarX ? "paddingLeft" : "paddingRight";
    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.scrollX;
    const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.scrollY;
    bodyStyle.overflow = "hidden";
    bodyStyle.setProperty(scrollbarProperty, scrollbarWidth + "px");
    if (scrollbarWidth) {
      bodyStyle[paddingProp] = scrollbarWidth + "px";
    }
    if (isIOS) {
      var _window$visualViewpor, _window$visualViewpor2;
      const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;
      const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;
      Object.assign(bodyStyle, {
        position: "fixed",
        top: -(scrollY - Math.floor(offsetTop)) + "px",
        left: -(scrollX - Math.floor(offsetLeft)) + "px",
        right: "0"
      });
    }
    return () => {
      Object.assign(bodyStyle, {
        overflow: "",
        [paddingProp]: ""
      });
      bodyStyle.removeProperty(scrollbarProperty);
      if (isIOS) {
        Object.assign(bodyStyle, {
          position: "",
          top: "",
          left: "",
          right: ""
        });
        window.scrollTo(scrollX, scrollY);
      }
    };
  }
  function isButtonTarget(event) {
    return isHTMLElement(event.target) && event.target.tagName === "BUTTON";
  }
  function isAnchorTarget(event) {
    return isHTMLElement(event.target) && event.target.tagName === "A";
  }
  function isSpaceIgnored(element) {
    return isTypeableElement(element);
  }
  function useClick(context2, props) {
    if (props === void 0) {
      props = {};
    }
    const {
      open: open2,
      onOpenChange,
      dataRef,
      elements: {
        domReference
      }
    } = context2;
    const {
      enabled = true,
      event: eventOption = "click",
      toggle = true,
      ignoreMouse = false,
      keyboardHandlers = true,
      stickIfOpen = true
    } = props;
    const pointerTypeRef = React36.useRef();
    const didKeyDownRef = React36.useRef(false);
    const reference = React36.useMemo(() => ({
      onPointerDown(event) {
        pointerTypeRef.current = event.pointerType;
      },
      onMouseDown(event) {
        const pointerType = pointerTypeRef.current;
        if (event.button !== 0) return;
        if (eventOption === "click") return;
        if (isMouseLikePointerType(pointerType, true) && ignoreMouse) return;
        if (open2 && toggle && (dataRef.current.openEvent && stickIfOpen ? dataRef.current.openEvent.type === "mousedown" : true)) {
          onOpenChange(false, event.nativeEvent, "click");
        } else {
          event.preventDefault();
          onOpenChange(true, event.nativeEvent, "click");
        }
      },
      onClick(event) {
        const pointerType = pointerTypeRef.current;
        if (eventOption === "mousedown" && pointerTypeRef.current) {
          pointerTypeRef.current = void 0;
          return;
        }
        if (isMouseLikePointerType(pointerType, true) && ignoreMouse) return;
        if (open2 && toggle && (dataRef.current.openEvent && stickIfOpen ? dataRef.current.openEvent.type === "click" : true)) {
          onOpenChange(false, event.nativeEvent, "click");
        } else {
          onOpenChange(true, event.nativeEvent, "click");
        }
      },
      onKeyDown(event) {
        pointerTypeRef.current = void 0;
        if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {
          return;
        }
        if (event.key === " " && !isSpaceIgnored(domReference)) {
          event.preventDefault();
          didKeyDownRef.current = true;
        }
        if (isAnchorTarget(event)) {
          return;
        }
        if (event.key === "Enter") {
          if (open2 && toggle) {
            onOpenChange(false, event.nativeEvent, "click");
          } else {
            onOpenChange(true, event.nativeEvent, "click");
          }
        }
      },
      onKeyUp(event) {
        if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {
          return;
        }
        if (event.key === " " && didKeyDownRef.current) {
          didKeyDownRef.current = false;
          if (open2 && toggle) {
            onOpenChange(false, event.nativeEvent, "click");
          } else {
            onOpenChange(true, event.nativeEvent, "click");
          }
        }
      }
    }), [dataRef, domReference, eventOption, ignoreMouse, keyboardHandlers, onOpenChange, open2, stickIfOpen, toggle]);
    return React36.useMemo(() => enabled ? {
      reference
    } : {}, [enabled, reference]);
  }
  function createVirtualElement(domElement, data) {
    let offsetX = null;
    let offsetY = null;
    let isAutoUpdateEvent = false;
    return {
      contextElement: domElement || void 0,
      getBoundingClientRect() {
        var _data$dataRef$current;
        const domRect = (domElement == null ? void 0 : domElement.getBoundingClientRect()) || {
          width: 0,
          height: 0,
          x: 0,
          y: 0
        };
        const isXAxis = data.axis === "x" || data.axis === "both";
        const isYAxis = data.axis === "y" || data.axis === "both";
        const canTrackCursorOnAutoUpdate = ["mouseenter", "mousemove"].includes(((_data$dataRef$current = data.dataRef.current.openEvent) == null ? void 0 : _data$dataRef$current.type) || "") && data.pointerType !== "touch";
        let width = domRect.width;
        let height = domRect.height;
        let x2 = domRect.x;
        let y2 = domRect.y;
        if (offsetX == null && data.x && isXAxis) {
          offsetX = domRect.x - data.x;
        }
        if (offsetY == null && data.y && isYAxis) {
          offsetY = domRect.y - data.y;
        }
        x2 -= offsetX || 0;
        y2 -= offsetY || 0;
        width = 0;
        height = 0;
        if (!isAutoUpdateEvent || canTrackCursorOnAutoUpdate) {
          width = data.axis === "y" ? domRect.width : 0;
          height = data.axis === "x" ? domRect.height : 0;
          x2 = isXAxis && data.x != null ? data.x : x2;
          y2 = isYAxis && data.y != null ? data.y : y2;
        } else if (isAutoUpdateEvent && !canTrackCursorOnAutoUpdate) {
          height = data.axis === "x" ? domRect.height : height;
          width = data.axis === "y" ? domRect.width : width;
        }
        isAutoUpdateEvent = true;
        return {
          width,
          height,
          x: x2,
          y: y2,
          top: y2,
          right: x2 + width,
          bottom: y2 + height,
          left: x2
        };
      }
    };
  }
  function isMouseBasedEvent(event) {
    return event != null && event.clientX != null;
  }
  function useClientPoint(context2, props) {
    if (props === void 0) {
      props = {};
    }
    const {
      open: open2,
      dataRef,
      elements: {
        floating,
        domReference
      },
      refs
    } = context2;
    const {
      enabled = true,
      axis = "both",
      x: x2 = null,
      y: y2 = null
    } = props;
    const initialRef = React36.useRef(false);
    const cleanupListenerRef = React36.useRef(null);
    const [pointerType, setPointerType] = React36.useState();
    const [reactive, setReactive] = React36.useState([]);
    const setReference = useEffectEvent((x3, y3) => {
      if (initialRef.current) return;
      if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {
        return;
      }
      refs.setPositionReference(createVirtualElement(domReference, {
        x: x3,
        y: y3,
        axis,
        dataRef,
        pointerType
      }));
    });
    const handleReferenceEnterOrMove = useEffectEvent((event) => {
      if (x2 != null || y2 != null) return;
      if (!open2) {
        setReference(event.clientX, event.clientY);
      } else if (!cleanupListenerRef.current) {
        setReactive([]);
      }
    });
    const openCheck = isMouseLikePointerType(pointerType) ? floating : open2;
    const addListener = React36.useCallback(() => {
      if (!openCheck || !enabled || x2 != null || y2 != null) return;
      const win = getWindow(floating);
      function handleMouseMove(event) {
        const target = getTarget(event);
        if (!contains(floating, target)) {
          setReference(event.clientX, event.clientY);
        } else {
          win.removeEventListener("mousemove", handleMouseMove);
          cleanupListenerRef.current = null;
        }
      }
      if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {
        win.addEventListener("mousemove", handleMouseMove);
        const cleanup2 = () => {
          win.removeEventListener("mousemove", handleMouseMove);
          cleanupListenerRef.current = null;
        };
        cleanupListenerRef.current = cleanup2;
        return cleanup2;
      }
      refs.setPositionReference(domReference);
    }, [openCheck, enabled, x2, y2, floating, dataRef, refs, domReference, setReference]);
    React36.useEffect(() => {
      return addListener();
    }, [addListener, reactive]);
    React36.useEffect(() => {
      if (enabled && !floating) {
        initialRef.current = false;
      }
    }, [enabled, floating]);
    React36.useEffect(() => {
      if (!enabled && open2) {
        initialRef.current = true;
      }
    }, [enabled, open2]);
    index(() => {
      if (enabled && (x2 != null || y2 != null)) {
        initialRef.current = false;
        setReference(x2, y2);
      }
    }, [enabled, x2, y2, setReference]);
    const reference = React36.useMemo(() => {
      function setPointerTypeRef(_ref) {
        let {
          pointerType: pointerType2
        } = _ref;
        setPointerType(pointerType2);
      }
      return {
        onPointerDown: setPointerTypeRef,
        onPointerEnter: setPointerTypeRef,
        onMouseMove: handleReferenceEnterOrMove,
        onMouseEnter: handleReferenceEnterOrMove
      };
    }, [handleReferenceEnterOrMove]);
    return React36.useMemo(() => enabled ? {
      reference
    } : {}, [enabled, reference]);
  }
  function useDismiss(context2, props) {
    if (props === void 0) {
      props = {};
    }
    const {
      open: open2,
      onOpenChange,
      elements,
      dataRef
    } = context2;
    const {
      enabled = true,
      escapeKey = true,
      outsidePress: unstable_outsidePress = true,
      outsidePressEvent = "pointerdown",
      referencePress = false,
      referencePressEvent = "pointerdown",
      ancestorScroll = false,
      bubbles,
      capture
    } = props;
    const tree = useFloatingTree();
    const outsidePressFn = useEffectEvent(typeof unstable_outsidePress === "function" ? unstable_outsidePress : () => false);
    const outsidePress = typeof unstable_outsidePress === "function" ? outsidePressFn : unstable_outsidePress;
    const endedOrStartedInsideRef = React36.useRef(false);
    const {
      escapeKey: escapeKeyBubbles,
      outsidePress: outsidePressBubbles
    } = normalizeProp(bubbles);
    const {
      escapeKey: escapeKeyCapture,
      outsidePress: outsidePressCapture
    } = normalizeProp(capture);
    const isComposingRef = React36.useRef(false);
    const closeOnEscapeKeyDown = useEffectEvent((event) => {
      var _dataRef$current$floa;
      if (!open2 || !enabled || !escapeKey || event.key !== "Escape") {
        return;
      }
      if (isComposingRef.current) {
        return;
      }
      const nodeId = (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId;
      const children = tree ? getNodeChildren(tree.nodesRef.current, nodeId) : [];
      if (!escapeKeyBubbles) {
        event.stopPropagation();
        if (children.length > 0) {
          let shouldDismiss = true;
          children.forEach((child) => {
            var _child$context;
            if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {
              shouldDismiss = false;
              return;
            }
          });
          if (!shouldDismiss) {
            return;
          }
        }
      }
      onOpenChange(false, isReactEvent(event) ? event.nativeEvent : event, "escape-key");
    });
    const closeOnEscapeKeyDownCapture = useEffectEvent((event) => {
      var _getTarget2;
      const callback = () => {
        var _getTarget;
        closeOnEscapeKeyDown(event);
        (_getTarget = getTarget(event)) == null || _getTarget.removeEventListener("keydown", callback);
      };
      (_getTarget2 = getTarget(event)) == null || _getTarget2.addEventListener("keydown", callback);
    });
    const closeOnPressOutside = useEffectEvent((event) => {
      var _dataRef$current$floa2;
      const insideReactTree = dataRef.current.insideReactTree;
      dataRef.current.insideReactTree = false;
      const endedOrStartedInside = endedOrStartedInsideRef.current;
      endedOrStartedInsideRef.current = false;
      if (outsidePressEvent === "click" && endedOrStartedInside) {
        return;
      }
      if (insideReactTree) {
        return;
      }
      if (typeof outsidePress === "function" && !outsidePress(event)) {
        return;
      }
      const target = getTarget(event);
      const inertSelector = "[" + createAttribute("inert") + "]";
      const markers = getDocument(elements.floating).querySelectorAll(inertSelector);
      let targetRootAncestor = isElement(target) ? target : null;
      while (targetRootAncestor && !isLastTraversableNode(targetRootAncestor)) {
        const nextParent = getParentNode(targetRootAncestor);
        if (isLastTraversableNode(nextParent) || !isElement(nextParent)) {
          break;
        }
        targetRootAncestor = nextParent;
      }
      if (markers.length && isElement(target) && !isRootElement(target) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
      !contains(target, elements.floating) && // If the target root element contains none of the markers, then the
      // element was injected after the floating element rendered.
      Array.from(markers).every((marker) => !contains(targetRootAncestor, marker))) {
        return;
      }
      if (isHTMLElement(target) && floating) {
        const lastTraversableNode = isLastTraversableNode(target);
        const style = getComputedStyle2(target);
        const scrollRe = /auto|scroll/;
        const isScrollableX = lastTraversableNode || scrollRe.test(style.overflowX);
        const isScrollableY = lastTraversableNode || scrollRe.test(style.overflowY);
        const canScrollX = isScrollableX && target.clientWidth > 0 && target.scrollWidth > target.clientWidth;
        const canScrollY = isScrollableY && target.clientHeight > 0 && target.scrollHeight > target.clientHeight;
        const isRTL2 = style.direction === "rtl";
        const pressedVerticalScrollbar = canScrollY && (isRTL2 ? event.offsetX <= target.offsetWidth - target.clientWidth : event.offsetX > target.clientWidth);
        const pressedHorizontalScrollbar = canScrollX && event.offsetY > target.clientHeight;
        if (pressedVerticalScrollbar || pressedHorizontalScrollbar) {
          return;
        }
      }
      const nodeId = (_dataRef$current$floa2 = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa2.nodeId;
      const targetIsInsideChildren = tree && getNodeChildren(tree.nodesRef.current, nodeId).some((node2) => {
        var _node$context;
        return isEventTargetWithin(event, (_node$context = node2.context) == null ? void 0 : _node$context.elements.floating);
      });
      if (isEventTargetWithin(event, elements.floating) || isEventTargetWithin(event, elements.domReference) || targetIsInsideChildren) {
        return;
      }
      const children = tree ? getNodeChildren(tree.nodesRef.current, nodeId) : [];
      if (children.length > 0) {
        let shouldDismiss = true;
        children.forEach((child) => {
          var _child$context2;
          if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {
            shouldDismiss = false;
            return;
          }
        });
        if (!shouldDismiss) {
          return;
        }
      }
      onOpenChange(false, event, "outside-press");
    });
    const closeOnPressOutsideCapture = useEffectEvent((event) => {
      var _getTarget4;
      const callback = () => {
        var _getTarget3;
        closeOnPressOutside(event);
        (_getTarget3 = getTarget(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);
      };
      (_getTarget4 = getTarget(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);
    });
    React36.useEffect(() => {
      if (!open2 || !enabled) {
        return;
      }
      dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;
      dataRef.current.__outsidePressBubbles = outsidePressBubbles;
      let compositionTimeout = -1;
      function onScroll(event) {
        onOpenChange(false, event, "ancestor-scroll");
      }
      function handleCompositionStart() {
        window.clearTimeout(compositionTimeout);
        isComposingRef.current = true;
      }
      function handleCompositionEnd() {
        compositionTimeout = window.setTimeout(
          () => {
            isComposingRef.current = false;
          },
          // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.
          // Only apply to WebKit for the test to remain 0ms.
          isWebKit() ? 5 : 0
        );
      }
      const doc = getDocument(elements.floating);
      if (escapeKey) {
        doc.addEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);
        doc.addEventListener("compositionstart", handleCompositionStart);
        doc.addEventListener("compositionend", handleCompositionEnd);
      }
      outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
      let ancestors = [];
      if (ancestorScroll) {
        if (isElement(elements.domReference)) {
          ancestors = getOverflowAncestors(elements.domReference);
        }
        if (isElement(elements.floating)) {
          ancestors = ancestors.concat(getOverflowAncestors(elements.floating));
        }
        if (!isElement(elements.reference) && elements.reference && elements.reference.contextElement) {
          ancestors = ancestors.concat(getOverflowAncestors(elements.reference.contextElement));
        }
      }
      ancestors = ancestors.filter((ancestor) => {
        var _doc$defaultView;
        return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);
      });
      ancestors.forEach((ancestor) => {
        ancestor.addEventListener("scroll", onScroll, {
          passive: true
        });
      });
      return () => {
        if (escapeKey) {
          doc.removeEventListener("keydown", escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);
          doc.removeEventListener("compositionstart", handleCompositionStart);
          doc.removeEventListener("compositionend", handleCompositionEnd);
        }
        outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);
        ancestors.forEach((ancestor) => {
          ancestor.removeEventListener("scroll", onScroll);
        });
        window.clearTimeout(compositionTimeout);
      };
    }, [dataRef, elements, escapeKey, outsidePress, outsidePressEvent, open2, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]);
    React36.useEffect(() => {
      dataRef.current.insideReactTree = false;
    }, [dataRef, outsidePress, outsidePressEvent]);
    const reference = React36.useMemo(() => ({
      onKeyDown: closeOnEscapeKeyDown,
      ...referencePress && {
        [bubbleHandlerKeys[referencePressEvent]]: (event) => {
          onOpenChange(false, event.nativeEvent, "reference-press");
        },
        ...referencePressEvent !== "click" && {
          onClick(event) {
            onOpenChange(false, event.nativeEvent, "reference-press");
          }
        }
      }
    }), [closeOnEscapeKeyDown, onOpenChange, referencePress, referencePressEvent]);
    const floating = React36.useMemo(() => ({
      onKeyDown: closeOnEscapeKeyDown,
      onMouseDown() {
        endedOrStartedInsideRef.current = true;
      },
      onMouseUp() {
        endedOrStartedInsideRef.current = true;
      },
      [captureHandlerKeys[outsidePressEvent]]: () => {
        dataRef.current.insideReactTree = true;
      }
    }), [closeOnEscapeKeyDown, outsidePressEvent, dataRef]);
    return React36.useMemo(() => enabled ? {
      reference,
      floating
    } : {}, [enabled, reference, floating]);
  }
  function useFloatingRootContext(options) {
    const {
      open: open2 = false,
      onOpenChange: onOpenChangeProp,
      elements: elementsProp
    } = options;
    const floatingId = useId();
    const dataRef = React36.useRef({});
    const [events] = React36.useState(() => createEventEmitter());
    const nested = useFloatingParentNodeId() != null;
    if (true) {
      const optionDomReference = elementsProp.reference;
      if (optionDomReference && !isElement(optionDomReference)) {
        error("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
      }
    }
    const [positionReference, setPositionReference] = React36.useState(elementsProp.reference);
    const onOpenChange = useEffectEvent((open3, event, reason) => {
      dataRef.current.openEvent = open3 ? event : void 0;
      events.emit("openchange", {
        open: open3,
        event,
        reason,
        nested
      });
      onOpenChangeProp == null || onOpenChangeProp(open3, event, reason);
    });
    const refs = React36.useMemo(() => ({
      setPositionReference
    }), []);
    const elements = React36.useMemo(() => ({
      reference: positionReference || elementsProp.reference || null,
      floating: elementsProp.floating || null,
      domReference: elementsProp.reference
    }), [positionReference, elementsProp.reference, elementsProp.floating]);
    return React36.useMemo(() => ({
      dataRef,
      open: open2,
      onOpenChange,
      elements,
      events,
      floatingId,
      refs
    }), [open2, onOpenChange, elements, events, floatingId, refs]);
  }
  function useFloating2(options) {
    if (options === void 0) {
      options = {};
    }
    const {
      nodeId
    } = options;
    const internalRootContext = useFloatingRootContext({
      ...options,
      elements: {
        reference: null,
        floating: null,
        ...options.elements
      }
    });
    const rootContext = options.rootContext || internalRootContext;
    const computedElements = rootContext.elements;
    const [_domReference, setDomReference] = React36.useState(null);
    const [positionReference, _setPositionReference] = React36.useState(null);
    const optionDomReference = computedElements == null ? void 0 : computedElements.domReference;
    const domReference = optionDomReference || _domReference;
    const domReferenceRef = React36.useRef(null);
    const tree = useFloatingTree();
    index(() => {
      if (domReference) {
        domReferenceRef.current = domReference;
      }
    }, [domReference]);
    const position2 = useFloating({
      ...options,
      elements: {
        ...computedElements,
        ...positionReference && {
          reference: positionReference
        }
      }
    });
    const setPositionReference = React36.useCallback((node2) => {
      const computedPositionReference = isElement(node2) ? {
        getBoundingClientRect: () => node2.getBoundingClientRect(),
        getClientRects: () => node2.getClientRects(),
        contextElement: node2
      } : node2;
      _setPositionReference(computedPositionReference);
      position2.refs.setReference(computedPositionReference);
    }, [position2.refs]);
    const setReference = React36.useCallback((node2) => {
      if (isElement(node2) || node2 === null) {
        domReferenceRef.current = node2;
        setDomReference(node2);
      }
      if (isElement(position2.refs.reference.current) || position2.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
      // `null` to support `positionReference` + an unstable `reference`
      // callback ref.
      node2 !== null && !isElement(node2)) {
        position2.refs.setReference(node2);
      }
    }, [position2.refs]);
    const refs = React36.useMemo(() => ({
      ...position2.refs,
      setReference,
      setPositionReference,
      domReference: domReferenceRef
    }), [position2.refs, setReference, setPositionReference]);
    const elements = React36.useMemo(() => ({
      ...position2.elements,
      domReference
    }), [position2.elements, domReference]);
    const context2 = React36.useMemo(() => ({
      ...position2,
      ...rootContext,
      refs,
      elements,
      nodeId
    }), [position2, refs, elements, nodeId, rootContext]);
    index(() => {
      rootContext.dataRef.current.floatingContext = context2;
      const node2 = tree == null ? void 0 : tree.nodesRef.current.find((node3) => node3.id === nodeId);
      if (node2) {
        node2.context = context2;
      }
    });
    return React36.useMemo(() => ({
      ...position2,
      context: context2,
      refs,
      elements
    }), [position2, refs, elements, context2]);
  }
  function isMacSafari() {
    return isMac() && isSafari();
  }
  function useFocus(context2, props) {
    if (props === void 0) {
      props = {};
    }
    const {
      open: open2,
      onOpenChange,
      events,
      dataRef,
      elements
    } = context2;
    const {
      enabled = true,
      visibleOnly = true
    } = props;
    const blockFocusRef = React36.useRef(false);
    const timeoutRef = React36.useRef(-1);
    const keyboardModalityRef = React36.useRef(true);
    React36.useEffect(() => {
      if (!enabled) return;
      const win = getWindow(elements.domReference);
      function onBlur() {
        if (!open2 && isHTMLElement(elements.domReference) && elements.domReference === activeElement(getDocument(elements.domReference))) {
          blockFocusRef.current = true;
        }
      }
      function onKeyDown() {
        keyboardModalityRef.current = true;
      }
      function onPointerDown() {
        keyboardModalityRef.current = false;
      }
      win.addEventListener("blur", onBlur);
      if (isMacSafari()) {
        win.addEventListener("keydown", onKeyDown, true);
        win.addEventListener("pointerdown", onPointerDown, true);
      }
      return () => {
        win.removeEventListener("blur", onBlur);
        if (isMacSafari()) {
          win.removeEventListener("keydown", onKeyDown, true);
          win.removeEventListener("pointerdown", onPointerDown, true);
        }
      };
    }, [elements.domReference, open2, enabled]);
    React36.useEffect(() => {
      if (!enabled) return;
      function onOpenChange2(_ref) {
        let {
          reason
        } = _ref;
        if (reason === "reference-press" || reason === "escape-key") {
          blockFocusRef.current = true;
        }
      }
      events.on("openchange", onOpenChange2);
      return () => {
        events.off("openchange", onOpenChange2);
      };
    }, [events, enabled]);
    React36.useEffect(() => {
      return () => {
        clearTimeoutIfSet(timeoutRef);
      };
    }, []);
    const reference = React36.useMemo(() => ({
      onMouseLeave() {
        blockFocusRef.current = false;
      },
      onFocus(event) {
        if (blockFocusRef.current) return;
        const target = getTarget(event.nativeEvent);
        if (visibleOnly && isElement(target)) {
          if (isMacSafari() && !event.relatedTarget) {
            if (!keyboardModalityRef.current && !isTypeableElement(target)) {
              return;
            }
          } else if (!matchesFocusVisible(target)) {
            return;
          }
        }
        onOpenChange(true, event.nativeEvent, "focus");
      },
      onBlur(event) {
        blockFocusRef.current = false;
        const relatedTarget = event.relatedTarget;
        const nativeEvent = event.nativeEvent;
        const movedToFocusGuard = isElement(relatedTarget) && relatedTarget.hasAttribute(createAttribute("focus-guard")) && relatedTarget.getAttribute("data-type") === "outside";
        timeoutRef.current = window.setTimeout(() => {
          var _dataRef$current$floa;
          const activeEl = activeElement(elements.domReference ? elements.domReference.ownerDocument : document);
          if (!relatedTarget && activeEl === elements.domReference) return;
          if (contains((_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.refs.floating.current, activeEl) || contains(elements.domReference, activeEl) || movedToFocusGuard) {
            return;
          }
          onOpenChange(false, nativeEvent, "focus");
        });
      }
    }), [dataRef, elements.domReference, onOpenChange, visibleOnly]);
    return React36.useMemo(() => enabled ? {
      reference
    } : {}, [enabled, reference]);
  }
  function mergeProps(userProps, propsList, elementKey) {
    const map = /* @__PURE__ */ new Map();
    const isItem = elementKey === "item";
    let domUserProps = userProps;
    if (isItem && userProps) {
      const {
        [ACTIVE_KEY]: _,
        [SELECTED_KEY]: __,
        ...validProps
      } = userProps;
      domUserProps = validProps;
    }
    return {
      ...elementKey === "floating" && {
        tabIndex: -1,
        [FOCUSABLE_ATTRIBUTE2]: ""
      },
      ...domUserProps,
      ...propsList.map((value) => {
        const propsOrGetProps = value ? value[elementKey] : null;
        if (typeof propsOrGetProps === "function") {
          return userProps ? propsOrGetProps(userProps) : null;
        }
        return propsOrGetProps;
      }).concat(userProps).reduce((acc, props) => {
        if (!props) {
          return acc;
        }
        Object.entries(props).forEach((_ref) => {
          let [key, value] = _ref;
          if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {
            return;
          }
          if (key.indexOf("on") === 0) {
            if (!map.has(key)) {
              map.set(key, []);
            }
            if (typeof value === "function") {
              var _map$get;
              (_map$get = map.get(key)) == null || _map$get.push(value);
              acc[key] = function() {
                var _map$get2;
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn) => fn(...args)).find((val) => val !== void 0);
              };
            }
          } else {
            acc[key] = value;
          }
        });
        return acc;
      }, {})
    };
  }
  function useInteractions(propsList) {
    if (propsList === void 0) {
      propsList = [];
    }
    const referenceDeps = propsList.map((key) => key == null ? void 0 : key.reference);
    const floatingDeps = propsList.map((key) => key == null ? void 0 : key.floating);
    const itemDeps = propsList.map((key) => key == null ? void 0 : key.item);
    const getReferenceProps = React36.useCallback(
      (userProps) => mergeProps(userProps, propsList, "reference"),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      referenceDeps
    );
    const getFloatingProps = React36.useCallback(
      (userProps) => mergeProps(userProps, propsList, "floating"),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      floatingDeps
    );
    const getItemProps = React36.useCallback(
      (userProps) => mergeProps(userProps, propsList, "item"),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      itemDeps
    );
    return React36.useMemo(() => ({
      getReferenceProps,
      getFloatingProps,
      getItemProps
    }), [getReferenceProps, getFloatingProps, getItemProps]);
  }
  function doSwitch(orientation, vertical, horizontal) {
    switch (orientation) {
      case "vertical":
        return vertical;
      case "horizontal":
        return horizontal;
      default:
        return vertical || horizontal;
    }
  }
  function isMainOrientationKey(key, orientation) {
    const vertical = key === ARROW_UP2 || key === ARROW_DOWN2;
    const horizontal = key === ARROW_LEFT2 || key === ARROW_RIGHT2;
    return doSwitch(orientation, vertical, horizontal);
  }
  function isMainOrientationToEndKey(key, orientation, rtl) {
    const vertical = key === ARROW_DOWN2;
    const horizontal = rtl ? key === ARROW_LEFT2 : key === ARROW_RIGHT2;
    return doSwitch(orientation, vertical, horizontal) || key === "Enter" || key === " " || key === "";
  }
  function isCrossOrientationOpenKey(key, orientation, rtl) {
    const vertical = rtl ? key === ARROW_LEFT2 : key === ARROW_RIGHT2;
    const horizontal = key === ARROW_DOWN2;
    return doSwitch(orientation, vertical, horizontal);
  }
  function isCrossOrientationCloseKey(key, orientation, rtl, cols) {
    const vertical = rtl ? key === ARROW_RIGHT2 : key === ARROW_LEFT2;
    const horizontal = key === ARROW_UP2;
    if (orientation === "both" || orientation === "horizontal" && cols && cols > 1) {
      return key === ESCAPE;
    }
    return doSwitch(orientation, vertical, horizontal);
  }
  function useListNavigation(context2, props) {
    const {
      open: open2,
      onOpenChange,
      elements,
      floatingId
    } = context2;
    const {
      listRef,
      activeIndex,
      onNavigate: unstable_onNavigate = () => {
      },
      enabled = true,
      selectedIndex = null,
      allowEscape = false,
      loop = false,
      nested = false,
      rtl = false,
      virtual = false,
      focusItemOnOpen = "auto",
      focusItemOnHover = true,
      openOnArrowKeyDown = true,
      disabledIndices = void 0,
      orientation = "vertical",
      parentOrientation,
      cols = 1,
      scrollItemIntoView = true,
      virtualItemRef,
      itemSizes,
      dense = false
    } = props;
    if (true) {
      if (allowEscape) {
        if (!loop) {
          warn("`useListNavigation` looping must be enabled to allow escaping.");
        }
        if (!virtual) {
          warn("`useListNavigation` must be virtual to allow escaping.");
        }
      }
      if (orientation === "vertical" && cols > 1) {
        warn("In grid list navigation mode (`cols` > 1), the `orientation` should", 'be either "horizontal" or "both".');
      }
    }
    const floatingFocusElement = getFloatingFocusElement(elements.floating);
    const floatingFocusElementRef = useLatestRef(floatingFocusElement);
    const parentId = useFloatingParentNodeId();
    const tree = useFloatingTree();
    index(() => {
      context2.dataRef.current.orientation = orientation;
    }, [context2, orientation]);
    const onNavigate = useEffectEvent(() => {
      unstable_onNavigate(indexRef.current === -1 ? null : indexRef.current);
    });
    const typeableComboboxReference = isTypeableCombobox(elements.domReference);
    const focusItemOnOpenRef = React36.useRef(focusItemOnOpen);
    const indexRef = React36.useRef(selectedIndex != null ? selectedIndex : -1);
    const keyRef = React36.useRef(null);
    const isPointerModalityRef = React36.useRef(true);
    const previousOnNavigateRef = React36.useRef(onNavigate);
    const previousMountedRef = React36.useRef(!!elements.floating);
    const previousOpenRef = React36.useRef(open2);
    const forceSyncFocusRef = React36.useRef(false);
    const forceScrollIntoViewRef = React36.useRef(false);
    const disabledIndicesRef = useLatestRef(disabledIndices);
    const latestOpenRef = useLatestRef(open2);
    const scrollItemIntoViewRef = useLatestRef(scrollItemIntoView);
    const selectedIndexRef = useLatestRef(selectedIndex);
    const [activeId, setActiveId] = React36.useState();
    const [virtualId, setVirtualId] = React36.useState();
    const focusItem = useEffectEvent(() => {
      function runFocus(item2) {
        if (virtual) {
          var _item$id;
          if ((_item$id = item2.id) != null && _item$id.endsWith("-fui-option")) {
            item2.id = floatingId + "-" + Math.random().toString(16).slice(2, 10);
          }
          setActiveId(item2.id);
          tree == null || tree.events.emit("virtualfocus", item2);
          if (virtualItemRef) {
            virtualItemRef.current = item2;
          }
        } else {
          enqueueFocus(item2, {
            sync: forceSyncFocusRef.current,
            preventScroll: true
          });
        }
      }
      const initialItem = listRef.current[indexRef.current];
      const forceScrollIntoView = forceScrollIntoViewRef.current;
      if (initialItem) {
        runFocus(initialItem);
      }
      const scheduler = forceSyncFocusRef.current ? (v2) => v2() : requestAnimationFrame;
      scheduler(() => {
        const waitedItem = listRef.current[indexRef.current] || initialItem;
        if (!waitedItem) return;
        if (!initialItem) {
          runFocus(waitedItem);
        }
        const scrollIntoViewOptions = scrollItemIntoViewRef.current;
        const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);
        if (shouldScrollIntoView) {
          waitedItem.scrollIntoView == null || waitedItem.scrollIntoView(typeof scrollIntoViewOptions === "boolean" ? {
            block: "nearest",
            inline: "nearest"
          } : scrollIntoViewOptions);
        }
      });
    });
    index(() => {
      if (!enabled) return;
      if (open2 && elements.floating) {
        if (focusItemOnOpenRef.current && selectedIndex != null) {
          forceScrollIntoViewRef.current = true;
          indexRef.current = selectedIndex;
          onNavigate();
        }
      } else if (previousMountedRef.current) {
        indexRef.current = -1;
        previousOnNavigateRef.current();
      }
    }, [enabled, open2, elements.floating, selectedIndex, onNavigate]);
    index(() => {
      if (!enabled) return;
      if (!open2) return;
      if (!elements.floating) return;
      if (activeIndex == null) {
        forceSyncFocusRef.current = false;
        if (selectedIndexRef.current != null) {
          return;
        }
        if (previousMountedRef.current) {
          indexRef.current = -1;
          focusItem();
        }
        if ((!previousOpenRef.current || !previousMountedRef.current) && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {
          let runs = 0;
          const waitForListPopulated = () => {
            if (listRef.current[0] == null) {
              if (runs < 2) {
                const scheduler = runs ? requestAnimationFrame : queueMicrotask;
                scheduler(waitForListPopulated);
              }
              runs++;
            } else {
              indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? getMinListIndex(listRef, disabledIndicesRef.current) : getMaxListIndex(listRef, disabledIndicesRef.current);
              keyRef.current = null;
              onNavigate();
            }
          };
          waitForListPopulated();
        }
      } else if (!isIndexOutOfListBounds(listRef, activeIndex)) {
        indexRef.current = activeIndex;
        focusItem();
        forceScrollIntoViewRef.current = false;
      }
    }, [enabled, open2, elements.floating, activeIndex, selectedIndexRef, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);
    index(() => {
      var _nodes$find;
      if (!enabled || elements.floating || !tree || virtual || !previousMountedRef.current) {
        return;
      }
      const nodes = tree.nodesRef.current;
      const parent = (_nodes$find = nodes.find((node2) => node2.id === parentId)) == null || (_nodes$find = _nodes$find.context) == null ? void 0 : _nodes$find.elements.floating;
      const activeEl = activeElement(getDocument(elements.floating));
      const treeContainsActiveEl = nodes.some((node2) => node2.context && contains(node2.context.elements.floating, activeEl));
      if (parent && !treeContainsActiveEl && isPointerModalityRef.current) {
        parent.focus({
          preventScroll: true
        });
      }
    }, [enabled, elements.floating, tree, parentId, virtual]);
    index(() => {
      if (!enabled) return;
      if (!tree) return;
      if (!virtual) return;
      if (parentId) return;
      function handleVirtualFocus(item2) {
        setVirtualId(item2.id);
        if (virtualItemRef) {
          virtualItemRef.current = item2;
        }
      }
      tree.events.on("virtualfocus", handleVirtualFocus);
      return () => {
        tree.events.off("virtualfocus", handleVirtualFocus);
      };
    }, [enabled, tree, virtual, parentId, virtualItemRef]);
    index(() => {
      previousOnNavigateRef.current = onNavigate;
      previousOpenRef.current = open2;
      previousMountedRef.current = !!elements.floating;
    });
    index(() => {
      if (!open2) {
        keyRef.current = null;
        focusItemOnOpenRef.current = focusItemOnOpen;
      }
    }, [open2, focusItemOnOpen]);
    const hasActiveIndex = activeIndex != null;
    const item = React36.useMemo(() => {
      function syncCurrentTarget(currentTarget) {
        if (!latestOpenRef.current) return;
        const index3 = listRef.current.indexOf(currentTarget);
        if (index3 !== -1 && indexRef.current !== index3) {
          indexRef.current = index3;
          onNavigate();
        }
      }
      const props2 = {
        onFocus(_ref) {
          let {
            currentTarget
          } = _ref;
          forceSyncFocusRef.current = true;
          syncCurrentTarget(currentTarget);
        },
        onClick: (_ref2) => {
          let {
            currentTarget
          } = _ref2;
          return currentTarget.focus({
            preventScroll: true
          });
        },
        // Safari
        onMouseMove(_ref3) {
          let {
            currentTarget
          } = _ref3;
          forceSyncFocusRef.current = true;
          forceScrollIntoViewRef.current = false;
          if (focusItemOnHover) {
            syncCurrentTarget(currentTarget);
          }
        },
        onPointerLeave(_ref4) {
          let {
            pointerType
          } = _ref4;
          if (!isPointerModalityRef.current || pointerType === "touch") {
            return;
          }
          forceSyncFocusRef.current = true;
          if (!focusItemOnHover) {
            return;
          }
          indexRef.current = -1;
          onNavigate();
          if (!virtual) {
            var _floatingFocusElement;
            (_floatingFocusElement = floatingFocusElementRef.current) == null || _floatingFocusElement.focus({
              preventScroll: true
            });
          }
        }
      };
      return props2;
    }, [latestOpenRef, floatingFocusElementRef, focusItemOnHover, listRef, onNavigate, virtual]);
    const getParentOrientation = React36.useCallback(() => {
      var _tree$nodesRef$curren;
      return parentOrientation != null ? parentOrientation : tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node2) => node2.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.dataRef) == null ? void 0 : _tree$nodesRef$curren.current.orientation;
    }, [parentId, tree, parentOrientation]);
    const commonOnKeyDown = useEffectEvent((event) => {
      isPointerModalityRef.current = false;
      forceSyncFocusRef.current = true;
      if (event.which === 229) {
        return;
      }
      if (!latestOpenRef.current && event.currentTarget === floatingFocusElementRef.current) {
        return;
      }
      if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl, cols)) {
        if (!isMainOrientationKey(event.key, getParentOrientation())) {
          stopEvent(event);
        }
        onOpenChange(false, event.nativeEvent, "list-navigation");
        if (isHTMLElement(elements.domReference)) {
          if (virtual) {
            tree == null || tree.events.emit("virtualfocus", elements.domReference);
          } else {
            elements.domReference.focus();
          }
        }
        return;
      }
      const currentIndex = indexRef.current;
      const minIndex = getMinListIndex(listRef, disabledIndices);
      const maxIndex = getMaxListIndex(listRef, disabledIndices);
      if (!typeableComboboxReference) {
        if (event.key === "Home") {
          stopEvent(event);
          indexRef.current = minIndex;
          onNavigate();
        }
        if (event.key === "End") {
          stopEvent(event);
          indexRef.current = maxIndex;
          onNavigate();
        }
      }
      if (cols > 1) {
        const sizes = itemSizes || Array.from({
          length: listRef.current.length
        }, () => ({
          width: 1,
          height: 1
        }));
        const cellMap = createGridCellMap(sizes, cols, dense);
        const minGridIndex = cellMap.findIndex((index4) => index4 != null && !isListIndexDisabled(listRef, index4, disabledIndices));
        const maxGridIndex = cellMap.reduce((foundIndex, index4, cellIndex) => index4 != null && !isListIndexDisabled(listRef, index4, disabledIndices) ? cellIndex : foundIndex, -1);
        const index3 = cellMap[getGridNavigatedIndex({
          current: cellMap.map((itemIndex) => itemIndex != null ? listRef.current[itemIndex] : null)
        }, {
          event,
          orientation,
          loop,
          rtl,
          cols,
          // treat undefined (empty grid spaces) as disabled indices so we
          // don't end up in them
          disabledIndices: getGridCellIndices([...(typeof disabledIndices !== "function" ? disabledIndices : null) || listRef.current.map((_, index4) => isListIndexDisabled(listRef, index4, disabledIndices) ? index4 : void 0), void 0], cellMap),
          minIndex: minGridIndex,
          maxIndex: maxGridIndex,
          prevIndex: getGridCellIndexOfCorner(
            indexRef.current > maxIndex ? minIndex : indexRef.current,
            sizes,
            cellMap,
            cols,
            // use a corner matching the edge closest to the direction
            // we're moving in so we don't end up in the same item. Prefer
            // top/left over bottom/right.
            event.key === ARROW_DOWN2 ? "bl" : event.key === (rtl ? ARROW_LEFT2 : ARROW_RIGHT2) ? "tr" : "tl"
          ),
          stopEvent: true
        })];
        if (index3 != null) {
          indexRef.current = index3;
          onNavigate();
        }
        if (orientation === "both") {
          return;
        }
      }
      if (isMainOrientationKey(event.key, orientation)) {
        stopEvent(event);
        if (open2 && !virtual && activeElement(event.currentTarget.ownerDocument) === event.currentTarget) {
          indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;
          onNavigate();
          return;
        }
        if (isMainOrientationToEndKey(event.key, orientation, rtl)) {
          if (loop) {
            indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : findNonDisabledListIndex(listRef, {
              startingIndex: currentIndex,
              disabledIndices
            });
          } else {
            indexRef.current = Math.min(maxIndex, findNonDisabledListIndex(listRef, {
              startingIndex: currentIndex,
              disabledIndices
            }));
          }
        } else {
          if (loop) {
            indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : findNonDisabledListIndex(listRef, {
              startingIndex: currentIndex,
              decrement: true,
              disabledIndices
            });
          } else {
            indexRef.current = Math.max(minIndex, findNonDisabledListIndex(listRef, {
              startingIndex: currentIndex,
              decrement: true,
              disabledIndices
            }));
          }
        }
        if (isIndexOutOfListBounds(listRef, indexRef.current)) {
          indexRef.current = -1;
        }
        onNavigate();
      }
    });
    const ariaActiveDescendantProp = React36.useMemo(() => {
      return virtual && open2 && hasActiveIndex && {
        "aria-activedescendant": virtualId || activeId
      };
    }, [virtual, open2, hasActiveIndex, virtualId, activeId]);
    const floating = React36.useMemo(() => {
      return {
        "aria-orientation": orientation === "both" ? void 0 : orientation,
        ...!typeableComboboxReference ? ariaActiveDescendantProp : {},
        onKeyDown: commonOnKeyDown,
        onPointerMove() {
          isPointerModalityRef.current = true;
        }
      };
    }, [ariaActiveDescendantProp, commonOnKeyDown, orientation, typeableComboboxReference]);
    const reference = React36.useMemo(() => {
      function checkVirtualMouse(event) {
        if (focusItemOnOpen === "auto" && isVirtualClick(event.nativeEvent)) {
          focusItemOnOpenRef.current = true;
        }
      }
      function checkVirtualPointer(event) {
        focusItemOnOpenRef.current = focusItemOnOpen;
        if (focusItemOnOpen === "auto" && isVirtualPointerEvent(event.nativeEvent)) {
          focusItemOnOpenRef.current = true;
        }
      }
      return {
        ...ariaActiveDescendantProp,
        onKeyDown(event) {
          isPointerModalityRef.current = false;
          const isArrowKey = event.key.startsWith("Arrow");
          const isHomeOrEndKey = ["Home", "End"].includes(event.key);
          const isMoveKey = isArrowKey || isHomeOrEndKey;
          const isCrossOpenKey = isCrossOrientationOpenKey(event.key, orientation, rtl);
          const isCrossCloseKey = isCrossOrientationCloseKey(event.key, orientation, rtl, cols);
          const isParentCrossOpenKey = isCrossOrientationOpenKey(event.key, getParentOrientation(), rtl);
          const isMainKey = isMainOrientationKey(event.key, orientation);
          const isNavigationKey = (nested ? isParentCrossOpenKey : isMainKey) || event.key === "Enter" || event.key.trim() === "";
          if (virtual && open2) {
            const rootNode = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.parentId == null);
            const deepestNode = tree && rootNode ? getDeepestNode(tree.nodesRef.current, rootNode.id) : null;
            if (isMoveKey && deepestNode && virtualItemRef) {
              const eventObject = new KeyboardEvent("keydown", {
                key: event.key,
                bubbles: true
              });
              if (isCrossOpenKey || isCrossCloseKey) {
                var _deepestNode$context, _deepestNode$context2;
                const isCurrentTarget = ((_deepestNode$context = deepestNode.context) == null ? void 0 : _deepestNode$context.elements.domReference) === event.currentTarget;
                const dispatchItem = isCrossCloseKey && !isCurrentTarget ? (_deepestNode$context2 = deepestNode.context) == null ? void 0 : _deepestNode$context2.elements.domReference : isCrossOpenKey ? listRef.current.find((item2) => (item2 == null ? void 0 : item2.id) === activeId) : null;
                if (dispatchItem) {
                  stopEvent(event);
                  dispatchItem.dispatchEvent(eventObject);
                  setVirtualId(void 0);
                }
              }
              if ((isMainKey || isHomeOrEndKey) && deepestNode.context) {
                if (deepestNode.context.open && deepestNode.parentId && event.currentTarget !== deepestNode.context.elements.domReference) {
                  var _deepestNode$context$;
                  stopEvent(event);
                  (_deepestNode$context$ = deepestNode.context.elements.domReference) == null || _deepestNode$context$.dispatchEvent(eventObject);
                  return;
                }
              }
            }
            return commonOnKeyDown(event);
          }
          if (!open2 && !openOnArrowKeyDown && isArrowKey) {
            return;
          }
          if (isNavigationKey) {
            const isParentMainKey = isMainOrientationKey(event.key, getParentOrientation());
            keyRef.current = nested && isParentMainKey ? null : event.key;
          }
          if (nested) {
            if (isParentCrossOpenKey) {
              stopEvent(event);
              if (open2) {
                indexRef.current = getMinListIndex(listRef, disabledIndicesRef.current);
                onNavigate();
              } else {
                onOpenChange(true, event.nativeEvent, "list-navigation");
              }
            }
            return;
          }
          if (isMainKey) {
            if (selectedIndex != null) {
              indexRef.current = selectedIndex;
            }
            stopEvent(event);
            if (!open2 && openOnArrowKeyDown) {
              onOpenChange(true, event.nativeEvent, "list-navigation");
            } else {
              commonOnKeyDown(event);
            }
            if (open2) {
              onNavigate();
            }
          }
        },
        onFocus() {
          if (open2 && !virtual) {
            indexRef.current = -1;
            onNavigate();
          }
        },
        onPointerDown: checkVirtualPointer,
        onPointerEnter: checkVirtualPointer,
        onMouseDown: checkVirtualMouse,
        onClick: checkVirtualMouse
      };
    }, [activeId, ariaActiveDescendantProp, cols, commonOnKeyDown, disabledIndicesRef, focusItemOnOpen, listRef, nested, onNavigate, onOpenChange, open2, openOnArrowKeyDown, orientation, getParentOrientation, rtl, selectedIndex, tree, virtual, virtualItemRef]);
    return React36.useMemo(() => enabled ? {
      reference,
      floating,
      item
    } : {}, [enabled, reference, floating, item]);
  }
  function useRole(context2, props) {
    var _elements$domReferenc, _componentRoleToAriaR;
    if (props === void 0) {
      props = {};
    }
    const {
      open: open2,
      elements,
      floatingId: defaultFloatingId
    } = context2;
    const {
      enabled = true,
      role = "dialog"
    } = props;
    const defaultReferenceId = useId();
    const referenceId = ((_elements$domReferenc = elements.domReference) == null ? void 0 : _elements$domReferenc.id) || defaultReferenceId;
    const floatingId = React36.useMemo(() => {
      var _getFloatingFocusElem;
      return ((_getFloatingFocusElem = getFloatingFocusElement(elements.floating)) == null ? void 0 : _getFloatingFocusElem.id) || defaultFloatingId;
    }, [elements.floating, defaultFloatingId]);
    const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;
    const parentId = useFloatingParentNodeId();
    const isNested = parentId != null;
    const reference = React36.useMemo(() => {
      if (ariaRole === "tooltip" || role === "label") {
        return {
          ["aria-" + (role === "label" ? "labelledby" : "describedby")]: open2 ? floatingId : void 0
        };
      }
      return {
        "aria-expanded": open2 ? "true" : "false",
        "aria-haspopup": ariaRole === "alertdialog" ? "dialog" : ariaRole,
        "aria-controls": open2 ? floatingId : void 0,
        ...ariaRole === "listbox" && {
          role: "combobox"
        },
        ...ariaRole === "menu" && {
          id: referenceId
        },
        ...ariaRole === "menu" && isNested && {
          role: "menuitem"
        },
        ...role === "select" && {
          "aria-autocomplete": "none"
        },
        ...role === "combobox" && {
          "aria-autocomplete": "list"
        }
      };
    }, [ariaRole, floatingId, isNested, open2, referenceId, role]);
    const floating = React36.useMemo(() => {
      const floatingProps = {
        id: floatingId,
        ...ariaRole && {
          role: ariaRole
        }
      };
      if (ariaRole === "tooltip" || role === "label") {
        return floatingProps;
      }
      return {
        ...floatingProps,
        ...ariaRole === "menu" && {
          "aria-labelledby": referenceId
        }
      };
    }, [ariaRole, floatingId, referenceId, role]);
    const item = React36.useCallback((_ref) => {
      let {
        active,
        selected
      } = _ref;
      const commonProps = {
        role: "option",
        ...active && {
          id: floatingId + "-fui-option"
        }
      };
      switch (role) {
        case "select":
        case "combobox":
          return {
            ...commonProps,
            "aria-selected": selected
          };
      }
      return {};
    }, [floatingId, role]);
    return React36.useMemo(() => enabled ? {
      reference,
      floating,
      item
    } : {}, [enabled, reference, floating, item]);
  }
  function execWithArgsOrReturn(valueOrFn, args) {
    return typeof valueOrFn === "function" ? valueOrFn(args) : valueOrFn;
  }
  function useDelayUnmount(open2, durationMs) {
    const [isMounted, setIsMounted] = React36.useState(open2);
    if (open2 && !isMounted) {
      setIsMounted(true);
    }
    React36.useEffect(() => {
      if (!open2 && isMounted) {
        const timeout3 = setTimeout(() => setIsMounted(false), durationMs);
        return () => clearTimeout(timeout3);
      }
    }, [open2, isMounted, durationMs]);
    return isMounted;
  }
  function useTransitionStatus(context2, props) {
    if (props === void 0) {
      props = {};
    }
    const {
      open: open2,
      elements: {
        floating
      }
    } = context2;
    const {
      duration = 250
    } = props;
    const isNumberDuration = typeof duration === "number";
    const closeDuration = (isNumberDuration ? duration : duration.close) || 0;
    const [status, setStatus] = React36.useState("unmounted");
    const isMounted = useDelayUnmount(open2, closeDuration);
    if (!isMounted && status === "close") {
      setStatus("unmounted");
    }
    index(() => {
      if (!floating) return;
      if (open2) {
        setStatus("initial");
        const frame = requestAnimationFrame(() => {
          ReactDOM2.flushSync(() => {
            setStatus("open");
          });
        });
        return () => {
          cancelAnimationFrame(frame);
        };
      }
      setStatus("close");
    }, [open2, floating]);
    return {
      isMounted,
      status
    };
  }
  function useTransitionStyles(context2, props) {
    if (props === void 0) {
      props = {};
    }
    const {
      initial: unstable_initial = {
        opacity: 0
      },
      open: unstable_open,
      close: unstable_close,
      common: unstable_common,
      duration = 250
    } = props;
    const placement = context2.placement;
    const side = placement.split("-")[0];
    const fnArgs = React36.useMemo(() => ({
      side,
      placement
    }), [side, placement]);
    const isNumberDuration = typeof duration === "number";
    const openDuration = (isNumberDuration ? duration : duration.open) || 0;
    const closeDuration = (isNumberDuration ? duration : duration.close) || 0;
    const [styles, setStyles] = React36.useState(() => ({
      ...execWithArgsOrReturn(unstable_common, fnArgs),
      ...execWithArgsOrReturn(unstable_initial, fnArgs)
    }));
    const {
      isMounted,
      status
    } = useTransitionStatus(context2, {
      duration
    });
    const initialRef = useLatestRef(unstable_initial);
    const openRef = useLatestRef(unstable_open);
    const closeRef = useLatestRef(unstable_close);
    const commonRef = useLatestRef(unstable_common);
    index(() => {
      const initialStyles = execWithArgsOrReturn(initialRef.current, fnArgs);
      const closeStyles = execWithArgsOrReturn(closeRef.current, fnArgs);
      const commonStyles = execWithArgsOrReturn(commonRef.current, fnArgs);
      const openStyles = execWithArgsOrReturn(openRef.current, fnArgs) || Object.keys(initialStyles).reduce((acc, key) => {
        acc[key] = "";
        return acc;
      }, {});
      if (status === "initial") {
        setStyles((styles2) => ({
          transitionProperty: styles2.transitionProperty,
          ...commonStyles,
          ...initialStyles
        }));
      }
      if (status === "open") {
        setStyles({
          transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(","),
          transitionDuration: openDuration + "ms",
          ...commonStyles,
          ...openStyles
        });
      }
      if (status === "close") {
        const styles2 = closeStyles || initialStyles;
        setStyles({
          transitionProperty: Object.keys(styles2).map(camelCaseToKebabCase).join(","),
          transitionDuration: closeDuration + "ms",
          ...commonStyles,
          ...styles2
        });
      }
    }, [closeDuration, closeRef, initialRef, openRef, commonRef, openDuration, status, fnArgs]);
    return {
      isMounted,
      styles
    };
  }
  function useTypeahead(context2, props) {
    var _ref;
    const {
      open: open2,
      dataRef
    } = context2;
    const {
      listRef,
      activeIndex,
      onMatch: unstable_onMatch,
      onTypingChange: unstable_onTypingChange,
      enabled = true,
      findMatch = null,
      resetMs = 750,
      ignoreKeys = [],
      selectedIndex = null
    } = props;
    const timeoutIdRef = React36.useRef(-1);
    const stringRef = React36.useRef("");
    const prevIndexRef = React36.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);
    const matchIndexRef = React36.useRef(null);
    const onMatch = useEffectEvent(unstable_onMatch);
    const onTypingChange = useEffectEvent(unstable_onTypingChange);
    const findMatchRef = useLatestRef(findMatch);
    const ignoreKeysRef = useLatestRef(ignoreKeys);
    index(() => {
      if (open2) {
        clearTimeoutIfSet(timeoutIdRef);
        matchIndexRef.current = null;
        stringRef.current = "";
      }
    }, [open2]);
    index(() => {
      if (open2 && stringRef.current === "") {
        var _ref2;
        prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;
      }
    }, [open2, selectedIndex, activeIndex]);
    const setTypingChange = useEffectEvent((value) => {
      if (value) {
        if (!dataRef.current.typing) {
          dataRef.current.typing = value;
          onTypingChange(value);
        }
      } else {
        if (dataRef.current.typing) {
          dataRef.current.typing = value;
          onTypingChange(value);
        }
      }
    });
    const onKeyDown = useEffectEvent((event) => {
      function getMatchingIndex(list, orderedList, string) {
        const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find((text) => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);
        return str ? list.indexOf(str) : -1;
      }
      const listContent = listRef.current;
      if (stringRef.current.length > 0 && stringRef.current[0] !== " ") {
        if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {
          setTypingChange(false);
        } else if (event.key === " ") {
          stopEvent(event);
        }
      }
      if (listContent == null || ignoreKeysRef.current.includes(event.key) || // Character key.
      event.key.length !== 1 || // Modifier key.
      event.ctrlKey || event.metaKey || event.altKey) {
        return;
      }
      if (open2 && event.key !== " ") {
        stopEvent(event);
        setTypingChange(true);
      }
      const allowRapidSuccessionOfFirstLetter = listContent.every((text) => {
        var _text$, _text$2;
        return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;
      });
      if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {
        stringRef.current = "";
        prevIndexRef.current = matchIndexRef.current;
      }
      stringRef.current += event.key;
      clearTimeoutIfSet(timeoutIdRef);
      timeoutIdRef.current = window.setTimeout(() => {
        stringRef.current = "";
        prevIndexRef.current = matchIndexRef.current;
        setTypingChange(false);
      }, resetMs);
      const prevIndex = prevIndexRef.current;
      const index3 = getMatchingIndex(listContent, [...listContent.slice((prevIndex || 0) + 1), ...listContent.slice(0, (prevIndex || 0) + 1)], stringRef.current);
      if (index3 !== -1) {
        onMatch(index3);
        matchIndexRef.current = index3;
      } else if (event.key !== " ") {
        stringRef.current = "";
        setTypingChange(false);
      }
    });
    const reference = React36.useMemo(() => ({
      onKeyDown
    }), [onKeyDown]);
    const floating = React36.useMemo(() => {
      return {
        onKeyDown,
        onKeyUp(event) {
          if (event.key === " ") {
            setTypingChange(false);
          }
        }
      };
    }, [onKeyDown, setTypingChange]);
    return React36.useMemo(() => enabled ? {
      reference,
      floating
    } : {}, [enabled, reference, floating]);
  }
  function getArgsWithCustomFloatingHeight(state, height) {
    return {
      ...state,
      rects: {
        ...state.rects,
        floating: {
          ...state.rects.floating,
          height
        }
      }
    };
  }
  function useInnerOffset(context2, props) {
    const {
      open: open2,
      elements
    } = context2;
    const {
      enabled = true,
      overflowRef,
      scrollRef,
      onChange: unstable_onChange
    } = props;
    const onChange = useEffectEvent(unstable_onChange);
    const controlledScrollingRef = React36.useRef(false);
    const prevScrollTopRef = React36.useRef(null);
    const initialOverflowRef = React36.useRef(null);
    React36.useEffect(() => {
      if (!enabled) return;
      function onWheel(e2) {
        if (e2.ctrlKey || !el || overflowRef.current == null) {
          return;
        }
        const dY = e2.deltaY;
        const isAtTop = overflowRef.current.top >= -0.5;
        const isAtBottom = overflowRef.current.bottom >= -0.5;
        const remainingScroll = el.scrollHeight - el.clientHeight;
        const sign = dY < 0 ? -1 : 1;
        const method = dY < 0 ? "max" : "min";
        if (el.scrollHeight <= el.clientHeight) {
          return;
        }
        if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {
          e2.preventDefault();
          ReactDOM2.flushSync(() => {
            onChange((d3) => d3 + Math[method](dY, remainingScroll * sign));
          });
        } else if (/firefox/i.test(getUserAgent())) {
          el.scrollTop += dY;
        }
      }
      const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
      if (open2 && el) {
        el.addEventListener("wheel", onWheel);
        requestAnimationFrame(() => {
          prevScrollTopRef.current = el.scrollTop;
          if (overflowRef.current != null) {
            initialOverflowRef.current = {
              ...overflowRef.current
            };
          }
        });
        return () => {
          prevScrollTopRef.current = null;
          initialOverflowRef.current = null;
          el.removeEventListener("wheel", onWheel);
        };
      }
    }, [enabled, open2, elements.floating, overflowRef, scrollRef, onChange]);
    const floating = React36.useMemo(() => ({
      onKeyDown() {
        controlledScrollingRef.current = true;
      },
      onWheel() {
        controlledScrollingRef.current = false;
      },
      onPointerMove() {
        controlledScrollingRef.current = false;
      },
      onScroll() {
        const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
        if (!overflowRef.current || !el || !controlledScrollingRef.current) {
          return;
        }
        if (prevScrollTopRef.current !== null) {
          const scrollDiff = el.scrollTop - prevScrollTopRef.current;
          if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {
            ReactDOM2.flushSync(() => onChange((d3) => d3 + scrollDiff));
          }
        }
        requestAnimationFrame(() => {
          prevScrollTopRef.current = el.scrollTop;
        });
      }
    }), [elements.floating, onChange, overflowRef, scrollRef]);
    return React36.useMemo(() => enabled ? {
      floating
    } : {}, [enabled, floating]);
  }
  function getNodeChildren2(nodes, id, onlyOpenChildren) {
    if (onlyOpenChildren === void 0) {
      onlyOpenChildren = true;
    }
    const directChildren = nodes.filter((node2) => {
      var _node$context;
      return node2.parentId === id && (!onlyOpenChildren || ((_node$context = node2.context) == null ? void 0 : _node$context.open));
    });
    return directChildren.flatMap((child) => [child, ...getNodeChildren2(nodes, child.id, onlyOpenChildren)]);
  }
  function isPointInPolygon(point, polygon) {
    const [x2, y2] = point;
    let isInside2 = false;
    const length2 = polygon.length;
    for (let i2 = 0, j2 = length2 - 1; i2 < length2; j2 = i2++) {
      const [xi, yi] = polygon[i2] || [0, 0];
      const [xj, yj] = polygon[j2] || [0, 0];
      const intersect = yi >= y2 !== yj >= y2 && x2 <= (xj - xi) * (y2 - yi) / (yj - yi) + xi;
      if (intersect) {
        isInside2 = !isInside2;
      }
    }
    return isInside2;
  }
  function isInside(point, rect) {
    return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;
  }
  function safePolygon(options) {
    if (options === void 0) {
      options = {};
    }
    const {
      buffer = 0.5,
      blockPointerEvents = false,
      requireIntent = true
    } = options;
    const timeoutRef = {
      current: -1
    };
    let hasLanded = false;
    let lastX = null;
    let lastY = null;
    let lastCursorTime = typeof performance !== "undefined" ? performance.now() : 0;
    function getCursorSpeed(x2, y2) {
      const currentTime = performance.now();
      const elapsedTime = currentTime - lastCursorTime;
      if (lastX === null || lastY === null || elapsedTime === 0) {
        lastX = x2;
        lastY = y2;
        lastCursorTime = currentTime;
        return null;
      }
      const deltaX = x2 - lastX;
      const deltaY = y2 - lastY;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      const speed = distance / elapsedTime;
      lastX = x2;
      lastY = y2;
      lastCursorTime = currentTime;
      return speed;
    }
    const fn = (_ref) => {
      let {
        x: x2,
        y: y2,
        placement,
        elements,
        onClose,
        nodeId,
        tree
      } = _ref;
      return function onMouseMove(event) {
        function close() {
          clearTimeoutIfSet(timeoutRef);
          onClose();
        }
        clearTimeoutIfSet(timeoutRef);
        if (!elements.domReference || !elements.floating || placement == null || x2 == null || y2 == null) {
          return;
        }
        const {
          clientX,
          clientY
        } = event;
        const clientPoint = [clientX, clientY];
        const target = getTarget2(event);
        const isLeave = event.type === "mouseleave";
        const isOverFloatingEl = contains2(elements.floating, target);
        const isOverReferenceEl = contains2(elements.domReference, target);
        const refRect = elements.domReference.getBoundingClientRect();
        const rect = elements.floating.getBoundingClientRect();
        const side = placement.split("-")[0];
        const cursorLeaveFromRight = x2 > rect.right - rect.width / 2;
        const cursorLeaveFromBottom = y2 > rect.bottom - rect.height / 2;
        const isOverReferenceRect = isInside(clientPoint, refRect);
        const isFloatingWider = rect.width > refRect.width;
        const isFloatingTaller = rect.height > refRect.height;
        const left = (isFloatingWider ? refRect : rect).left;
        const right = (isFloatingWider ? refRect : rect).right;
        const top = (isFloatingTaller ? refRect : rect).top;
        const bottom = (isFloatingTaller ? refRect : rect).bottom;
        if (isOverFloatingEl) {
          hasLanded = true;
          if (!isLeave) {
            return;
          }
        }
        if (isOverReferenceEl) {
          hasLanded = false;
        }
        if (isOverReferenceEl && !isLeave) {
          hasLanded = true;
          return;
        }
        if (isLeave && isElement(event.relatedTarget) && contains2(elements.floating, event.relatedTarget)) {
          return;
        }
        if (tree && getNodeChildren2(tree.nodesRef.current, nodeId).length) {
          return;
        }
        if (side === "top" && y2 >= refRect.bottom - 1 || side === "bottom" && y2 <= refRect.top + 1 || side === "left" && x2 >= refRect.right - 1 || side === "right" && x2 <= refRect.left + 1) {
          return close();
        }
        let rectPoly = [];
        switch (side) {
          case "top":
            rectPoly = [[left, refRect.top + 1], [left, rect.bottom - 1], [right, rect.bottom - 1], [right, refRect.top + 1]];
            break;
          case "bottom":
            rectPoly = [[left, rect.top + 1], [left, refRect.bottom - 1], [right, refRect.bottom - 1], [right, rect.top + 1]];
            break;
          case "left":
            rectPoly = [[rect.right - 1, bottom], [rect.right - 1, top], [refRect.left + 1, top], [refRect.left + 1, bottom]];
            break;
          case "right":
            rectPoly = [[refRect.right - 1, bottom], [refRect.right - 1, top], [rect.left + 1, top], [rect.left + 1, bottom]];
            break;
        }
        function getPolygon(_ref2) {
          let [x3, y3] = _ref2;
          switch (side) {
            case "top": {
              const cursorPointOne = [isFloatingWider ? x3 + buffer / 2 : cursorLeaveFromRight ? x3 + buffer * 4 : x3 - buffer * 4, y3 + buffer + 1];
              const cursorPointTwo = [isFloatingWider ? x3 - buffer / 2 : cursorLeaveFromRight ? x3 + buffer * 4 : x3 - buffer * 4, y3 + buffer + 1];
              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];
              return [cursorPointOne, cursorPointTwo, ...commonPoints];
            }
            case "bottom": {
              const cursorPointOne = [isFloatingWider ? x3 + buffer / 2 : cursorLeaveFromRight ? x3 + buffer * 4 : x3 - buffer * 4, y3 - buffer];
              const cursorPointTwo = [isFloatingWider ? x3 - buffer / 2 : cursorLeaveFromRight ? x3 + buffer * 4 : x3 - buffer * 4, y3 - buffer];
              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];
              return [cursorPointOne, cursorPointTwo, ...commonPoints];
            }
            case "left": {
              const cursorPointOne = [x3 + buffer + 1, isFloatingTaller ? y3 + buffer / 2 : cursorLeaveFromBottom ? y3 + buffer * 4 : y3 - buffer * 4];
              const cursorPointTwo = [x3 + buffer + 1, isFloatingTaller ? y3 - buffer / 2 : cursorLeaveFromBottom ? y3 + buffer * 4 : y3 - buffer * 4];
              const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];
              return [...commonPoints, cursorPointOne, cursorPointTwo];
            }
            case "right": {
              const cursorPointOne = [x3 - buffer, isFloatingTaller ? y3 + buffer / 2 : cursorLeaveFromBottom ? y3 + buffer * 4 : y3 - buffer * 4];
              const cursorPointTwo = [x3 - buffer, isFloatingTaller ? y3 - buffer / 2 : cursorLeaveFromBottom ? y3 + buffer * 4 : y3 - buffer * 4];
              const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];
              return [cursorPointOne, cursorPointTwo, ...commonPoints];
            }
          }
        }
        if (isPointInPolygon([clientX, clientY], rectPoly)) {
          return;
        }
        if (hasLanded && !isOverReferenceRect) {
          return close();
        }
        if (!isLeave && requireIntent) {
          const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);
          const cursorSpeedThreshold = 0.1;
          if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {
            return close();
          }
        }
        if (!isPointInPolygon([clientX, clientY], getPolygon([x2, y2]))) {
          close();
        } else if (!hasLanded && requireIntent) {
          timeoutRef.current = window.setTimeout(close, 40);
        }
      };
    };
    fn.__options = {
      blockPointerEvents
    };
    return fn;
  }
  var React36, import_jsx_runtime16, ReactDOM2, FloatingListContext, FOCUSABLE_ATTRIBUTE2, ACTIVE_KEY, SELECTED_KEY, ARROW_LEFT2, ARROW_RIGHT2, ARROW_UP2, ARROW_DOWN2, CompositeContext, horizontalKeys, verticalKeys, allKeys, Composite, CompositeItem, SafeReact2, serverHandoffComplete, count, genId, useReactId, useId, devMessageSet, FloatingArrow, FloatingNodeContext, FloatingTreeContext, useFloatingParentNodeId, useFloatingTree, safePolygonIdentifier, NOOP, FloatingDelayGroupContext, useDelayGroupContext, NextFloatingDelayGroupContext, rafId, counters, uncontrolledElementsSet, markerMap, lockCount$1, supportsInert, unwrapHost, correctElements, HIDDEN_STYLES, FocusGuard, PortalContext, attr, usePortalContext, LIST_LIMIT, previouslyFocusedElements, VisuallyHiddenDismiss, lockCount, scrollbarProperty, cleanup, FloatingOverlay, bubbleHandlerKeys, captureHandlerKeys, normalizeProp, ESCAPE, componentRoleToAriaRoleMap, camelCaseToKebabCase, inner;
  var init_floating_ui_react_esm = __esm({
    "node_modules/@floating-ui/react/dist/floating-ui.react.esm.js"() {
      React36 = __toESM(require_react());
      init_floating_ui_react_utils();
      import_jsx_runtime16 = __toESM(require_jsx_runtime());
      init_floating_ui_utils_dom();
      init_index_esm();
      ReactDOM2 = __toESM(require_react_dom());
      init_floating_ui_react_dom();
      init_floating_ui_react_dom();
      init_floating_ui_utils();
      FloatingListContext = /* @__PURE__ */ React36.createContext({
        register: () => {
        },
        unregister: () => {
        },
        map: /* @__PURE__ */ new Map(),
        elementsRef: {
          current: []
        }
      });
      FOCUSABLE_ATTRIBUTE2 = "data-floating-ui-focusable";
      ACTIVE_KEY = "active";
      SELECTED_KEY = "selected";
      ARROW_LEFT2 = "ArrowLeft";
      ARROW_RIGHT2 = "ArrowRight";
      ARROW_UP2 = "ArrowUp";
      ARROW_DOWN2 = "ArrowDown";
      CompositeContext = /* @__PURE__ */ React36.createContext({
        activeIndex: 0,
        onNavigate: () => {
        }
      });
      horizontalKeys = [ARROW_LEFT2, ARROW_RIGHT2];
      verticalKeys = [ARROW_UP2, ARROW_DOWN2];
      allKeys = [...horizontalKeys, ...verticalKeys];
      Composite = /* @__PURE__ */ React36.forwardRef(function Composite2(props, forwardedRef) {
        const {
          render: render2,
          orientation = "both",
          loop = true,
          rtl = false,
          cols = 1,
          disabledIndices,
          activeIndex: externalActiveIndex,
          onNavigate: externalSetActiveIndex,
          itemSizes,
          dense = false,
          ...domProps
        } = props;
        const [internalActiveIndex, internalSetActiveIndex] = React36.useState(0);
        const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;
        const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);
        const elementsRef = React36.useRef([]);
        const renderElementProps = render2 && typeof render2 !== "function" ? render2.props : {};
        const contextValue = React36.useMemo(() => ({
          activeIndex,
          onNavigate
        }), [activeIndex, onNavigate]);
        const isGrid = cols > 1;
        function handleKeyDown(event) {
          if (!allKeys.includes(event.key)) return;
          let nextIndex = activeIndex;
          const minIndex = getMinListIndex(elementsRef, disabledIndices);
          const maxIndex = getMaxListIndex(elementsRef, disabledIndices);
          const horizontalEndKey = rtl ? ARROW_LEFT2 : ARROW_RIGHT2;
          const horizontalStartKey = rtl ? ARROW_RIGHT2 : ARROW_LEFT2;
          if (isGrid) {
            const sizes = itemSizes || Array.from({
              length: elementsRef.current.length
            }, () => ({
              width: 1,
              height: 1
            }));
            const cellMap = createGridCellMap(sizes, cols, dense);
            const minGridIndex = cellMap.findIndex((index3) => index3 != null && !isListIndexDisabled(elementsRef, index3, disabledIndices));
            const maxGridIndex = cellMap.reduce((foundIndex, index3, cellIndex) => index3 != null && !isListIndexDisabled(elementsRef, index3, disabledIndices) ? cellIndex : foundIndex, -1);
            const maybeNextIndex = cellMap[getGridNavigatedIndex({
              current: cellMap.map((itemIndex) => itemIndex ? elementsRef.current[itemIndex] : null)
            }, {
              event,
              orientation,
              loop,
              rtl,
              cols,
              // treat undefined (empty grid spaces) as disabled indices so we
              // don't end up in them
              disabledIndices: getGridCellIndices([...(typeof disabledIndices !== "function" ? disabledIndices : null) || elementsRef.current.map((_, index3) => isListIndexDisabled(elementsRef, index3, disabledIndices) ? index3 : void 0), void 0], cellMap),
              minIndex: minGridIndex,
              maxIndex: maxGridIndex,
              prevIndex: getGridCellIndexOfCorner(
                activeIndex > maxIndex ? minIndex : activeIndex,
                sizes,
                cellMap,
                cols,
                // use a corner matching the edge closest to the direction we're
                // moving in so we don't end up in the same item. Prefer
                // top/left over bottom/right.
                event.key === ARROW_DOWN2 ? "bl" : event.key === horizontalEndKey ? "tr" : "tl"
              )
            })];
            if (maybeNextIndex != null) {
              nextIndex = maybeNextIndex;
            }
          }
          const toEndKeys = {
            horizontal: [horizontalEndKey],
            vertical: [ARROW_DOWN2],
            both: [horizontalEndKey, ARROW_DOWN2]
          }[orientation];
          const toStartKeys = {
            horizontal: [horizontalStartKey],
            vertical: [ARROW_UP2],
            both: [horizontalStartKey, ARROW_UP2]
          }[orientation];
          const preventedKeys = isGrid ? allKeys : {
            horizontal: horizontalKeys,
            vertical: verticalKeys,
            both: allKeys
          }[orientation];
          if (nextIndex === activeIndex && [...toEndKeys, ...toStartKeys].includes(event.key)) {
            if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {
              nextIndex = minIndex;
            } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {
              nextIndex = maxIndex;
            } else {
              nextIndex = findNonDisabledListIndex(elementsRef, {
                startingIndex: nextIndex,
                decrement: toStartKeys.includes(event.key),
                disabledIndices
              });
            }
          }
          if (nextIndex !== activeIndex && !isIndexOutOfListBounds(elementsRef, nextIndex)) {
            var _elementsRef$current$;
            event.stopPropagation();
            if (preventedKeys.includes(event.key)) {
              event.preventDefault();
            }
            onNavigate(nextIndex);
            (_elementsRef$current$ = elementsRef.current[nextIndex]) == null || _elementsRef$current$.focus();
          }
        }
        const computedProps = {
          ...domProps,
          ...renderElementProps,
          ref: forwardedRef,
          "aria-orientation": orientation === "both" ? void 0 : orientation,
          onKeyDown(e2) {
            domProps.onKeyDown == null || domProps.onKeyDown(e2);
            renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e2);
            handleKeyDown(e2);
          }
        };
        return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(CompositeContext.Provider, {
          value: contextValue,
          children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(FloatingList, {
            elementsRef,
            children: renderJsx(render2, computedProps)
          })
        });
      });
      CompositeItem = /* @__PURE__ */ React36.forwardRef(function CompositeItem2(props, forwardedRef) {
        const {
          render: render2,
          ...domProps
        } = props;
        const renderElementProps = render2 && typeof render2 !== "function" ? render2.props : {};
        const {
          activeIndex,
          onNavigate
        } = React36.useContext(CompositeContext);
        const {
          ref,
          index: index3
        } = useListItem();
        const mergedRef = useMergeRefs([ref, forwardedRef, renderElementProps.ref]);
        const isActive = activeIndex === index3;
        const computedProps = {
          ...domProps,
          ...renderElementProps,
          ref: mergedRef,
          tabIndex: isActive ? 0 : -1,
          "data-active": isActive ? "" : void 0,
          onFocus(e2) {
            domProps.onFocus == null || domProps.onFocus(e2);
            renderElementProps.onFocus == null || renderElementProps.onFocus(e2);
            onNavigate(index3);
          }
        };
        return renderJsx(render2, computedProps);
      });
      SafeReact2 = {
        ...React36
      };
      serverHandoffComplete = false;
      count = 0;
      genId = () => (
        // Ensure the id is unique with multiple independent versions of Floating UI
        // on <React 18
        "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
      );
      useReactId = SafeReact2.useId;
      useId = useReactId || useFloatingId;
      if (true) {
        devMessageSet = /* @__PURE__ */ new Set();
      }
      FloatingArrow = /* @__PURE__ */ React36.forwardRef(function FloatingArrow2(props, ref) {
        const {
          context: {
            placement,
            elements: {
              floating
            },
            middlewareData: {
              arrow: arrow4,
              shift: shift4
            }
          },
          width = 14,
          height = 7,
          tipRadius = 0,
          strokeWidth = 0,
          staticOffset,
          stroke,
          d: d3,
          style: {
            transform: transform2,
            ...restStyle
          } = {},
          ...rest
        } = props;
        if (true) {
          if (!ref) {
            warn("The `ref` prop is required for `FloatingArrow`.");
          }
        }
        const clipPathId = useId();
        const [isRTL2, setIsRTL] = React36.useState(false);
        index(() => {
          if (!floating) return;
          const isRTL3 = getComputedStyle2(floating).direction === "rtl";
          if (isRTL3) {
            setIsRTL(true);
          }
        }, [floating]);
        if (!floating) {
          return null;
        }
        const [side, alignment] = placement.split("-");
        const isVerticalSide = side === "top" || side === "bottom";
        let computedStaticOffset = staticOffset;
        if (isVerticalSide && shift4 != null && shift4.x || !isVerticalSide && shift4 != null && shift4.y) {
          computedStaticOffset = null;
        }
        const computedStrokeWidth = strokeWidth * 2;
        const halfStrokeWidth = computedStrokeWidth / 2;
        const svgX = width / 2 * (tipRadius / -8 + 1);
        const svgY = height / 2 * tipRadius / 4;
        const isCustomShape = !!d3;
        const yOffsetProp = computedStaticOffset && alignment === "end" ? "bottom" : "top";
        let xOffsetProp = computedStaticOffset && alignment === "end" ? "right" : "left";
        if (computedStaticOffset && isRTL2) {
          xOffsetProp = alignment === "end" ? "left" : "right";
        }
        const arrowX = (arrow4 == null ? void 0 : arrow4.x) != null ? computedStaticOffset || arrow4.x : "";
        const arrowY = (arrow4 == null ? void 0 : arrow4.y) != null ? computedStaticOffset || arrow4.y : "";
        const dValue = d3 || "M0,0" + (" H" + width) + (" L" + (width - svgX) + "," + (height - svgY)) + (" Q" + width / 2 + "," + height + " " + svgX + "," + (height - svgY)) + " Z";
        const rotation = {
          top: isCustomShape ? "rotate(180deg)" : "",
          left: isCustomShape ? "rotate(90deg)" : "rotate(-90deg)",
          bottom: isCustomShape ? "" : "rotate(180deg)",
          right: isCustomShape ? "rotate(-90deg)" : "rotate(90deg)"
        }[side];
        return /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)("svg", {
          ...rest,
          "aria-hidden": true,
          ref,
          width: isCustomShape ? width : width + computedStrokeWidth,
          height: width,
          viewBox: "0 0 " + width + " " + (height > width ? height : width),
          style: {
            position: "absolute",
            pointerEvents: "none",
            [xOffsetProp]: arrowX,
            [yOffsetProp]: arrowY,
            [side]: isVerticalSide || isCustomShape ? "100%" : "calc(100% - " + computedStrokeWidth / 2 + "px)",
            transform: [rotation, transform2].filter((t2) => !!t2).join(" "),
            ...restStyle
          },
          children: [computedStrokeWidth > 0 && /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("path", {
            clipPath: "url(#" + clipPathId + ")",
            fill: "none",
            stroke,
            strokeWidth: computedStrokeWidth + (d3 ? 0 : 1),
            d: dValue
          }), /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("path", {
            stroke: computedStrokeWidth && !d3 ? rest.fill : "none",
            d: dValue
          }), /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("clipPath", {
            id: clipPathId,
            children: /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("rect", {
              x: -halfStrokeWidth,
              y: halfStrokeWidth * (isCustomShape ? -1 : 1),
              width: width + computedStrokeWidth,
              height: width
            })
          })]
        });
      });
      FloatingNodeContext = /* @__PURE__ */ React36.createContext(null);
      FloatingTreeContext = /* @__PURE__ */ React36.createContext(null);
      useFloatingParentNodeId = () => {
        var _React$useContext;
        return ((_React$useContext = React36.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
      };
      useFloatingTree = () => React36.useContext(FloatingTreeContext);
      safePolygonIdentifier = /* @__PURE__ */ createAttribute("safe-polygon");
      NOOP = () => {
      };
      FloatingDelayGroupContext = /* @__PURE__ */ React36.createContext({
        delay: 0,
        initialDelay: 0,
        timeoutMs: 0,
        currentId: null,
        setCurrentId: NOOP,
        setState: NOOP,
        isInstantPhase: false
      });
      useDelayGroupContext = () => React36.useContext(FloatingDelayGroupContext);
      NextFloatingDelayGroupContext = /* @__PURE__ */ React36.createContext({
        hasProvider: false,
        timeoutMs: 0,
        delayRef: {
          current: 0
        },
        initialDelayRef: {
          current: 0
        },
        timeoutIdRef: {
          current: -1
        },
        currentIdRef: {
          current: null
        },
        currentContextRef: {
          current: null
        }
      });
      rafId = 0;
      counters = {
        inert: /* @__PURE__ */ new WeakMap(),
        "aria-hidden": /* @__PURE__ */ new WeakMap(),
        none: /* @__PURE__ */ new WeakMap()
      };
      uncontrolledElementsSet = /* @__PURE__ */ new WeakSet();
      markerMap = {};
      lockCount$1 = 0;
      supportsInert = () => typeof HTMLElement !== "undefined" && "inert" in HTMLElement.prototype;
      unwrapHost = (node2) => node2 && (node2.host || unwrapHost(node2.parentNode));
      correctElements = (parent, targets) => targets.map((target) => {
        if (parent.contains(target)) {
          return target;
        }
        const correctedTarget = unwrapHost(target);
        if (parent.contains(correctedTarget)) {
          return correctedTarget;
        }
        return null;
      }).filter((x2) => x2 != null);
      HIDDEN_STYLES = {
        border: 0,
        clip: "rect(0 0 0 0)",
        height: "1px",
        margin: "-1px",
        overflow: "hidden",
        padding: 0,
        position: "fixed",
        whiteSpace: "nowrap",
        width: "1px",
        top: 0,
        left: 0
      };
      FocusGuard = /* @__PURE__ */ React36.forwardRef(function FocusGuard2(props, ref) {
        const [role, setRole] = React36.useState();
        index(() => {
          if (isSafari()) {
            setRole("button");
          }
        }, []);
        const restProps = {
          ref,
          tabIndex: 0,
          // Role is only for VoiceOver
          role,
          "aria-hidden": role ? void 0 : true,
          [createAttribute("focus-guard")]: "",
          style: HIDDEN_STYLES
        };
        return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("span", {
          ...props,
          ...restProps
        });
      });
      PortalContext = /* @__PURE__ */ React36.createContext(null);
      attr = /* @__PURE__ */ createAttribute("portal");
      usePortalContext = () => React36.useContext(PortalContext);
      LIST_LIMIT = 20;
      previouslyFocusedElements = [];
      VisuallyHiddenDismiss = /* @__PURE__ */ React36.forwardRef(function VisuallyHiddenDismiss2(props, ref) {
        return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("button", {
          ...props,
          type: "button",
          ref,
          tabIndex: -1,
          style: HIDDEN_STYLES
        });
      });
      lockCount = 0;
      scrollbarProperty = "--floating-ui-scrollbar-width";
      cleanup = () => {
      };
      FloatingOverlay = /* @__PURE__ */ React36.forwardRef(function FloatingOverlay2(props, ref) {
        const {
          lockScroll = false,
          ...rest
        } = props;
        index(() => {
          if (!lockScroll) return;
          lockCount++;
          if (lockCount === 1) {
            cleanup = enableScrollLock();
          }
          return () => {
            lockCount--;
            if (lockCount === 0) {
              cleanup();
            }
          };
        }, [lockScroll]);
        return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)("div", {
          ref,
          ...rest,
          style: {
            position: "fixed",
            overflow: "auto",
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
            ...rest.style
          }
        });
      });
      bubbleHandlerKeys = {
        pointerdown: "onPointerDown",
        mousedown: "onMouseDown",
        click: "onClick"
      };
      captureHandlerKeys = {
        pointerdown: "onPointerDownCapture",
        mousedown: "onMouseDownCapture",
        click: "onClickCapture"
      };
      normalizeProp = (normalizable) => {
        var _normalizable$escapeK, _normalizable$outside;
        return {
          escapeKey: typeof normalizable === "boolean" ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,
          outsidePress: typeof normalizable === "boolean" ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true
        };
      };
      ESCAPE = "Escape";
      componentRoleToAriaRoleMap = /* @__PURE__ */ new Map([["select", "listbox"], ["combobox", "listbox"], ["label", false]]);
      camelCaseToKebabCase = (str) => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($2, ofs) => (ofs ? "-" : "") + $2.toLowerCase());
      inner = (props) => ({
        name: "inner",
        options: props,
        async fn(state) {
          const {
            listRef,
            overflowRef,
            onFallbackChange,
            offset: innerOffset = 0,
            index: index3 = 0,
            minItemsVisible = 4,
            referenceOverflowThreshold = 0,
            scrollRef,
            ...detectOverflowOptions
          } = evaluate(props, state);
          const {
            rects,
            elements: {
              floating
            }
          } = state;
          const item = listRef.current[index3];
          const scrollEl = (scrollRef == null ? void 0 : scrollRef.current) || floating;
          const clientTop = floating.clientTop || scrollEl.clientTop;
          const floatingIsBordered = floating.clientTop !== 0;
          const scrollElIsBordered = scrollEl.clientTop !== 0;
          const floatingIsScrollEl = floating === scrollEl;
          if (true) {
            if (!state.placement.startsWith("bottom")) {
              warn('`placement` side must be "bottom" when using the `inner`', "middleware.");
            }
          }
          if (!item) {
            return {};
          }
          const nextArgs = {
            ...state,
            ...await offset3(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state)
          };
          const overflow = await detectOverflow2(getArgsWithCustomFloatingHeight(nextArgs, scrollEl.scrollHeight + clientTop + floating.clientTop), detectOverflowOptions);
          const refOverflow = await detectOverflow2(nextArgs, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const diffY = max(0, overflow.top);
          const nextY = nextArgs.y + diffY;
          const isScrollable = scrollEl.scrollHeight > scrollEl.clientHeight;
          const rounder = isScrollable ? (v2) => v2 : round;
          const maxHeight = rounder(max(0, scrollEl.scrollHeight + (floatingIsBordered && floatingIsScrollEl || scrollElIsBordered ? clientTop * 2 : 0) - diffY - max(0, overflow.bottom)));
          scrollEl.style.maxHeight = maxHeight + "px";
          scrollEl.scrollTop = diffY;
          if (onFallbackChange) {
            const shouldFallback = scrollEl.offsetHeight < item.offsetHeight * min(minItemsVisible, listRef.current.length) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold;
            ReactDOM2.flushSync(() => onFallbackChange(shouldFallback));
          }
          if (overflowRef) {
            overflowRef.current = await detectOverflow2(getArgsWithCustomFloatingHeight({
              ...nextArgs,
              y: nextY
            }, scrollEl.offsetHeight + clientTop + floating.clientTop), detectOverflowOptions);
          }
          return {
            y: nextY
          };
        }
      });
    }
  });

  // node_modules/@jbrowse/core/ui/BaseTooltip.js
  var require_BaseTooltip = __commonJS({
    "node_modules/@jbrowse/core/ui/BaseTooltip.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = BaseTooltip2;
      var jsx_runtime_1 = require_jsx_runtime();
      var react_1 = (init_floating_ui_react_esm(), __toCommonJS(floating_ui_react_esm_exports));
      var material_1 = require_material();
      var mui_1 = require_mui();
      function round2(value) {
        return Math.round(value * 1e5) / 1e5;
      }
      var useStyles18 = (0, mui_1.makeStyles)()((theme) => ({
        tooltip: {
          position: "absolute",
          pointerEvents: "none",
          backgroundColor: (0, material_1.alpha)(theme.palette.grey[700], 0.9),
          borderRadius: theme.shape.borderRadius,
          color: theme.palette.common.white,
          fontFamily: theme.typography.fontFamily,
          padding: "4px 8px",
          fontSize: theme.typography.fontSize,
          lineHeight: `${round2(14 / 10)}em`,
          maxWidth: 300,
          wordWrap: "break-word"
        }
      }));
      function BaseTooltip2({ clientPoint: clientPointCoords, children, placement = "right" }) {
        var _a, _b;
        const theme = (0, material_1.useTheme)();
        const popperTheme = (_a = theme.components) === null || _a === void 0 ? void 0 : _a.MuiPopper;
        const { classes } = useStyles18();
        const { refs, floatingStyles, context: context2 } = (0, react_1.useFloating)({
          placement,
          strategy: "fixed",
          middleware: [(0, react_1.offset)(5)]
        });
        const clientPoint = (0, react_1.useClientPoint)(context2, clientPointCoords);
        const { getFloatingProps } = (0, react_1.useInteractions)([clientPoint]);
        return (0, jsx_runtime_1.jsx)(material_1.Portal, { container: (_b = popperTheme === null || popperTheme === void 0 ? void 0 : popperTheme.defaultProps) === null || _b === void 0 ? void 0 : _b.container, children: (0, jsx_runtime_1.jsx)("div", { className: classes.tooltip, ref: refs.setFloating, style: {
          ...floatingStyles,
          zIndex: 1e5,
          visibility: floatingStyles.transform === "translate(0px, 0px)" ? "hidden" : void 0,
          pointerEvents: "none"
        }, ...getFloatingProps(), children }) });
      }
    }
  });

  // node_modules/@jbrowse/core/ui/index.js
  var require_ui2 = __commonJS({
    "node_modules/@jbrowse/core/ui/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o2, m2, k2, k22) {
        if (k22 === void 0) k22 = k2;
        var desc = Object.getOwnPropertyDescriptor(m2, k2);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k2];
          } };
        }
        Object.defineProperty(o2, k22, desc);
      }) : (function(o2, m2, k2, k22) {
        if (k22 === void 0) k22 = k2;
        o2[k22] = m2[k2];
      }));
      var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
        for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.VIEW_HEADER_HEIGHT = exports.BaseTooltip = exports.SanitizedHTML = exports.ExternalLink = exports.ResizeHandle = exports.PrerenderedCanvas = exports.Menu = exports.LoadingEllipses = exports.FileSelector = exports.FatalErrorDialog = exports.ErrorMessage = exports.EditableTypography = exports.Dialog = exports.CascadingMenuButton = exports.CascadingMenu = exports.AssemblySelector = exports.Logomark = exports.LogoFull = void 0;
      __exportStar(require_theme(), exports);
      var Logo_1 = require_Logo();
      Object.defineProperty(exports, "LogoFull", { enumerable: true, get: function() {
        return Logo_1.LogoFull;
      } });
      Object.defineProperty(exports, "Logomark", { enumerable: true, get: function() {
        return Logo_1.Logomark;
      } });
      var AssemblySelector_1 = require_AssemblySelector();
      Object.defineProperty(exports, "AssemblySelector", { enumerable: true, get: function() {
        return __importDefault(AssemblySelector_1).default;
      } });
      var CascadingMenu_1 = require_CascadingMenu();
      Object.defineProperty(exports, "CascadingMenu", { enumerable: true, get: function() {
        return __importDefault(CascadingMenu_1).default;
      } });
      var CascadingMenuButton_1 = require_CascadingMenuButton();
      Object.defineProperty(exports, "CascadingMenuButton", { enumerable: true, get: function() {
        return __importDefault(CascadingMenuButton_1).default;
      } });
      var Dialog_1 = require_Dialog();
      Object.defineProperty(exports, "Dialog", { enumerable: true, get: function() {
        return __importDefault(Dialog_1).default;
      } });
      var EditableTypography_1 = require_EditableTypography();
      Object.defineProperty(exports, "EditableTypography", { enumerable: true, get: function() {
        return __importDefault(EditableTypography_1).default;
      } });
      var ErrorMessage_1 = require_ErrorMessage();
      Object.defineProperty(exports, "ErrorMessage", { enumerable: true, get: function() {
        return __importDefault(ErrorMessage_1).default;
      } });
      var FatalErrorDialog_1 = require_FatalErrorDialog();
      Object.defineProperty(exports, "FatalErrorDialog", { enumerable: true, get: function() {
        return __importDefault(FatalErrorDialog_1).default;
      } });
      var FileSelector_1 = require_FileSelector2();
      Object.defineProperty(exports, "FileSelector", { enumerable: true, get: function() {
        return __importDefault(FileSelector_1).default;
      } });
      var LoadingEllipses_1 = require_LoadingEllipses();
      Object.defineProperty(exports, "LoadingEllipses", { enumerable: true, get: function() {
        return __importDefault(LoadingEllipses_1).default;
      } });
      var Menu_1 = require_Menu();
      Object.defineProperty(exports, "Menu", { enumerable: true, get: function() {
        return __importDefault(Menu_1).default;
      } });
      var PrerenderedCanvas_1 = require_PrerenderedCanvas();
      Object.defineProperty(exports, "PrerenderedCanvas", { enumerable: true, get: function() {
        return __importDefault(PrerenderedCanvas_1).default;
      } });
      var ResizeHandle_1 = require_ResizeHandle();
      Object.defineProperty(exports, "ResizeHandle", { enumerable: true, get: function() {
        return __importDefault(ResizeHandle_1).default;
      } });
      var ExternalLink_1 = require_ExternalLink();
      Object.defineProperty(exports, "ExternalLink", { enumerable: true, get: function() {
        return __importDefault(ExternalLink_1).default;
      } });
      var SanitizedHTML_1 = require_SanitizedHTML();
      Object.defineProperty(exports, "SanitizedHTML", { enumerable: true, get: function() {
        return __importDefault(SanitizedHTML_1).default;
      } });
      var BaseTooltip_1 = require_BaseTooltip();
      Object.defineProperty(exports, "BaseTooltip", { enumerable: true, get: function() {
        return __importDefault(BaseTooltip_1).default;
      } });
      __exportStar(require_Menu(), exports);
      exports.VIEW_HEADER_HEIGHT = 28;
    }
  });

  // node_modules/@jbrowse/core/BaseFeatureWidget/BaseFeatureDetail/BasicValue.js
  var require_BasicValue = __commonJS({
    "node_modules/@jbrowse/core/BaseFeatureWidget/BaseFeatureDetail/BasicValue.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = BasicValue;
      var jsx_runtime_1 = require_jsx_runtime();
      var react_1 = require_react();
      var material_1 = require_material();
      var mui_1 = require_mui();
      var ui_1 = require_ui2();
      var util_1 = require_util5();
      var useStyles18 = (0, mui_1.makeStyles)()((theme) => ({
        fieldValue: {
          wordBreak: "break-word",
          maxHeight: 300,
          fontSize: 12,
          padding: theme.spacing(0.5),
          overflow: "auto"
        }
      }));
      function BasicValue({ value }) {
        const { classes } = useStyles18();
        const isLink = /^https?:\/\//.exec(`${value}`);
        return (0, jsx_runtime_1.jsx)("div", { className: classes.fieldValue, children: (0, react_1.isValidElement)(value) ? value : isLink ? (0, jsx_runtime_1.jsx)(material_1.Link, { href: `${value}`, children: `${value}` }) : (0, jsx_runtime_1.jsx)(ui_1.SanitizedHTML, { html: (0, util_1.isObject)(value) ? JSON.stringify(value) : String(value) }) });
      }
    }
  });

  // node_modules/@jbrowse/core/BaseFeatureWidget/BaseFeatureDetail/FieldName.js
  var require_FieldName = __commonJS({
    "node_modules/@jbrowse/core/BaseFeatureWidget/BaseFeatureDetail/FieldName.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = FieldName;
      var jsx_runtime_1 = require_jsx_runtime();
      var material_1 = require_material();
      var mui_1 = require_mui();
      var useStyles18 = (0, mui_1.makeStyles)()((theme) => ({
        fieldDescription: {
          "&:hover": {
            background: theme.palette.mode === "dark" ? "#e65100" : "yellow"
          }
        },
        fieldName: {
          wordBreak: "break-all",
          minWidth: 90,
          borderBottom: "1px solid #0003",
          fontSize: 12,
          background: theme.palette.action.disabledBackground,
          marginRight: theme.spacing(1),
          padding: theme.spacing(0.5)
        }
      }));
      function FieldName({ description, name, width, prefix: prefix2 = [] }) {
        const { classes, cx } = useStyles18();
        const val = [...prefix2, name].join(".");
        return description ? (0, jsx_runtime_1.jsx)(material_1.Tooltip, { title: description, placement: "left", children: (0, jsx_runtime_1.jsx)("div", { className: cx(classes.fieldDescription, classes.fieldName), children: val }) }) : (0, jsx_runtime_1.jsx)("div", { className: classes.fieldName, style: { width }, children: val });
      }
    }
  });

  // node_modules/@jbrowse/core/BaseFeatureWidget/BaseFeatureDetail/ArrayValue.js
  var require_ArrayValue = __commonJS({
    "node_modules/@jbrowse/core/BaseFeatureWidget/BaseFeatureDetail/ArrayValue.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = ArrayValue;
      var jsx_runtime_1 = require_jsx_runtime();
      var mui_1 = require_mui();
      var Attributes_1 = __importDefault(require_Attributes());
      var BasicValue_1 = __importDefault(require_BasicValue());
      var FieldName_1 = __importDefault(require_FieldName());
      var util_1 = require_util5();
      var useStyles18 = (0, mui_1.makeStyles)()((theme) => ({
        field: {
          display: "flex",
          flexWrap: "wrap"
        },
        fieldSubvalue: {
          wordBreak: "break-word",
          maxHeight: 300,
          padding: theme.spacing(0.5),
          border: `1px solid ${theme.palette.action.selected}`,
          boxSizing: "border-box",
          overflow: "auto"
        }
      }));
      function ArrayValue({ name, value, description, formatter, prefix: prefix2 = [] }) {
        const { classes } = useStyles18();
        if (value.length === 1) {
          return (0, util_1.isObject)(value[0]) ? (0, jsx_runtime_1.jsx)(Attributes_1.default, { formatter, attributes: value[0], prefix: [...prefix2, name] }) : (0, jsx_runtime_1.jsxs)("div", { className: classes.field, children: [(0, jsx_runtime_1.jsx)(FieldName_1.default, { prefix: prefix2, description, name }), (0, jsx_runtime_1.jsx)(BasicValue_1.default, { value: formatter ? formatter(value[0], name) : value[0] })] });
        } else if (value.every((val) => (0, util_1.isObject)(val))) {
          return (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: value.map((val, i2) => (0, jsx_runtime_1.jsx)(Attributes_1.default, { formatter, attributes: val, prefix: [...prefix2, `${name}-${i2}`] }, `${JSON.stringify(val)}-${i2}`)) });
        } else {
          return (0, jsx_runtime_1.jsxs)("div", { className: classes.field, children: [(0, jsx_runtime_1.jsx)(FieldName_1.default, { prefix: prefix2, description, name }), value.map((val, i2) => (0, jsx_runtime_1.jsx)("div", { className: classes.fieldSubvalue, children: (0, jsx_runtime_1.jsx)(BasicValue_1.default, { value: formatter ? formatter(val, name) : val }) }, `${JSON.stringify(val)}-${i2}`))] });
        }
      }
    }
  });

  // global-externals:@mui/x-data-grid
  var require_x_data_grid = __commonJS({
    "global-externals:@mui/x-data-grid"(exports, module) {
      module.exports = JBrowseExports["@mui/x-data-grid"];
    }
  });

  // node_modules/@jbrowse/core/ui/DataGridFlexContainer.js
  var require_DataGridFlexContainer = __commonJS({
    "node_modules/@jbrowse/core/ui/DataGridFlexContainer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = DataGridFlexContainer;
      var jsx_runtime_1 = require_jsx_runtime();
      var mui_1 = require_mui();
      var useStyles18 = (0, mui_1.makeStyles)()({
        flexContainer: {
          display: "flex",
          flexDirection: "column"
        }
      });
      function DataGridFlexContainer({ children }) {
        const { classes } = useStyles18();
        return (0, jsx_runtime_1.jsx)("div", { className: classes.flexContainer, children });
      }
    }
  });

  // node_modules/@jbrowse/core/BaseFeatureWidget/BaseFeatureDetail/DataGridDetails.js
  var require_DataGridDetails = __commonJS({
    "node_modules/@jbrowse/core/BaseFeatureWidget/BaseFeatureDetail/DataGridDetails.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = DataGridDetails;
      var jsx_runtime_1 = require_jsx_runtime();
      var react_1 = require_react();
      var material_1 = require_material();
      var x_data_grid_1 = require_x_data_grid();
      var mui_1 = require_mui();
      var FieldName_1 = __importDefault(require_FieldName());
      var ui_1 = require_ui2();
      var DataGridFlexContainer_1 = __importDefault(require_DataGridFlexContainer());
      var util_1 = require_util5();
      var useStyles18 = (0, mui_1.makeStyles)()((theme) => ({
        margin: {
          marginBottom: theme.spacing(4)
        },
        cell: {
          whiteSpace: "nowrap",
          overflow: "hidden",
          textOverflow: "ellipsis"
        }
      }));
      function DataGridDetails({ value, prefix: prefix2, name }) {
        const { classes } = useStyles18();
        const [checked, setChecked] = (0, react_1.useState)(false);
        const keys = Object.keys(value[0]).sort();
        const unionKeys = new Set(keys);
        const rows = Object.entries(value).map(([k2, val]) => {
          const { id, ...rest } = val;
          return {
            id: k2,
            identifier: id,
            ...rest
          };
        });
        for (const val of value) {
          for (const k2 of Object.keys(val)) {
            unionKeys.add(k2);
          }
        }
        let colNames;
        if (unionKeys.has("id")) {
          unionKeys.delete("id");
          colNames = ["identifier", ...unionKeys];
        } else {
          colNames = [...unionKeys];
        }
        const widths = colNames.map((e2) => (0, util_1.measureGridWidth)(rows.map((r2) => r2[e2])));
        if (unionKeys.size < keys.length + 5) {
          return (0, jsx_runtime_1.jsxs)("div", { className: classes.margin, children: [(0, jsx_runtime_1.jsx)(FieldName_1.default, { prefix: prefix2, name }), (0, jsx_runtime_1.jsx)(material_1.FormControlLabel, { control: (0, jsx_runtime_1.jsx)(material_1.Checkbox, { checked, onChange: (event) => {
            setChecked(event.target.checked);
          } }), label: (0, jsx_runtime_1.jsx)(material_1.Typography, { variant: "body2", children: "Show options" }) }), (0, jsx_runtime_1.jsx)(DataGridFlexContainer_1.default, { children: (0, jsx_runtime_1.jsx)(x_data_grid_1.DataGrid, { disableRowSelectionOnClick: true, rows, rowHeight: 20, columnHeaderHeight: 35, hideFooter: rows.length < 25, showToolbar: checked, columns: colNames.map((val, index3) => ({
            field: val,
            width: widths[index3],
            renderCell: ({ value: value2 }) => (0, jsx_runtime_1.jsx)("div", { className: classes.cell, children: (0, jsx_runtime_1.jsx)(ui_1.SanitizedHTML, { html: (0, util_1.getStr)(value2 || "") }) })
          })) }) })] });
        }
        return null;
      }
    }
  });

  // node_modules/@jbrowse/core/BaseFeatureWidget/BaseFeatureDetail/SimpleField.js
  var require_SimpleField = __commonJS({
    "node_modules/@jbrowse/core/BaseFeatureWidget/BaseFeatureDetail/SimpleField.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = SimpleField;
      var jsx_runtime_1 = require_jsx_runtime();
      var mui_1 = require_mui();
      var BasicValue_1 = __importDefault(require_BasicValue());
      var FieldName_1 = __importDefault(require_FieldName());
      var useStyles18 = (0, mui_1.makeStyles)()({
        field: {
          display: "flex",
          flexWrap: "wrap"
        }
      });
      function SimpleField({ name, value, description, prefix: prefix2, width, formatter }) {
        const { classes } = useStyles18();
        return value != null ? (0, jsx_runtime_1.jsxs)("div", { className: classes.field, children: [(0, jsx_runtime_1.jsx)(FieldName_1.default, { prefix: prefix2, description, name, width }), (0, jsx_runtime_1.jsx)(BasicValue_1.default, { value: formatter ? formatter(value, name) : value })] }) : null;
      }
    }
  });

  // node_modules/@jbrowse/core/BaseFeatureWidget/BaseFeatureDetail/UriField.js
  var require_UriField = __commonJS({
    "node_modules/@jbrowse/core/BaseFeatureWidget/BaseFeatureDetail/UriField.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = UriField;
      var jsx_runtime_1 = require_jsx_runtime();
      var mui_1 = require_mui();
      var BasicValue_1 = __importDefault(require_BasicValue());
      var FieldName_1 = __importDefault(require_FieldName());
      var useStyles18 = (0, mui_1.makeStyles)()({
        field: {
          display: "flex",
          flexWrap: "wrap"
        }
      });
      function UriField({ value, prefix: prefix2, name }) {
        const { classes } = useStyles18();
        const { uri, baseUri = "" } = value;
        let href;
        try {
          href = new URL(uri, baseUri).href;
        } catch (e2) {
          href = uri;
        }
        return (0, jsx_runtime_1.jsxs)("div", { className: classes.field, children: [(0, jsx_runtime_1.jsx)(FieldName_1.default, { prefix: prefix2, name }), (0, jsx_runtime_1.jsx)(BasicValue_1.default, { value: href })] });
      }
    }
  });

  // node_modules/@jbrowse/core/BaseFeatureWidget/util.js
  var require_util8 = __commonJS({
    "node_modules/@jbrowse/core/BaseFeatureWidget/util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.stitch = stitch2;
      exports.filterSuccessiveElementsWithSameStartAndEndCoord = filterSuccessiveElementsWithSameStartAndEndCoord;
      exports.revlist = revlist2;
      exports.calculateUTRs = calculateUTRs;
      exports.calculateUTRs2 = calculateUTRs2;
      exports.ellipses = ellipses;
      exports.replaceUndefinedWithNull = replaceUndefinedWithNull;
      exports.formatSubfeatures = formatSubfeatures;
      function stitch2(subfeats, sequence) {
        return subfeats.map((sub) => sequence.slice(sub.start, sub.end)).join("");
      }
      function getItemId(feat) {
        return `${feat.start}-${feat.end}`;
      }
      function filterSuccessiveElementsWithSameStartAndEndCoord(list) {
        return list.filter((item, pos, ary) => !pos || getItemId(item) !== getItemId(ary[pos - 1]));
      }
      function revlist2(list, seqlen) {
        return list.map((sub) => ({
          ...sub,
          start: seqlen - sub.end,
          end: seqlen - sub.start
        })).sort((a2, b2) => a2.start - b2.start);
      }
      function calculateUTRs(cds, exons) {
        if (!cds.length) {
          return [];
        }
        if (exons.length < cds.length) {
          console.warn("exons.length less than cds.length, cant calculate UTR properly", { exons, cds });
          return [];
        }
        const firstCds = cds.at(0);
        const lastCds = cds.at(-1);
        const firstCdsIdx = exons.findIndex((exon) => exon.end >= firstCds.start && exon.start <= firstCds.start);
        const lastCdsIdx = exons.findIndex((exon) => exon.end >= lastCds.end && exon.start <= lastCds.end);
        const lastCdsExon = exons[lastCdsIdx];
        const firstCdsExon = exons[firstCdsIdx];
        const fivePrimeUTRs = [
          ...exons.slice(0, firstCdsIdx),
          {
            start: firstCdsExon.start,
            end: firstCds.start
          }
        ].map((elt) => ({
          ...elt,
          type: "five_prime_UTR"
        }));
        const threePrimeUTRs = [
          {
            start: lastCds.end,
            end: lastCdsExon.end
          },
          ...exons.slice(lastCdsIdx + 1)
        ].map((elt) => ({
          ...elt,
          type: "three_prime_UTR"
        }));
        return [...fivePrimeUTRs, ...threePrimeUTRs];
      }
      function calculateUTRs2(cds, parentFeat) {
        if (!cds.length) {
          return [];
        }
        const firstCds = cds.at(0);
        const lastCds = cds.at(-1);
        const fivePrimeUTRs = [
          {
            start: parentFeat.start,
            end: firstCds.start
          }
        ].map((elt) => ({
          ...elt,
          type: "five_prime_UTR"
        }));
        const threePrimeUTRs = [
          {
            start: lastCds.end,
            end: parentFeat.end
          }
        ].map((elt) => ({
          ...elt,
          type: "three_prime_UTR"
        }));
        return [...fivePrimeUTRs, ...threePrimeUTRs];
      }
      function ellipses(slug) {
        return slug.length > 20 ? `${slug.slice(0, 20)}...` : slug;
      }
      function replaceUndefinedWithNull(obj) {
        return JSON.parse(JSON.stringify(obj, (_, v2) => v2 === void 0 ? null : v2));
      }
      function formatSubfeatures(obj, depth, parse4, currentDepth = 0, returnObj = {}) {
        var _a;
        if (depth <= currentDepth) {
          return;
        }
        (_a = obj.subfeatures) === null || _a === void 0 ? void 0 : _a.map((sub) => {
          formatSubfeatures(sub, depth, parse4, currentDepth + 1, returnObj);
          parse4(sub);
        });
      }
    }
  });

  // node_modules/@jbrowse/core/BaseFeatureWidget/BaseFeatureDetail/util.js
  var require_util9 = __commonJS({
    "node_modules/@jbrowse/core/BaseFeatureWidget/BaseFeatureDetail/util.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isEmpty = isEmpty;
      exports.generateTitle = generateTitle;
      exports.generateMaxWidth = generateMaxWidth;
      exports.accessNested = accessNested;
      var util_1 = require_util5();
      var util_2 = require_util8();
      function isEmpty(obj) {
        return Object.keys(obj).length === 0;
      }
      function generateTitle(name, id, type) {
        return [(0, util_2.ellipses)(`${name || id || ""}`), `${type}`].filter((f2) => !!f2).join(" - ");
      }
      function generateMaxWidth(array, prefix2) {
        return Math.ceil((0, util_1.max)(array.map((key) => (0, util_1.measureText)([...prefix2, key[0]].join("."), 12)))) + 10;
      }
      function accessNested(arr, obj = {}) {
        let obj2 = obj;
        for (const elt of arr) {
          if ((0, util_1.isObject)(obj2)) {
            obj2 = obj2[elt];
          }
        }
        return typeof obj2 === "string" ? obj2 : (0, util_1.isObject)(obj2) && typeof obj2.Description === "string" ? obj2.Description : void 0;
      }
    }
  });

  // node_modules/@jbrowse/core/BaseFeatureWidget/BaseFeatureDetail/Attributes.js
  var require_Attributes = __commonJS({
    "node_modules/@jbrowse/core/BaseFeatureWidget/BaseFeatureDetail/Attributes.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = Attributes3;
      var jsx_runtime_1 = require_jsx_runtime();
      var ArrayValue_1 = __importDefault(require_ArrayValue());
      var DataGridDetails_1 = __importDefault(require_DataGridDetails());
      var SimpleField_1 = __importDefault(require_SimpleField());
      var UriField_1 = __importDefault(require_UriField());
      var util_1 = require_util9();
      var util_2 = require_util5();
      var MAX_FIELD_NAME_WIDTH = 170;
      var globalOmit = [
        "__jbrowsefmt",
        "length",
        "position",
        "subfeatures",
        "uniqueId",
        "exonFrames",
        "parentId",
        "thickStart",
        "thickEnd"
      ];
      function Attributes3(props) {
        const { attributes, omit = [], omitSingleLevel = [], descriptions, formatter, hideUris, prefix: prefix2 = [] } = props;
        const omits = /* @__PURE__ */ new Set([...omit, ...globalOmit, ...omitSingleLevel]);
        const { __jbrowsefmt, ...rest } = attributes;
        const filteredFormattedAttributes = Object.entries({
          ...rest,
          ...__jbrowsefmt
        }).filter(([k2, v2]) => v2 != null && !omits.has(k2));
        const maxLabelWidth = (0, util_1.generateMaxWidth)(filteredFormattedAttributes, prefix2);
        return (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: filteredFormattedAttributes.map(([key, value]) => {
          const description = (0, util_1.accessNested)([...prefix2, key], descriptions);
          if (Array.isArray(value)) {
            return value.length > 1 && value.every((val) => (0, util_2.isObject)(val)) ? (0, jsx_runtime_1.jsx)(DataGridDetails_1.default, { name: key, prefix: prefix2, value }, key) : (0, jsx_runtime_1.jsx)(ArrayValue_1.default, { name: key, value, formatter, description, prefix: prefix2 }, key);
          } else if ((0, util_2.isObject)(value)) {
            const { omitSingleLevel: omitSingleLevel2, ...rest2 } = props;
            return (0, util_2.isUriLocation)(value) ? hideUris ? null : (0, jsx_runtime_1.jsx)(UriField_1.default, { name: key, prefix: prefix2, value }, key) : (0, jsx_runtime_1.jsx)(Attributes3, { ...rest2, formatter, attributes: value, descriptions, prefix: [...prefix2, key] }, key);
          } else {
            return (0, jsx_runtime_1.jsx)(SimpleField_1.default, { name: key, formatter, value, description, prefix: prefix2, width: Math.min(maxLabelWidth, MAX_FIELD_NAME_WIDTH) }, key);
          }
        }) });
      }
    }
  });

  // node_modules/@mui/icons-material/ExpandMore.js
  var require_ExpandMore = __commonJS({
    "node_modules/@mui/icons-material/ExpandMore.js"(exports) {
      "use strict";
      "use client";
      var _interopRequireDefault = require_interopRequireDefault().default;
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _createSvgIcon = _interopRequireDefault(require_createSvgIcon());
      var _jsxRuntime = require_jsx_runtime();
      var _default = exports.default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
        d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"
      }), "ExpandMore");
    }
  });

  // node_modules/@jbrowse/core/BaseFeatureWidget/BaseFeatureDetail/BaseCard.js
  var require_BaseCard = __commonJS({
    "node_modules/@jbrowse/core/BaseFeatureWidget/BaseFeatureDetail/BaseCard.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = BaseCard3;
      var jsx_runtime_1 = require_jsx_runtime();
      var ExpandMore_1 = __importDefault(require_ExpandMore());
      var material_1 = require_material();
      var mui_1 = require_mui();
      var useStyles18 = (0, mui_1.makeStyles)()((theme) => ({
        expansionPanelDetails: {
          display: "block",
          padding: theme.spacing(1)
        },
        icon: {
          color: theme.palette.tertiary.contrastText || "#fff"
        }
      }));
      function BaseCard3({ children, title, defaultExpanded = true }) {
        const { classes } = useStyles18();
        return (0, jsx_runtime_1.jsxs)(material_1.Accordion, { defaultExpanded, children: [(0, jsx_runtime_1.jsx)(material_1.AccordionSummary, { expandIcon: (0, jsx_runtime_1.jsx)(ExpandMore_1.default, { className: classes.icon }), children: (0, jsx_runtime_1.jsx)(material_1.Typography, { variant: "button", children: title }) }), (0, jsx_runtime_1.jsx)(material_1.AccordionDetails, { className: classes.expansionPanelDetails, children })] });
      }
    }
  });

  // node_modules/react-msaview/dist/components/Checkbox2.js
  function FormControlLabel22(rest) {
    return import_react40.default.createElement(
      "div",
      null,
      import_react40.default.createElement(import_material17.FormControlLabel, { ...rest })
    );
  }
  function Checkbox2({ checked, label, disabled, onChange }) {
    return import_react40.default.createElement(FormControlLabel22, { control: import_react40.default.createElement(import_material17.Checkbox, { disabled, checked, onChange }), label });
  }
  var import_react40, import_material17;
  var init_Checkbox2 = __esm({
    "node_modules/react-msaview/dist/components/Checkbox2.js"() {
      import_react40 = __toESM(require_react());
      import_material17 = __toESM(require_material());
    }
  });

  // node_modules/react-msaview/dist/components/SequenceTextArea.js
  function SequenceTextArea({ str }) {
    const { classes } = useStyles13();
    const [copied, setCopied] = (0, import_react41.useState)(false);
    const [showGaps, setShowGaps] = (0, import_react41.useState)(false);
    const [showEmpty, setShowEmpty] = (0, import_react41.useState)(false);
    const removeGaps = (s2) => s2.replaceAll("-", "").replaceAll(".", "");
    const disp = str.map(([s1, s2]) => [s1, showGaps ? s2 : removeGaps(s2)]).filter((f2) => showEmpty ? true : !!f2[1]).map(([s1, s2]) => `>${s1}
${showGaps ? s2 : removeGaps(s2)}`).join("\n");
    return import_react41.default.createElement(
      import_react41.default.Fragment,
      null,
      import_react41.default.createElement(import_material18.Button, { color: "primary", variant: "contained", onClick: () => {
        (0, import_copy_to_clipboard2.default)(disp);
        setCopied(true);
        setTimeout(() => {
          setCopied(false);
        }, 500);
      } }, copied ? "Copied!" : "Copy to clipboard"),
      import_react41.default.createElement(Checkbox2, { label: "Show gaps", checked: showGaps, onChange: () => {
        setShowGaps(!showGaps);
      } }),
      import_react41.default.createElement(Checkbox2, { label: "Show empty", checked: showEmpty, onChange: () => {
        setShowEmpty(!showEmpty);
      } }),
      import_react41.default.createElement(import_material18.TextField, { variant: "outlined", multiline: true, className: classes.dialogContent, minRows: 5, maxRows: 10, fullWidth: true, value: disp, InputProps: {
        readOnly: true,
        classes: {
          input: classes.textAreaFont
        }
      } })
    );
  }
  var import_react41, import_material18, import_copy_to_clipboard2, import_mui12, useStyles13;
  var init_SequenceTextArea = __esm({
    "node_modules/react-msaview/dist/components/SequenceTextArea.js"() {
      import_react41 = __toESM(require_react());
      import_material18 = __toESM(require_material());
      import_copy_to_clipboard2 = __toESM(require_copy_to_clipboard());
      import_mui12 = __toESM(require_mui());
      init_Checkbox2();
      useStyles13 = (0, import_mui12.makeStyles)()({
        textAreaFont: {
          fontFamily: "Courier New",
          wordWrap: "break-word"
        },
        dialogContent: {
          background: "lightgrey",
          margin: 4,
          minWidth: "80em"
        }
      });
    }
  });

  // node_modules/react-msaview/dist/components/dialogs/MetadataDialog.js
  var MetadataDialog_exports = {};
  __export(MetadataDialog_exports, {
    default: () => MetadataDialog_default
  });
  var import_react42, import_Attributes, import_BaseCard, import_ui8, import_material19, import_mobx_react15, MetadataDialog, MetadataDialog_default;
  var init_MetadataDialog = __esm({
    "node_modules/react-msaview/dist/components/dialogs/MetadataDialog.js"() {
      import_react42 = __toESM(require_react());
      import_Attributes = __toESM(require_Attributes());
      import_BaseCard = __toESM(require_BaseCard());
      import_ui8 = __toESM(require_ui());
      import_material19 = __toESM(require_material());
      import_mobx_react15 = __toESM(require_mobx_react());
      init_SequenceTextArea();
      MetadataDialog = (0, import_mobx_react15.observer)(function({ model, onClose }) {
        const { header } = model;
        return import_react42.default.createElement(
          import_ui8.Dialog,
          { onClose: () => {
            onClose();
          }, open: true, title: "Metadata", maxWidth: "xl" },
          import_react42.default.createElement(
            import_material19.DialogContent,
            null,
            import_react42.default.createElement(import_Attributes.default, { attributes: header }),
            import_react42.default.createElement(
              import_BaseCard.default,
              { title: "sequence" },
              import_react42.default.createElement(SequenceTextArea, { str: model.rows })
            )
          )
        );
      });
      MetadataDialog_default = MetadataDialog;
    }
  });

  // node_modules/react-msaview/dist/components/dialogs/ExportSVGDialog.js
  var ExportSVGDialog_exports = {};
  __export(ExportSVGDialog_exports, {
    default: () => ExportSVGDialog
  });
  function ExportSVGDialog({ model, onClose }) {
    const [includeMinimap, setIncludeMinimap] = (0, import_react43.useState)(true);
    const [includeTracks, setIncludeTracks] = (0, import_react43.useState)(true);
    const [exportType, setExportType] = (0, import_react43.useState)("viewport");
    const [error2, setError] = (0, import_react43.useState)();
    const theme = (0, import_material20.useTheme)();
    const { totalWidth, totalHeight, treeAreaWidth, turnedOnTracks } = model;
    const hasTracks = turnedOnTracks.length > 0;
    const entireWidth = totalWidth + treeAreaWidth;
    const entireHeight = totalHeight;
    const isLargeExport = exportType === "entire" && (entireWidth > 1e4 || entireHeight > 1e4);
    return import_react43.default.createElement(
      import_ui9.Dialog,
      { onClose: () => {
        onClose();
      }, open: true, title: "Export SVG" },
      import_react43.default.createElement(
        import_material20.DialogContent,
        null,
        error2 ? import_react43.default.createElement(import_ui9.ErrorMessage, { error: error2 }) : null,
        import_react43.default.createElement(import_material20.Typography, null, "Settings:"),
        import_react43.default.createElement(Checkbox2, { label: "Include minimap?", disabled: exportType === "entire", checked: includeMinimap, onChange: () => {
          setIncludeMinimap(!includeMinimap);
        } }),
        hasTracks ? import_react43.default.createElement(Checkbox2, { label: "Include tracks?", checked: includeTracks, onChange: () => {
          setIncludeTracks(!includeTracks);
        } }) : null,
        import_react43.default.createElement(
          "div",
          null,
          import_react43.default.createElement(
            import_material20.FormControl,
            null,
            import_react43.default.createElement(import_material20.FormLabel, null, "Export type"),
            import_react43.default.createElement(
              import_material20.RadioGroup,
              { value: exportType, onChange: (event) => {
                setExportType(event.target.value);
              } },
              import_react43.default.createElement(import_material20.FormControlLabel, { value: "entire", control: import_react43.default.createElement(import_material20.Radio, null), label: "Entire MSA" }),
              import_react43.default.createElement(import_material20.FormControlLabel, { value: "viewport", control: import_react43.default.createElement(import_material20.Radio, null), label: "Current viewport only" })
            )
          )
        ),
        isLargeExport ? import_react43.default.createElement(
          import_material20.Alert,
          { severity: "warning", style: { marginTop: 8 } },
          "The entire MSA is very large (",
          Math.round(entireWidth),
          "x",
          Math.round(entireHeight),
          " pixels). Export may be slow or fail."
        ) : null
      ),
      import_react43.default.createElement(
        import_material20.DialogActions,
        null,
        import_react43.default.createElement(import_material20.Button, { variant: "contained", color: "primary", onClick: () => {
          ;
          (async () => {
            try {
              await model.exportSVG({
                theme,
                includeMinimap: exportType === "entire" ? false : includeMinimap,
                includeTracks: hasTracks && includeTracks,
                exportType
              });
              onClose();
            } catch (e2) {
              console.error(e2);
              setError(e2);
            }
          })();
        } }, "Submit"),
        import_react43.default.createElement(import_material20.Button, { variant: "contained", color: "secondary", onClick: () => {
          onClose();
        } }, "Cancel")
      )
    );
  }
  var import_react43, import_ui9, import_material20;
  var init_ExportSVGDialog = __esm({
    "node_modules/react-msaview/dist/components/dialogs/ExportSVGDialog.js"() {
      import_react43 = __toESM(require_react());
      import_ui9 = __toESM(require_ui());
      import_material20 = __toESM(require_material());
      init_Checkbox2();
    }
  });

  // node_modules/react-msaview/dist/ggplotPalettes.js
  function getPalette(l2) {
    return palettes[Math.min(l2, palettes.length - 1)];
  }
  var palettes, ggplotPalettes_default;
  var init_ggplotPalettes = __esm({
    "node_modules/react-msaview/dist/ggplotPalettes.js"() {
      palettes = [
        ["#F8766D"],
        ["#F8766D", "#00BFC4"],
        ["#F8766D", "#00BA38", "#619CFF"],
        ["#F8766D", "#7CAE00", "#00BFC4", "#C77CFF"],
        ["#F8766D", "#A3A500", "#00BF7D", "#00B0F6", "#E76BF3"],
        ["#F8766D", "#B79F00", "#00BA38", "#00BFC4", "#619CFF", "#F564E3"],
        ["#F8766D", "#C49A00", "#53B400", "#00C094", "#00B6EB", "#A58AFF", "#FB61D7"],
        [
          "#F8766D",
          "#CD9600",
          "#7CAE00",
          "#00BE67",
          "#00BFC4",
          "#00A9FF",
          "#C77CFF",
          "#FF61CC"
        ]
      ];
      ggplotPalettes_default = palettes;
    }
  });

  // node_modules/react-msaview/dist/components/dialogs/FeatureDialog.js
  var FeatureDialog_exports = {};
  __export(FeatureDialog_exports, {
    default: () => FeatureDialog_default
  });
  var import_react44, import_ui10, import_material21, import_mobx_react16, Toggles, Table, FeatureTypeDialog, FeatureDialog_default;
  var init_FeatureDialog = __esm({
    "node_modules/react-msaview/dist/components/dialogs/FeatureDialog.js"() {
      import_react44 = __toESM(require_react());
      import_ui10 = __toESM(require_ui());
      import_material21 = __toESM(require_material());
      import_mobx_react16 = __toESM(require_mobx_react());
      init_ggplotPalettes();
      Toggles = (0, import_mobx_react16.observer)(function({ model }) {
        const { featureFilters } = model;
        return import_react44.default.createElement(
          "div",
          null,
          import_react44.default.createElement(import_material21.Button, { onClick: () => {
            for (const key of featureFilters.keys()) {
              model.setFilter(key, true);
            }
          } }, "Toggle all on"),
          import_react44.default.createElement(import_material21.Button, { onClick: () => {
            for (const key of featureFilters.keys()) {
              model.setFilter(key, false);
            }
          } }, "Toggle all off")
        );
      });
      Table = (0, import_mobx_react16.observer)(function({ model }) {
        const { tidyInterProAnnotationTypes, featureFilters } = model;
        const values = [...tidyInterProAnnotationTypes.values()];
        const palette = getPalette(values.length - 1);
        return import_react44.default.createElement(
          import_react44.default.Fragment,
          null,
          import_react44.default.createElement(Toggles, { model }),
          import_react44.default.createElement(
            "table",
            null,
            import_react44.default.createElement(
              "thead",
              null,
              import_react44.default.createElement(
                "tr",
                null,
                import_react44.default.createElement("td", null),
                import_react44.default.createElement("td", null, "accession"),
                import_react44.default.createElement("td", null, "name"),
                import_react44.default.createElement("td", null, "description")
              )
            ),
            import_react44.default.createElement("tbody", null, values.map(({ accession, name, description }, idx) => import_react44.default.createElement(
              "tr",
              { key: accession },
              import_react44.default.createElement(
                "td",
                null,
                import_react44.default.createElement("input", { type: "checkbox", checked: featureFilters.get(accession) ?? false, onChange: () => {
                  model.setFilter(accession, !model.featureFilters.get(accession));
                } })
              ),
              import_react44.default.createElement("td", null, accession),
              import_react44.default.createElement("td", null, name),
              import_react44.default.createElement("td", null, description),
              import_react44.default.createElement(
                "td",
                null,
                import_react44.default.createElement("div", { style: {
                  width: 20,
                  height: 20,
                  background: palette[idx] || "black"
                } })
              )
            )))
          )
        );
      });
      FeatureTypeDialog = (0, import_mobx_react16.observer)(function({ onClose, model }) {
        return import_react44.default.createElement(
          import_ui10.Dialog,
          { onClose: () => {
            onClose();
          }, open: true, title: "Feature filters", maxWidth: "xl" },
          import_react44.default.createElement(
            import_material21.DialogContent,
            null,
            import_react44.default.createElement(Table, { model })
          )
        );
      });
      FeatureDialog_default = FeatureTypeDialog;
    }
  });

  // node_modules/@mui/material/esm/colors/red.js
  var red, red_default;
  var init_red = __esm({
    "node_modules/@mui/material/esm/colors/red.js"() {
      red = {
        50: "#ffebee",
        100: "#ffcdd2",
        200: "#ef9a9a",
        300: "#e57373",
        400: "#ef5350",
        500: "#f44336",
        600: "#e53935",
        700: "#d32f2f",
        800: "#c62828",
        900: "#b71c1c",
        A100: "#ff8a80",
        A200: "#ff5252",
        A400: "#ff1744",
        A700: "#d50000"
      };
      red_default = red;
    }
  });

  // node_modules/@mui/material/esm/colors/blue.js
  var blue, blue_default;
  var init_blue = __esm({
    "node_modules/@mui/material/esm/colors/blue.js"() {
      blue = {
        50: "#e3f2fd",
        100: "#bbdefb",
        200: "#90caf9",
        300: "#64b5f6",
        400: "#42a5f5",
        500: "#2196f3",
        600: "#1e88e5",
        700: "#1976d2",
        800: "#1565c0",
        900: "#0d47a1",
        A100: "#82b1ff",
        A200: "#448aff",
        A400: "#2979ff",
        A700: "#2962ff"
      };
      blue_default = blue;
    }
  });

  // node_modules/@mui/material/esm/colors/green.js
  var green, green_default;
  var init_green = __esm({
    "node_modules/@mui/material/esm/colors/green.js"() {
      green = {
        50: "#e8f5e9",
        100: "#c8e6c9",
        200: "#a5d6a7",
        300: "#81c784",
        400: "#66bb6a",
        500: "#4caf50",
        600: "#43a047",
        700: "#388e3c",
        800: "#2e7d32",
        900: "#1b5e20",
        A100: "#b9f6ca",
        A200: "#69f0ae",
        A400: "#00e676",
        A700: "#00c853"
      };
      green_default = green;
    }
  });

  // node_modules/@mui/material/esm/colors/orange.js
  var orange, orange_default;
  var init_orange = __esm({
    "node_modules/@mui/material/esm/colors/orange.js"() {
      orange = {
        50: "#fff3e0",
        100: "#ffe0b2",
        200: "#ffcc80",
        300: "#ffb74d",
        400: "#ffa726",
        500: "#ff9800",
        600: "#fb8c00",
        700: "#f57c00",
        800: "#ef6c00",
        900: "#e65100",
        A100: "#ffd180",
        A200: "#ffab40",
        A400: "#ff9100",
        A700: "#ff6d00"
      };
      orange_default = orange;
    }
  });

  // node_modules/@mui/material/esm/colors/index.js
  var init_colors = __esm({
    "node_modules/@mui/material/esm/colors/index.js"() {
      init_red();
      init_blue();
      init_green();
      init_orange();
    }
  });

  // node_modules/colord/index.mjs
  var r, t, n, e, u, a, o, i, s, h, b, g, d, f, c, l, p, v, m, y, N, x, M, H, $, j, w, S, k;
  var init_colord = __esm({
    "node_modules/colord/index.mjs"() {
      r = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) };
      t = function(r2) {
        return "string" == typeof r2 ? r2.length > 0 : "number" == typeof r2;
      };
      n = function(r2, t2, n2) {
        return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = Math.pow(10, t2)), Math.round(n2 * r2) / n2 + 0;
      };
      e = function(r2, t2, n2) {
        return void 0 === t2 && (t2 = 0), void 0 === n2 && (n2 = 1), r2 > n2 ? n2 : r2 > t2 ? r2 : t2;
      };
      u = function(r2) {
        return (r2 = isFinite(r2) ? r2 % 360 : 0) > 0 ? r2 : r2 + 360;
      };
      a = function(r2) {
        return { r: e(r2.r, 0, 255), g: e(r2.g, 0, 255), b: e(r2.b, 0, 255), a: e(r2.a) };
      };
      o = function(r2) {
        return { r: n(r2.r), g: n(r2.g), b: n(r2.b), a: n(r2.a, 3) };
      };
      i = /^#([0-9a-f]{3,8})$/i;
      s = function(r2) {
        var t2 = r2.toString(16);
        return t2.length < 2 ? "0" + t2 : t2;
      };
      h = function(r2) {
        var t2 = r2.r, n2 = r2.g, e2 = r2.b, u2 = r2.a, a2 = Math.max(t2, n2, e2), o2 = a2 - Math.min(t2, n2, e2), i2 = o2 ? a2 === t2 ? (n2 - e2) / o2 : a2 === n2 ? 2 + (e2 - t2) / o2 : 4 + (t2 - n2) / o2 : 0;
        return { h: 60 * (i2 < 0 ? i2 + 6 : i2), s: a2 ? o2 / a2 * 100 : 0, v: a2 / 255 * 100, a: u2 };
      };
      b = function(r2) {
        var t2 = r2.h, n2 = r2.s, e2 = r2.v, u2 = r2.a;
        t2 = t2 / 360 * 6, n2 /= 100, e2 /= 100;
        var a2 = Math.floor(t2), o2 = e2 * (1 - n2), i2 = e2 * (1 - (t2 - a2) * n2), s2 = e2 * (1 - (1 - t2 + a2) * n2), h2 = a2 % 6;
        return { r: 255 * [e2, i2, o2, o2, s2, e2][h2], g: 255 * [s2, e2, e2, i2, o2, o2][h2], b: 255 * [o2, o2, s2, e2, e2, i2][h2], a: u2 };
      };
      g = function(r2) {
        return { h: u(r2.h), s: e(r2.s, 0, 100), l: e(r2.l, 0, 100), a: e(r2.a) };
      };
      d = function(r2) {
        return { h: n(r2.h), s: n(r2.s), l: n(r2.l), a: n(r2.a, 3) };
      };
      f = function(r2) {
        return b((n2 = (t2 = r2).s, { h: t2.h, s: (n2 *= ((e2 = t2.l) < 50 ? e2 : 100 - e2) / 100) > 0 ? 2 * n2 / (e2 + n2) * 100 : 0, v: e2 + n2, a: t2.a }));
        var t2, n2, e2;
      };
      c = function(r2) {
        return { h: (t2 = h(r2)).h, s: (u2 = (200 - (n2 = t2.s)) * (e2 = t2.v) / 100) > 0 && u2 < 200 ? n2 * e2 / 100 / (u2 <= 100 ? u2 : 200 - u2) * 100 : 0, l: u2 / 2, a: t2.a };
        var t2, n2, e2, u2;
      };
      l = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      p = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      v = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      m = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i;
      y = { string: [[function(r2) {
        var t2 = i.exec(r2);
        return t2 ? (r2 = t2[1]).length <= 4 ? { r: parseInt(r2[0] + r2[0], 16), g: parseInt(r2[1] + r2[1], 16), b: parseInt(r2[2] + r2[2], 16), a: 4 === r2.length ? n(parseInt(r2[3] + r2[3], 16) / 255, 2) : 1 } : 6 === r2.length || 8 === r2.length ? { r: parseInt(r2.substr(0, 2), 16), g: parseInt(r2.substr(2, 2), 16), b: parseInt(r2.substr(4, 2), 16), a: 8 === r2.length ? n(parseInt(r2.substr(6, 2), 16) / 255, 2) : 1 } : null : null;
      }, "hex"], [function(r2) {
        var t2 = v.exec(r2) || m.exec(r2);
        return t2 ? t2[2] !== t2[4] || t2[4] !== t2[6] ? null : a({ r: Number(t2[1]) / (t2[2] ? 100 / 255 : 1), g: Number(t2[3]) / (t2[4] ? 100 / 255 : 1), b: Number(t2[5]) / (t2[6] ? 100 / 255 : 1), a: void 0 === t2[7] ? 1 : Number(t2[7]) / (t2[8] ? 100 : 1) }) : null;
      }, "rgb"], [function(t2) {
        var n2 = l.exec(t2) || p.exec(t2);
        if (!n2) return null;
        var e2, u2, a2 = g({ h: (e2 = n2[1], u2 = n2[2], void 0 === u2 && (u2 = "deg"), Number(e2) * (r[u2] || 1)), s: Number(n2[3]), l: Number(n2[4]), a: void 0 === n2[5] ? 1 : Number(n2[5]) / (n2[6] ? 100 : 1) });
        return f(a2);
      }, "hsl"]], object: [[function(r2) {
        var n2 = r2.r, e2 = r2.g, u2 = r2.b, o2 = r2.a, i2 = void 0 === o2 ? 1 : o2;
        return t(n2) && t(e2) && t(u2) ? a({ r: Number(n2), g: Number(e2), b: Number(u2), a: Number(i2) }) : null;
      }, "rgb"], [function(r2) {
        var n2 = r2.h, e2 = r2.s, u2 = r2.l, a2 = r2.a, o2 = void 0 === a2 ? 1 : a2;
        if (!t(n2) || !t(e2) || !t(u2)) return null;
        var i2 = g({ h: Number(n2), s: Number(e2), l: Number(u2), a: Number(o2) });
        return f(i2);
      }, "hsl"], [function(r2) {
        var n2 = r2.h, a2 = r2.s, o2 = r2.v, i2 = r2.a, s2 = void 0 === i2 ? 1 : i2;
        if (!t(n2) || !t(a2) || !t(o2)) return null;
        var h2 = (function(r3) {
          return { h: u(r3.h), s: e(r3.s, 0, 100), v: e(r3.v, 0, 100), a: e(r3.a) };
        })({ h: Number(n2), s: Number(a2), v: Number(o2), a: Number(s2) });
        return b(h2);
      }, "hsv"]] };
      N = function(r2, t2) {
        for (var n2 = 0; n2 < t2.length; n2++) {
          var e2 = t2[n2][0](r2);
          if (e2) return [e2, t2[n2][1]];
        }
        return [null, void 0];
      };
      x = function(r2) {
        return "string" == typeof r2 ? N(r2.trim(), y.string) : "object" == typeof r2 && null !== r2 ? N(r2, y.object) : [null, void 0];
      };
      M = function(r2, t2) {
        var n2 = c(r2);
        return { h: n2.h, s: e(n2.s + 100 * t2, 0, 100), l: n2.l, a: n2.a };
      };
      H = function(r2) {
        return (299 * r2.r + 587 * r2.g + 114 * r2.b) / 1e3 / 255;
      };
      $ = function(r2, t2) {
        var n2 = c(r2);
        return { h: n2.h, s: n2.s, l: e(n2.l + 100 * t2, 0, 100), a: n2.a };
      };
      j = (function() {
        function r2(r3) {
          this.parsed = x(r3)[0], this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 };
        }
        return r2.prototype.isValid = function() {
          return null !== this.parsed;
        }, r2.prototype.brightness = function() {
          return n(H(this.rgba), 2);
        }, r2.prototype.isDark = function() {
          return H(this.rgba) < 0.5;
        }, r2.prototype.isLight = function() {
          return H(this.rgba) >= 0.5;
        }, r2.prototype.toHex = function() {
          return r3 = o(this.rgba), t2 = r3.r, e2 = r3.g, u2 = r3.b, i2 = (a2 = r3.a) < 1 ? s(n(255 * a2)) : "", "#" + s(t2) + s(e2) + s(u2) + i2;
          var r3, t2, e2, u2, a2, i2;
        }, r2.prototype.toRgb = function() {
          return o(this.rgba);
        }, r2.prototype.toRgbString = function() {
          return r3 = o(this.rgba), t2 = r3.r, n2 = r3.g, e2 = r3.b, (u2 = r3.a) < 1 ? "rgba(" + t2 + ", " + n2 + ", " + e2 + ", " + u2 + ")" : "rgb(" + t2 + ", " + n2 + ", " + e2 + ")";
          var r3, t2, n2, e2, u2;
        }, r2.prototype.toHsl = function() {
          return d(c(this.rgba));
        }, r2.prototype.toHslString = function() {
          return r3 = d(c(this.rgba)), t2 = r3.h, n2 = r3.s, e2 = r3.l, (u2 = r3.a) < 1 ? "hsla(" + t2 + ", " + n2 + "%, " + e2 + "%, " + u2 + ")" : "hsl(" + t2 + ", " + n2 + "%, " + e2 + "%)";
          var r3, t2, n2, e2, u2;
        }, r2.prototype.toHsv = function() {
          return r3 = h(this.rgba), { h: n(r3.h), s: n(r3.s), v: n(r3.v), a: n(r3.a, 3) };
          var r3;
        }, r2.prototype.invert = function() {
          return w({ r: 255 - (r3 = this.rgba).r, g: 255 - r3.g, b: 255 - r3.b, a: r3.a });
          var r3;
        }, r2.prototype.saturate = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, r3));
        }, r2.prototype.desaturate = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w(M(this.rgba, -r3));
        }, r2.prototype.grayscale = function() {
          return w(M(this.rgba, -1));
        }, r2.prototype.lighten = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w($(this.rgba, r3));
        }, r2.prototype.darken = function(r3) {
          return void 0 === r3 && (r3 = 0.1), w($(this.rgba, -r3));
        }, r2.prototype.rotate = function(r3) {
          return void 0 === r3 && (r3 = 15), this.hue(this.hue() + r3);
        }, r2.prototype.alpha = function(r3) {
          return "number" == typeof r3 ? w({ r: (t2 = this.rgba).r, g: t2.g, b: t2.b, a: r3 }) : n(this.rgba.a, 3);
          var t2;
        }, r2.prototype.hue = function(r3) {
          var t2 = c(this.rgba);
          return "number" == typeof r3 ? w({ h: r3, s: t2.s, l: t2.l, a: t2.a }) : n(t2.h);
        }, r2.prototype.isEqual = function(r3) {
          return this.toHex() === w(r3).toHex();
        }, r2;
      })();
      w = function(r2) {
        return r2 instanceof j ? r2 : new j(r2);
      };
      S = [];
      k = function(r2) {
        r2.forEach(function(r3) {
          S.indexOf(r3) < 0 && (r3(j, y), S.push(r3));
        });
      };
    }
  });

  // node_modules/colord/plugins/names.mjs
  function names_default(e2, f2) {
    var a2 = { white: "#ffffff", bisque: "#ffe4c4", blue: "#0000ff", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", antiquewhite: "#faebd7", aqua: "#00ffff", azure: "#f0ffff", whitesmoke: "#f5f5f5", papayawhip: "#ffefd5", plum: "#dda0dd", blanchedalmond: "#ffebcd", black: "#000000", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", cornsilk: "#fff8dc", cornflowerblue: "#6495ed", burlywood: "#deb887", aquamarine: "#7fffd4", beige: "#f5f5dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkkhaki: "#bdb76b", darkgray: "#a9a9a9", darkgreen: "#006400", darkgrey: "#a9a9a9", peachpuff: "#ffdab9", darkmagenta: "#8b008b", darkred: "#8b0000", darkorchid: "#9932cc", darkorange: "#ff8c00", darkslateblue: "#483d8b", gray: "#808080", darkslategray: "#2f4f4f", darkslategrey: "#2f4f4f", deeppink: "#ff1493", deepskyblue: "#00bfff", wheat: "#f5deb3", firebrick: "#b22222", floralwhite: "#fffaf0", ghostwhite: "#f8f8ff", darkviolet: "#9400d3", magenta: "#ff00ff", green: "#008000", dodgerblue: "#1e90ff", grey: "#808080", honeydew: "#f0fff0", hotpink: "#ff69b4", blueviolet: "#8a2be2", forestgreen: "#228b22", lawngreen: "#7cfc00", indianred: "#cd5c5c", indigo: "#4b0082", fuchsia: "#ff00ff", brown: "#a52a2a", maroon: "#800000", mediumblue: "#0000cd", lightcoral: "#f08080", darkturquoise: "#00ced1", lightcyan: "#e0ffff", ivory: "#fffff0", lightyellow: "#ffffe0", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", linen: "#faf0e6", mediumaquamarine: "#66cdaa", lemonchiffon: "#fffacd", lime: "#00ff00", khaki: "#f0e68c", mediumseagreen: "#3cb371", limegreen: "#32cd32", mediumspringgreen: "#00fa9a", lightskyblue: "#87cefa", lightblue: "#add8e6", midnightblue: "#191970", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", mintcream: "#f5fffa", lightslategray: "#778899", lightslategrey: "#778899", navajowhite: "#ffdead", navy: "#000080", mediumvioletred: "#c71585", powderblue: "#b0e0e6", palegoldenrod: "#eee8aa", oldlace: "#fdf5e6", paleturquoise: "#afeeee", mediumturquoise: "#48d1cc", mediumorchid: "#ba55d3", rebeccapurple: "#663399", lightsteelblue: "#b0c4de", mediumslateblue: "#7b68ee", thistle: "#d8bfd8", tan: "#d2b48c", orchid: "#da70d6", mediumpurple: "#9370db", purple: "#800080", pink: "#ffc0cb", skyblue: "#87ceeb", springgreen: "#00ff7f", palegreen: "#98fb98", red: "#ff0000", yellow: "#ffff00", slateblue: "#6a5acd", lavenderblush: "#fff0f5", peru: "#cd853f", palevioletred: "#db7093", violet: "#ee82ee", teal: "#008080", slategray: "#708090", slategrey: "#708090", aliceblue: "#f0f8ff", darkseagreen: "#8fbc8f", darkolivegreen: "#556b2f", greenyellow: "#adff2f", seagreen: "#2e8b57", seashell: "#fff5ee", tomato: "#ff6347", silver: "#c0c0c0", sienna: "#a0522d", lavender: "#e6e6fa", lightgreen: "#90ee90", orange: "#ffa500", orangered: "#ff4500", steelblue: "#4682b4", royalblue: "#4169e1", turquoise: "#40e0d0", yellowgreen: "#9acd32", salmon: "#fa8072", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", darksalmon: "#e9967a", lightgoldenrodyellow: "#fafad2", snow: "#fffafa", lightgrey: "#d3d3d3", lightgray: "#d3d3d3", dimgray: "#696969", dimgrey: "#696969", olivedrab: "#6b8e23", olive: "#808000" }, r2 = {};
    for (var d3 in a2) r2[a2[d3]] = d3;
    var l2 = {};
    e2.prototype.toName = function(f3) {
      if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
      var d4, i2, n2 = r2[this.toHex()];
      if (n2) return n2;
      if (null == f3 ? void 0 : f3.closest) {
        var o2 = this.toRgb(), t2 = 1 / 0, b2 = "black";
        if (!l2.length) for (var c2 in a2) l2[c2] = new e2(a2[c2]).toRgb();
        for (var g2 in a2) {
          var u2 = (d4 = o2, i2 = l2[g2], Math.pow(d4.r - i2.r, 2) + Math.pow(d4.g - i2.g, 2) + Math.pow(d4.b - i2.b, 2));
          u2 < t2 && (t2 = u2, b2 = g2);
        }
        return b2;
      }
    };
    f2.string.push([function(f3) {
      var r3 = f3.toLowerCase(), d4 = "transparent" === r3 ? "#0000" : a2[r3];
      return d4 ? new e2(d4).toRgb() : null;
    }, "name"]);
  }
  var init_names = __esm({
    "node_modules/colord/plugins/names.mjs"() {
    }
  });

  // node_modules/d3-array/src/ascending.js
  function ascending(a2, b2) {
    return a2 == null || b2 == null ? NaN : a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
  }
  var init_ascending = __esm({
    "node_modules/d3-array/src/ascending.js"() {
    }
  });

  // node_modules/d3-array/src/max.js
  function max2(values, valueof) {
    let max3;
    if (valueof === void 0) {
      for (const value of values) {
        if (value != null && (max3 < value || max3 === void 0 && value >= value)) {
          max3 = value;
        }
      }
    } else {
      let index3 = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index3, values)) != null && (max3 < value || max3 === void 0 && value >= value)) {
          max3 = value;
        }
      }
    }
    return max3;
  }
  var init_max = __esm({
    "node_modules/d3-array/src/max.js"() {
    }
  });

  // node_modules/d3-array/src/index.js
  var init_src = __esm({
    "node_modules/d3-array/src/index.js"() {
      init_ascending();
      init_max();
    }
  });

  // node_modules/react-msaview/dist/util.js
  function transform(obj, cb) {
    return Object.fromEntries(Object.entries(obj).map(cb));
  }
  function colorContrast(colorScheme, theme) {
    return transform(colorScheme, ([letter, color]) => [
      letter,
      theme.palette.getContrastText(w(color).toHex())
    ]);
  }
  function skipBlanks(blanks, arg) {
    if (blanks.length === 0) {
      return typeof arg === "string" ? arg : arg.join("");
    }
    const chunks = [];
    let lastEnd = 0;
    for (const blankIdx of blanks) {
      if (blankIdx > lastEnd) {
        chunks.push(typeof arg === "string" ? arg.slice(lastEnd, blankIdx) : arg.slice(lastEnd, blankIdx).join(""));
      }
      lastEnd = blankIdx + 1;
    }
    if (lastEnd < arg.length) {
      chunks.push(typeof arg === "string" ? arg.slice(lastEnd) : arg.slice(lastEnd).join(""));
    }
    return chunks.join("");
  }
  function setBrLength(d3, y0, k2) {
    d3.len = (y0 += Math.max(d3.data.length || 0, 0)) * k2;
    if (d3.children) {
      d3.children.forEach((d4) => {
        setBrLength(d4, y0, k2);
      });
    }
  }
  function maxLength(d3) {
    return (d3.data.length || 0) + (d3.children ? max2(d3.children, maxLength) || 0 : 0);
  }
  function collapse(d3) {
    if (d3.children) {
      d3._children = d3.children;
      d3.children = null;
    }
  }
  function len(a2) {
    return a2.end - a2.start;
  }
  function isBlank(s2) {
    return s2 === "-" || s2 === ".";
  }
  var init_util = __esm({
    "node_modules/react-msaview/dist/util.js"() {
      init_colord();
      init_names();
      init_src();
      k([names_default]);
    }
  });

  // node_modules/react-msaview/dist/colorSchemes.js
  var colorSchemes, colorSchemes_default;
  var init_colorSchemes = __esm({
    "node_modules/react-msaview/dist/colorSchemes.js"() {
      init_colors();
      init_colord();
      init_names();
      init_util();
      k([names_default]);
      colorSchemes = {
        none: {},
        clustal: {
          G: "orange",
          P: "orange",
          S: "orange",
          T: "orange",
          H: "red",
          K: "red",
          R: "red",
          F: "blue",
          W: "blue",
          Y: "blue",
          I: "green",
          L: "green",
          M: "green",
          V: "green"
        },
        lesk: {
          G: "orange",
          A: "orange",
          S: "orange",
          T: "orange",
          C: "green",
          V: "green",
          I: "green",
          L: "green",
          P: "green",
          F: "green",
          Y: "green",
          M: "green",
          W: "green",
          N: "magenta",
          Q: "magenta",
          H: "magenta",
          D: "red",
          E: "red",
          K: "blue",
          R: "blue"
        },
        maeditor: {
          A: "lightgreen",
          G: "lightgreen",
          C: "green",
          D: "darkgreen",
          E: "darkgreen",
          N: "darkgreen",
          Q: "darkgreen",
          I: "blue",
          L: "blue",
          M: "blue",
          V: "blue",
          F: "#c8a2c8",
          W: "#c8a2c8",
          Y: "#c8a2c8",
          H: "darkblue",
          K: "orange",
          R: "orange",
          P: "pink",
          S: "red",
          T: "red"
        },
        percent_identity_dynamic: {},
        // https://github.com/biotite-dev/biotite/blob/8c460972f8ab904312f130dfb80f3efc8c9bd7c5/src/biotite/sequence/graphics/color_schemes/flower.json
        flower: {
          A: "#b18a51",
          C: "#ff5701",
          D: "#01a578",
          E: "#2da0a1",
          F: "#fa559d",
          G: "#b1c23c",
          H: "#0194f9",
          I: "#f27663",
          K: "#7fc3d7",
          L: "#df6e75",
          M: "#fe9daf",
          N: "#0bcec6",
          P: "#4fa32a",
          Q: "#7295ae",
          R: "#83bff1",
          S: "#b4bd9b",
          T: "#d2b576",
          V: "#fd997b",
          W: "#ff2ded",
          Y: "#c96ecf"
        },
        rainbow_dna: {
          A: "#3737f5",
          C: "#37f537",
          G: "#f5f537",
          T: "#f53737",
          U: "#f53737"
        },
        // https://github.com/biotite-dev/biotite/blob/8c460972f8ab904312f130dfb80f3efc8c9bd7c5/src/biotite/sequence/graphics/color_schemes/clustalx_protein.json
        clustalx_protein: {
          A: "#197fe5",
          C: "#e57f7f",
          D: "#cc4ccc",
          E: "#cc4ccc",
          F: "#197fe5",
          G: "#e5994c",
          H: "#19b2b2",
          I: "#197fe5",
          K: "#e53319",
          L: "#197fe5",
          M: "#197fe5",
          N: "#19cc19",
          P: "#cccc00",
          Q: "#19cc19",
          R: "#e53319",
          S: "#19cc19",
          T: "#19cc19",
          V: "#197fe5",
          W: "#197fe5",
          Y: "#19b2b2"
        },
        // this has special handling
        clustalx_protein_dynamic: {},
        clustalx_dna: {
          A: "#e53319",
          C: "#197fe5",
          G: "#e5994c",
          T: "#19cc19",
          U: "#19cc19"
        },
        jbrowse_dna: {
          A: green_default[500],
          C: blue_default[500],
          G: orange_default[500],
          T: red_default[500],
          U: red_default[500]
        },
        jalview_buried: {
          A: "#00a35c",
          R: "#00fc03",
          N: "#00eb14",
          D: "#00eb14",
          C: "#0000ff",
          Q: "#00f10e",
          E: "#00f10e",
          G: "#009d62",
          H: "#00d52a",
          I: "#0054ab",
          L: "#007b84",
          K: "#00ff00",
          M: "#009768",
          F: "#008778",
          P: "#00e01f",
          S: "#00d52a",
          T: "#00db24",
          W: "#00a857",
          Y: "#00e619",
          V: "#005fa0",
          B: "#00eb14",
          X: "#00b649",
          Z: "#00f10e"
        },
        jalview_hydrophobicity: {
          A: "#ad0052",
          R: "#0000ff",
          N: "#0c00f3",
          D: "#0c00f3",
          C: "#c2003d",
          Q: "#0c00f3",
          E: "#0c00f3",
          G: "#6a0095",
          H: "#1500ea",
          I: "#ff0000",
          L: "#ea0015",
          K: "#0000ff",
          M: "#b0004f",
          F: "#cb0034",
          P: "#4600b9",
          S: "#5e00a1",
          T: "#61009e",
          W: "#5b00a4",
          Y: "#4f00b0",
          V: "#f60009",
          B: "#0c00f3",
          X: "#680097",
          Z: "#0c00f3"
        },
        jalview_prophelix: {
          A: "#e718e7",
          R: "#6f906f",
          N: "#1be41b",
          D: "#778877",
          C: "#23dc23",
          Q: "#926d92",
          E: "#ff00ff",
          G: "#00ff00",
          H: "#758a75",
          I: "#8a758a",
          L: "#ae51ae",
          K: "#a05fa0",
          M: "#ef10ef",
          F: "#986798",
          P: "#00ff00",
          S: "#36c936",
          T: "#47b847",
          W: "#8a758a",
          Y: "#21de21",
          V: "#857a85",
          B: "#49b649",
          X: "#758a75",
          Z: "#c936c9"
        },
        jalview_propstrand: {
          A: "#5858a7",
          R: "#6b6b94",
          N: "#64649b",
          D: "#2121de",
          C: "#9d9d62",
          Q: "#8c8c73",
          E: "#0000ff",
          G: "#4949b6",
          H: "#60609f",
          I: "#ecec13",
          L: "#b2b24d",
          K: "#4747b8",
          M: "#82827d",
          F: "#c2c23d",
          P: "#2323dc",
          S: "#4949b6",
          T: "#9d9d62",
          W: "#c0c03f",
          Y: "#d3d32c",
          V: "#ffff00",
          B: "#4343bc",
          X: "#797986",
          Z: "#4747b8"
        },
        jalview_propturn: {
          A: "#2cd3d3",
          R: "#708f8f",
          N: "#ff0000",
          D: "#e81717",
          C: "#a85757",
          Q: "#3fc0c0",
          E: "#778888",
          G: "#ff0000",
          H: "#708f8f",
          I: "#00ffff",
          L: "#1ce3e3",
          K: "#7e8181",
          M: "#1ee1e1",
          F: "#1ee1e1",
          P: "#f60909",
          S: "#e11e1e",
          T: "#738c8c",
          W: "#738c8c",
          Y: "#9d6262",
          V: "#07f8f8",
          B: "#f30c0c",
          X: "#7c8383",
          Z: "#5ba4a4"
        },
        jalview_taylor: {
          A: "#ccff00",
          R: "#0000ff",
          N: "#cc00ff",
          D: "#ff0000",
          C: "#ffff00",
          Q: "#ff00cc",
          E: "#ff0066",
          G: "#ff9900",
          H: "#0066ff",
          I: "#66ff00",
          L: "#33ff00",
          K: "#6600ff",
          M: "#00ff00",
          F: "#00ff66",
          P: "#ffcc00",
          S: "#ff3300",
          T: "#ff6600",
          W: "#00ccff",
          Y: "#00ffcc",
          V: "#99ff00"
        },
        jalview_zappo: {
          A: "#ffafaf",
          R: "#6464ff",
          N: "#00ff00",
          D: "#ff0000",
          C: "#ffff00",
          Q: "#00ff00",
          E: "#ff0000",
          G: "#ff00ff",
          H: "#6464ff",
          I: "#ffafaf",
          L: "#ffafaf",
          K: "#6464ff",
          M: "#ffafaf",
          F: "#ffc800",
          P: "#ff00ff",
          S: "#00ff00",
          T: "#00ff00",
          W: "#ffc800",
          Y: "#ffc800",
          V: "#ffafaf"
        },
        cinema: {
          H: "blue",
          K: "blue",
          R: "blue",
          D: "red",
          E: "red",
          S: "green",
          T: "green",
          N: "green",
          Q: "green",
          A: "white",
          V: "white",
          L: "white",
          I: "white",
          M: "white",
          F: "magenta",
          W: "magenta",
          Y: "magenta",
          P: "brown",
          G: "brown",
          C: "yellow",
          B: "gray",
          Z: "gray",
          X: "gray",
          "-": "gray",
          ".": "gray"
        }
      };
      colorSchemes_default = transform(colorSchemes, ([key, val]) => [
        key,
        transform(val, ([letter, color]) => [letter, w(color).toHex()])
      ]);
    }
  });

  // node_modules/react-msaview/dist/components/dialogs/SettingsDialog.js
  var SettingsDialog_exports = {};
  __export(SettingsDialog_exports, {
    default: () => SettingsDialog_default
  });
  var import_react45, import_ui11, import_material22, import_mobx_react17, import_mui13, useStyles14, toP, SettingsContent, TreeSettings, MSASettings, SettingsDialog, SettingsDialog_default;
  var init_SettingsDialog = __esm({
    "node_modules/react-msaview/dist/components/dialogs/SettingsDialog.js"() {
      import_react45 = __toESM(require_react());
      import_ui11 = __toESM(require_ui());
      import_material22 = __toESM(require_material());
      import_mobx_react17 = __toESM(require_mobx_react());
      import_mui13 = __toESM(require_mui());
      init_colorSchemes();
      init_Checkbox2();
      useStyles14 = (0, import_mui13.makeStyles)()((theme) => ({
        field: {
          margin: theme.spacing(4)
        },
        flex: {
          display: "flex"
        },
        minw: {
          width: "80em"
        }
      }));
      toP = (s2 = 0) => +s2.toFixed(1);
      SettingsContent = (0, import_mobx_react17.observer)(function({ model }) {
        return import_react45.default.createElement(
          import_react45.default.Fragment,
          null,
          import_react45.default.createElement(TreeSettings, { model }),
          import_react45.default.createElement(MSASettings, { model })
        );
      });
      TreeSettings = (0, import_mobx_react17.observer)(function TreeSettings2({ model }) {
        const { classes } = useStyles14();
        const { drawTree, drawLabels, drawNodeBubbles, labelsAlignRight, noTree, showBranchLen, treeWidthMatchesArea, treeWidth } = model;
        return import_react45.default.createElement(
          "div",
          null,
          import_react45.default.createElement("h1", null, "Tree options"),
          import_react45.default.createElement(Checkbox2, { checked: showBranchLen, label: "Show branch length?", onChange: () => {
            model.setShowBranchLen(!showBranchLen);
          } }),
          import_react45.default.createElement(Checkbox2, { checked: drawNodeBubbles, label: "Draw clickable bubbles on tree branches?", onChange: () => {
            model.setDrawNodeBubbles(!drawNodeBubbles);
          } }),
          import_react45.default.createElement(Checkbox2, { checked: drawTree, label: "Show tree?", onChange: () => {
            model.setDrawTree(!drawTree);
          } }),
          import_react45.default.createElement(Checkbox2, { checked: labelsAlignRight, label: "Tree labels align right?", onChange: () => {
            model.setLabelsAlignRight(!labelsAlignRight);
          } }),
          import_react45.default.createElement(Checkbox2, { checked: drawLabels, label: "Draw labels", onChange: () => {
            model.setDrawLabels(!drawLabels);
          } }),
          noTree ? null : import_react45.default.createElement(
            "div",
            null,
            import_react45.default.createElement(Checkbox2, { checked: treeWidthMatchesArea, label: "Make tree width fit to tree area?", onChange: () => {
              model.setTreeWidthMatchesArea(!treeWidthMatchesArea);
            } }),
            treeWidthMatchesArea ? null : import_react45.default.createElement(
              "div",
              { className: classes.flex },
              import_react45.default.createElement(
                import_material22.Typography,
                null,
                "Tree width (",
                treeWidth,
                "px)"
              ),
              import_react45.default.createElement(import_material22.Slider, { className: classes.field, min: 50, max: 600, value: treeWidth, onChange: (_, val) => {
                model.setTreeWidth(val);
              } })
            )
          )
        );
      });
      MSASettings = (0, import_mobx_react17.observer)(function MSASettings2({ model }) {
        const { classes } = useStyles14();
        const { bgColor, contrastLettering, colWidth, allowedGappyness, drawMsaLetters, colorSchemeName, hideGaps, rowHeight } = model;
        return import_react45.default.createElement(
          "div",
          null,
          import_react45.default.createElement("h1", null, "MSA options"),
          import_react45.default.createElement(Checkbox2, { checked: drawMsaLetters, label: "Draw letters", onChange: () => {
            model.setDrawMsaLetters(!drawMsaLetters);
          } }),
          import_react45.default.createElement(Checkbox2, { checked: bgColor, label: "Color letters instead of background of tiles", onChange: () => {
            model.setBgColor(!bgColor);
          } }),
          import_react45.default.createElement(Checkbox2, { checked: contrastLettering, label: "Use contrast lettering", onChange: () => {
            model.setContrastLettering(!contrastLettering);
          } }),
          import_react45.default.createElement(Checkbox2, { checked: hideGaps, label: "Enable hiding gappy columns?", onChange: () => {
            model.setHideGaps(!hideGaps);
          } }),
          hideGaps ? import_react45.default.createElement(
            "div",
            { className: classes.flex },
            import_react45.default.createElement(
              import_material22.Typography,
              null,
              "Hide columns w/ >",
              allowedGappyness,
              "% gaps"
            ),
            import_react45.default.createElement(import_material22.Slider, { className: classes.field, min: 1, max: 100, value: allowedGappyness, onChange: (_, val) => {
              model.setAllowedGappyness(val);
            } })
          ) : null,
          import_react45.default.createElement(
            "div",
            { className: classes.flex },
            import_react45.default.createElement(
              import_material22.Typography,
              null,
              "Column width (",
              toP(colWidth),
              "px)"
            ),
            import_react45.default.createElement(import_material22.Slider, { className: classes.field, min: 1, max: 50, value: colWidth, onChange: (_, val) => {
              model.setColWidth(val);
            } })
          ),
          import_react45.default.createElement(
            "div",
            { className: classes.flex },
            import_react45.default.createElement(
              import_material22.Typography,
              null,
              "Row height (",
              toP(rowHeight),
              "px)"
            ),
            import_react45.default.createElement(import_material22.Slider, { className: classes.field, min: 1, max: 50, value: rowHeight, onChange: (_, val) => {
              model.setRowHeight(val);
            } })
          ),
          import_react45.default.createElement(import_material22.TextField, { select: true, label: "Color scheme", value: colorSchemeName, onChange: (event) => {
            model.setColorSchemeName(event.target.value);
          } }, Object.keys(colorSchemes_default).map((option) => import_react45.default.createElement(import_material22.MenuItem, { key: option, value: option }, option)))
        );
      });
      SettingsDialog = (0, import_mobx_react17.observer)(function({ model, onClose }) {
        const { classes } = useStyles14();
        return import_react45.default.createElement(
          import_ui11.Dialog,
          { open: true, title: "Settings", maxWidth: "xl", onClose: () => {
            onClose();
          } },
          import_react45.default.createElement(
            import_material22.DialogContent,
            { className: classes.minw },
            import_react45.default.createElement(SettingsContent, { model }),
            import_react45.default.createElement(
              import_material22.DialogActions,
              null,
              import_react45.default.createElement(import_material22.Button, { variant: "contained", color: "primary", onClick: () => {
                onClose();
              } }, "Submit")
            )
          )
        );
      });
      SettingsDialog_default = SettingsDialog;
    }
  });

  // node_modules/react-msaview/dist/fetchUtils.js
  async function myfetch(url, args) {
    const response = await fetch(url, args);
    if (!response.ok) {
      throw new Error(`HTTP ${response.status} fetching ${url} ${await response.text()}`);
    }
    return response;
  }
  async function textfetch2(url, args) {
    const response = await myfetch(url, args);
    return response.text();
  }
  async function jsonfetch2(url, args) {
    const response = await myfetch(url, args);
    return response.json();
  }
  function timeout2(time) {
    return new Promise((res) => setTimeout(res, time));
  }
  var init_fetchUtils = __esm({
    "node_modules/react-msaview/dist/fetchUtils.js"() {
    }
  });

  // node_modules/react-msaview/dist/components/dialogs/UserProvidedDomainsDialog.js
  var UserProvidedDomainsDialog_exports = {};
  __export(UserProvidedDomainsDialog_exports, {
    default: () => UserProvidedDomainsDialog_default
  });
  var import_react46, import_ui12, import_util26, import_material23, import_mobx_react18, UserProvidedDomainsDialog, UserProvidedDomainsDialog_default;
  var init_UserProvidedDomainsDialog = __esm({
    "node_modules/react-msaview/dist/components/dialogs/UserProvidedDomainsDialog.js"() {
      import_react46 = __toESM(require_react());
      import_ui12 = __toESM(require_ui());
      import_util26 = __toESM(require_util());
      import_material23 = __toESM(require_material());
      import_mobx_react18 = __toESM(require_mobx_react());
      init_fetchUtils();
      UserProvidedDomainsDialog = (0, import_mobx_react18.observer)(function({ handleClose, model }) {
        const [file, setFile] = (0, import_react46.useState)();
        const [choice, setChoice] = (0, import_react46.useState)("file");
        const [interProURL, setInterProURL] = (0, import_react46.useState)("");
        return import_react46.default.createElement(
          import_ui12.Dialog,
          { maxWidth: "xl", title: "Open protein domains from file", onClose: () => {
            handleClose();
          }, open: true },
          import_react46.default.createElement(
            import_material23.DialogContent,
            null,
            import_react46.default.createElement(
              "div",
              null,
              import_react46.default.createElement(import_material23.Typography, null, "Open a JSON file of InterProScan results that you run remotely on EBI servers or locally"),
              import_react46.default.createElement(
                "div",
                { style: { display: "flex", margin: 30 } },
                import_react46.default.createElement(
                  import_material23.FormControl,
                  { component: "fieldset" },
                  import_react46.default.createElement(
                    import_material23.RadioGroup,
                    { value: choice, onChange: (event) => {
                      setChoice(event.target.value);
                    } },
                    import_react46.default.createElement(import_material23.FormControlLabel, { value: "url", control: import_react46.default.createElement(import_material23.Radio, null), label: "URL" }),
                    import_react46.default.createElement(import_material23.FormControlLabel, { value: "file", control: import_react46.default.createElement(import_material23.Radio, null), label: "File" })
                  )
                ),
                choice === "url" ? import_react46.default.createElement(
                  "div",
                  null,
                  import_react46.default.createElement(import_material23.Typography, null, "Open a InterProScan JSON file remote URL"),
                  import_react46.default.createElement(import_material23.TextField, { label: "URL", value: interProURL, onChange: (event) => {
                    setInterProURL(event.target.value);
                  } })
                ) : null,
                choice === "file" ? import_react46.default.createElement(
                  "div",
                  { style: { paddingTop: 20 } },
                  import_react46.default.createElement(import_material23.Typography, null, "Open a InterProScan JSON file file from your local drive"),
                  import_react46.default.createElement(
                    import_material23.Button,
                    { variant: "outlined", component: "label" },
                    "Choose File",
                    import_react46.default.createElement("input", { type: "file", hidden: true, onChange: ({ target }) => {
                      const file2 = target.files?.[0];
                      if (file2) {
                        setFile(file2);
                      }
                    } })
                  )
                ) : null
              )
            )
          ),
          import_react46.default.createElement(
            import_material23.DialogActions,
            null,
            import_react46.default.createElement(import_material23.Button, { variant: "contained", color: "primary", onClick: () => {
              ;
              (async () => {
                try {
                  const ret = file ? JSON.parse(await file.text()) : await jsonfetch2(interProURL);
                  model.setInterProAnnotations(Object.fromEntries(ret.results.map((r2) => [r2.xref[0].id, r2])));
                  model.setShowDomains(true);
                  (0, import_util26.getSession)(model).notify("Loaded interproscan results", "success");
                } catch (e2) {
                  console.error(e2);
                  (0, import_util26.getSession)(model).notifyError(`${e2}`, e2);
                } finally {
                  model.setStatus();
                }
              })();
              handleClose();
            } }, "Open results")
          )
        );
      });
      UserProvidedDomainsDialog_default = UserProvidedDomainsDialog;
    }
  });

  // node_modules/react-msaview/dist/launchInterProScan.js
  async function runInterProScan({ seq, onProgress, onJobId, programs, model }) {
    const jobId = await textfetch2(`${base2}/iprscan5/run`, {
      method: "POST",
      body: new URLSearchParams({
        email: "colin.diesh@gmail.com",
        sequence: seq,
        programs: programs.join(",")
      })
    });
    onJobId?.(jobId);
    await wait({
      jobId,
      onProgress
    });
    await loadInterProScanResultsWithStatus({ jobId, model });
  }
  function loadInterProScanResults(jobId) {
    return jsonfetch2(`${base2}/iprscan5/result/${jobId}/json`);
  }
  async function wait({ onProgress, jobId }) {
    const url = `${base2}/iprscan5/status/${jobId}`;
    try {
      while (true) {
        for (let i2 = 0; i2 < 10; i2++) {
          await timeout2(1e3);
          onProgress({ msg: `Checking status ${10 - i2}`, url });
        }
        const result = await textfetch2(url);
        if (result.includes("FINISHED")) {
          break;
        }
        if (result.includes("FAILURE")) {
          throw new Error(`Failed to run: jobId ${jobId}`);
        }
      }
    } finally {
      onProgress();
    }
  }
  async function launchInterProScan({ algorithm, seq, programs, onJobId, onProgress, model }) {
    try {
      onProgress({ msg: `Launching ${algorithm} MSA` });
      if (algorithm === "interproscan") {
        await runInterProScan({
          seq,
          onJobId,
          onProgress,
          programs,
          model
        });
      }
      throw new Error("unknown algorithm");
    } finally {
      onProgress();
    }
  }
  async function loadInterProScanResultsWithStatus({ jobId, model }) {
    try {
      model.setStatus({
        msg: `Downloading results of ${jobId} (for larger sequences this can be slow, click status to download and upload in the manual tab)`,
        url: `https://www.ebi.ac.uk/Tools/services/rest/iprscan5/result/${jobId}/json`
      });
      const ret = await loadInterProScanResults(jobId);
      model.setInterProAnnotations(Object.fromEntries(ret.results.map((r2) => [r2.xref[0].id, r2])));
      model.setShowDomains(true);
      (0, import_util27.getSession)(model).notify(`Loaded interproscan ${jobId} results`, "success");
    } catch (e2) {
      console.error(e2);
      (0, import_util27.getSession)(model).notifyError(`${e2}`, e2);
    } finally {
      model.setStatus();
    }
  }
  var import_util27, base2;
  var init_launchInterProScan = __esm({
    "node_modules/react-msaview/dist/launchInterProScan.js"() {
      import_util27 = __toESM(require_util());
      init_fetchUtils();
      base2 = "https://www.ebi.ac.uk/Tools/services/rest";
    }
  });

  // node_modules/react-msaview/dist/components/dialogs/InterProScanDialog.js
  var InterProScanDialog_exports = {};
  __export(InterProScanDialog_exports, {
    default: () => InterProScanDialog_default
  });
  var import_react47, import_ui13, import_util28, import_material24, import_mobx_react19, InterProScanDialog, InterProScanDialog_default;
  var init_InterProScanDialog = __esm({
    "node_modules/react-msaview/dist/components/dialogs/InterProScanDialog.js"() {
      import_react47 = __toESM(require_react());
      import_ui13 = __toESM(require_ui());
      import_util28 = __toESM(require_util());
      import_material24 = __toESM(require_material());
      import_mobx_react19 = __toESM(require_mobx_react());
      init_launchInterProScan();
      InterProScanDialog = (0, import_mobx_react19.observer)(function({ handleClose, model }) {
        const [vals, setVals] = (0, import_react47.useState)([
          {
            name: "NCBIfam",
            description: "NCBI RefSeq FAMs including TIGRFAMs",
            category: "Families, domains, sites & repeats",
            checked: true
          },
          {
            name: "SFLD",
            description: "Structure function linkage database",
            category: "Families, domains, sites & repeats",
            checked: true
          },
          {
            name: "Phobius",
            checked: true,
            description: "A combined transmembrane topology and signal peptide predictor",
            category: "Other sequence features"
          },
          {
            name: "SignalP",
            checked: true,
            category: "Other sequence features"
          },
          {
            name: "SignalP_EUK",
            category: "Other category",
            checked: true
          },
          {
            name: "SignalP_GRAM_POSITIVE",
            category: "Other category",
            checked: true
          },
          {
            name: "SignalP_GRAM_NEGATIVE",
            checked: true,
            category: "Other category"
          },
          {
            name: "SUPERFAMILY",
            category: "Structural domains",
            checked: true
          },
          {
            name: "PANTHER",
            category: "Families, domains, sites & repeats",
            checked: true
          },
          {
            name: "Gene3D",
            category: "Structural domains",
            checked: true
          },
          {
            name: "Hamap",
            category: "Families, domains, sites & repeats",
            checked: true
          },
          {
            name: "ProSiteProfiles",
            category: "Families, domains, sites & repeats",
            checked: true
          },
          {
            name: "ProSitePatterns",
            category: "Families, domains, sites & repeats",
            checked: true
          },
          {
            name: "Coils",
            category: "Other sequence features",
            checked: true
          },
          {
            name: "SMART",
            category: "Families, domains, sites & repeats",
            checked: true
          },
          {
            name: "CDD",
            description: "Conserved Domains Database",
            category: "Families, domains, sites & repeats",
            checked: true
          },
          {
            name: "PRINTS",
            category: "Families, domains, sites & repeats",
            checked: true
          },
          {
            name: "Pfam",
            category: "Families, domains, sites & repeats",
            checked: true
          },
          {
            name: "MobiDBLite",
            checked: true,
            category: "Other sequence features"
          },
          {
            name: "PIRSF",
            checked: true,
            category: "Other category"
          },
          {
            name: "TMHMM",
            checked: true,
            category: "Other sequence features"
          },
          {
            name: "AntiFam",
            checked: true,
            category: "Other category"
          },
          {
            name: "FunFam",
            checked: true,
            category: "Other category"
          },
          {
            name: "PIRSR",
            checked: true,
            category: "Families, domains, sites & repeats"
          }
        ]);
        const programs = vals.filter((e2) => e2.checked).map((e2) => e2.name);
        const [show, setShow] = (0, import_react47.useState)(false);
        return import_react47.default.createElement(
          import_ui13.Dialog,
          { maxWidth: "xl", title: "Query InterProScan API for domains", onClose: () => {
            handleClose();
          }, open: true },
          import_react47.default.createElement(
            import_material24.DialogContent,
            null,
            import_react47.default.createElement(import_material24.Typography, null, "This will run InterProScan via the InterProScan API on all rows of the current MSA"),
            import_react47.default.createElement(
              import_material24.Button,
              { onClick: () => {
                setShow(!show);
              } },
              show ? "Hide" : "Show",
              " advanced options"
            ),
            show ? import_react47.default.createElement(
              "div",
              null,
              import_react47.default.createElement(import_material24.Typography, null, "Select algorithms for InterProScan to run"),
              import_react47.default.createElement(
                "div",
                null,
                import_react47.default.createElement(import_material24.Button, { variant: "contained", color: "secondary", onClick: () => {
                  setVals(vals.map((v2) => ({ ...v2, checked: false })));
                } }, "Select none"),
                import_react47.default.createElement(import_material24.Button, { variant: "contained", color: "primary", onClick: () => {
                  setVals(vals.map((v2) => ({ ...v2, checked: true })));
                } }, "Select all")
              ),
              import_react47.default.createElement(
                "table",
                null,
                import_react47.default.createElement("tbody", null, vals.toSorted((a2, b2) => a2.category.localeCompare(b2.category)).map(({ name, checked, category }) => import_react47.default.createElement(
                  "tr",
                  { key: name },
                  import_react47.default.createElement(
                    "td",
                    null,
                    import_react47.default.createElement("input", { type: "checkbox", key: name, checked, onChange: () => {
                      setVals(vals.map((e2) => e2.name === name ? { ...e2, checked: !e2.checked } : e2));
                    } })
                  ),
                  import_react47.default.createElement("td", null, name),
                  import_react47.default.createElement("td", null, category)
                )))
              )
            ) : null
          ),
          import_react47.default.createElement(
            import_material24.DialogActions,
            null,
            import_react47.default.createElement(import_material24.Button, { variant: "contained", color: "secondary", onClick: () => {
              handleClose();
            } }, "Cancel"),
            import_react47.default.createElement(import_material24.Button, { variant: "contained", color: "primary", onClick: () => {
              ;
              (async () => {
                try {
                  const { rows } = model;
                  if (rows.length > 140) {
                    throw new Error("Too many sequences, please run InterProScan offline");
                  }
                  await launchInterProScan({
                    algorithm: "interproscan",
                    programs,
                    seq: rows.map((row) => [row[0], row[1].replaceAll("-", "")]).filter((f2) => !!f2[1]).map((row) => `>${row[0]}
${row[1]}`).join("\n"),
                    onProgress: (arg) => {
                      model.setStatus(arg);
                    },
                    model
                  });
                } catch (e2) {
                  console.error(e2);
                  (0, import_util28.getSession)(model).notifyError(`${e2}`, e2);
                } finally {
                  model.setStatus();
                }
              })();
              handleClose();
            } }, "Send sequences to InterProScan")
          )
        );
      });
      InterProScanDialog_default = InterProScanDialog;
    }
  });

  // node_modules/react-msaview/dist/components/header/HeaderMenu.js
  var import_react48, import_CascadingMenuButton, import_mobx_react20, MetadataDialog2, ExportSVGDialog2, FeatureFilterDialog, SettingsDialog2, UserProvidedDomainsDialog2, InterProScanDialog2, HeaderMenu, HeaderMenu_default;
  var init_HeaderMenu = __esm({
    "node_modules/react-msaview/dist/components/header/HeaderMenu.js"() {
      import_react48 = __toESM(require_react());
      import_CascadingMenuButton = __toESM(require_CascadingMenuButton());
      init_AccountTree();
      init_Assignment();
      init_FilterAlt();
      init_FolderOpen();
      init_Menu();
      init_PhotoCamera();
      init_Search();
      init_Sort();
      init_Visibility();
      import_mobx_react20 = __toESM(require_mobx_react());
      MetadataDialog2 = (0, import_react48.lazy)(() => Promise.resolve().then(() => (init_MetadataDialog(), MetadataDialog_exports)));
      ExportSVGDialog2 = (0, import_react48.lazy)(() => Promise.resolve().then(() => (init_ExportSVGDialog(), ExportSVGDialog_exports)));
      FeatureFilterDialog = (0, import_react48.lazy)(() => Promise.resolve().then(() => (init_FeatureDialog(), FeatureDialog_exports)));
      SettingsDialog2 = (0, import_react48.lazy)(() => Promise.resolve().then(() => (init_SettingsDialog(), SettingsDialog_exports)));
      UserProvidedDomainsDialog2 = (0, import_react48.lazy)(() => Promise.resolve().then(() => (init_UserProvidedDomainsDialog(), UserProvidedDomainsDialog_exports)));
      InterProScanDialog2 = (0, import_react48.lazy)(() => Promise.resolve().then(() => (init_InterProScanDialog(), InterProScanDialog_exports)));
      HeaderMenu = (0, import_mobx_react20.observer)(({ model }) => {
        const { showDomains, actuallyShowDomains, subFeatureRows, noDomains, tracks, turnedOffTracks } = model;
        return import_react48.default.createElement(
          import_CascadingMenuButton.default,
          { menuItems: [
            {
              label: "Return to import form",
              icon: FolderOpen_default,
              onClick: () => {
                model.reset();
              }
            },
            {
              label: "Metadata",
              icon: Assignment_default,
              onClick: () => {
                model.queueDialog((onClose) => [
                  MetadataDialog2,
                  {
                    model,
                    onClose
                  }
                ]);
              }
            },
            {
              label: "More settings",
              onClick: () => {
                model.queueDialog((onClose) => [
                  SettingsDialog2,
                  {
                    model,
                    onClose
                  }
                ]);
              }
            },
            {
              label: "Tracks",
              icon: Visibility_default,
              type: "subMenu",
              subMenu: tracks.map((track) => ({
                label: track.model.name,
                type: "checkbox",
                checked: !turnedOffTracks.has(track.model.id),
                onClick: () => {
                  model.toggleTrack(track.model.id);
                }
              }))
            },
            {
              label: "Export SVG",
              icon: PhotoCamera_default,
              onClick: () => {
                model.queueDialog((onClose) => [
                  ExportSVGDialog2,
                  {
                    onClose,
                    model
                  }
                ]);
              }
            },
            ...model.rows.length >= 2 ? [
              {
                label: "Calculate neighbor joining tree (BLOSUM62)",
                icon: AccountTree_default,
                onClick: () => {
                  try {
                    model.calculateNeighborJoiningTreeFromMSA();
                  } catch (e2) {
                    console.error("Failed to calculate NJ tree:", e2);
                    model.setError(e2);
                  }
                }
              }
            ] : [],
            {
              label: "Features/protein domains",
              type: "subMenu",
              subMenu: [
                {
                  label: "Open domains...",
                  icon: FolderOpen_default,
                  onClick: () => {
                    model.queueDialog((handleClose) => [
                      UserProvidedDomainsDialog2,
                      {
                        handleClose,
                        model
                      }
                    ]);
                  }
                },
                {
                  label: "Query InterProScan for domains...",
                  icon: Search_default,
                  onClick: () => {
                    model.queueDialog((handleClose) => [
                      InterProScanDialog2,
                      {
                        handleClose,
                        model
                      }
                    ]);
                  }
                },
                {
                  label: `Show domains${noDomains ? " (no domains loaded)" : ""}`,
                  disabled: noDomains,
                  icon: Visibility_default,
                  checked: actuallyShowDomains ? showDomains : false,
                  type: "checkbox",
                  onClick: () => {
                    model.setShowDomains(!showDomains);
                  }
                },
                {
                  label: `Use sub-row layout${noDomains ? " (no domains loaded)" : ""}`,
                  disabled: noDomains,
                  checked: actuallyShowDomains ? subFeatureRows : false,
                  icon: Sort_default,
                  type: "checkbox",
                  onClick: () => {
                    model.setSubFeatureRows(!subFeatureRows);
                  }
                },
                {
                  label: `Filter domains${noDomains ? " (no domains loaded)" : ""}`,
                  icon: FilterAlt_default,
                  disabled: noDomains,
                  onClick: () => {
                    model.queueDialog((onClose) => [
                      FeatureFilterDialog,
                      {
                        onClose,
                        model
                      }
                    ]);
                  }
                }
              ]
            },
            ...model.extraViewMenuItems()
          ] },
          import_react48.default.createElement(Menu_default, null)
        );
      });
      HeaderMenu_default = HeaderMenu;
    }
  });

  // node_modules/react-msaview/dist/components/header/HeaderStatusArea.js
  var import_react49, import_ui14, import_material25, import_mobx_react21, import_mui14, useStyles15, HeaderStatusArea, HeaderStatusArea_default;
  var init_HeaderStatusArea = __esm({
    "node_modules/react-msaview/dist/components/header/HeaderStatusArea.js"() {
      import_react49 = __toESM(require_react());
      import_ui14 = __toESM(require_ui());
      import_material25 = __toESM(require_material());
      import_mobx_react21 = __toESM(require_mobx_react());
      import_mui14 = __toESM(require_mui());
      useStyles15 = (0, import_mui14.makeStyles)()({
        margin: {
          margin: "auto",
          marginLeft: 10
        }
      });
      HeaderStatusArea = (0, import_mobx_react21.observer)(({ model }) => {
        const { status } = model;
        const { classes } = useStyles15();
        return status ? import_react49.default.createElement(
          import_material25.Typography,
          { className: classes.margin },
          import_react49.default.createElement(import_ui14.LoadingEllipses, { message: status.msg, component: "span" }),
          " ",
          status.url ? import_react49.default.createElement("a", { href: status.url, target: "_blank", rel: "noreferrer" }, "(status)") : null
        ) : null;
      });
      HeaderStatusArea_default = HeaderStatusArea;
    }
  });

  // node_modules/react-msaview/dist/components/header/MultiAlignmentSelector.js
  var import_react50, import_material26, import_mobx_react22, MultiAlignmentSelector, MultiAlignmentSelector_default;
  var init_MultiAlignmentSelector = __esm({
    "node_modules/react-msaview/dist/components/header/MultiAlignmentSelector.js"() {
      import_react50 = __toESM(require_react());
      import_material26 = __toESM(require_material());
      import_mobx_react22 = __toESM(require_mobx_react());
      MultiAlignmentSelector = (0, import_mobx_react22.observer)(function({ model }) {
        const { currentAlignment, alignmentNames } = model;
        return alignmentNames.length > 0 ? import_react50.default.createElement(import_material26.TextField, { select: true, variant: "outlined", value: currentAlignment, size: "small", onChange: (event) => {
          model.setCurrentAlignment(+event.target.value);
          model.setScrollX(0);
          model.setScrollY(0);
        } }, alignmentNames.map((option, index3) => import_react50.default.createElement(import_material26.MenuItem, { key: `${option}-${index3}`, value: index3 }, option))) : null;
      });
      MultiAlignmentSelector_default = MultiAlignmentSelector;
    }
  });

  // node_modules/@mui/icons-material/esm/Palette.js
  var import_jsx_runtime17, Palette_default;
  var init_Palette = __esm({
    "node_modules/@mui/icons-material/esm/Palette.js"() {
      "use client";
      init_createSvgIcon();
      import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
      Palette_default = (0, import_utils.createSvgIcon)(/* @__PURE__ */ (0, import_jsx_runtime17.jsx)("path", {
        d: "M12 2C6.49 2 2 6.49 2 12s4.49 10 10 10c1.38 0 2.5-1.12 2.5-2.5 0-.61-.23-1.2-.64-1.67-.08-.1-.13-.21-.13-.33 0-.28.22-.5.5-.5H16c3.31 0 6-2.69 6-6 0-4.96-4.49-9-10-9m5.5 11c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5m-3-4c-.83 0-1.5-.67-1.5-1.5S13.67 6 14.5 6s1.5.67 1.5 1.5S15.33 9 14.5 9M5 11.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5S7.33 13 6.5 13 5 12.33 5 11.5m6-4c0 .83-.67 1.5-1.5 1.5S8 8.33 8 7.5 8.67 6 9.5 6s1.5.67 1.5 1.5"
      }), "Palette");
    }
  });

  // node_modules/react-msaview/dist/components/header/SettingsMenu.js
  var import_react51, import_CascadingMenuButton2, import_mobx_react23, SettingsMenu, SettingsMenu_default;
  var init_SettingsMenu = __esm({
    "node_modules/react-msaview/dist/components/header/SettingsMenu.js"() {
      import_react51 = __toESM(require_react());
      import_CascadingMenuButton2 = __toESM(require_CascadingMenuButton());
      init_AccountTree();
      init_Palette();
      init_Settings();
      import_mobx_react23 = __toESM(require_mobx_react());
      init_colorSchemes();
      SettingsMenu = (0, import_mobx_react23.observer)(function({ model }) {
        const { colorSchemeName, drawMsaLetters, contrastLettering, hideGaps, bgColor, drawTree, showBranchLen, labelsAlignRight, drawNodeBubbles, drawLabels, treeWidthMatchesArea, noTree } = model;
        return import_react51.default.createElement(
          import_CascadingMenuButton2.default,
          { closeAfterItemClick: false, menuItems: [
            {
              label: "Color scheme",
              icon: Palette_default,
              type: "subMenu",
              subMenu: Object.keys(colorSchemes_default).map((option) => ({
                label: option,
                type: "radio",
                checked: colorSchemeName === option,
                onClick: () => {
                  model.setColorSchemeName(option);
                }
              }))
            },
            {
              label: "MSA settings",
              type: "subMenu",
              subMenu: [
                {
                  label: "Draw letters",
                  type: "checkbox",
                  checked: drawMsaLetters,
                  onClick: () => {
                    model.setDrawMsaLetters(!drawMsaLetters);
                  }
                },
                {
                  label: "Color letters instead of background of tiles",
                  type: "checkbox",
                  checked: !bgColor,
                  onClick: () => {
                    model.setBgColor(!bgColor);
                  }
                },
                {
                  label: "Use contrast lettering",
                  type: "checkbox",
                  checked: contrastLettering,
                  onClick: () => {
                    model.setContrastLettering(!contrastLettering);
                  }
                },
                {
                  label: "Enable hiding gappy columns?",
                  type: "checkbox",
                  checked: hideGaps,
                  onClick: () => {
                    model.setHideGaps(!hideGaps);
                  }
                }
              ]
            },
            {
              label: "Tree settings",
              type: "subMenu",
              icon: AccountTree_default,
              subMenu: [
                {
                  label: "Show branch length",
                  type: "checkbox",
                  checked: showBranchLen,
                  onClick: () => {
                    model.setShowBranchLen(!showBranchLen);
                  }
                },
                {
                  label: "Show tree",
                  type: "checkbox",
                  checked: drawTree,
                  onClick: () => {
                    model.setDrawTree(!drawTree);
                  }
                },
                {
                  label: "Draw clickable bubbles on tree branches",
                  type: "checkbox",
                  checked: drawNodeBubbles,
                  onClick: () => {
                    model.setDrawNodeBubbles(!drawNodeBubbles);
                  }
                },
                {
                  label: "Tree labels align right",
                  type: "checkbox",
                  checked: labelsAlignRight,
                  onClick: () => {
                    model.setLabelsAlignRight(!labelsAlignRight);
                  }
                },
                {
                  label: "Draw labels",
                  type: "checkbox",
                  checked: drawLabels,
                  onClick: () => {
                    model.setDrawLabels(!drawLabels);
                  }
                },
                ...noTree ? [] : [
                  {
                    label: "Make tree width fit to tree area",
                    type: "checkbox",
                    checked: treeWidthMatchesArea,
                    onClick: () => {
                      model.setTreeWidthMatchesArea(!treeWidthMatchesArea);
                    }
                  }
                ]
              ]
            }
          ] },
          import_react51.default.createElement(Settings_default, null)
        );
      });
      SettingsMenu_default = SettingsMenu;
    }
  });

  // node_modules/@mui/icons-material/esm/ZoomIn.js
  var import_jsx_runtime18, ZoomIn_default;
  var init_ZoomIn = __esm({
    "node_modules/@mui/icons-material/esm/ZoomIn.js"() {
      "use client";
      init_createSvgIcon();
      import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
      ZoomIn_default = (0, import_utils.createSvgIcon)([/* @__PURE__ */ (0, import_jsx_runtime18.jsx)("path", {
        d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"
      }, "0"), /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("path", {
        d: "M12 10h-2v2H9v-2H7V9h2V7h1v2h2z"
      }, "1")], "ZoomIn");
    }
  });

  // node_modules/@mui/icons-material/esm/ZoomOut.js
  var import_jsx_runtime19, ZoomOut_default;
  var init_ZoomOut = __esm({
    "node_modules/@mui/icons-material/esm/ZoomOut.js"() {
      "use client";
      init_createSvgIcon();
      import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
      ZoomOut_default = (0, import_utils.createSvgIcon)(/* @__PURE__ */ (0, import_jsx_runtime19.jsx)("path", {
        d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14M7 9h5v1H7z"
      }), "ZoomOut");
    }
  });

  // node_modules/react-msaview/dist/components/header/ZoomControls.js
  var import_react52, import_material27, import_mobx_react24, ZoomControls, ZoomControls_default;
  var init_ZoomControls = __esm({
    "node_modules/react-msaview/dist/components/header/ZoomControls.js"() {
      import_react52 = __toESM(require_react());
      init_ZoomIn();
      init_ZoomOut();
      import_material27 = __toESM(require_material());
      import_mobx_react24 = __toESM(require_mobx_react());
      ZoomControls = (0, import_mobx_react24.observer)(function ZoomControls2({ model }) {
        return import_react52.default.createElement(
          import_react52.default.Fragment,
          null,
          import_react52.default.createElement(
            import_material27.IconButton,
            { onClick: () => {
              model.zoomIn();
            } },
            import_react52.default.createElement(ZoomIn_default, null)
          ),
          import_react52.default.createElement(
            import_material27.IconButton,
            { onClick: () => {
              model.zoomOut();
            } },
            import_react52.default.createElement(ZoomOut_default, null)
          )
        );
      });
      ZoomControls_default = ZoomControls;
    }
  });

  // node_modules/@mui/icons-material/esm/MoreVert.js
  var import_jsx_runtime20, MoreVert_default;
  var init_MoreVert = __esm({
    "node_modules/@mui/icons-material/esm/MoreVert.js"() {
      "use client";
      init_createSvgIcon();
      import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
      MoreVert_default = (0, import_utils.createSvgIcon)(/* @__PURE__ */ (0, import_jsx_runtime20.jsx)("path", {
        d: "M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2"
      }), "MoreVert");
    }
  });

  // node_modules/@mui/icons-material/esm/RestartAlt.js
  var import_jsx_runtime21, RestartAlt_default;
  var init_RestartAlt = __esm({
    "node_modules/@mui/icons-material/esm/RestartAlt.js"() {
      "use client";
      init_createSvgIcon();
      import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
      RestartAlt_default = (0, import_utils.createSvgIcon)(/* @__PURE__ */ (0, import_jsx_runtime21.jsx)("path", {
        d: "M12 5V2L8 6l4 4V7c3.31 0 6 2.69 6 6 0 2.97-2.17 5.43-5 5.91v2.02c3.95-.49 7-3.85 7-7.93 0-4.42-3.58-8-8-8m-6 8c0-1.65.67-3.15 1.76-4.24L6.34 7.34C4.9 8.79 4 10.79 4 13c0 4.08 3.05 7.44 7 7.93v-2.02c-2.83-.48-5-2.94-5-5.91"
      }), "RestartAlt");
    }
  });

  // node_modules/react-msaview/dist/components/header/ZoomMenu.js
  var import_react53, import_CascadingMenuButton3, import_mobx_react25, ZoomMenu, ZoomMenu_default;
  var init_ZoomMenu = __esm({
    "node_modules/react-msaview/dist/components/header/ZoomMenu.js"() {
      import_react53 = __toESM(require_react());
      import_CascadingMenuButton3 = __toESM(require_CascadingMenuButton());
      init_MoreVert();
      init_RestartAlt();
      import_mobx_react25 = __toESM(require_mobx_react());
      ZoomMenu = (0, import_mobx_react25.observer)(function({ model }) {
        return import_react53.default.createElement(
          import_CascadingMenuButton3.default,
          { menuItems: [
            {
              label: "Fit both vertically/horizontally",
              onClick: () => {
                model.fit();
              }
            },
            {
              label: "Fit vertically",
              onClick: () => {
                model.fitVertically();
              }
            },
            {
              label: "Fit horizontally",
              onClick: () => {
                model.fitHorizontally();
              }
            },
            {
              label: "Reset zoom to default",
              icon: RestartAlt_default,
              onClick: () => {
                model.resetZoom();
              }
            },
            {
              label: "Show extra zoom options",
              checked: model.showZoomStar,
              type: "checkbox",
              onClick: () => {
                model.setShowZoomStar(!model.showZoomStar);
              }
            }
          ] },
          import_react53.default.createElement(MoreVert_default, null)
        );
      });
      ZoomMenu_default = ZoomMenu;
    }
  });

  // node_modules/react-msaview/dist/components/header/ZoomStar.js
  var import_react54, import_material28, import_mobx_react26, import_mui15, useStyles16, ZoomStar, ZoomStar_default;
  var init_ZoomStar = __esm({
    "node_modules/react-msaview/dist/components/header/ZoomStar.js"() {
      import_react54 = __toESM(require_react());
      init_RestartAlt();
      import_material28 = __toESM(require_material());
      import_mobx_react26 = __toESM(require_mobx_react());
      import_mui15 = __toESM(require_mui());
      useStyles16 = (0, import_mui15.makeStyles)()((theme) => ({
        dpad: {
          display: "grid",
          gridTemplateColumns: "repeat(3, 1fr)"
        },
        icon: {
          padding: theme.spacing(0.5)
        }
      }));
      ZoomStar = (0, import_mobx_react26.observer)(function({ model }) {
        const { classes } = useStyles16();
        return import_react54.default.createElement(
          "div",
          { className: classes.dpad },
          import_react54.default.createElement("div", null),
          import_react54.default.createElement(import_material28.IconButton, { className: classes.icon, onClick: () => {
            model.zoomInVertical();
          } }, "Y+"),
          import_react54.default.createElement("div", null),
          import_react54.default.createElement(import_material28.IconButton, { className: classes.icon, onClick: () => {
            model.zoomOutHorizontal();
          } }, "X-"),
          import_react54.default.createElement(
            import_material28.IconButton,
            { className: classes.icon, onClick: () => {
              model.resetZoom();
            } },
            import_react54.default.createElement(RestartAlt_default, null)
          ),
          import_react54.default.createElement(import_material28.IconButton, { className: classes.icon, onClick: () => {
            model.zoomInHorizontal();
          } }, "X+"),
          import_react54.default.createElement("div", null),
          import_react54.default.createElement(import_material28.IconButton, { className: classes.icon, onClick: () => {
            model.zoomOutVertical();
          } }, "Y-"),
          import_react54.default.createElement("div", null)
        );
      });
      ZoomStar_default = ZoomStar;
    }
  });

  // node_modules/react-msaview/dist/version.js
  var version2;
  var init_version = __esm({
    "node_modules/react-msaview/dist/version.js"() {
      version2 = "4.8.0";
    }
  });

  // node_modules/react-msaview/dist/components/dialogs/AboutDialog.js
  var AboutDialog_exports = {};
  __export(AboutDialog_exports, {
    default: () => AboutDialog
  });
  function AboutDialog({ onClose }) {
    return import_react55.default.createElement(
      import_ui15.Dialog,
      { open: true, title: "About", onClose: () => {
        onClose();
      } },
      import_react55.default.createElement(
        import_material29.DialogContent,
        null,
        import_react55.default.createElement(
          import_material29.Typography,
          null,
          "MSAView ",
          version2,
          " (",
          import_react55.default.createElement(import_material29.Link, { href: "https://github.com/gmod/react-msaview" }, "Github"),
          ")"
        ),
        import_react55.default.createElement(
          "ul",
          null,
          import_react55.default.createElement(
            "li",
            null,
            import_react55.default.createElement(
              import_material29.Typography,
              null,
              "We use some color schemes from the",
              " ",
              import_react55.default.createElement(import_material29.Link, { href: "https://github.com/biotite-dev/biotite" }, "biotite"),
              " ",
              "project, and their license is reproduced",
              " ",
              import_react55.default.createElement(import_material29.Link, { href: "https://github.com/biotite-dev/biotite/blob/master/LICENSE.rst" }, "here")
            )
          ),
          import_react55.default.createElement(
            "li",
            null,
            import_react55.default.createElement(
              import_material29.Typography,
              null,
              "See this page for some information on jalview colorings",
              " ",
              import_react55.default.createElement(import_material29.Link, { href: "https://www.jalview.org/help/html/colourSchemes/" }, "here")
            )
          ),
          import_react55.default.createElement(
            "li",
            null,
            import_react55.default.createElement(
              import_material29.Typography,
              null,
              "See this page for some info on the clustal, cinema, maeditor, and lesk color schemes",
              " ",
              import_react55.default.createElement(import_material29.Link, { href: "http://www.bioinformatics.nl/~berndb/aacolour.html" }, "here")
            )
          ),
          import_react55.default.createElement(
            "li",
            null,
            import_react55.default.createElement(
              import_material29.Typography,
              null,
              "See this paper about the flower color scheme",
              " ",
              import_react55.default.createElement(import_material29.Link, { href: "https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7245768/" }, "here")
            )
          )
        )
      )
    );
  }
  var import_react55, import_ui15, import_material29;
  var init_AboutDialog = __esm({
    "node_modules/react-msaview/dist/components/dialogs/AboutDialog.js"() {
      import_react55 = __toESM(require_react());
      import_ui15 = __toESM(require_ui());
      import_material29 = __toESM(require_material());
      init_version();
    }
  });

  // node_modules/react-msaview/dist/components/header/Header.js
  function Spacer() {
    return import_react56.default.createElement("div", { style: { flex: 1 } });
  }
  var import_react56, import_useMeasure, import_material30, import_mobx_react27, AboutDialog2, Header, Header_default;
  var init_Header = __esm({
    "node_modules/react-msaview/dist/components/header/Header.js"() {
      import_react56 = __toESM(require_react());
      import_useMeasure = __toESM(require_useMeasure());
      init_Help();
      import_material30 = __toESM(require_material());
      import_mobx_react27 = __toESM(require_mobx_react());
      init_GappynessSlider();
      init_HeaderInfoArea();
      init_HeaderMenu();
      init_HeaderStatusArea();
      init_MultiAlignmentSelector();
      init_SettingsMenu();
      init_ZoomControls();
      init_ZoomMenu();
      init_ZoomStar();
      AboutDialog2 = (0, import_react56.lazy)(() => Promise.resolve().then(() => (init_AboutDialog(), AboutDialog_exports)));
      Header = (0, import_mobx_react27.observer)(function({ model }) {
        const [ref, { height }] = (0, import_useMeasure.default)();
        (0, import_react56.useEffect)(() => {
          model.setHeaderHeight(height || 0);
        }, [model, height]);
        return import_react56.default.createElement(
          "div",
          { ref, style: { display: "flex" } },
          import_react56.default.createElement(HeaderMenu_default, { model }),
          import_react56.default.createElement(SettingsMenu_default, { model }),
          import_react56.default.createElement(ZoomControls_default, { model }),
          model.showZoomStar ? import_react56.default.createElement(ZoomStar_default, { model }) : null,
          import_react56.default.createElement(ZoomMenu_default, { model }),
          import_react56.default.createElement(GappynessSlider_default, { model }),
          import_react56.default.createElement(
            "div",
            { style: { paddingLeft: 20, margin: "auto" } },
            import_react56.default.createElement(MultiAlignmentSelector_default, { model })
          ),
          import_react56.default.createElement(HeaderInfoArea_default, { model }),
          import_react56.default.createElement(Spacer, null),
          import_react56.default.createElement(HeaderStatusArea_default, { model }),
          import_react56.default.createElement(
            import_material30.IconButton,
            { onClick: () => {
              model.queueDialog((onClose) => [AboutDialog2, { onClose }]);
            } },
            import_react56.default.createElement(Help_default, null)
          )
        );
      });
      Header_default = Header;
    }
  });

  // node_modules/react-msaview/dist/components/minimap/Minimap.js
  var import_react57, import_mobx_react28, Minimap, Minimap_default;
  var init_Minimap = __esm({
    "node_modules/react-msaview/dist/components/minimap/Minimap.js"() {
      import_react57 = __toESM(require_react());
      import_mobx_react28 = __toESM(require_mobx_react());
      Minimap = (0, import_mobx_react28.observer)(function({ model }) {
        const [mouseDown, setMouseDown] = (0, import_react57.useState)();
        const [hovered, setHovered] = (0, import_react57.useState)(false);
        const scheduled = (0, import_react57.useRef)(false);
        const { scrollX, msaAreaWidth, minimapHeight, colWidth, numColumns } = model;
        const unit = msaAreaWidth / numColumns / colWidth;
        const left = -scrollX;
        const right = left + msaAreaWidth;
        const s2 = left * unit;
        const e2 = right * unit;
        const fill = "rgba(66, 119, 127, 0.3)";
        const w2 = Math.max(e2 - s2, 20);
        (0, import_react57.useEffect)(() => {
          function fn(event) {
            if (mouseDown !== void 0) {
              if (!scheduled.current) {
                scheduled.current = true;
                window.requestAnimationFrame(() => {
                  model.setScrollX(mouseDown.scrollX - (event.clientX - mouseDown.clientX) / unit);
                  scheduled.current = false;
                });
              }
            }
          }
          function fn2() {
            setMouseDown(void 0);
          }
          if (mouseDown !== void 0) {
            document.addEventListener("mousemove", fn);
            document.addEventListener("mouseup", fn2);
            return () => {
              document.removeEventListener("mousemove", fn);
              document.removeEventListener("mousemove", fn2);
            };
          }
        }, [model, unit, mouseDown]);
        const barHeight = 12;
        const polygonHeight = minimapHeight - barHeight;
        return import_react57.default.createElement(
          "div",
          { style: {
            position: "relative",
            height: minimapHeight,
            width: "100%"
          } },
          import_react57.default.createElement("div", { style: {
            height: barHeight,
            boxSizing: "border-box",
            border: "1px solid #555"
          } }),
          import_react57.default.createElement("div", { style: {
            position: "absolute",
            top: 0,
            left: Math.max(0, s2),
            background: hovered ? "rgba(66,119,127,0.6)" : fill,
            cursor: "pointer",
            height: barHeight,
            width: w2,
            zIndex: 100
          }, onMouseOver: () => {
            setHovered(true);
          }, onMouseOut: () => {
            setHovered(false);
          }, onMouseDown: (event) => {
            setMouseDown({
              clientX: event.clientX,
              scrollX: model.scrollX
            });
          } }),
          import_react57.default.createElement(
            "svg",
            { height: polygonHeight, style: { width: "100%" } },
            import_react57.default.createElement("polygon", { fill, points: [
              [s2 + w2, 0],
              [s2, 0],
              [0, polygonHeight],
              [msaAreaWidth, polygonHeight]
            ].toString() })
          )
        );
      });
      Minimap_default = Minimap;
    }
  });

  // node_modules/react-msaview/dist/components/msa/Loading.js
  function Loading() {
    return import_react58.default.createElement(
      "div",
      { style: {
        position: "absolute",
        left: "50%",
        top: "50%"
      } },
      import_react58.default.createElement(import_material31.CircularProgress, null),
      import_react58.default.createElement(import_material31.Typography, null, "Loading...")
    );
  }
  var import_react58, import_material31;
  var init_Loading = __esm({
    "node_modules/react-msaview/dist/components/msa/Loading.js"() {
      import_react58 = __toESM(require_react());
      import_material31 = __toESM(require_material());
    }
  });

  // node_modules/react-msaview/dist/components/msa/renderBoxFeatureCanvasBlock.js
  function renderBoxFeatureCanvasBlock({ model, offsetX, offsetY, ctx, highResScaleFactorOverride, blockSizeYOverride }) {
    const { leaves, blockSize, rowHeight, highResScaleFactor, showDomains } = model;
    if (showDomains) {
      const k2 = highResScaleFactorOverride || highResScaleFactor;
      const by = blockSizeYOverride || blockSize;
      ctx.resetTransform();
      ctx.scale(k2, k2);
      ctx.translate(-offsetX, rowHeight / 2 - offsetY);
      const yStart = Math.max(0, Math.floor((offsetY - rowHeight) / rowHeight));
      const yEnd = Math.max(0, Math.ceil((offsetY + by + rowHeight) / rowHeight));
      const visibleLeaves = leaves.slice(yStart, yEnd);
      drawTiles({
        model,
        ctx,
        visibleLeaves
      });
    }
  }
  function drawTiles({ model, ctx, visibleLeaves }) {
    const { subFeatureRows, colWidth, rowHeight, fillPalette, strokePalette, tidyFilteredGatheredInterProAnnotations } = model;
    for (let i2 = 0, l1 = visibleLeaves.length; i2 < l1; i2++) {
      const node2 = visibleLeaves[i2];
      const { x: x2, data: { name } } = node2;
      const y2 = x2;
      const entry = tidyFilteredGatheredInterProAnnotations[name];
      if (entry) {
        for (let j2 = 0, l2 = entry.length; j2 < l2; j2++) {
          const { start, end, accession } = entry[j2];
          const m1 = model.seqPosToVisibleCol(name, start - 1);
          const m2 = model.seqPosToVisibleCol(name, end);
          if (m1 === void 0 || m2 === void 0) {
            continue;
          }
          const x3 = m1 * colWidth;
          ctx.fillStyle = fillPalette[accession];
          ctx.strokeStyle = strokePalette[accession];
          const h2 = subFeatureRows ? 4 : rowHeight;
          const t2 = y2 - rowHeight + (subFeatureRows ? j2 * h2 : 0);
          const lw = colWidth * (m2 - m1);
          ctx.fillRect(x3, t2, lw, h2);
          ctx.strokeRect(x3, t2, lw, h2);
        }
      }
    }
  }
  var init_renderBoxFeatureCanvasBlock = __esm({
    "node_modules/react-msaview/dist/components/msa/renderBoxFeatureCanvasBlock.js"() {
    }
  });

  // node_modules/react-msaview/dist/components/msa/renderMSABlock.js
  function renderMSABlock({ model, offsetX, offsetY, contrastScheme, ctx, theme, highResScaleFactorOverride, blockSizeXOverride, blockSizeYOverride }) {
    const { colWidth, blockSize, rowHeight, fontSize, highResScaleFactor, actuallyShowDomains, leaves, bgColor } = model;
    const k2 = highResScaleFactorOverride || highResScaleFactor;
    const bx = blockSizeXOverride || blockSize;
    const by = blockSizeYOverride || blockSize;
    ctx.resetTransform();
    ctx.scale(k2, k2);
    ctx.translate(-offsetX, rowHeight / 2 - offsetY);
    ctx.textAlign = "center";
    ctx.font = ctx.font.replace(/\d+px/, `${bgColor ? "" : "bold "}${fontSize}px`);
    const yStart = Math.max(0, Math.floor((offsetY - rowHeight) / rowHeight));
    const yEnd = Math.max(0, Math.ceil((offsetY + by + rowHeight) / rowHeight));
    const xStart = Math.max(0, Math.floor(offsetX / colWidth));
    const xEnd = Math.max(0, Math.ceil((offsetX + bx) / colWidth));
    const visibleLeaves = leaves.slice(yStart, yEnd);
    if (!actuallyShowDomains) {
      drawTiles2({
        model,
        ctx,
        theme,
        offsetX,
        xStart,
        xEnd,
        visibleLeaves
      });
    }
    drawText({
      model,
      ctx,
      offsetX,
      contrastScheme,
      xStart,
      xEnd,
      visibleLeaves
    });
    drawInsertionIndicators({
      model,
      ctx,
      xStart,
      xEnd,
      visibleLeaves
    });
    ctx.resetTransform();
  }
  function drawTiles2({ model, offsetX, ctx, visibleLeaves, theme, xStart, xEnd }) {
    const { bgColor, colorSchemeName, colorScheme, columns, colWidth, rowHeight, relativeTo } = model;
    const referenceSeq = relativeTo ? columns[relativeTo]?.slice(xStart, xEnd) : null;
    const isClustalX = colorSchemeName === "clustalx_protein_dynamic";
    const isPercentIdentity = colorSchemeName === "percent_identity_dynamic";
    const offsetXAligned = offsetX - offsetX % colWidth;
    for (let i2 = 0, l1 = visibleLeaves.length; i2 < l1; i2++) {
      const node2 = visibleLeaves[i2];
      const { data: { name } } = node2;
      const y2 = node2.x;
      const str = columns[name]?.slice(xStart, xEnd);
      if (str) {
        for (let j2 = 0, l2 = str.length; j2 < l2; j2++) {
          const letter = str[j2];
          const isMatchingReference = referenceSeq && name !== relativeTo && letter === referenceSeq[j2];
          const color = isClustalX ? model.colClustalX[xStart + j2][letter] : isPercentIdentity ? (() => {
            const consensus = model.colConsensus[xStart + j2];
            return letter === consensus.letter ? consensus.color : void 0;
          })() : colorScheme[letter.toUpperCase()];
          if (bgColor || isClustalX || isPercentIdentity) {
            const finalColor = isMatchingReference ? theme.palette.action.hover : color || theme.palette.background.default;
            ctx.fillStyle = finalColor;
            ctx.fillRect(j2 * colWidth + offsetXAligned, y2 - rowHeight, colWidth, rowHeight);
          }
        }
      }
    }
  }
  function drawText({ model, offsetX, contrastScheme, ctx, visibleLeaves, xStart, xEnd }) {
    const { bgColor, actuallyShowDomains, showMsaLetters, colorScheme, columns, colWidth, contrastLettering, rowHeight, relativeTo } = model;
    const referenceSeq = relativeTo ? columns[relativeTo]?.slice(xStart, xEnd) : null;
    if (showMsaLetters) {
      const offsetXAligned = offsetX - offsetX % colWidth;
      const halfColWidth = colWidth / 2;
      const quarterRowHeight = rowHeight / 4;
      for (let i2 = 0, l1 = visibleLeaves.length; i2 < l1; i2++) {
        const node2 = visibleLeaves[i2];
        const { data: { name } } = node2;
        const y2 = node2.x - quarterRowHeight;
        const str = columns[name]?.slice(xStart, xEnd);
        if (str) {
          for (let j2 = 0, l2 = str.length; j2 < l2; j2++) {
            const letter = str[j2];
            const isMatchingReference = referenceSeq && name !== relativeTo && letter === referenceSeq[j2];
            const displayLetter = isMatchingReference ? "." : letter;
            const color = colorScheme[letter.toUpperCase()];
            const contrast = contrastLettering ? contrastScheme[letter.toUpperCase()] || "black" : "black";
            ctx.fillStyle = actuallyShowDomains ? "black" : bgColor ? contrast : color || "black";
            ctx.fillText(displayLetter, j2 * colWidth + offsetXAligned + halfColWidth, y2);
          }
        }
      }
    }
  }
  function drawInsertionIndicators({ model, ctx, visibleLeaves, xStart, xEnd }) {
    const { bgColor, hideGapsEffective } = model;
    if (!hideGapsEffective) {
      return;
    }
    ctx.lineWidth = 1;
    ctx.strokeStyle = "#f0f";
    drawZigZag({ visibleLeaves, xStart, ctx, model, xEnd, offset: 0 });
    ctx.strokeStyle = !bgColor ? "#000" : "#fff";
    drawZigZag({ visibleLeaves, xStart, ctx, model, xEnd, offset: -1 });
  }
  function drawZigZag({ model, ctx, visibleLeaves, xStart, xEnd, offset: offset4 }) {
    const zigSize = 1;
    const { colWidth, rowHeight, insertionPositions } = model;
    for (const node2 of visibleLeaves) {
      const { name } = node2.data;
      const insertions = insertionPositions.get(name);
      if (insertions) {
        const y2 = node2.x;
        for (const { pos } of insertions) {
          if (pos >= xStart && pos < xEnd) {
            const x2 = pos * colWidth;
            const top = y2 - rowHeight;
            const bottom = y2;
            ctx.beginPath();
            ctx.moveTo(x2 + offset4, top + offset4);
            let currentY = top;
            let goRight = true;
            while (currentY < bottom) {
              const nextY = Math.min(currentY + zigSize * 2, bottom);
              const nextX = goRight ? x2 + zigSize : x2 - zigSize;
              ctx.lineTo(nextX + offset4, nextY + offset4);
              currentY = nextY;
              goRight = !goRight;
            }
            ctx.stroke();
          }
        }
      }
    }
  }
  var init_renderMSABlock = __esm({
    "node_modules/react-msaview/dist/components/msa/renderMSABlock.js"() {
    }
  });

  // node_modules/react-msaview/dist/components/msa/MSACanvasBlock.js
  var import_react59, import_ui16, import_material32, import_mobx, import_mobx_react29, MSACanvasBlock, MSACanvasBlock_default;
  var init_MSACanvasBlock = __esm({
    "node_modules/react-msaview/dist/components/msa/MSACanvasBlock.js"() {
      import_react59 = __toESM(require_react());
      import_ui16 = __toESM(require_ui());
      import_material32 = __toESM(require_material());
      import_mobx = __toESM(require_mobx());
      import_mobx_react29 = __toESM(require_mobx_react());
      init_renderBoxFeatureCanvasBlock();
      init_renderMSABlock();
      init_util();
      MSACanvasBlock = (0, import_mobx_react29.observer)(function({ model, offsetX, offsetY }) {
        const { colWidth, rowHeight, scrollY, scrollX, colorScheme, blockSize, mouseClickCol, mouseClickRow, highResScaleFactor } = model;
        const theme = (0, import_material32.useTheme)();
        const contrastScheme = (0, import_react59.useMemo)(() => colorContrast(colorScheme, theme), [colorScheme, theme]);
        const ref = (0, import_react59.useRef)(null);
        (0, import_react59.useEffect)(() => {
          const ctx = ref.current?.getContext("2d");
          if (!ctx) {
            return;
          }
          return (0, import_mobx.autorun)(() => {
            ctx.resetTransform();
            ctx.clearRect(0, 0, blockSize * highResScaleFactor, blockSize * highResScaleFactor);
            const { actuallyShowDomains } = model;
            if (actuallyShowDomains) {
              renderBoxFeatureCanvasBlock({
                ctx,
                offsetX,
                offsetY,
                model
              });
            }
            renderMSABlock({
              ctx,
              theme,
              offsetX,
              offsetY,
              contrastScheme,
              model
            });
          });
        }, [
          model,
          offsetX,
          offsetY,
          theme,
          blockSize,
          highResScaleFactor,
          contrastScheme
        ]);
        const [mousePosition, setMousePosition] = (0, import_react59.useState)();
        const { hoveredInsertion } = model;
        return import_react59.default.createElement(
          import_react59.default.Fragment,
          null,
          import_react59.default.createElement("canvas", { ref, onMouseMove: (event) => {
            if (!ref.current) {
              return;
            }
            setMousePosition({ x: event.clientX, y: event.clientY });
            const { left, top } = ref.current.getBoundingClientRect();
            const mouseX = event.clientX - left + offsetX;
            const mouseY = event.clientY - top + offsetY;
            const x2 = Math.floor(mouseX / colWidth);
            const y2 = Math.floor(mouseY / rowHeight);
            if (x2 >= 0 && x2 < model.numColumns && y2 >= 0 && y2 < model.numRows) {
              model.setMousePos(x2, y2);
            } else {
              model.setMousePos(void 0, void 0);
            }
          }, onClick: (event) => {
            if (!ref.current) {
              return;
            }
            const { left, top } = ref.current.getBoundingClientRect();
            const mouseX = event.clientX - left + offsetX;
            const mouseY = event.clientY - top + offsetY;
            const x2 = Math.floor(mouseX / colWidth);
            const y2 = Math.floor(mouseY / rowHeight);
            if (x2 === mouseClickCol && y2 === mouseClickRow) {
              model.setMouseClickPos(void 0, void 0);
            } else {
              model.setMouseClickPos(x2, y2);
            }
          }, onMouseLeave: () => {
            model.setMousePos();
            setMousePosition(void 0);
          }, width: blockSize * highResScaleFactor, height: blockSize * highResScaleFactor, style: {
            position: "absolute",
            top: scrollY + offsetY,
            left: scrollX + offsetX,
            width: blockSize,
            height: blockSize
          } }),
          hoveredInsertion && mousePosition ? import_react59.default.createElement(
            import_ui16.BaseTooltip,
            { clientPoint: { x: mousePosition.x, y: mousePosition.y + 15 } },
            "Insertion (",
            hoveredInsertion.letters.length,
            "bp):",
            " ",
            hoveredInsertion.letters.length > 20 ? `${hoveredInsertion.letters.slice(0, 20)}...` : hoveredInsertion.letters
          ) : null
        );
      });
      MSACanvasBlock_default = MSACanvasBlock;
    }
  });

  // node_modules/react-msaview/dist/components/msa/MSACanvas.js
  var import_react60, import_mobx_react30, MSACanvas, MSACanvas_default;
  var init_MSACanvas = __esm({
    "node_modules/react-msaview/dist/components/msa/MSACanvas.js"() {
      import_react60 = __toESM(require_react());
      import_mobx_react30 = __toESM(require_mobx_react());
      init_Loading();
      init_MSACanvasBlock();
      MSACanvas = (0, import_mobx_react30.observer)(function({ model }) {
        const { MSA, verticalScrollbarWidth, msaFilehandle, height, msaAreaWidth, blocks2d } = model;
        const ref = (0, import_react60.useRef)(null);
        const scheduled = (0, import_react60.useRef)(false);
        const deltaX = (0, import_react60.useRef)(0);
        const deltaY = (0, import_react60.useRef)(0);
        const prevX = (0, import_react60.useRef)(0);
        const prevY = (0, import_react60.useRef)(0);
        const [mouseDragging, setMouseDragging] = (0, import_react60.useState)(false);
        (0, import_react60.useEffect)(() => {
          const curr = ref.current;
          if (!curr) {
            return;
          }
          function onWheel(event) {
            deltaX.current += event.deltaX;
            deltaY.current += event.deltaY;
            if (!scheduled.current) {
              scheduled.current = true;
              requestAnimationFrame(() => {
                model.doScrollX(-deltaX.current);
                model.doScrollY(-deltaY.current);
                deltaX.current = 0;
                deltaY.current = 0;
                scheduled.current = false;
              });
            }
            event.preventDefault();
            event.stopPropagation();
          }
          curr.addEventListener("wheel", onWheel, { passive: false });
          return () => {
            curr.removeEventListener("wheel", onWheel);
          };
        }, [model]);
        (0, import_react60.useEffect)(() => {
          let cleanup2 = () => {
          };
          function globalMouseMove(event) {
            event.preventDefault();
            const currX = event.clientX;
            const currY = event.clientY;
            const distanceX = currX - prevX.current;
            const distanceY = currY - prevY.current;
            if (distanceX || distanceY) {
              if (!scheduled.current) {
                scheduled.current = true;
                window.requestAnimationFrame(() => {
                  model.doScrollX(distanceX);
                  model.doScrollY(distanceY);
                  scheduled.current = false;
                  prevX.current = event.clientX;
                  prevY.current = event.clientY;
                });
              }
            }
          }
          function globalMouseUp() {
            prevX.current = 0;
            if (mouseDragging) {
              setMouseDragging(false);
            }
          }
          if (mouseDragging) {
            window.addEventListener("mousemove", globalMouseMove, true);
            window.addEventListener("mouseup", globalMouseUp, true);
            cleanup2 = () => {
              window.removeEventListener("mousemove", globalMouseMove, true);
              window.removeEventListener("mouseup", globalMouseUp, true);
            };
          }
          return cleanup2;
        }, [model, mouseDragging]);
        return import_react60.default.createElement("div", { ref, onMouseDown: (event) => {
          const target = event.target;
          if (target.draggable || target.dataset.resizer) {
            return;
          }
          if (event.button === 0) {
            prevX.current = event.clientX;
            prevY.current = event.clientY;
            setMouseDragging(true);
          }
        }, onMouseUp: (event) => {
          event.preventDefault();
          setMouseDragging(false);
        }, onMouseLeave: (event) => {
          event.preventDefault();
        }, style: {
          position: "relative",
          height,
          width: msaAreaWidth - verticalScrollbarWidth,
          overflow: "hidden"
        } }, !MSA && !msaFilehandle ? null : MSA ? blocks2d.map(([bx, by]) => import_react60.default.createElement(MSACanvasBlock_default, { key: `${bx}_${by}`, model, offsetX: bx, offsetY: by })) : import_react60.default.createElement(Loading, null));
      });
      MSACanvas_default = MSACanvas;
    }
  });

  // node_modules/react-msaview/dist/components/msa/renderMSAMouseover.js
  function renderMouseover({ ctx, model }) {
    const {
      mouseCol,
      colWidth,
      width,
      height,
      rowHeight,
      scrollX,
      scrollY,
      mouseRow,
      // @ts-expect-error
      mouseCol2,
      mouseClickRow,
      mouseClickCol,
      relativeTo,
      rowNamesSet,
      hoveredTreeNode,
      highlightedColumns
    } = model;
    ctx.resetTransform();
    ctx.clearRect(0, 0, width, height);
    if (relativeTo) {
      const referenceRowIndex = rowNamesSet.get(relativeTo);
      if (referenceRowIndex !== void 0) {
        ctx.fillStyle = referenceColor;
        ctx.fillRect(0, referenceRowIndex * rowHeight + scrollY, width, rowHeight);
      }
    }
    if (hoveredTreeNode) {
      ctx.fillStyle = multiRowHoverColor;
      for (const descendantName of hoveredTreeNode.descendantNames) {
        const rowIndex = rowNamesSet.get(descendantName);
        if (rowIndex !== void 0) {
          ctx.fillRect(0, rowIndex * rowHeight + scrollY, width, rowHeight);
        }
      }
    }
    if (highlightedColumns?.length) {
      ctx.fillStyle = highlightColor;
      for (const col of highlightedColumns) {
        ctx.fillRect(col * colWidth + scrollX, 0, colWidth, height);
      }
    }
    if (mouseCol !== void 0) {
      ctx.fillStyle = hoverColor;
      ctx.fillRect(mouseCol * colWidth + scrollX, 0, colWidth, height);
    }
    if (mouseRow !== void 0) {
      ctx.fillStyle = hoverColor;
      ctx.fillRect(0, mouseRow * rowHeight + scrollY, width, rowHeight);
    }
    if (mouseClickCol !== void 0) {
      ctx.fillStyle = highlightColor;
      ctx.fillRect(mouseClickCol * colWidth + scrollX, 0, colWidth, height);
    }
    if (mouseClickRow !== void 0) {
      ctx.fillStyle = highlightColor;
      ctx.fillRect(0, mouseClickRow * rowHeight + scrollY, width, rowHeight);
    }
    if (mouseCol2 !== void 0) {
      ctx.fillStyle = highlightColor;
      ctx.fillRect(mouseCol2 * colWidth + scrollX, 0, colWidth, height);
    }
  }
  var hoverColor, highlightColor, referenceColor, multiRowHoverColor;
  var init_renderMSAMouseover = __esm({
    "node_modules/react-msaview/dist/components/msa/renderMSAMouseover.js"() {
      hoverColor = "rgba(0,0,0,0.15)";
      highlightColor = "rgba(128,128,0,0.2)";
      referenceColor = "rgba(0,128,255,0.3)";
      multiRowHoverColor = "rgba(255,165,0,0.15)";
    }
  });

  // node_modules/react-msaview/dist/components/msa/MSAMouseoverCanvas.js
  var import_react61, import_mobx2, import_mobx_react31, import_mobx_state_tree, MSAMouseoverCanvas, MSAMouseoverCanvas_default;
  var init_MSAMouseoverCanvas = __esm({
    "node_modules/react-msaview/dist/components/msa/MSAMouseoverCanvas.js"() {
      import_react61 = __toESM(require_react());
      import_mobx2 = __toESM(require_mobx());
      import_mobx_react31 = __toESM(require_mobx_react());
      import_mobx_state_tree = __toESM(require_mobx_state_tree());
      init_renderMSAMouseover();
      MSAMouseoverCanvas = (0, import_mobx_react31.observer)(function({ model }) {
        const ref = (0, import_react61.useRef)(null);
        const { height, width } = model;
        (0, import_react61.useEffect)(() => {
          const ctx = ref.current?.getContext("2d");
          return ctx ? (0, import_mobx2.autorun)(() => {
            if ((0, import_mobx_state_tree.isAlive)(model)) {
              renderMouseover({ ctx, model });
            }
          }) : void 0;
        }, [model]);
        return import_react61.default.createElement("canvas", { ref, id: "mouseover", width, height, style: {
          position: "absolute",
          top: 0,
          left: 0,
          width,
          height,
          zIndex: 1e3,
          pointerEvents: "none"
        } });
      });
      MSAMouseoverCanvas_default = MSAMouseoverCanvas;
    }
  });

  // node_modules/react-msaview/dist/components/msa/MSAPanel.js
  var import_react62, import_mobx_react32, MSAPanel, MSAPanel_default;
  var init_MSAPanel = __esm({
    "node_modules/react-msaview/dist/components/msa/MSAPanel.js"() {
      import_react62 = __toESM(require_react());
      import_mobx_react32 = __toESM(require_mobx_react());
      init_MSACanvas();
      init_MSAMouseoverCanvas();
      MSAPanel = (0, import_mobx_react32.observer)(function({ model }) {
        return import_react62.default.createElement(
          "div",
          { style: { position: "relative" } },
          import_react62.default.createElement(MSACanvas_default, { model }),
          import_react62.default.createElement(MSAMouseoverCanvas_default, { model })
        );
      });
      MSAPanel_default = MSAPanel;
    }
  });

  // node_modules/flatqueue/index.js
  var FlatQueue;
  var init_flatqueue = __esm({
    "node_modules/flatqueue/index.js"() {
      FlatQueue = class {
        constructor() {
          this.ids = [];
          this.values = [];
          this.length = 0;
        }
        /** Removes all items from the queue. */
        clear() {
          this.length = 0;
        }
        /**
         * Adds `item` to the queue with the specified `priority`.
         *
         * `priority` must be a number. Items are sorted and returned from low to high priority. Multiple items
         * with the same priority value can be added to the queue, but there is no guaranteed order between these items.
         *
         * @param {T} item
         * @param {number} priority
         */
        push(item, priority) {
          let pos = this.length++;
          while (pos > 0) {
            const parent = pos - 1 >> 1;
            const parentValue = this.values[parent];
            if (priority >= parentValue) break;
            this.ids[pos] = this.ids[parent];
            this.values[pos] = parentValue;
            pos = parent;
          }
          this.ids[pos] = item;
          this.values[pos] = priority;
        }
        /**
         * Removes and returns the item from the head of this queue, which is one of
         * the items with the lowest priority. If this queue is empty, returns `undefined`.
         */
        pop() {
          if (this.length === 0) return void 0;
          const ids = this.ids, values = this.values, top = ids[0], last = --this.length;
          if (last > 0) {
            const id = ids[last];
            const value = values[last];
            let pos = 0;
            const halfLen = last >> 1;
            while (pos < halfLen) {
              const left = (pos << 1) + 1;
              const right = left + 1;
              const child = left + (+(right < last) & +(values[right] < values[left]));
              if (values[child] >= value) break;
              ids[pos] = ids[child];
              values[pos] = values[child];
              pos = child;
            }
            ids[pos] = id;
            values[pos] = value;
          }
          return top;
        }
        /** Returns the item from the head of this queue without removing it. If this queue is empty, returns `undefined`. */
        peek() {
          return this.length > 0 ? this.ids[0] : void 0;
        }
        /**
         * Returns the priority value of the item at the head of this queue without
         * removing it. If this queue is empty, returns `undefined`.
         */
        peekValue() {
          return this.length > 0 ? this.values[0] : void 0;
        }
        /**
         * Shrinks the internal arrays to `this.length`.
         *
         * `pop()` and `clear()` calls don't free memory automatically to avoid unnecessary resize operations.
         * This also means that items that have been added to the queue can't be garbage collected until
         * a new item is pushed in their place, or this method is called.
         */
        shrink() {
          this.ids.length = this.values.length = this.length;
        }
      };
    }
  });

  // node_modules/flatbush/index.js
  function upperBound(value, arr) {
    let i2 = 0;
    let j2 = arr.length - 1;
    while (i2 < j2) {
      const m2 = i2 + j2 >> 1;
      if (arr[m2] > value) {
        j2 = m2;
      } else {
        i2 = m2 + 1;
      }
    }
    return arr[i2];
  }
  function sort(values, boxes, indices, left, right, nodeSize) {
    if (Math.floor(left / nodeSize) >= Math.floor(right / nodeSize)) return;
    const start = values[left];
    const mid = values[left + right >> 1];
    const end = values[right];
    let pivot = end;
    const x2 = Math.max(start, mid);
    if (end > x2) {
      pivot = x2;
    } else if (x2 === start) {
      pivot = Math.max(mid, end);
    } else if (x2 === mid) {
      pivot = Math.max(start, end);
    }
    let i2 = left - 1;
    let j2 = right + 1;
    while (true) {
      do
        i2++;
      while (values[i2] < pivot);
      do
        j2--;
      while (values[j2] > pivot);
      if (i2 >= j2) break;
      swap(values, boxes, indices, i2, j2);
    }
    sort(values, boxes, indices, left, j2, nodeSize);
    sort(values, boxes, indices, j2 + 1, right, nodeSize);
  }
  function swap(values, boxes, indices, i2, j2) {
    const temp = values[i2];
    values[i2] = values[j2];
    values[j2] = temp;
    const k2 = 4 * i2;
    const m2 = 4 * j2;
    const a2 = boxes[k2];
    const b2 = boxes[k2 + 1];
    const c2 = boxes[k2 + 2];
    const d3 = boxes[k2 + 3];
    boxes[k2] = boxes[m2];
    boxes[k2 + 1] = boxes[m2 + 1];
    boxes[k2 + 2] = boxes[m2 + 2];
    boxes[k2 + 3] = boxes[m2 + 3];
    boxes[m2] = a2;
    boxes[m2 + 1] = b2;
    boxes[m2 + 2] = c2;
    boxes[m2 + 3] = d3;
    const e2 = indices[i2];
    indices[i2] = indices[j2];
    indices[j2] = e2;
  }
  function hilbert(x2, y2) {
    let a2 = x2 ^ y2;
    let b2 = 65535 ^ a2;
    let c2 = 65535 ^ (x2 | y2);
    let d3 = x2 & (y2 ^ 65535);
    let A = a2 | b2 >> 1;
    let B = a2 >> 1 ^ a2;
    let C = c2 >> 1 ^ b2 & d3 >> 1 ^ c2;
    let D = a2 & c2 >> 1 ^ d3 >> 1 ^ d3;
    a2 = A;
    b2 = B;
    c2 = C;
    d3 = D;
    A = a2 & a2 >> 2 ^ b2 & b2 >> 2;
    B = a2 & b2 >> 2 ^ b2 & (a2 ^ b2) >> 2;
    C ^= a2 & c2 >> 2 ^ b2 & d3 >> 2;
    D ^= b2 & c2 >> 2 ^ (a2 ^ b2) & d3 >> 2;
    a2 = A;
    b2 = B;
    c2 = C;
    d3 = D;
    A = a2 & a2 >> 4 ^ b2 & b2 >> 4;
    B = a2 & b2 >> 4 ^ b2 & (a2 ^ b2) >> 4;
    C ^= a2 & c2 >> 4 ^ b2 & d3 >> 4;
    D ^= b2 & c2 >> 4 ^ (a2 ^ b2) & d3 >> 4;
    a2 = A;
    b2 = B;
    c2 = C;
    d3 = D;
    C ^= a2 & c2 >> 8 ^ b2 & d3 >> 8;
    D ^= b2 & c2 >> 8 ^ (a2 ^ b2) & d3 >> 8;
    a2 = C ^ C >> 1;
    b2 = D ^ D >> 1;
    let i0 = x2 ^ y2;
    let i1 = b2 | 65535 ^ (i0 | a2);
    i0 = (i0 | i0 << 8) & 16711935;
    i0 = (i0 | i0 << 4) & 252645135;
    i0 = (i0 | i0 << 2) & 858993459;
    i0 = (i0 | i0 << 1) & 1431655765;
    i1 = (i1 | i1 << 8) & 16711935;
    i1 = (i1 | i1 << 4) & 252645135;
    i1 = (i1 | i1 << 2) & 858993459;
    i1 = (i1 | i1 << 1) & 1431655765;
    return (i1 << 1 | i0) >>> 0;
  }
  var ARRAY_TYPES, VERSION, Flatbush;
  var init_flatbush = __esm({
    "node_modules/flatbush/index.js"() {
      init_flatqueue();
      ARRAY_TYPES = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
      VERSION = 3;
      Flatbush = class _Flatbush {
        /**
         * Recreate a Flatbush index from raw `ArrayBuffer` or `SharedArrayBuffer` data.
         * @param {ArrayBufferLike} data
         * @param {number} [byteOffset=0] byte offset to the start of the Flatbush buffer in the referenced ArrayBuffer.
         * @returns {Flatbush} index
         */
        static from(data, byteOffset = 0) {
          if (byteOffset % 8 !== 0) {
            throw new Error("byteOffset must be 8-byte aligned.");
          }
          if (!data || data.byteLength === void 0 || data.buffer) {
            throw new Error("Data must be an instance of ArrayBuffer or SharedArrayBuffer.");
          }
          const [magic, versionAndType] = new Uint8Array(data, byteOffset + 0, 2);
          if (magic !== 251) {
            throw new Error("Data does not appear to be in a Flatbush format.");
          }
          const version3 = versionAndType >> 4;
          if (version3 !== VERSION) {
            throw new Error(`Got v${version3} data when expected v${VERSION}.`);
          }
          const ArrayType = ARRAY_TYPES[versionAndType & 15];
          if (!ArrayType) {
            throw new Error("Unrecognized array type.");
          }
          const [nodeSize] = new Uint16Array(data, byteOffset + 2, 1);
          const [numItems] = new Uint32Array(data, byteOffset + 4, 1);
          return new _Flatbush(numItems, nodeSize, ArrayType, void 0, data, byteOffset);
        }
        /**
         * Create a Flatbush index that will hold a given number of items.
         * @param {number} numItems
         * @param {number} [nodeSize=16] Size of the tree node (16 by default).
         * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
         * @param {ArrayBufferConstructor | SharedArrayBufferConstructor} [ArrayBufferType=ArrayBuffer] The array buffer type used to store data (`ArrayBuffer` by default).
         * @param {ArrayBufferLike} [data] (Only used internally)
         * @param {number} [byteOffset=0] (Only used internally)
         */
        constructor(numItems, nodeSize = 16, ArrayType = Float64Array, ArrayBufferType = ArrayBuffer, data, byteOffset = 0) {
          if (numItems === void 0) throw new Error("Missing required argument: numItems.");
          if (isNaN(numItems) || numItems <= 0) throw new Error(`Unexpected numItems value: ${numItems}.`);
          this.numItems = +numItems;
          this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);
          this.byteOffset = byteOffset;
          let n2 = numItems;
          let numNodes = n2;
          this._levelBounds = [n2 * 4];
          do {
            n2 = Math.ceil(n2 / this.nodeSize);
            numNodes += n2;
            this._levelBounds.push(numNodes * 4);
          } while (n2 !== 1);
          this.ArrayType = ArrayType;
          this.IndexArrayType = numNodes < 16384 ? Uint16Array : Uint32Array;
          const arrayTypeIndex = ARRAY_TYPES.indexOf(ArrayType);
          const nodesByteSize = numNodes * 4 * ArrayType.BYTES_PER_ELEMENT;
          if (arrayTypeIndex < 0) {
            throw new Error(`Unexpected typed array class: ${ArrayType}.`);
          }
          if (data) {
            this.data = data;
            this._boxes = new ArrayType(data, byteOffset + 8, numNodes * 4);
            this._indices = new this.IndexArrayType(data, byteOffset + 8 + nodesByteSize, numNodes);
            this._pos = numNodes * 4;
            this.minX = this._boxes[this._pos - 4];
            this.minY = this._boxes[this._pos - 3];
            this.maxX = this._boxes[this._pos - 2];
            this.maxY = this._boxes[this._pos - 1];
          } else {
            const data2 = this.data = new ArrayBufferType(8 + nodesByteSize + numNodes * this.IndexArrayType.BYTES_PER_ELEMENT);
            this._boxes = new ArrayType(data2, 8, numNodes * 4);
            this._indices = new this.IndexArrayType(data2, 8 + nodesByteSize, numNodes);
            this._pos = 0;
            this.minX = Infinity;
            this.minY = Infinity;
            this.maxX = -Infinity;
            this.maxY = -Infinity;
            new Uint8Array(data2, 0, 2).set([251, (VERSION << 4) + arrayTypeIndex]);
            new Uint16Array(data2, 2, 1)[0] = nodeSize;
            new Uint32Array(data2, 4, 1)[0] = numItems;
          }
          this._queue = new FlatQueue();
        }
        /**
         * Add a given rectangle to the index.
         * @param {number} minX
         * @param {number} minY
         * @param {number} maxX
         * @param {number} maxY
         * @returns {number} A zero-based, incremental number that represents the newly added rectangle.
         */
        add(minX, minY, maxX = minX, maxY2 = minY) {
          const index3 = this._pos >> 2;
          const boxes = this._boxes;
          this._indices[index3] = index3;
          boxes[this._pos++] = minX;
          boxes[this._pos++] = minY;
          boxes[this._pos++] = maxX;
          boxes[this._pos++] = maxY2;
          if (minX < this.minX) this.minX = minX;
          if (minY < this.minY) this.minY = minY;
          if (maxX > this.maxX) this.maxX = maxX;
          if (maxY2 > this.maxY) this.maxY = maxY2;
          return index3;
        }
        /** Perform indexing of the added rectangles. */
        finish() {
          if (this._pos >> 2 !== this.numItems) {
            throw new Error(`Added ${this._pos >> 2} items when expected ${this.numItems}.`);
          }
          const boxes = this._boxes;
          if (this.numItems <= this.nodeSize) {
            boxes[this._pos++] = this.minX;
            boxes[this._pos++] = this.minY;
            boxes[this._pos++] = this.maxX;
            boxes[this._pos++] = this.maxY;
            return;
          }
          const width = this.maxX - this.minX || 1;
          const height = this.maxY - this.minY || 1;
          const hilbertValues = new Uint32Array(this.numItems);
          const hilbertMax = (1 << 16) - 1;
          for (let i2 = 0, pos = 0; i2 < this.numItems; i2++) {
            const minX = boxes[pos++];
            const minY = boxes[pos++];
            const maxX = boxes[pos++];
            const maxY2 = boxes[pos++];
            const x2 = Math.floor(hilbertMax * ((minX + maxX) / 2 - this.minX) / width);
            const y2 = Math.floor(hilbertMax * ((minY + maxY2) / 2 - this.minY) / height);
            hilbertValues[i2] = hilbert(x2, y2);
          }
          sort(hilbertValues, boxes, this._indices, 0, this.numItems - 1, this.nodeSize);
          for (let i2 = 0, pos = 0; i2 < this._levelBounds.length - 1; i2++) {
            const end = this._levelBounds[i2];
            while (pos < end) {
              const nodeIndex = pos;
              let nodeMinX = boxes[pos++];
              let nodeMinY = boxes[pos++];
              let nodeMaxX = boxes[pos++];
              let nodeMaxY = boxes[pos++];
              for (let j2 = 1; j2 < this.nodeSize && pos < end; j2++) {
                nodeMinX = Math.min(nodeMinX, boxes[pos++]);
                nodeMinY = Math.min(nodeMinY, boxes[pos++]);
                nodeMaxX = Math.max(nodeMaxX, boxes[pos++]);
                nodeMaxY = Math.max(nodeMaxY, boxes[pos++]);
              }
              this._indices[this._pos >> 2] = nodeIndex;
              boxes[this._pos++] = nodeMinX;
              boxes[this._pos++] = nodeMinY;
              boxes[this._pos++] = nodeMaxX;
              boxes[this._pos++] = nodeMaxY;
            }
          }
        }
        /**
         * Search the index by a bounding box.
         * @param {number} minX
         * @param {number} minY
         * @param {number} maxX
         * @param {number} maxY
         * @param {(index: number, x0: number, y0: number, x1: number, y1: number) => boolean} [filterFn] An optional function that is called on every found item; if supplied, only items for which this function returns true will be included in the results array.
         * @returns {number[]} An array of indices of items intersecting or touching the given bounding box.
         */
        search(minX, minY, maxX, maxY2, filterFn) {
          if (this._pos !== this._boxes.length) {
            throw new Error("Data not yet indexed - call index.finish().");
          }
          let nodeIndex = this._boxes.length - 4;
          const queue = [];
          const results = [];
          while (nodeIndex !== void 0) {
            const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));
            for (let pos = nodeIndex; pos < end; pos += 4) {
              const x0 = this._boxes[pos];
              if (maxX < x0) continue;
              const y0 = this._boxes[pos + 1];
              if (maxY2 < y0) continue;
              const x1 = this._boxes[pos + 2];
              if (minX > x1) continue;
              const y1 = this._boxes[pos + 3];
              if (minY > y1) continue;
              const index3 = this._indices[pos >> 2] | 0;
              if (nodeIndex >= this.numItems * 4) {
                queue.push(index3);
              } else if (filterFn === void 0 || filterFn(index3, x0, y0, x1, y1)) {
                results.push(index3);
              }
            }
            nodeIndex = queue.pop();
          }
          return results;
        }
        /**
         * Search items in order of distance from the given point.
         * @param {number} x
         * @param {number} y
         * @param {number} [maxResults=Infinity]
         * @param {number} [maxDistance=Infinity]
         * @param {(index: number) => boolean} [filterFn] An optional function for filtering the results.
         * @returns {number[]} An array of indices of items found.
         */
        neighbors(x2, y2, maxResults = Infinity, maxDistance = Infinity, filterFn) {
          if (this._pos !== this._boxes.length) {
            throw new Error("Data not yet indexed - call index.finish().");
          }
          let nodeIndex = this._boxes.length - 4;
          const q = this._queue;
          const results = [];
          const maxDistSquared = maxDistance * maxDistance;
          outer: while (nodeIndex !== void 0) {
            const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));
            for (let pos = nodeIndex; pos < end; pos += 4) {
              const index3 = this._indices[pos >> 2] | 0;
              const minX = this._boxes[pos];
              const minY = this._boxes[pos + 1];
              const maxX = this._boxes[pos + 2];
              const maxY2 = this._boxes[pos + 3];
              const dx = x2 < minX ? minX - x2 : x2 > maxX ? x2 - maxX : 0;
              const dy = y2 < minY ? minY - y2 : y2 > maxY2 ? y2 - maxY2 : 0;
              const dist = dx * dx + dy * dy;
              if (dist > maxDistSquared) continue;
              if (nodeIndex >= this.numItems * 4) {
                q.push(index3 << 1, dist);
              } else if (filterFn === void 0 || filterFn(index3)) {
                q.push((index3 << 1) + 1, dist);
              }
            }
            while (q.length && q.peek() & 1) {
              const dist = q.peekValue();
              if (dist > maxDistSquared) break outer;
              results.push(q.pop() >> 1);
              if (results.length === maxResults) break outer;
            }
            nodeIndex = q.length ? q.pop() >> 1 : void 0;
          }
          q.clear();
          return results;
        }
      };
    }
  });

  // node_modules/react-msaview/dist/components/tree/TreeBranchMenu.js
  var import_react63, import_material33, import_mobx_react33, TreeBranchMenu, TreeBranchMenu_default;
  var init_TreeBranchMenu = __esm({
    "node_modules/react-msaview/dist/components/tree/TreeBranchMenu.js"() {
      import_react63 = __toESM(require_react());
      import_material33 = __toESM(require_material());
      import_mobx_react33 = __toESM(require_mobx_react());
      TreeBranchMenu = (0, import_mobx_react33.observer)(function({ node: node2, model, onClose }) {
        return import_react63.default.createElement(
          import_material33.Menu,
          { anchorReference: "anchorPosition", anchorPosition: {
            left: node2.x,
            top: node2.y
          }, transitionDuration: 0, keepMounted: true, open: Boolean(node2), onClose },
          import_react63.default.createElement(import_material33.MenuItem, { dense: true, disabled: true }, node2.name),
          import_react63.default.createElement(import_material33.MenuItem, { dense: true, onClick: () => {
            model.toggleCollapsed(node2.id);
            onClose();
          } }, model.collapsed.includes(node2.id) ? "Expand this node" : "Collapse this node"),
          import_react63.default.createElement(import_material33.MenuItem, { dense: true, onClick: () => {
            if (model.showOnly === node2.id) {
              model.setShowOnly(void 0);
            } else {
              model.setShowOnly(node2.id);
            }
            onClose();
          } }, model.showOnly === node2.id ? "Disable show only this node" : "Show only this node")
        );
      });
      TreeBranchMenu_default = TreeBranchMenu;
    }
  });

  // node_modules/react-msaview/dist/components/tree/dialogs/TreeNodeInfoDialog.js
  var TreeNodeInfoDialog_exports = {};
  __export(TreeNodeInfoDialog_exports, {
    default: () => TreeNodeInfoDialog_default
  });
  var import_react64, import_Attributes2, import_BaseCard2, import_ui17, import_material34, import_mobx_react34, TreeNodeInfoDialog, TreeNodeInfoDialog_default;
  var init_TreeNodeInfoDialog = __esm({
    "node_modules/react-msaview/dist/components/tree/dialogs/TreeNodeInfoDialog.js"() {
      import_react64 = __toESM(require_react());
      import_Attributes2 = __toESM(require_Attributes());
      import_BaseCard2 = __toESM(require_BaseCard());
      import_ui17 = __toESM(require_ui());
      import_material34 = __toESM(require_material());
      import_mobx_react34 = __toESM(require_mobx_react());
      init_SequenceTextArea();
      TreeNodeInfoDialog = (0, import_mobx_react34.observer)(function({ info, model, nodeName, onClose }) {
        const { treeMetadata, rows } = model;
        const metadata = treeMetadata[nodeName];
        const res = rows.find((f2) => f2[0] === nodeName);
        return import_react64.default.createElement(
          import_ui17.Dialog,
          { onClose: () => {
            onClose();
          }, open: true, title: "Tree node info", maxWidth: "xl" },
          import_react64.default.createElement(
            import_material34.DialogContent,
            null,
            import_react64.default.createElement(
              import_BaseCard2.default,
              { title: "Attributes" },
              import_react64.default.createElement(import_Attributes2.default, { attributes: { nodeName, ...info } })
            ),
            import_react64.default.createElement(import_BaseCard2.default, { title: "Sequence" }, res ? import_react64.default.createElement(SequenceTextArea, { str: [res] }) : import_react64.default.createElement("div", null, "Sequence not found")),
            metadata ? import_react64.default.createElement(
              import_BaseCard2.default,
              { title: "Extra metadata" },
              import_react64.default.createElement(import_Attributes2.default, { attributes: metadata })
            ) : null
          )
        );
      });
      TreeNodeInfoDialog_default = TreeNodeInfoDialog;
    }
  });

  // node_modules/react-msaview/dist/components/tree/TreeNodeMenu.js
  var import_react65, import_material35, import_mobx_react35, TreeNodeInfoDialog2, TreeMenu, TreeNodeMenu_default;
  var init_TreeNodeMenu = __esm({
    "node_modules/react-msaview/dist/components/tree/TreeNodeMenu.js"() {
      import_react65 = __toESM(require_react());
      import_material35 = __toESM(require_material());
      import_mobx_react35 = __toESM(require_mobx_react());
      TreeNodeInfoDialog2 = (0, import_react65.lazy)(() => Promise.resolve().then(() => (init_TreeNodeInfoDialog(), TreeNodeInfoDialog_exports)));
      TreeMenu = (0, import_mobx_react35.observer)(function({ node: node2, onClose, model }) {
        const { collapsed, collapsedLeaves } = model;
        const { name } = node2;
        return import_react65.default.createElement(
          import_material35.Menu,
          { anchorReference: "anchorPosition", anchorPosition: {
            top: node2.y,
            left: node2.x
          }, transitionDuration: 0, keepMounted: true, open: Boolean(node2), onClose },
          import_react65.default.createElement(import_material35.MenuItem, { dense: true, disabled: true }, name),
          import_react65.default.createElement(import_material35.MenuItem, { dense: true, onClick: () => {
            model.queueDialog((onClose2) => [
              TreeNodeInfoDialog2,
              {
                info: model.getRowData(name),
                model,
                nodeName: name,
                onClose: onClose2
              }
            ]);
            onClose();
          } }, "More info..."),
          import_react65.default.createElement(import_material35.MenuItem, { dense: true, onClick: () => {
            if (collapsed.includes(node2.id)) {
              model.toggleCollapsed(node2.id);
            } else {
              if (node2.id.endsWith("-leafnode")) {
                model.toggleCollapsedLeaf(node2.id);
              } else {
                model.toggleCollapsedLeaf(`${node2.id}-leafnode`);
              }
            }
            onClose();
          } }, collapsed.includes(node2.id) || collapsedLeaves.includes(node2.id) ? "Show node" : "Hide node"),
          import_react65.default.createElement(import_material35.MenuItem, { dense: true, onClick: () => {
            model.drawRelativeTo(node2.name);
            onClose();
          } }, "Indicate differences from this row"),
          model.relativeTo ? import_react65.default.createElement(import_material35.MenuItem, { dense: true, onClick: () => {
            model.drawRelativeTo(void 0);
            onClose();
          } }, "Clear reference row") : null
        );
      });
      TreeNodeMenu_default = TreeMenu;
    }
  });

  // node_modules/react-msaview/dist/components/tree/renderTreeCanvas.js
  function renderTree({ offsetY, ctx, model, theme, blockSizeYOverride }) {
    const { hierarchy: hierarchy2, showBranchLenEffective: showBranchLen, blockSize } = model;
    const by = blockSizeYOverride || blockSize;
    ctx.strokeStyle = theme.palette.text.primary;
    for (const link of hierarchy2.links()) {
      const { source, target } = link;
      if (target.height === 0 && !showBranchLen) {
        continue;
      }
      const sy = source.x;
      const ty = target.x;
      const tx = showBranchLen ? target.len : target.y;
      const sx = showBranchLen ? source.len : source.y;
      if (tx === void 0 || sx === void 0) {
        continue;
      }
      const y1 = Math.min(sy, ty);
      const y2 = Math.max(sy, ty);
      if (offsetY + by >= y1 && y2 >= offsetY) {
        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(sx, ty);
        ctx.lineTo(tx, ty);
        ctx.stroke();
      }
    }
  }
  function renderNodeBubbles({ ctx, clickMap, offsetY, model, blockSizeYOverride }) {
    const { hierarchy: hierarchy2, showBranchLenEffective: showBranchLen, collapsed, blockSize, marginLeft: ml } = model;
    const by = blockSizeYOverride || blockSize;
    for (const node2 of hierarchy2.descendants()) {
      const x2 = showBranchLen ? node2.len : node2.y;
      if (x2 === void 0) {
        continue;
      }
      const { data } = node2;
      const y2 = node2.x;
      const { id, name } = data;
      if (node2.height > 1 && y2 > offsetY - extendBounds && y2 < offsetY + by + extendBounds) {
        ctx.strokeStyle = "black";
        ctx.fillStyle = collapsed.includes(id) ? "black" : "white";
        ctx.beginPath();
        ctx.arc(x2, y2, radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
        clickMap?.insert({
          minX: x2 - radius + ml,
          maxX: x2 - radius + d2 + ml,
          minY: y2 - radius,
          maxY: y2 - radius + d2,
          branch: true,
          id,
          name
        });
      }
    }
  }
  function renderTreeLabels({ theme, model, offsetY, ctx, clickMap, blockSizeYOverride }) {
    const { fontSize, showBranchLenEffective: showBranchLen, treeMetadata, hierarchy: hierarchy2, collapsed, collapsedLeaves, blockSize, labelsAlignRight, drawTree, treeAreaWidth, treeWidth, treeAreaWidthMinusMargin, marginLeft, leaves, noTree } = model;
    const by = blockSizeYOverride || blockSize;
    const emHeight = ctx.measureText("M").width;
    if (labelsAlignRight) {
      ctx.textAlign = "right";
      ctx.setLineDash([1, 3]);
    } else {
      ctx.textAlign = "start";
    }
    for (const node2 of leaves) {
      const { data: { name, id } } = node2;
      const len2 = node2.len;
      const y2 = node2.x;
      const x2 = node2.y;
      const displayName = treeMetadata[name]?.genome || name;
      if (y2 > offsetY - extendBounds && y2 < offsetY + by + extendBounds) {
        const yp = y2 + fontSize / 4;
        let xp = 0;
        if (!noTree) {
          xp = (showBranchLen ? len2 : x2) || 0;
          if (!showBranchLen && !collapsed.includes(id) && !collapsedLeaves.includes(id)) {
            xp -= treeWidth / hierarchy2.height;
          }
        }
        const { width } = ctx.measureText(displayName);
        ctx.fillStyle = theme.palette.text.primary;
        if (labelsAlignRight) {
          const smallPadding = 2;
          const offset4 = treeAreaWidthMinusMargin - smallPadding;
          if (drawTree && !noTree) {
            ctx.moveTo(xp + radius + 2, y2);
            ctx.lineTo(offset4 - smallPadding - width, y2);
            ctx.stroke();
          }
          ctx.fillText(displayName, offset4, yp);
          clickMap?.insert({
            minX: treeAreaWidth - width,
            maxX: treeAreaWidth,
            minY: yp - emHeight,
            maxY: yp,
            name,
            id
          });
        } else {
          const labelX = noTree ? 2 : xp + d2;
          ctx.fillText(displayName, labelX, yp);
          clickMap?.insert({
            minX: labelX + marginLeft,
            maxX: labelX + width + marginLeft,
            minY: yp - emHeight,
            maxY: yp,
            name,
            id
          });
        }
      }
    }
    ctx.setLineDash([]);
  }
  function renderTreeCanvas({ model, clickMap, ctx, offsetY, theme, highResScaleFactorOverride, blockSizeYOverride }) {
    clickMap?.clear();
    const {
      noTree,
      drawTree,
      drawNodeBubbles,
      highResScaleFactor,
      fontSize,
      showTreeText,
      marginLeft,
      nref,
      // eslint-disable-next-line  @typescript-eslint/no-unused-vars
      rowHeight: _rowHeight
      // this is needed for redrawing after zoom change
    } = model;
    ctx.resetTransform();
    const k2 = nref < 0 ? Number.NEGATIVE_INFINITY : highResScaleFactorOverride || highResScaleFactor;
    ctx.scale(k2, k2);
    ctx.translate(marginLeft, -offsetY);
    const font = ctx.font;
    ctx.font = font.replace(/\d+px/, `${fontSize}px`);
    if (!noTree && drawTree) {
      renderTree({
        ctx,
        offsetY,
        model,
        theme,
        blockSizeYOverride
      });
      if (drawNodeBubbles) {
        renderNodeBubbles({
          ctx,
          offsetY,
          clickMap,
          model,
          blockSizeYOverride
        });
      }
    }
    if (showTreeText) {
      renderTreeLabels({
        ctx,
        offsetY,
        model,
        clickMap,
        theme,
        blockSizeYOverride
      });
    }
    clickMap?.finish();
  }
  var padding, extendBounds, radius, d2;
  var init_renderTreeCanvas = __esm({
    "node_modules/react-msaview/dist/components/tree/renderTreeCanvas.js"() {
      padding = 600;
      extendBounds = 5;
      radius = 2.5;
      d2 = radius * 2;
    }
  });

  // node_modules/react-msaview/dist/components/tree/TreeCanvasBlock.js
  var import_react66, import_material36, import_mobx3, import_mobx_react36, ClickMapIndex, TreeCanvasBlock, TreeCanvasBlock_default;
  var init_TreeCanvasBlock = __esm({
    "node_modules/react-msaview/dist/components/tree/TreeCanvasBlock.js"() {
      import_react66 = __toESM(require_react());
      import_material36 = __toESM(require_material());
      init_flatbush();
      import_mobx3 = __toESM(require_mobx());
      import_mobx_react36 = __toESM(require_mobx_react());
      init_TreeBranchMenu();
      init_TreeNodeMenu();
      init_renderTreeCanvas();
      ClickMapIndex = class {
        flatbush = null;
        entries = [];
        clear() {
          this.flatbush = null;
          this.entries = [];
        }
        insert(entry) {
          this.entries.push(entry);
        }
        finish() {
          if (this.entries.length === 0) {
            this.flatbush = null;
            return;
          } else {
            this.flatbush = new Flatbush(this.entries.length);
            for (const entry of this.entries) {
              this.flatbush.add(entry.minX, entry.minY, entry.maxX, entry.maxY);
            }
            this.flatbush.finish();
          }
        }
        search(box) {
          return this.flatbush?.search(box.minX, box.minY, box.maxX, box.maxY).map((i2) => this.entries[i2]) ?? [];
        }
      };
      TreeCanvasBlock = (0, import_mobx_react36.observer)(function({ model, offsetY }) {
        const theme = (0, import_material36.useTheme)();
        const ref = (0, import_react66.useRef)(null);
        const clickMap = (0, import_react66.useRef)(new ClickMapIndex());
        const mouseoverRef = (0, import_react66.useRef)(null);
        const [branchMenu, setBranchMenu] = (0, import_react66.useState)();
        const [toggleNodeMenu, setToggleNodeMenu] = (0, import_react66.useState)();
        const [hoverElt, setHoverElt] = (0, import_react66.useState)();
        const { scrollY, treeAreaWidth, blockSize, highResScaleFactor } = model;
        const width = treeAreaWidth + padding;
        const height = blockSize;
        const w2 = width * highResScaleFactor;
        const h2 = height * highResScaleFactor;
        const vref = (0, import_react66.useCallback)(
          (arg) => {
            model.incrementRef();
            ref.current = arg;
          },
          // eslint-disable-next-line react-hooks/exhaustive-deps
          [model, height, width]
        );
        (0, import_react66.useEffect)(() => {
          const ctx = ref.current?.getContext("2d");
          if (!ctx) {
            return;
          }
          return (0, import_mobx3.autorun)(() => {
            ctx.resetTransform();
            ctx.clearRect(0, 0, (treeAreaWidth + padding) * highResScaleFactor, blockSize * highResScaleFactor);
            renderTreeCanvas({
              ctx,
              model,
              offsetY,
              clickMap: clickMap.current,
              theme
            });
          });
        }, [model, blockSize, highResScaleFactor, treeAreaWidth, offsetY, theme]);
        (0, import_react66.useEffect)(() => {
          const ctx = mouseoverRef.current?.getContext("2d");
          if (!ctx) {
            return;
          }
          ctx.resetTransform();
          ctx.clearRect(0, 0, treeAreaWidth + padding, blockSize);
          ctx.translate(0, -offsetY);
          if (hoverElt) {
            const { minX, maxX, minY, maxY: maxY2 } = hoverElt;
            ctx.fillStyle = "rgba(0,0,0,0.1)";
            ctx.fillRect(minX, minY, maxX - minX, maxY2 - minY);
          }
        }, [hoverElt, offsetY, blockSize, treeAreaWidth]);
        function hoverBranchClickMap(event) {
          const x2 = event.nativeEvent.offsetX;
          const y2 = event.nativeEvent.offsetY;
          const [entry] = clickMap.current.search({
            minX: x2,
            maxX: x2 + 1,
            minY: y2 + offsetY,
            maxY: y2 + 1 + offsetY
          });
          return entry?.branch ? { ...entry, x: event.clientX, y: event.clientY } : void 0;
        }
        function hoverNameClickMap(event) {
          const x2 = event.nativeEvent.offsetX;
          const y2 = event.nativeEvent.offsetY;
          const [entry] = clickMap.current.search({
            minX: x2,
            maxX: x2 + 1,
            minY: y2 + offsetY,
            maxY: y2 + 1 + offsetY
          });
          return entry && !entry.branch ? { ...entry, x: event.clientX, y: event.clientY } : void 0;
        }
        const style = {
          width,
          height,
          top: scrollY + offsetY,
          left: 0,
          position: "absolute"
        };
        return import_react66.default.createElement(
          import_react66.default.Fragment,
          null,
          branchMenu?.id ? import_react66.default.createElement(TreeBranchMenu_default, { node: branchMenu, model, onClose: () => {
            setBranchMenu(void 0);
          } }) : null,
          toggleNodeMenu?.id ? import_react66.default.createElement(TreeNodeMenu_default, { node: toggleNodeMenu, model, onClose: () => {
            setToggleNodeMenu(void 0);
          } }) : null,
          import_react66.default.createElement("canvas", { width: w2, height: h2, style, onMouseMove: (event) => {
            if (!ref.current) {
              return;
            }
            const hoveredLeaf = hoverNameClickMap(event);
            const hoveredBranch = hoverBranchClickMap(event);
            const hoveredAny = hoveredLeaf || hoveredBranch;
            ref.current.style.cursor = hoveredAny ? "pointer" : "default";
            setHoverElt(hoveredLeaf);
            if (hoveredAny) {
              model.setHoveredTreeNode(hoveredAny.id);
              if (hoveredLeaf?.name) {
                const rowIndex = model.rowNamesSet.get(hoveredLeaf.name);
                if (rowIndex !== void 0) {
                  model.setMousePos(void 0, rowIndex);
                }
              }
            } else {
              model.setHoveredTreeNode(void 0);
              model.setMousePos(void 0, void 0);
            }
          }, onClick: (event) => {
            const { clientX: x2, clientY: y2 } = event;
            const data = hoverBranchClickMap(event);
            if (data?.id) {
              setBranchMenu({ x: x2, y: y2, id: data.id, name: data.name });
            }
            const data2 = hoverNameClickMap(event);
            if (data2?.id) {
              setToggleNodeMenu({ ...data2, x: x2, y: y2 });
            }
          }, onMouseLeave: () => {
            setHoverElt(void 0);
            model.setHoveredTreeNode(void 0);
            model.setMousePos(void 0, void 0);
          }, ref: vref }),
          import_react66.default.createElement("canvas", { style: {
            ...style,
            pointerEvents: "none",
            zIndex: 100
          }, width, height, ref: mouseoverRef })
        );
      });
      TreeCanvasBlock_default = TreeCanvasBlock;
    }
  });

  // node_modules/react-msaview/dist/components/tree/TreeCanvas.js
  var import_react67, import_mobx4, import_mobx_react37, import_mobx_state_tree2, TreeCanvas, TreeCanvas_default;
  var init_TreeCanvas = __esm({
    "node_modules/react-msaview/dist/components/tree/TreeCanvas.js"() {
      import_react67 = __toESM(require_react());
      import_mobx4 = __toESM(require_mobx());
      import_mobx_react37 = __toESM(require_mobx_react());
      import_mobx_state_tree2 = __toESM(require_mobx_state_tree());
      init_TreeCanvasBlock();
      init_renderTreeCanvas();
      TreeCanvas = (0, import_mobx_react37.observer)(function({ model }) {
        const ref = (0, import_react67.useRef)(null);
        const mouseoverRef = (0, import_react67.useRef)(null);
        const scheduled = (0, import_react67.useRef)(false);
        const deltaY = (0, import_react67.useRef)(0);
        const prevY = (0, import_react67.useRef)(0);
        const { treeWidth, height, blocksY: blocksY2, treeAreaWidth, scrollY } = model;
        const [mouseDragging, setMouseDragging] = (0, import_react67.useState)(false);
        (0, import_react67.useEffect)(() => {
          const curr = ref.current;
          if (!curr) {
            return;
          }
          function onWheel(event) {
            deltaY.current += event.deltaY;
            if (!scheduled.current) {
              scheduled.current = true;
              requestAnimationFrame(() => {
                model.doScrollY(-deltaY.current);
                deltaY.current = 0;
                scheduled.current = false;
              });
            }
            event.preventDefault();
            event.stopPropagation();
          }
          curr.addEventListener("wheel", onWheel);
          return () => {
            curr.removeEventListener("wheel", onWheel);
          };
        }, [model]);
        (0, import_react67.useEffect)(() => {
          let cleanup2 = () => {
          };
          function globalMouseMove(event) {
            event.preventDefault();
            const currY = event.clientY;
            const distanceY = currY - prevY.current;
            if (distanceY) {
              if (!scheduled.current) {
                scheduled.current = true;
                window.requestAnimationFrame(() => {
                  model.doScrollY(distanceY);
                  scheduled.current = false;
                  prevY.current = event.clientY;
                });
              }
            }
          }
          function globalMouseUp() {
            prevY.current = 0;
            if (mouseDragging) {
              setMouseDragging(false);
            }
          }
          if (mouseDragging) {
            window.addEventListener("mousemove", globalMouseMove, true);
            window.addEventListener("mouseup", globalMouseUp, true);
            cleanup2 = () => {
              window.removeEventListener("mousemove", globalMouseMove, true);
              window.removeEventListener("mouseup", globalMouseUp, true);
            };
          }
          return cleanup2;
        }, [model, mouseDragging]);
        (0, import_react67.useEffect)(() => {
          const ctx = mouseoverRef.current?.getContext("2d");
          return ctx ? (0, import_mobx4.autorun)(() => {
            if ((0, import_mobx_state_tree2.isAlive)(model)) {
              ctx.resetTransform();
              ctx.clearRect(0, 0, treeAreaWidth, height);
              const { relativeTo, leaves, rowHeight, hoveredTreeNode } = model;
              if (relativeTo) {
                const referenceLeaf = leaves.find((leaf) => leaf.data.name === relativeTo);
                if (referenceLeaf) {
                  const y2 = referenceLeaf.x + scrollY;
                  ctx.fillStyle = "rgba(0,128,255,0.3)";
                  ctx.fillRect(0, y2 - rowHeight / 2, treeAreaWidth, rowHeight);
                }
              }
              if (hoveredTreeNode) {
                ctx.fillStyle = "rgba(255,165,0,0.2)";
                for (const descendantName of hoveredTreeNode.descendantNames) {
                  const matchingLeaf = leaves.find((leaf) => leaf.data.name === descendantName);
                  if (matchingLeaf) {
                    const y2 = matchingLeaf.x + scrollY;
                    ctx.fillRect(0, y2 - rowHeight / 2, treeAreaWidth, rowHeight);
                  }
                }
              }
              const { mouseOverRowName } = model;
              if (mouseOverRowName && mouseOverRowName !== relativeTo && !hoveredTreeNode?.descendantNames.includes(mouseOverRowName)) {
                const matchingLeaf = leaves.find((leaf) => leaf.data.name === mouseOverRowName);
                if (matchingLeaf) {
                  const y2 = matchingLeaf.x + scrollY;
                  ctx.fillStyle = "rgba(255,165,0,0.2)";
                  ctx.fillRect(0, y2 - rowHeight / 2, treeAreaWidth, rowHeight);
                }
              }
            }
          }) : void 0;
        }, [model, treeAreaWidth, height, scrollY]);
        function mouseDown(event) {
          const target = event.target;
          if (target.draggable || target.dataset.resizer) {
            return;
          }
          if (event.button === 0) {
            prevY.current = event.clientY;
            setMouseDragging(true);
          }
        }
        return import_react67.default.createElement(
          "div",
          { ref, onMouseDown: mouseDown, onMouseUp: (event) => {
            event.preventDefault();
            setMouseDragging(false);
          }, onMouseLeave: (event) => {
            event.preventDefault();
          }, style: {
            height,
            position: "relative",
            width: treeWidth + padding
          } },
          blocksY2.map((block) => import_react67.default.createElement(TreeCanvasBlock_default, { key: block, model, offsetY: block })),
          import_react67.default.createElement("canvas", { ref: mouseoverRef, width: treeAreaWidth, height, style: {
            position: "absolute",
            top: 0,
            left: 0,
            width: treeAreaWidth,
            height,
            zIndex: 1e3,
            pointerEvents: "none"
          } })
        );
      });
      TreeCanvas_default = TreeCanvas;
    }
  });

  // node_modules/react-msaview/dist/components/tree/TreePanel.js
  var import_react68, import_mobx_react38, TreePanel, TreePanel_default;
  var init_TreePanel = __esm({
    "node_modules/react-msaview/dist/components/tree/TreePanel.js"() {
      import_react68 = __toESM(require_react());
      import_mobx_react38 = __toESM(require_mobx_react());
      init_TreeCanvas();
      TreePanel = (0, import_mobx_react38.observer)(function({ model }) {
        const { treeAreaWidth } = model;
        return import_react68.default.createElement(
          "div",
          { style: { overflow: "hidden", flexShrink: 0, width: treeAreaWidth } },
          import_react68.default.createElement(TreeCanvas_default, { model })
        );
      });
      TreePanel_default = TreePanel;
    }
  });

  // node_modules/react-msaview/dist/components/tree/TreeRuler.js
  var import_react69, import_mobx_react39, TreeRuler, TreeRuler_default;
  var init_TreeRuler = __esm({
    "node_modules/react-msaview/dist/components/tree/TreeRuler.js"() {
      import_react69 = __toESM(require_react());
      import_mobx_react39 = __toESM(require_mobx_react());
      TreeRuler = (0, import_mobx_react39.observer)(({ model }) => {
        const { treeAreaWidth } = model;
        return import_react69.default.createElement("div", { style: { flexShrink: 0, width: treeAreaWidth } });
      });
      TreeRuler_default = TreeRuler;
    }
  });

  // node_modules/react-msaview/dist/components/MSAView.js
  var import_react70, import_mobx_react40, TopArea, TrackColumnIndicator, TrackArea, MainArea, View, MSAView, MSAView_default;
  var init_MSAView = __esm({
    "node_modules/react-msaview/dist/components/MSAView.js"() {
      import_react70 = __toESM(require_react());
      import_mobx_react40 = __toESM(require_mobx_react());
      init_ResizeHandles();
      init_Track();
      init_VerticalScrollbar();
      init_Header();
      init_Minimap();
      init_MSAPanel();
      init_TreePanel();
      init_TreeRuler();
      TopArea = (0, import_mobx_react40.observer)(function({ model }) {
        const { showHorizontalScrollbar } = model;
        return import_react70.default.createElement(
          "div",
          { style: { display: "flex" } },
          import_react70.default.createElement(TreeRuler_default, { model }),
          showHorizontalScrollbar ? import_react70.default.createElement(Minimap_default, { model }) : null
        );
      });
      TrackColumnIndicator = (0, import_mobx_react40.observer)(function({ model }) {
        const { mouseCol, mouseClickCol, colWidth, scrollX, treeAreaWidth, resizeHandleWidth, totalTrackAreaHeight } = model;
        const left = treeAreaWidth + resizeHandleWidth;
        return import_react70.default.createElement(
          import_react70.default.Fragment,
          null,
          mouseCol !== void 0 ? import_react70.default.createElement("div", { style: {
            position: "absolute",
            left: left + mouseCol * colWidth + scrollX,
            top: 0,
            width: colWidth,
            height: totalTrackAreaHeight,
            backgroundColor: "rgba(0,0,0,0.15)",
            pointerEvents: "none",
            zIndex: 100
          } }) : null,
          mouseClickCol !== void 0 ? import_react70.default.createElement("div", { style: {
            position: "absolute",
            left: left + mouseClickCol * colWidth + scrollX,
            top: 0,
            width: colWidth,
            height: totalTrackAreaHeight,
            backgroundColor: "rgba(128,128,0,0.2)",
            pointerEvents: "none",
            zIndex: 100
          } }) : null
        );
      });
      TrackArea = (0, import_mobx_react40.observer)(function({ model }) {
        const { turnedOnTracks } = model;
        if (turnedOnTracks.length === 0) {
          return null;
        }
        return import_react70.default.createElement(
          "div",
          { style: { position: "relative" } },
          import_react70.default.createElement(TrackColumnIndicator, { model }),
          turnedOnTracks.map((track) => import_react70.default.createElement(Track_default, { key: track.model.id, model, track }))
        );
      });
      MainArea = (0, import_mobx_react40.observer)(function({ model }) {
        const { showVerticalScrollbar } = model;
        return import_react70.default.createElement(
          "div",
          { style: { display: "flex" } },
          import_react70.default.createElement(TreePanel_default, { model }),
          import_react70.default.createElement(VerticalResizeHandle, { model }),
          import_react70.default.createElement(MSAPanel_default, { model }),
          showVerticalScrollbar ? import_react70.default.createElement(VerticalScrollbar_default, { model }) : null
        );
      });
      View = (0, import_mobx_react40.observer)(function({ model }) {
        return import_react70.default.createElement(
          "div",
          { style: { position: "relative" } },
          import_react70.default.createElement(TopArea, { model }),
          import_react70.default.createElement(TrackArea, { model }),
          import_react70.default.createElement(MainArea, { model })
        );
      });
      MSAView = (0, import_mobx_react40.observer)(function({ model }) {
        const { height, viewInitialized, DialogComponent, DialogProps } = model;
        return import_react70.default.createElement("div", null, viewInitialized ? import_react70.default.createElement(
          import_react70.default.Fragment,
          null,
          import_react70.default.createElement(
            "div",
            { style: { height, overflow: "hidden" } },
            import_react70.default.createElement(Header_default, { model }),
            import_react70.default.createElement(View, { model })
          ),
          import_react70.default.createElement(HorizontalResizeHandle, { model }),
          DialogComponent ? import_react70.default.createElement(
            import_react70.Suspense,
            { fallback: null },
            import_react70.default.createElement(DialogComponent, { ...DialogProps })
          ) : null
        ) : null);
      });
      MSAView_default = MSAView;
    }
  });

  // node_modules/react-msaview/dist/components/import/data/seq2.js
  var smallMSA, smallMSAOnly, smallTree;
  var init_seq2 = __esm({
    "node_modules/react-msaview/dist/components/import/data/seq2.js"() {
      smallMSA = `CLUSTAL O(1.2.3) multiple sequence alignment
UniProt/Swiss-Prot|P26898|IL2RA_SHEEP      MEPSLLMWRFFVFIVVPGCVTEACHDDPPSLRNA----------MFKVLRYE----VGTM
UniProt/Swiss-Prot|P01590|IL2RA_MOUSE      MEPRLLMLGFLSLTIVPSCRAELCLYDPPEVPNA----------TFKALSYK----NGTI
UniProt/Swiss-Prot|P41690|IL2RA_FELCA      MEPSLLLWGILTFVVVHGHVTELCDENPPDIQHA----------TFKALTYK----TGTM
UniProt/Swiss-Prot|P01589|IL2RA_HUMAN      MDSYLLMWGLLTFIMVPGCQAELCDDDPPEIPHA----------TFKAMAYK----EGTM
UniProt/Swiss-Prot|Q5MNY4|IL2RA_MACMU      MDPYLLMWGLLTFITVPGCQAELCDDDPPKITHA----------TFKAVAYK----EGTM
UniProt/Swiss-Prot|Q95118|IL2RG_BOVIN      -----------------------------------LLMWGLLT-----------------
UniProt/Swiss-Prot|P40321|IL2RG_CANFA      MLKPPLPLRSLLFLQLSLLGVGLNSTVPMPNGNEDIT------PDFFLTATPSETLSVSS
UniProt/Swiss-Prot|P26896|IL2RB_RAT        MATVDLSWRLPLYILLLLLATT--------------------------------WVSAAV
UniProt/Swiss-Prot|Q8BZM1|GLMN_MOUSE       PLPLRSLLFLQLPLLGVGLNP------------------PLPLRSLLFLQLPLLGVGLNP
UniProt/Swiss-Prot|P36835|IL2_CAPHI        -----------LLGVGLNPKFLTP------------------------------------
UniProt/Swiss-Prot|Q7JFM4|IL2_AOTVO        MLKPPLPLRSLLFLQLPLLGVGLNPKFLTPSGNEDIGGKPGTGGDFFLTSTPAGTLDVST
UniProt/Swiss-Prot|Q29416|IL2_CANFA        --------------LFLQLSLLG-------------------------------------
`;
      smallMSAOnly = `CLUSTAL O(1.2.4) multiple sequence alignment


sp|P69905|HBA_HUMAN       MVLSPADKTNVKAAWGKVGAHAGEYGAEALERMFLSFPTTKTYFPHFDLSHGSAQVKGHG	60
sp|P01942|HBA_MOUSE       MVLSGEDKSNIKAAWGKIGGHGAEYGAEALERMFASFPTTKTYFPHFDVSHGSAQVKGHG	60
sp|P13786|HBAZ_CAPHI      MSLTRTERTIILSLWSKISTQADVIGTETLERLFSCYPQAKTYFPHFDLHSGSAQLRAHG	60
                          * *:  ::: : : *.*:. :.   *:*:***:* .:* :********:  ****::.**

sp|P69905|HBA_HUMAN       KKVADALTNAVAHVDDMPNALSALSDLHAHKLRVDPVNFKLLSHCLLVTLAAHLPAEFTP	120
sp|P01942|HBA_MOUSE       KKVADALASAAGHLDDLPGALSALSDLHAHKLRVDPVNFKLLSHCLLVTLASHHPADFTP	120
sp|P13786|HBAZ_CAPHI      SKVVAAVGDAVKSIDNVTSALSKLSELHAYVLRVDPVNFKFLSHCLLVTLASHFPADFTA	120
                          .**. *: .*.  :*:: .*** **:***: *********:**********:* **:**

sp|P69905|HBA_HUMAN       AVHASLDKFLASVSTVLTSKYR	142
sp|P01942|HBA_MOUSE       AVHASLDKFLASVSTVLTSKYR	142
sp|P13786|HBAZ_CAPHI      DAHAAWDKFLSIVSGVLTEKYR	142
                           .**: ****: ** ***.***`;
      smallTree = "(((UniProt/Swiss-Prot|P26898|IL2RA_SHEEP:0.24036,(UniProt/Swiss-Prot|P41690|IL2RA_FELCA:0.17737,(UniProt/Swiss-Prot|P01589|IL2RA_HUMAN:0.03906,UniProt/Swiss-Prot|Q5MNY4|IL2RA_MACMU:0.03787):0.13033):0.04964):0.02189,UniProt/Swiss-Prot|P01590|IL2RA_MOUSE:0.23072):0.06814,(((UniProt/Swiss-Prot|Q95118|IL2RG_BOVIN:0.09600,UniProt/Swiss-Prot|P40321|IL2RG_CANFA:0.09845):0.25333,UniProt/Swiss-Prot|Q29416|IL2_CANFA:-0.35055):0.10231,(UniProt/Swiss-Prot|P26896|IL2RB_RAT:0.33631,UniProt/Swiss-Prot|Q7JFM4|IL2_AOTVO:-0.33631):0.10166):0.01607,(UniProt/Swiss-Prot|Q8BZM1|GLMN_MOUSE:0.32378,UniProt/Swiss-Prot|P36835|IL2_CAPHI:-0.32378):0.09999)";
    }
  });

  // node_modules/react-msaview/dist/components/import/util.js
  async function load(model, msaFile, treeFile, gffFile) {
    model.setError(void 0);
    if (msaFile) {
      model.setMSAFilehandle(msaFile);
    }
    if (treeFile) {
      model.setTreeFilehandle(treeFile);
    }
    if (gffFile) {
      model.setGFFFilehandle(gffFile);
    }
  }
  var init_util2 = __esm({
    "node_modules/react-msaview/dist/components/import/util.js"() {
    }
  });

  // node_modules/react-msaview/dist/components/import/ImportFormExamples.js
  function ListItem({ onClick, model, children }) {
    return import_react71.default.createElement(
      "li",
      null,
      import_react71.default.createElement(
        import_material37.Link,
        { onClick: (event) => {
          model.setError(void 0);
          event.preventDefault();
          onClick();
        }, href: "#" },
        import_react71.default.createElement(import_material37.Typography, { display: "inline" }, children)
      )
    );
  }
  var import_react71, import_material37, import_mobx_react41, ImportFormExamples, ImportFormExamples_default;
  var init_ImportFormExamples = __esm({
    "node_modules/react-msaview/dist/components/import/ImportFormExamples.js"() {
      import_react71 = __toESM(require_react());
      import_material37 = __toESM(require_material());
      import_mobx_react41 = __toESM(require_mobx_react());
      init_seq2();
      init_util2();
      ImportFormExamples = (0, import_mobx_react41.observer)(function({ model }) {
        function l2(uri1, uri2) {
          ;
          (async () => {
            try {
              await load(model, uri1 ? {
                uri: uri1,
                locationType: "UriLocation"
              } : void 0, uri2 ? {
                uri: uri2,
                locationType: "UriLocation"
              } : void 0);
            } catch (e2) {
              console.error(e2);
              model.setError(e2);
            }
          })();
        }
        return import_react71.default.createElement(
          "ul",
          null,
          import_react71.default.createElement(ListItem, { model, onClick: () => {
            l2(void 0, "https://jbrowse.org/genomes/newicktrees/sarscov2phylo.pub.ft.nh");
          } }, "230k COVID-19 samples (tree only)"),
          import_react71.default.createElement(ListItem, { model, onClick: () => {
            model.setData({ msa: smallMSA, tree: smallTree });
          } }, "Small protein MSA+tree"),
          import_react71.default.createElement(ListItem, { model, onClick: () => {
            model.setData({ msa: smallMSAOnly });
          } }, "Small MSA only"),
          import_react71.default.createElement(ListItem, { model, onClick: () => {
            l2("https://jbrowse.org/genomes/multiple_sequence_alignments/pfam-cov2.stock");
          } }, "PFAM SARS-CoV2 multi-stockholm"),
          import_react71.default.createElement(ListItem, { model, onClick: () => {
            l2("https://jbrowse.org/genomes/multiple_sequence_alignments/Lysine.stock");
          } }, "Lysine stockholm file"),
          import_react71.default.createElement(ListItem, { model, onClick: () => {
            l2("https://jbrowse.org/genomes/multiple_sequence_alignments/PF01601_full.txt");
          } }, "PF01601 stockholm file (SARS-CoV2 spike protein)"),
          import_react71.default.createElement(ListItem, { model, onClick: () => {
            l2("https://jbrowse.org/genomes/multiple_sequence_alignments/europe_covid.fa");
          } }, "Europe COVID full genomes (LR883044.1 and 199 other sequences)"),
          import_react71.default.createElement(ListItem, { model, onClick: () => {
            l2("https://jbrowse.org/genomes/multiple_sequence_alignments/rhv_test-only.aligned_with_mafft_auto.fa", "https://jbrowse.org/genomes/multiple_sequence_alignments/rhv_test-only.aligned_with_mafft_auto.nh");
          } }, "MAFFT+VeryFastTree(17.9k samples)"),
          import_react71.default.createElement(ListItem, { model, onClick: () => {
            l2("https://jbrowse.org/demos/ttc39a.mfa");
          } }, "Human BLAST results mfa")
        );
      });
      ImportFormExamples_default = ImportFormExamples;
    }
  });

  // node_modules/react-msaview/dist/components/import/ImportForm.js
  var import_react72, import_ui18, import_material38, import_mobx_react42, ImportForm, ImportForm_default;
  var init_ImportForm = __esm({
    "node_modules/react-msaview/dist/components/import/ImportForm.js"() {
      import_react72 = __toESM(require_react());
      import_ui18 = __toESM(require_ui());
      import_material38 = __toESM(require_material());
      import_mobx_react42 = __toESM(require_mobx_react());
      init_ImportFormExamples();
      init_util2();
      ImportForm = (0, import_mobx_react42.observer)(function({ model }) {
        const [msaFile, setMsaFile] = (0, import_react72.useState)();
        const [treeFile, setTreeFile] = (0, import_react72.useState)();
        const [gffFile, setGffFile] = (0, import_react72.useState)();
        const { error: error2 } = model;
        return import_react72.default.createElement(
          import_material38.Container,
          null,
          import_react72.default.createElement(
            "div",
            { style: { width: "50%" } },
            error2 ? import_react72.default.createElement(import_ui18.ErrorMessage, { error: error2 }) : null,
            import_react72.default.createElement(import_material38.Typography, null, "Open an MSA file (stockholm or clustal format) and/or a tree file (newick format)."),
            import_react72.default.createElement(import_material38.Typography, { color: "error" }, "Note: you can open up just an MSA or just a tree, both are not required. Some MSA files e.g. stockholm format have an embedded tree also and this is fine, and opening a separate tree file is not required.")
          ),
          import_react72.default.createElement(
            "div",
            { style: {
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              gap: 40
            } },
            import_react72.default.createElement(
              "div",
              null,
              import_react72.default.createElement(
                "div",
                null,
                import_react72.default.createElement(import_material38.Typography, null, "MSA file or URL"),
                import_react72.default.createElement(import_ui18.FileSelector, { location: msaFile, setLocation: setMsaFile })
              ),
              import_react72.default.createElement(
                "div",
                null,
                import_react72.default.createElement(import_material38.Typography, null, "Tree file or URL"),
                import_react72.default.createElement(import_ui18.FileSelector, { location: treeFile, setLocation: setTreeFile })
              ),
              import_react72.default.createElement(
                "div",
                null,
                import_react72.default.createElement(import_material38.Typography, null, "InterProScan GFF file or URL (optional)"),
                import_react72.default.createElement(import_ui18.FileSelector, { location: gffFile, setLocation: setGffFile })
              )
            ),
            import_react72.default.createElement(
              "div",
              null,
              import_react72.default.createElement(import_material38.Button, { onClick: () => {
                ;
                (async () => {
                  try {
                    await load(model, msaFile, treeFile, gffFile);
                  } catch (e2) {
                    console.error(e2);
                    model.setError(e2);
                  }
                })();
              }, variant: "contained", color: "primary", disabled: !msaFile && !treeFile }, "Open")
            ),
            import_react72.default.createElement(
              "div",
              null,
              import_react72.default.createElement(import_material38.Typography, null, "Examples"),
              import_react72.default.createElement(ImportFormExamples_default, { model })
            )
          )
        );
      });
      ImportForm_default = ImportForm;
    }
  });

  // node_modules/react-msaview/dist/components/Loading.js
  function LoadingSpinner() {
    return import_react73.default.createElement(
      "div",
      { style: { display: "flex", alignItems: "center", gap: 12, padding: 20 } },
      import_react73.default.createElement(
        "svg",
        { width: "24", height: "24", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" },
        import_react73.default.createElement("style", null, `@keyframes spinner { to { transform: rotate(360deg); } }`),
        import_react73.default.createElement("circle", { cx: "12", cy: "12", r: "10", stroke: "#ccc", strokeWidth: "3", fill: "none" }),
        import_react73.default.createElement("path", { d: "M12 2a10 10 0 0 1 10 10", stroke: "#1976d2", strokeWidth: "3", fill: "none", strokeLinecap: "round", style: {
          animation: "spinner 1s linear infinite",
          transformOrigin: "center"
        } })
      ),
      import_react73.default.createElement(import_material39.Typography, { variant: "h6" }, "Loading...")
    );
  }
  var import_react73, import_ui19, import_ErrorBoundary, import_material39, import_mobx_react43, Reset, Loading2, Loading_default;
  var init_Loading2 = __esm({
    "node_modules/react-msaview/dist/components/Loading.js"() {
      import_react73 = __toESM(require_react());
      import_ui19 = __toESM(require_ui());
      import_ErrorBoundary = __toESM(require_ErrorBoundary());
      import_material39 = __toESM(require_material());
      import_mobx_react43 = __toESM(require_mobx_react());
      init_MSAView();
      init_ImportForm();
      Reset = (0, import_mobx_react43.observer)(function({ model, error: error2 }) {
        return import_react73.default.createElement(
          "div",
          null,
          import_react73.default.createElement(import_ui19.ErrorMessage, { error: error2 }),
          import_react73.default.createElement(import_material39.Button, { variant: "contained", color: "primary", onClick: () => {
            model.reset();
          } }, "Return to import form")
        );
      });
      Loading2 = (0, import_mobx_react43.observer)(function({ model }) {
        const { isLoading, dataInitialized, msaFilehandle, treeFilehandle } = model;
        const hasPendingFilehandle = !!(msaFilehandle || treeFilehandle);
        return import_react73.default.createElement(
          "div",
          null,
          import_react73.default.createElement(import_ErrorBoundary.ErrorBoundary, { FallbackComponent: (e2) => import_react73.default.createElement(Reset, { model, error: e2.error }) }, dataInitialized ? isLoading ? import_react73.default.createElement(LoadingSpinner, null) : import_react73.default.createElement(MSAView_default, { model }) : hasPendingFilehandle || isLoading ? import_react73.default.createElement(LoadingSpinner, null) : import_react73.default.createElement(ImportForm_default, { model }))
        );
      });
      Loading_default = Loading2;
    }
  });

  // global-externals:@jbrowse/core/util/io
  var require_io = __commonJS({
    "global-externals:@jbrowse/core/util/io"(exports, module) {
      module.exports = JBrowseExports["@jbrowse/core/util/io"];
    }
  });

  // global-externals:@jbrowse/core/util/types/mst
  var require_mst2 = __commonJS({
    "global-externals:@jbrowse/core/util/types/mst"(exports, module) {
      module.exports = JBrowseExports["@jbrowse/core/util/types/mst"];
    }
  });

  // node_modules/msa-parsers/dist/types.js
  var init_types3 = __esm({
    "node_modules/msa-parsers/dist/types.js"() {
    }
  });

  // node_modules/msa-parsers/dist/util.js
  function generateNodeIds(tree, parent = "node", depth = 0) {
    const id = `${parent}-${depth}`;
    return {
      ...tree,
      id,
      name: tree.name || id,
      children: tree.children?.map((b2, i2) => generateNodeIds(b2, `${id}-${i2}`, depth + 1)) || []
    };
  }
  var init_util3 = __esm({
    "node_modules/msa-parsers/dist/util.js"() {
    }
  });

  // node_modules/msa-parsers/dist/msa/A3mMSA.js
  function isLower(code) {
    return code >= CODE_a && code <= CODE_z;
  }
  var CODE_A, CODE_Z, CODE_a, CODE_z, CODE_DASH, CODE_DOT, A3mMSA;
  var init_A3mMSA = __esm({
    "node_modules/msa-parsers/dist/msa/A3mMSA.js"() {
      CODE_A = 65;
      CODE_Z = 90;
      CODE_a = 97;
      CODE_z = 122;
      CODE_DASH = 45;
      CODE_DOT = 46;
      A3mMSA = class {
        MSA;
        orderedNames;
        constructor(text) {
          const rawSeqs = [];
          const names = [];
          for (const entry of text.split(">")) {
            if (!/\S/.test(entry)) {
              continue;
            }
            const newlineIdx = entry.indexOf("\n");
            if (newlineIdx === -1) {
              continue;
            }
            const defLine = entry.slice(0, newlineIdx);
            const spaceIdx = defLine.indexOf(" ");
            const id = spaceIdx === -1 ? defLine : defLine.slice(0, spaceIdx);
            if (id) {
              rawSeqs.push(entry.slice(newlineIdx + 1).replaceAll(/\s/g, ""));
              names.push(id);
            }
          }
          this.orderedNames = names;
          this.MSA = { seqdata: this.expandA3M(rawSeqs, names) };
        }
        /**
         * Detect if text is likely A3M format
         */
        static sniff(text) {
          if (!text.startsWith(">")) {
            return false;
          }
          const seqs = [];
          for (const entry of text.split(">")) {
            if (!/\S/.test(entry)) {
              continue;
            }
            const newlineIdx = entry.indexOf("\n");
            if (newlineIdx === -1) {
              continue;
            }
            const seq = entry.slice(newlineIdx + 1).replaceAll(/\s/g, "");
            if (seq) {
              seqs.push(seq);
            }
          }
          if (seqs.length < 2) {
            return false;
          }
          let hasLowercase = false;
          let firstUppercaseLen = -1;
          let sameUppercaseLength = true;
          for (const seq of seqs) {
            let uppercaseLen = 0;
            for (let i2 = 0; i2 < seq.length; i2++) {
              const code = seq.charCodeAt(i2);
              if (isLower(code)) {
                hasLowercase = true;
              } else if (code >= CODE_A && code <= CODE_Z) {
                uppercaseLen++;
              }
            }
            if (firstUppercaseLen === -1) {
              firstUppercaseLen = uppercaseLen;
            } else {
              if (uppercaseLen !== firstUppercaseLen) {
                sameUppercaseLength = false;
              }
            }
          }
          return hasLowercase && sameUppercaseLength;
        }
        /**
         * Expand A3M format to standard aligned format.
         *
         * In A3M, lowercase characters are insertions that implicitly introduce
         * gaps in sequences that don't have an insert at that position.
         * Gaps (-) following match columns in sequences without inserts align
         * with lowercase inserts in other sequences.
         */
        expandA3M(rawSeqs, names) {
          const numSeqs = names.length;
          if (numSeqs === 0) {
            return {};
          }
          const matchChars = [];
          const insertContent = [];
          for (let seqIdx = 0; seqIdx < numSeqs; seqIdx++) {
            const seq = rawSeqs[seqIdx];
            const matches2 = [];
            const inserts = [];
            let i2 = 0;
            while (i2 < seq.length) {
              const code = seq.charCodeAt(i2);
              if (code >= CODE_A && code <= CODE_Z) {
                matches2.push(seq[i2]);
                let ins = "";
                let j2 = i2 + 1;
                while (j2 < seq.length) {
                  const c2 = seq.charCodeAt(j2);
                  if (isLower(c2) || c2 === CODE_DASH || c2 === CODE_DOT) {
                    ins += seq[j2];
                    j2++;
                  } else {
                    break;
                  }
                }
                inserts.push(ins);
                i2 = j2;
              } else if (code === CODE_DASH || code === CODE_DOT) {
                i2++;
              } else if (isLower(code)) {
                let ins = "";
                while (i2 < seq.length && isLower(seq.charCodeAt(i2))) {
                  ins += seq[i2];
                  i2++;
                }
                matches2.push("");
                inserts.push(ins);
              } else {
                i2++;
              }
            }
            matchChars.push(matches2);
            insertContent.push(inserts);
          }
          const numPositions = Math.max(...matchChars.map((m2) => m2.length), 0);
          const maxInserts = new Array(numPositions).fill(0);
          for (let seqIdx = 0; seqIdx < numSeqs; seqIdx++) {
            const inserts = insertContent[seqIdx];
            for (let pos = 0; pos < inserts.length; pos++) {
              let lcCount = 0;
              for (const c2 of inserts[pos]) {
                if (isLower(c2.charCodeAt(0))) {
                  lcCount++;
                }
              }
              if (lcCount > maxInserts[pos]) {
                maxInserts[pos] = lcCount;
              }
            }
          }
          const expanded = {};
          for (let seqIdx = 0; seqIdx < numSeqs; seqIdx++) {
            const matches2 = matchChars[seqIdx];
            const inserts = insertContent[seqIdx];
            const result = [];
            for (let pos = 0; pos < numPositions; pos++) {
              const maxIns = maxInserts[pos];
              if (pos < matches2.length) {
                const matchChar = matches2[pos];
                const insContent = inserts[pos] || "";
                result.push(matchChar || "-");
                let lcContent = "";
                for (const c2 of insContent) {
                  if (isLower(c2.charCodeAt(0))) {
                    lcContent += c2.toUpperCase();
                  }
                }
                result.push(lcContent);
                const padding2 = maxIns - lcContent.length;
                if (padding2 > 0) {
                  result.push(".".repeat(padding2));
                }
              } else {
                result.push("-");
                if (maxIns > 0) {
                  result.push(".".repeat(maxIns));
                }
              }
            }
            expanded[names[seqIdx]] = result.join("");
          }
          return expanded;
        }
        getMSA() {
          return this.MSA;
        }
        getRowData() {
          return void 0;
        }
        getNames() {
          return this.orderedNames;
        }
        getRow(name) {
          return this.MSA.seqdata[name] || "";
        }
        getWidth() {
          const name = Object.keys(this.MSA.seqdata)[0];
          return name ? this.getRow(name).length : 0;
        }
        getStructures() {
          return {};
        }
        get alignmentNames() {
          return [];
        }
        getHeader() {
          return {};
        }
        getTree() {
          return {
            id: "root",
            name: "root",
            noTree: true,
            children: this.getNames().map((name) => ({
              id: name,
              children: [],
              name
            }))
          };
        }
        get seqConsensus() {
          return void 0;
        }
        get secondaryStructureConsensus() {
          return void 0;
        }
        get tracks() {
          return [];
        }
      };
    }
  });

  // node_modules/clustal-js/esm/util.js
  function parseVersion(line2) {
    const res = /\(?(\d+(\.\d+)+)\)?/.exec(line2);
    return res && res.length > 1 ? res[1] : "";
  }
  function parseHeader(info) {
    const knownHeaders = ["CLUSTAL", "PROBCONS", "MUSCLE", "MSAPROBS", "Kalign"];
    if (!knownHeaders.some((l2) => info.startsWith(l2))) {
      console.warn(`${info} is not a known CLUSTAL header: ${knownHeaders.join(",")}, proceeding but could indicate an issue`);
    }
    const version3 = parseVersion(info);
    return { info, version: version3 };
  }
  function getFirstNonEmptyLine(arr) {
    let line2 = arr.next();
    while (!line2.done && line2.value.trim() === "") {
      line2 = arr.next();
    }
    return line2.value;
  }
  function getSeqBounds(line2) {
    const fields = line2.split(/\s+/);
    const temp = line2.slice(fields[0].length);
    const s2 = fields[0].length + temp.indexOf(fields[1]);
    const e2 = s2 + fields[1].length;
    return [s2, e2];
  }
  function parseBlock(arr) {
    let line2 = getFirstNonEmptyLine(arr);
    const block = [];
    let consensusLine = "";
    if (!line2) {
      return void 0;
    }
    while (line2) {
      if (line2.startsWith(" ")) {
        consensusLine = line2;
      } else {
        block.push(line2);
      }
      line2 = arr.next().value;
    }
    const [start, end] = getSeqBounds(block[0]);
    const fields = block.map((s2) => s2.split(/\s+/));
    const ids = fields.map((s2) => s2[0]);
    const seqs = block.map((s2) => s2.slice(start, end));
    let consensus = consensusLine.slice(start, end);
    const remainder = seqs[0].length - consensus.length;
    if (remainder) {
      consensus += " ".repeat(remainder);
    }
    return {
      ids,
      seqs,
      consensus
    };
  }
  function parseBlocks(arr) {
    let block;
    const res = parseBlock(arr);
    if (res !== void 0) {
      while (block = parseBlock(arr)) {
        for (let i2 = 0; i2 < block.seqs.length; i2++) {
          res.seqs[i2] += block.seqs[i2];
        }
        res.consensus += block.consensus;
      }
    }
    return res;
  }
  var init_util4 = __esm({
    "node_modules/clustal-js/esm/util.js"() {
    }
  });

  // node_modules/clustal-js/esm/pairwise.js
  var init_pairwise = __esm({
    "node_modules/clustal-js/esm/pairwise.js"() {
      init_util4();
    }
  });

  // node_modules/clustal-js/esm/index.js
  function parseClustalIter(arr) {
    const line2 = getFirstNonEmptyLine(arr);
    if (!line2) {
      throw new Error("Empty file received");
    }
    const header = parseHeader(line2);
    const res = parseBlocks(arr);
    if (res === void 0) {
      throw new Error("No blocks parsed");
    }
    const alns = res.seqs.map((n2, index3) => ({ id: res.ids[index3], seq: n2 }));
    const { consensus } = res;
    if (consensus.length != alns[0].seq.length) {
      throw new Error(`Consensus length != sequence length. Con ${consensus.length} seq ${alns[0].seq.length}`);
    }
    return { consensus, alns, header };
  }
  function parse2(contents) {
    const iter = contents.split("\n")[Symbol.iterator]();
    return parseClustalIter(iter);
  }
  var init_esm2 = __esm({
    "node_modules/clustal-js/esm/index.js"() {
      init_pairwise();
      init_util4();
    }
  });

  // node_modules/msa-parsers/dist/msa/ClustalMSA.js
  var ClustalMSA;
  var init_ClustalMSA = __esm({
    "node_modules/msa-parsers/dist/msa/ClustalMSA.js"() {
      init_esm2();
      ClustalMSA = class {
        MSA;
        constructor(text) {
          this.MSA = parse2(text);
        }
        getMSA() {
          return this.MSA;
        }
        getRow(name) {
          return this.MSA.alns.find((aln) => aln.id === name)?.seq || "";
        }
        getWidth() {
          return this.MSA.alns[0].seq.length;
        }
        getRowData() {
          return void 0;
        }
        getHeader() {
          return this.MSA.header;
        }
        getNames() {
          return this.MSA.alns.map((aln) => aln.id);
        }
        getStructures() {
          return {};
        }
        get alignmentNames() {
          return [];
        }
        getTree() {
          return {
            id: "root",
            name: "root",
            noTree: true,
            children: this.getNames().map((name) => ({
              id: name,
              name,
              children: []
            }))
          };
        }
        get seqConsensus() {
          return this.MSA.consensus;
        }
        get secondaryStructureConsensus() {
          return void 0;
        }
        get tracks() {
          return [];
        }
      };
    }
  });

  // node_modules/emf-js/esm/index.js
  function parseEmfAln(contents) {
    const lines = contents.split("\n").map((f2) => f2.trim()).filter((f2) => !!f2);
    const seqs = [];
    const alns = [];
    for (const line2 of lines) {
      if (line2.startsWith("SEQ")) {
        seqs.push(line2);
      } else if (line2.startsWith("DATA")) {
        continue;
      } else if (line2.startsWith("//")) {
        break;
      } else {
        alns.push(line2);
      }
    }
    const arr = seqs.map((s2) => {
      const [, species, protein, chr, start, end, strand, geneId, unknown] = s2.split(" ");
      return {
        species,
        protein,
        chr,
        start: +start,
        end: +end,
        strand: +strand,
        geneId,
        unknown,
        seq: ""
      };
    });
    for (const aln of alns) {
      for (let j2 = 0; j2 < seqs.length; j2++) {
        arr[j2].seq += aln[j2];
      }
    }
    return arr;
  }
  function parseEmfTree(contents) {
    const lines = contents.split("\n").map((f2) => f2.trim()).filter((f2) => !!f2);
    const seqs = [];
    let tree = "";
    for (const line2 of lines) {
      if (line2.startsWith("SEQ")) {
        seqs.push(line2);
      } else if (line2.startsWith("DATA")) {
        continue;
      } else if (line2.startsWith("//")) {
        break;
      } else {
        tree = line2;
      }
    }
    const arr = seqs.map((s2) => {
      const [, species, protein, chr, start, end, strand, geneId, unknown] = s2.split(" ");
      return {
        species,
        protein,
        chr,
        start: +start,
        end: +end,
        strand: +strand,
        geneId,
        unknown
      };
    });
    return { tree, seqs: arr };
  }
  var init_esm3 = __esm({
    "node_modules/emf-js/esm/index.js"() {
    }
  });

  // node_modules/msa-parsers/dist/msa/EmfMSA.js
  var EmfMSA;
  var init_EmfMSA = __esm({
    "node_modules/msa-parsers/dist/msa/EmfMSA.js"() {
      init_esm3();
      EmfMSA = class {
        MSA;
        constructor(text) {
          this.MSA = parseEmfAln(text);
        }
        getMSA() {
          return this.MSA;
        }
        getRow(name) {
          return this.MSA.find((aln) => aln.protein === name)?.seq || "";
        }
        getWidth() {
          return this.MSA[0].seq.length;
        }
        getRowData() {
          return void 0;
        }
        getHeader() {
          return "";
        }
        getNames() {
          return this.MSA.map((aln) => aln.protein);
        }
        getStructures() {
          return {};
        }
        get alignmentNames() {
          return [];
        }
        getTree() {
          return {
            id: "root",
            name: "root",
            noTree: true,
            children: this.getNames().map((name) => ({
              id: name,
              name,
              children: []
            }))
          };
        }
        get seqConsensus() {
          return void 0;
        }
        get secondaryStructureConsensus() {
          return void 0;
        }
        get tracks() {
          return [];
        }
      };
    }
  });

  // node_modules/msa-parsers/dist/msa/FastaMSA.js
  var FastaMSA;
  var init_FastaMSA = __esm({
    "node_modules/msa-parsers/dist/msa/FastaMSA.js"() {
      FastaMSA = class {
        MSA;
        constructor(text) {
          const seqdata = {};
          for (const entry of text.split(">")) {
            if (!/\S/.test(entry)) {
              continue;
            }
            const newlineIdx = entry.indexOf("\n");
            if (newlineIdx === -1) {
              continue;
            }
            const defLine = entry.slice(0, newlineIdx);
            const spaceIdx = defLine.indexOf(" ");
            const id = spaceIdx === -1 ? defLine : defLine.slice(0, spaceIdx);
            if (id) {
              seqdata[id] = entry.slice(newlineIdx + 1).replaceAll(/\s/g, "");
            }
          }
          this.MSA = { seqdata };
        }
        getMSA() {
          return this.MSA;
        }
        getRowData() {
          return void 0;
        }
        getNames() {
          return Object.keys(this.MSA.seqdata);
        }
        getRow(name) {
          return this.MSA.seqdata[name] || "";
        }
        getWidth() {
          const name = Object.keys(this.MSA.seqdata)[0];
          return this.getRow(name).length;
        }
        getStructures() {
          return {};
        }
        get alignmentNames() {
          return [];
        }
        getHeader() {
          return {};
        }
        getTree() {
          return {
            id: "root",
            name: "root",
            noTree: true,
            children: this.getNames().map((name) => ({
              id: name,
              children: [],
              name
            }))
          };
        }
        get seqConsensus() {
          return void 0;
        }
        get secondaryStructureConsensus() {
          return void 0;
        }
        get tracks() {
          return [];
        }
      };
    }
  });

  // node_modules/msa-parsers/dist/msa/parseNewick.js
  function parse3(s2) {
    const ancestors = [];
    let tree = {};
    const tokens = s2.split(/\s*(;|\(|\)|,|:)\s*/);
    for (let i2 = 0; i2 < tokens.length; i2++) {
      const token2 = tokens[i2];
      const subtree = {};
      switch (token2) {
        case "(":
          tree.children = [subtree];
          ancestors.push(tree);
          tree = subtree;
          break;
        case ",":
          ancestors.at(-1)?.children.push(subtree);
          tree = subtree;
          break;
        case ")":
          tree = ancestors.pop();
          break;
        case ":":
          break;
        default: {
          const x2 = tokens[i2 - 1];
          if (x2 === ")" || x2 === "(" || x2 === ",") {
            tree.name = token2;
          } else if (x2 === ":") {
            tree.length = Number.parseFloat(token2);
          }
        }
      }
    }
    return tree;
  }
  var init_parseNewick = __esm({
    "node_modules/msa-parsers/dist/msa/parseNewick.js"() {
    }
  });

  // node_modules/msa-parsers/dist/msa/stockholmParser.js
  function createStockholm() {
    return {
      gf: {},
      gc: {},
      gs: {},
      gr: {},
      seqname: [],
      seqdata: {}
    };
  }
  function sniff(text) {
    return formatStartRegex.test(text);
  }
  function parseAll(text, opts) {
    const options = opts ?? {};
    const db = [];
    let stock = null;
    const lines = text.split("\n");
    for (const line2 of lines) {
      let match2;
      if (formatStartRegex.test(line2)) {
        stock = createStockholm();
      } else if (formatEndRegex.test(line2)) {
        if (stock) {
          db.push(stock);
        }
        stock = null;
      } else if (match2 = gfRegex.exec(line2)) {
        if (!stock) {
          if (options.strict) {
            throw new Error("No format header: # STOCKHOLM 1.0");
          }
          stock = createStockholm();
        }
        const tag = match2[1];
        if (!stock.gf[tag]) {
          stock.gf[tag] = [];
        }
        stock.gf[tag].push(match2[2]);
      } else if (match2 = gcRegex.exec(line2)) {
        if (!stock) {
          if (options.strict) {
            throw new Error("No format header: # STOCKHOLM 1.0");
          }
          stock = createStockholm();
        }
        const tag = match2[1];
        if (!stock.gc[tag]) {
          stock.gc[tag] = "";
        }
        stock.gc[tag] += match2[2];
      } else if (match2 = gsRegex.exec(line2)) {
        if (!stock) {
          if (options.strict) {
            throw new Error("No format header: # STOCKHOLM 1.0");
          }
          stock = createStockholm();
        }
        const seqname = match2[1];
        const tag = match2[2];
        const value = match2[3];
        if (!stock.gs[tag]) {
          stock.gs[tag] = {};
        }
        if (!stock.gs[tag][seqname]) {
          stock.gs[tag][seqname] = [];
        }
        stock.gs[tag][seqname].push(value);
      } else if (match2 = grRegex.exec(line2)) {
        if (!stock) {
          if (options.strict) {
            throw new Error("No format header: # STOCKHOLM 1.0");
          }
          stock = createStockholm();
        }
        const seqname = match2[1];
        const tag = match2[2];
        const value = match2[3];
        if (!stock.gr[tag]) {
          stock.gr[tag] = {};
        }
        if (!stock.gr[tag][seqname]) {
          stock.gr[tag][seqname] = "";
        }
        stock.gr[tag][seqname] += value;
      } else if (match2 = lineRegex.exec(line2)) {
        if (!stock) {
          if (options.strict) {
            throw new Error("No format header: # STOCKHOLM 1.0");
          }
          stock = createStockholm();
        }
        const seqname = match2[1];
        const seqdata = match2[2];
        if (!stock.seqdata[seqname]) {
          stock.seqdata[seqname] = "";
          stock.seqname.push(seqname);
        }
        stock.seqdata[seqname] += seqdata;
      } else if (nonwhiteRegex.test(line2)) {
        if (options.strict) {
          throw new Error("Malformed line");
        }
      }
    }
    if (stock) {
      db.push(stock);
    }
    return db;
  }
  var formatStartRegex, formatEndRegex, gfRegex, gcRegex, gsRegex, grRegex, lineRegex, nonwhiteRegex;
  var init_stockholmParser = __esm({
    "node_modules/msa-parsers/dist/msa/stockholmParser.js"() {
      formatStartRegex = /^# STOCKHOLM 1.0/;
      formatEndRegex = /^\/\/\s*$/;
      gfRegex = /^#=GF\s+(\S+)\s+(.*?)\s*$/;
      gcRegex = /^#=GC\s+(\S+)\s+(.*?)\s*$/;
      gsRegex = /^#=GS\s+(\S+)\s+(\S+)\s+(.*?)\s*$/;
      grRegex = /^#=GR\s+(\S+)\s+(\S+)\s+(.*?)\s*$/;
      lineRegex = /^\s*(\S+)\s+(\S+)\s*$/;
      nonwhiteRegex = /\S/;
    }
  });

  // node_modules/msa-parsers/dist/msa/StockholmMSA.js
  var StockholmMSA;
  var init_StockholmMSA = __esm({
    "node_modules/msa-parsers/dist/msa/StockholmMSA.js"() {
      init_parseNewick();
      init_stockholmParser();
      init_util3();
      init_stockholmParser();
      StockholmMSA = class {
        data;
        MSA;
        constructor(text, currentAlignment) {
          const res = parseAll(text);
          this.data = res;
          this.MSA = res[currentAlignment];
        }
        getMSA() {
          return this.MSA;
        }
        getRow(name) {
          return this.MSA.seqdata[name] || "";
        }
        getWidth() {
          const name = Object.keys(this.MSA.seqdata)[0];
          return this.getRow(name).length;
        }
        get alignmentNames() {
          return this.data.map((aln, idx) => aln.gf.DE?.[0] ?? `Alignment ${idx + 1}`);
        }
        getHeader() {
          const acEntries = this.MSA.gs.AC ?? {};
          const drEntries = this.MSA.gs.DR ?? {};
          return {
            General: this.MSA.gf,
            Accessions: Object.fromEntries(Object.entries(acEntries).map(([k2, v2]) => [k2, v2[0]])),
            Dbxref: Object.fromEntries(Object.entries(drEntries).map(([k2, v2]) => [k2, v2.join("; ")]))
          };
        }
        getRowData(rowName) {
          return {
            name: rowName,
            accession: this.MSA.gs.AC?.[rowName]?.[0],
            dbxref: this.MSA.gs.DR?.[rowName]?.join("; ")
          };
        }
        getNames() {
          return Object.keys(this.MSA.seqdata);
        }
        getSeqCoords() {
        }
        getStructures() {
          const pdbRegex = /PDB; +(\S+) +(\S); ([0-9]+)-([0-9]+)/;
          const drEntries = this.MSA.gs.DR ?? {};
          const args = Object.entries(drEntries).flatMap(([id, drList]) => drList.map((dr) => {
            const match2 = pdbRegex.exec(dr);
            return match2 ? { id, match: match2 } : null;
          })).filter((item) => !!item).map(({ id, match: match2 }) => ({
            id,
            pdb: match2[1].toLowerCase(),
            chain: match2[2],
            startPos: +match2[3],
            endPos: +match2[4]
          }));
          const ret = {};
          for (const entry of args) {
            const { id, ...rest } = entry;
            if (!ret[id]) {
              ret[id] = [];
            }
            ret[id].push(rest);
          }
          return ret;
        }
        getTree() {
          const tree = this.MSA.gf.NH?.[0];
          return tree ? generateNodeIds(parse3(tree)) : {
            id: "root",
            name: "root",
            noTree: true,
            children: this.getNames().map((name) => ({
              id: name,
              children: [],
              name
            }))
          };
        }
        get seqConsensus() {
          return this.MSA.gc.seq_cons;
        }
        get secondaryStructureConsensus() {
          return this.MSA.gc.SS_cons;
        }
        get tracks() {
          return [
            {
              id: "seqConsensus",
              name: "Sequence consensus",
              data: this.seqConsensus,
              customColorScheme: {}
            },
            {
              id: "secondaryStruct",
              name: "Secondary-structure",
              data: this.secondaryStructureConsensus,
              customColorScheme: {
                ">": "pink",
                "<": "lightblue"
              }
            }
          ];
        }
      };
    }
  });

  // node_modules/msa-parsers/dist/msa/index.js
  var init_msa = __esm({
    "node_modules/msa-parsers/dist/msa/index.js"() {
      init_A3mMSA();
      init_ClustalMSA();
      init_EmfMSA();
      init_FastaMSA();
      init_StockholmMSA();
      init_esm3();
      init_parseNewick();
      init_A3mMSA();
      init_ClustalMSA();
      init_EmfMSA();
      init_FastaMSA();
      init_StockholmMSA();
    }
  });

  // node_modules/msa-parsers/dist/gff/parseGFF.js
  function parseAttributes(col9) {
    if (!col9) {
      return {};
    }
    return Object.fromEntries(col9.split(";").map((f2) => f2.trim()).filter((f2) => !!f2).map((f2) => f2.split("=")).map(([key, val]) => [
      key?.trim() ?? "",
      val ? decodeURIComponent(val).trim().split(",").join(" ") : void 0
    ]).filter(([key]) => key !== ""));
  }
  function parseGFF(str) {
    if (!str) {
      return [];
    }
    return str.split("\n").map((f2) => f2.trim()).filter((f2) => !!f2 && !f2.startsWith("#")).map((f2) => {
      const parts = f2.split("	");
      const [seq_id, source, type, start, end, score, strand, phase] = parts;
      const col9 = parts[8];
      return {
        seq_id: seq_id ?? "",
        source: source ?? "",
        type: type ?? "",
        start: Number(start) || 0,
        end: Number(end) || 0,
        score: Number(score) || 0,
        strand: strand ?? ".",
        phase: phase ?? ".",
        ...parseAttributes(col9)
      };
    });
  }
  var init_parseGFF = __esm({
    "node_modules/msa-parsers/dist/gff/parseGFF.js"() {
    }
  });

  // node_modules/msa-parsers/dist/gff/gffToInterPro.js
  function gffToInterProResults(gffRecords) {
    const bySequence = /* @__PURE__ */ new Map();
    for (const record of gffRecords) {
      const existing = bySequence.get(record.seq_id);
      if (existing) {
        existing.push(record);
      } else {
        bySequence.set(record.seq_id, [record]);
      }
    }
    const results = {};
    for (const [seqId, records] of bySequence) {
      const matchesByAccession = /* @__PURE__ */ new Map();
      const matchInfo = /* @__PURE__ */ new Map();
      for (const record of records) {
        const accession = record.Name || record.ID || `${record.source}_${record.start}_${record.end}`;
        const name = record.signature_desc || record.Name || accession;
        const description = record.Ontology_term || record.description || record.Note || name;
        if (!matchInfo.has(accession)) {
          matchInfo.set(accession, { name, description, accession });
        }
        const locations = matchesByAccession.get(accession);
        if (locations) {
          locations.push({ start: record.start, end: record.end });
        } else {
          matchesByAccession.set(accession, [
            { start: record.start, end: record.end }
          ]);
        }
      }
      const matches2 = [];
      for (const [accession, locations] of matchesByAccession) {
        const info = matchInfo.get(accession);
        matches2.push({
          signature: {
            entry: info
          },
          locations
        });
      }
      results[seqId] = {
        matches: matches2,
        xref: [{ id: seqId }]
      };
    }
    return results;
  }
  var init_gffToInterPro = __esm({
    "node_modules/msa-parsers/dist/gff/gffToInterPro.js"() {
    }
  });

  // node_modules/msa-parsers/dist/gff/interProToGFF.js
  var init_interProToGFF = __esm({
    "node_modules/msa-parsers/dist/gff/interProToGFF.js"() {
    }
  });

  // node_modules/msa-parsers/dist/gff/index.js
  var init_gff = __esm({
    "node_modules/msa-parsers/dist/gff/index.js"() {
      init_parseGFF();
      init_gffToInterPro();
      init_interProToGFF();
    }
  });

  // node_modules/msa-parsers/dist/index.js
  var init_dist = __esm({
    "node_modules/msa-parsers/dist/index.js"() {
      init_types3();
      init_util3();
      init_msa();
      init_gff();
    }
  });

  // node_modules/d3-hierarchy/src/cluster.js
  function defaultSeparation(a2, b2) {
    return a2.parent === b2.parent ? 1 : 2;
  }
  function meanX(children) {
    return children.reduce(meanXReduce, 0) / children.length;
  }
  function meanXReduce(x2, c2) {
    return x2 + c2.x;
  }
  function maxY(children) {
    return 1 + children.reduce(maxYReduce, 0);
  }
  function maxYReduce(y2, c2) {
    return Math.max(y2, c2.y);
  }
  function leafLeft(node2) {
    var children;
    while (children = node2.children) node2 = children[0];
    return node2;
  }
  function leafRight(node2) {
    var children;
    while (children = node2.children) node2 = children[children.length - 1];
    return node2;
  }
  function cluster_default() {
    var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
    function cluster(root) {
      var previousNode, x2 = 0;
      root.eachAfter(function(node2) {
        var children = node2.children;
        if (children) {
          node2.x = meanX(children);
          node2.y = maxY(children);
        } else {
          node2.x = previousNode ? x2 += separation(node2, previousNode) : 0;
          node2.y = 0;
          previousNode = node2;
        }
      });
      var left = leafLeft(root), right = leafRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
      return root.eachAfter(nodeSize ? function(node2) {
        node2.x = (node2.x - root.x) * dx;
        node2.y = (root.y - node2.y) * dy;
      } : function(node2) {
        node2.x = (node2.x - x0) / (x1 - x0) * dx;
        node2.y = (1 - (root.y ? node2.y / root.y : 1)) * dy;
      });
    }
    cluster.separation = function(x2) {
      return arguments.length ? (separation = x2, cluster) : separation;
    };
    cluster.size = function(x2) {
      return arguments.length ? (nodeSize = false, dx = +x2[0], dy = +x2[1], cluster) : nodeSize ? null : [dx, dy];
    };
    cluster.nodeSize = function(x2) {
      return arguments.length ? (nodeSize = true, dx = +x2[0], dy = +x2[1], cluster) : nodeSize ? [dx, dy] : null;
    };
    return cluster;
  }
  var init_cluster = __esm({
    "node_modules/d3-hierarchy/src/cluster.js"() {
    }
  });

  // node_modules/d3-hierarchy/src/hierarchy/count.js
  function count2(node2) {
    var sum3 = 0, children = node2.children, i2 = children && children.length;
    if (!i2) sum3 = 1;
    else while (--i2 >= 0) sum3 += children[i2].value;
    node2.value = sum3;
  }
  function count_default() {
    return this.eachAfter(count2);
  }
  var init_count = __esm({
    "node_modules/d3-hierarchy/src/hierarchy/count.js"() {
    }
  });

  // node_modules/d3-hierarchy/src/hierarchy/each.js
  function each_default(callback, that) {
    let index3 = -1;
    for (const node2 of this) {
      callback.call(that, node2, ++index3, this);
    }
    return this;
  }
  var init_each = __esm({
    "node_modules/d3-hierarchy/src/hierarchy/each.js"() {
    }
  });

  // node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
  function eachBefore_default(callback, that) {
    var node2 = this, nodes = [node2], children, i2, index3 = -1;
    while (node2 = nodes.pop()) {
      callback.call(that, node2, ++index3, this);
      if (children = node2.children) {
        for (i2 = children.length - 1; i2 >= 0; --i2) {
          nodes.push(children[i2]);
        }
      }
    }
    return this;
  }
  var init_eachBefore = __esm({
    "node_modules/d3-hierarchy/src/hierarchy/eachBefore.js"() {
    }
  });

  // node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
  function eachAfter_default(callback, that) {
    var node2 = this, nodes = [node2], next2 = [], children, i2, n2, index3 = -1;
    while (node2 = nodes.pop()) {
      next2.push(node2);
      if (children = node2.children) {
        for (i2 = 0, n2 = children.length; i2 < n2; ++i2) {
          nodes.push(children[i2]);
        }
      }
    }
    while (node2 = next2.pop()) {
      callback.call(that, node2, ++index3, this);
    }
    return this;
  }
  var init_eachAfter = __esm({
    "node_modules/d3-hierarchy/src/hierarchy/eachAfter.js"() {
    }
  });

  // node_modules/d3-hierarchy/src/hierarchy/find.js
  function find_default(callback, that) {
    let index3 = -1;
    for (const node2 of this) {
      if (callback.call(that, node2, ++index3, this)) {
        return node2;
      }
    }
  }
  var init_find = __esm({
    "node_modules/d3-hierarchy/src/hierarchy/find.js"() {
    }
  });

  // node_modules/d3-hierarchy/src/hierarchy/sum.js
  function sum_default(value) {
    return this.eachAfter(function(node2) {
      var sum3 = +value(node2.data) || 0, children = node2.children, i2 = children && children.length;
      while (--i2 >= 0) sum3 += children[i2].value;
      node2.value = sum3;
    });
  }
  var init_sum = __esm({
    "node_modules/d3-hierarchy/src/hierarchy/sum.js"() {
    }
  });

  // node_modules/d3-hierarchy/src/hierarchy/sort.js
  function sort_default(compare2) {
    return this.eachBefore(function(node2) {
      if (node2.children) {
        node2.children.sort(compare2);
      }
    });
  }
  var init_sort = __esm({
    "node_modules/d3-hierarchy/src/hierarchy/sort.js"() {
    }
  });

  // node_modules/d3-hierarchy/src/hierarchy/path.js
  function path_default(end) {
    var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
    while (start !== ancestor) {
      start = start.parent;
      nodes.push(start);
    }
    var k2 = nodes.length;
    while (end !== ancestor) {
      nodes.splice(k2, 0, end);
      end = end.parent;
    }
    return nodes;
  }
  function leastCommonAncestor(a2, b2) {
    if (a2 === b2) return a2;
    var aNodes = a2.ancestors(), bNodes = b2.ancestors(), c2 = null;
    a2 = aNodes.pop();
    b2 = bNodes.pop();
    while (a2 === b2) {
      c2 = a2;
      a2 = aNodes.pop();
      b2 = bNodes.pop();
    }
    return c2;
  }
  var init_path = __esm({
    "node_modules/d3-hierarchy/src/hierarchy/path.js"() {
    }
  });

  // node_modules/d3-hierarchy/src/hierarchy/ancestors.js
  function ancestors_default() {
    var node2 = this, nodes = [node2];
    while (node2 = node2.parent) {
      nodes.push(node2);
    }
    return nodes;
  }
  var init_ancestors = __esm({
    "node_modules/d3-hierarchy/src/hierarchy/ancestors.js"() {
    }
  });

  // node_modules/d3-hierarchy/src/hierarchy/descendants.js
  function descendants_default() {
    return Array.from(this);
  }
  var init_descendants = __esm({
    "node_modules/d3-hierarchy/src/hierarchy/descendants.js"() {
    }
  });

  // node_modules/d3-hierarchy/src/hierarchy/leaves.js
  function leaves_default() {
    var leaves = [];
    this.eachBefore(function(node2) {
      if (!node2.children) {
        leaves.push(node2);
      }
    });
    return leaves;
  }
  var init_leaves = __esm({
    "node_modules/d3-hierarchy/src/hierarchy/leaves.js"() {
    }
  });

  // node_modules/d3-hierarchy/src/hierarchy/links.js
  function links_default() {
    var root = this, links = [];
    root.each(function(node2) {
      if (node2 !== root) {
        links.push({ source: node2.parent, target: node2 });
      }
    });
    return links;
  }
  var init_links = __esm({
    "node_modules/d3-hierarchy/src/hierarchy/links.js"() {
    }
  });

  // node_modules/d3-hierarchy/src/hierarchy/iterator.js
  function* iterator_default() {
    var node2 = this, current, next2 = [node2], children, i2, n2;
    do {
      current = next2.reverse(), next2 = [];
      while (node2 = current.pop()) {
        yield node2;
        if (children = node2.children) {
          for (i2 = 0, n2 = children.length; i2 < n2; ++i2) {
            next2.push(children[i2]);
          }
        }
      }
    } while (next2.length);
  }
  var init_iterator = __esm({
    "node_modules/d3-hierarchy/src/hierarchy/iterator.js"() {
    }
  });

  // node_modules/d3-hierarchy/src/hierarchy/index.js
  function hierarchy(data, children) {
    if (data instanceof Map) {
      data = [void 0, data];
      if (children === void 0) children = mapChildren;
    } else if (children === void 0) {
      children = objectChildren;
    }
    var root = new Node2(data), node2, nodes = [root], child, childs, i2, n2;
    while (node2 = nodes.pop()) {
      if ((childs = children(node2.data)) && (n2 = (childs = Array.from(childs)).length)) {
        node2.children = childs;
        for (i2 = n2 - 1; i2 >= 0; --i2) {
          nodes.push(child = childs[i2] = new Node2(childs[i2]));
          child.parent = node2;
          child.depth = node2.depth + 1;
        }
      }
    }
    return root.eachBefore(computeHeight);
  }
  function node_copy() {
    return hierarchy(this).eachBefore(copyData);
  }
  function objectChildren(d3) {
    return d3.children;
  }
  function mapChildren(d3) {
    return Array.isArray(d3) ? d3[1] : null;
  }
  function copyData(node2) {
    if (node2.data.value !== void 0) node2.value = node2.data.value;
    node2.data = node2.data.data;
  }
  function computeHeight(node2) {
    var height = 0;
    do
      node2.height = height;
    while ((node2 = node2.parent) && node2.height < ++height);
  }
  function Node2(data) {
    this.data = data;
    this.depth = this.height = 0;
    this.parent = null;
  }
  var init_hierarchy = __esm({
    "node_modules/d3-hierarchy/src/hierarchy/index.js"() {
      init_count();
      init_each();
      init_eachBefore();
      init_eachAfter();
      init_find();
      init_sum();
      init_sort();
      init_path();
      init_ancestors();
      init_descendants();
      init_leaves();
      init_links();
      init_iterator();
      Node2.prototype = hierarchy.prototype = {
        constructor: Node2,
        count: count_default,
        each: each_default,
        eachAfter: eachAfter_default,
        eachBefore: eachBefore_default,
        find: find_default,
        sum: sum_default,
        sort: sort_default,
        path: path_default,
        ancestors: ancestors_default,
        descendants: descendants_default,
        leaves: leaves_default,
        links: links_default,
        copy: node_copy,
        [Symbol.iterator]: iterator_default
      };
    }
  });

  // node_modules/d3-hierarchy/src/index.js
  var init_src2 = __esm({
    "node_modules/d3-hierarchy/src/index.js"() {
      init_cluster();
      init_hierarchy();
    }
  });

  // node_modules/file-saver/dist/FileSaver.min.js
  var require_FileSaver_min = __commonJS({
    "node_modules/file-saver/dist/FileSaver.min.js"(exports, module) {
      (function(a2, b2) {
        if ("function" == typeof define && define.amd) define([], b2);
        else if ("undefined" != typeof exports) b2();
        else {
          b2(), a2.FileSaver = { exports: {} }.exports;
        }
      })(exports, function() {
        "use strict";
        function b2(a3, b3) {
          return "undefined" == typeof b3 ? b3 = { autoBom: false } : "object" != typeof b3 && (console.warn("Deprecated: Expected third argument to be a object"), b3 = { autoBom: !b3 }), b3.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a3.type) ? new Blob(["\uFEFF", a3], { type: a3.type }) : a3;
        }
        function c2(a3, b3, c3) {
          var d4 = new XMLHttpRequest();
          d4.open("GET", a3), d4.responseType = "blob", d4.onload = function() {
            g2(d4.response, b3, c3);
          }, d4.onerror = function() {
            console.error("could not download file");
          }, d4.send();
        }
        function d3(a3) {
          var b3 = new XMLHttpRequest();
          b3.open("HEAD", a3, false);
          try {
            b3.send();
          } catch (a4) {
          }
          return 200 <= b3.status && 299 >= b3.status;
        }
        function e2(a3) {
          try {
            a3.dispatchEvent(new MouseEvent("click"));
          } catch (c3) {
            var b3 = document.createEvent("MouseEvents");
            b3.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), a3.dispatchEvent(b3);
          }
        }
        var f2 = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof global && global.global === global ? global : void 0, a2 = f2.navigator && /Macintosh/.test(navigator.userAgent) && /AppleWebKit/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent), g2 = f2.saveAs || ("object" != typeof window || window !== f2 ? function() {
        } : "download" in HTMLAnchorElement.prototype && !a2 ? function(b3, g3, h2) {
          var i2 = f2.URL || f2.webkitURL, j2 = document.createElement("a");
          g3 = g3 || b3.name || "download", j2.download = g3, j2.rel = "noopener", "string" == typeof b3 ? (j2.href = b3, j2.origin === location.origin ? e2(j2) : d3(j2.href) ? c2(b3, g3, h2) : e2(j2, j2.target = "_blank")) : (j2.href = i2.createObjectURL(b3), setTimeout(function() {
            i2.revokeObjectURL(j2.href);
          }, 4e4), setTimeout(function() {
            e2(j2);
          }, 0));
        } : "msSaveOrOpenBlob" in navigator ? function(f3, g3, h2) {
          if (g3 = g3 || f3.name || "download", "string" != typeof f3) navigator.msSaveOrOpenBlob(b2(f3, h2), g3);
          else if (d3(f3)) c2(f3, g3, h2);
          else {
            var i2 = document.createElement("a");
            i2.href = f3, i2.target = "_blank", setTimeout(function() {
              e2(i2);
            });
          }
        } : function(b3, d4, e3, g3) {
          if (g3 = g3 || open("", "_blank"), g3 && (g3.document.title = g3.document.body.innerText = "downloading..."), "string" == typeof b3) return c2(b3, d4, e3);
          var h2 = "application/octet-stream" === b3.type, i2 = /constructor/i.test(f2.HTMLElement) || f2.safari, j2 = /CriOS\/[\d]+/.test(navigator.userAgent);
          if ((j2 || h2 && i2 || a2) && "undefined" != typeof FileReader) {
            var k2 = new FileReader();
            k2.onloadend = function() {
              var a3 = k2.result;
              a3 = j2 ? a3 : a3.replace(/^data:[^;]*;/, "data:attachment/file;"), g3 ? g3.location.href = a3 : location = a3, g3 = null;
            }, k2.readAsDataURL(b3);
          } else {
            var l2 = f2.URL || f2.webkitURL, m2 = l2.createObjectURL(b3);
            g3 ? g3.location = m2 : location.href = m2, g3 = null, setTimeout(function() {
              l2.revokeObjectURL(m2);
            }, 4e4);
          }
        });
        f2.saveAs = g2.saveAs = g2, "undefined" != typeof module && (module.exports = g2);
      });
    }
  });

  // node_modules/react-msaview/dist/calculateBlocks.js
  function blocksY({ mapHeight, blockSize, viewportY, viewportHeight }) {
    const clampedViewportY = Math.max(0, Math.min(viewportY, mapHeight * blockSize - viewportHeight));
    const minTileY = Math.floor(clampedViewportY / blockSize);
    const maxTileY = Math.floor((clampedViewportY + viewportHeight - 1) / blockSize);
    const blocksY2 = [];
    for (let tileY = minTileY; tileY <= maxTileY; tileY++) {
      blocksY2.push(tileY * blockSize);
    }
    return blocksY2;
  }
  function blocksX({ mapWidth, blockSize, viewportX, viewportWidth }) {
    const clampedViewportX = Math.max(0, Math.min(viewportX, mapWidth - viewportWidth));
    const minTileX = Math.floor(clampedViewportX / blockSize);
    const maxTileX = Math.floor((clampedViewportX + viewportWidth - 1) / blockSize);
    const blocksX2 = [];
    for (let tileX = minTileX; tileX <= maxTileX; tileX++) {
      blocksX2.push(tileX * blockSize);
    }
    return blocksX2;
  }
  var init_calculateBlocks = __esm({
    "node_modules/react-msaview/dist/calculateBlocks.js"() {
    }
  });

  // node_modules/react-msaview/dist/components/ConservationTrack.js
  var import_react74, import_mobx_react44, ConservationBlock, ConservationTrack, ConservationTrack_default;
  var init_ConservationTrack = __esm({
    "node_modules/react-msaview/dist/components/ConservationTrack.js"() {
      import_react74 = __toESM(require_react());
      import_mobx_react44 = __toESM(require_mobx_react());
      ConservationBlock = (0, import_mobx_react44.observer)(function({ model, offsetX, trackHeight }) {
        const { blockSize, scrollX, colWidth, highResScaleFactor, conservation } = model;
        const ref = (0, import_react74.useRef)(null);
        (0, import_react74.useEffect)(() => {
          if (!ref.current) {
            return;
          }
          const ctx = ref.current.getContext("2d");
          if (!ctx) {
            return;
          }
          ctx.resetTransform();
          ctx.scale(highResScaleFactor, highResScaleFactor);
          ctx.clearRect(0, 0, blockSize, trackHeight);
          ctx.translate(-offsetX, 0);
          const xStart = Math.max(0, Math.floor(offsetX / colWidth));
          const xEnd = Math.max(0, Math.ceil((offsetX + blockSize) / colWidth));
          for (let i2 = xStart; i2 < xEnd && i2 < conservation.length; i2++) {
            const value = conservation[i2];
            const barHeight = value * trackHeight;
            const x2 = i2 * colWidth;
            const hue = value * 120;
            ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
            ctx.fillRect(x2, trackHeight - barHeight, colWidth, barHeight);
          }
        }, [
          blockSize,
          colWidth,
          trackHeight,
          offsetX,
          highResScaleFactor,
          conservation
        ]);
        return import_react74.default.createElement("canvas", { ref, height: trackHeight * highResScaleFactor, width: blockSize * highResScaleFactor, style: {
          position: "absolute",
          left: scrollX + offsetX,
          width: blockSize,
          height: trackHeight
        } });
      });
      ConservationTrack = (0, import_mobx_react44.observer)(function({ model, track }) {
        const { blocksX: blocksX2, msaAreaWidth } = model;
        const trackHeight = track.model.height;
        return import_react74.default.createElement("div", { style: {
          position: "relative",
          height: trackHeight,
          width: msaAreaWidth,
          overflow: "hidden"
        } }, blocksX2.map((bx) => import_react74.default.createElement(ConservationBlock, { key: bx, model, offsetX: bx, trackHeight })));
      });
      ConservationTrack_default = ConservationTrack;
    }
  });

  // node_modules/react-msaview/dist/components/TextTrack.js
  var import_react75, import_material40, import_mobx_react45, AnnotationBlock, AnnotationTrack, TextTrack_default;
  var init_TextTrack = __esm({
    "node_modules/react-msaview/dist/components/TextTrack.js"() {
      import_react75 = __toESM(require_react());
      import_material40 = __toESM(require_material());
      import_mobx_react45 = __toESM(require_mobx_react());
      init_util();
      AnnotationBlock = (0, import_mobx_react45.observer)(function({ track, model, offsetX }) {
        const { blockSize, scrollX, bgColor, colorScheme: modelColorScheme, colWidth, fontSize, rowHeight, highResScaleFactor } = model;
        const { model: { customColorScheme, data } } = track;
        const colorScheme = customColorScheme || modelColorScheme;
        const theme = (0, import_material40.useTheme)();
        const ref = (0, import_react75.useRef)(null);
        const contrastScheme = (0, import_react75.useMemo)(() => colorContrast(colorScheme, theme), [colorScheme, theme]);
        (0, import_react75.useEffect)(() => {
          if (!ref.current) {
            return;
          }
          const ctx = ref.current.getContext("2d");
          if (!ctx) {
            return;
          }
          ctx.resetTransform();
          ctx.scale(highResScaleFactor, highResScaleFactor);
          ctx.clearRect(0, 0, blockSize, rowHeight);
          ctx.translate(-offsetX, 0);
          ctx.textAlign = "center";
          ctx.font = ctx.font.replace(/\d+px/, `${fontSize}px`);
          const xStart = Math.max(0, Math.floor(offsetX / colWidth));
          const xEnd = Math.max(0, Math.ceil((offsetX + blockSize) / colWidth));
          const str = data?.slice(xStart, xEnd);
          for (let i2 = 0; str && i2 < str.length; i2++) {
            const letter = str[i2];
            const color = colorScheme[letter.toUpperCase()];
            if (bgColor) {
              const x2 = i2 * colWidth + offsetX - offsetX % colWidth;
              ctx.fillStyle = color || "white";
              ctx.fillRect(x2, 0, colWidth, rowHeight);
              if (rowHeight >= 10 && colWidth >= rowHeight / 2) {
                ctx.fillStyle = contrastScheme[letter.toUpperCase()] || "black";
                ctx.fillText(letter, x2 + colWidth / 2, rowHeight / 2 + 1);
              }
            }
          }
        }, [
          fontSize,
          bgColor,
          blockSize,
          colWidth,
          rowHeight,
          offsetX,
          contrastScheme,
          colorScheme,
          highResScaleFactor,
          data
        ]);
        return import_react75.default.createElement("canvas", { ref, height: rowHeight * highResScaleFactor, width: blockSize * highResScaleFactor, style: {
          position: "absolute",
          left: scrollX + offsetX,
          width: blockSize,
          height: rowHeight
        } });
      });
      AnnotationTrack = (0, import_mobx_react45.observer)(function({ track, model }) {
        const { blocksX: blocksX2, msaAreaWidth, rowHeight } = model;
        if (!track.model.data) {
          return null;
        }
        return import_react75.default.createElement("div", { style: {
          position: "relative",
          height: rowHeight,
          width: msaAreaWidth,
          overflow: "hidden"
        } }, blocksX2.map((bx) => import_react75.default.createElement(AnnotationBlock, { key: bx, track, model, offsetX: bx })));
      });
      TextTrack_default = AnnotationTrack;
    }
  });

  // node_modules/react-msaview/dist/constants.js
  var defaultRowHeight, defaultColWidth, defaultHeight, defaultScrollX, defaultScrollY, defaultCurrentAlignment, defaultShowDomains, defaultHideGaps, defaultAllowedGappyness, defaultContrastLettering, defaultSubFeatureRows, defaultDrawMsaLetters, defaultBgColor, defaultColorSchemeName, defaultDrawLabels, defaultLabelsAlignRight, defaultTreeAreaWidth, defaultTreeWidth, defaultTreeWidthMatchesArea, defaultShowBranchLen, defaultDrawTree, defaultDrawNodeBubbles;
  var init_constants = __esm({
    "node_modules/react-msaview/dist/constants.js"() {
      defaultRowHeight = 16;
      defaultColWidth = 12;
      defaultHeight = 550;
      defaultScrollX = 0;
      defaultScrollY = 0;
      defaultCurrentAlignment = 0;
      defaultShowDomains = false;
      defaultHideGaps = true;
      defaultAllowedGappyness = 100;
      defaultContrastLettering = true;
      defaultSubFeatureRows = false;
      defaultDrawMsaLetters = true;
      defaultBgColor = true;
      defaultColorSchemeName = "maeditor";
      defaultDrawLabels = true;
      defaultLabelsAlignRight = false;
      defaultTreeAreaWidth = 400;
      defaultTreeWidth = 300;
      defaultTreeWidthMatchesArea = true;
      defaultShowBranchLen = true;
      defaultDrawTree = true;
      defaultDrawNodeBubbles = true;
    }
  });

  // node_modules/react-msaview/dist/flatToTree.js
  function flatToTree(items) {
    const nodeMap = /* @__PURE__ */ new Map();
    items.forEach((item) => {
      nodeMap.set(item.id, {
        ...item,
        id: `${item.id}`,
        name: `${item.id}`,
        parent: item.parent !== void 0 ? `${item.parent}` : void 0,
        children: []
      });
    });
    const roots = [];
    items.forEach((item) => {
      const node2 = nodeMap.get(item.id);
      if (item.parent !== void 0) {
        const parentNode = nodeMap.get(item.parent);
        if (parentNode) {
          parentNode.children.push(node2);
        } else {
          roots.push(node2);
        }
      } else {
        roots.push(node2);
      }
    });
    return roots[0];
  }
  var init_flatToTree = __esm({
    "node_modules/react-msaview/dist/flatToTree.js"() {
    }
  });

  // node_modules/react-msaview/dist/measureTextCanvas.js
  function measureTextCanvas(text, fontSize) {
    if (!canvasHandle) {
      canvasHandle = document.createElement("canvas");
    }
    const ctx = canvasHandle.getContext("2d");
    if (!ctx) {
      throw new Error("no canvas context");
    }
    ctx.font = ctx.font.replace(/\d+px/, `${fontSize}px`);
    return ctx.measureText(text).width;
  }
  var canvasHandle;
  var init_measureTextCanvas = __esm({
    "node_modules/react-msaview/dist/measureTextCanvas.js"() {
    }
  });

  // node_modules/react-msaview/dist/model/DataModel.js
  function DataModelF() {
    return import_mobx_state_tree3.types.model({
      /**
       * #property
       */
      tree: import_mobx_state_tree3.types.maybe(import_mobx_state_tree3.types.string),
      /**
       * #property
       */
      msa: import_mobx_state_tree3.types.maybe(import_mobx_state_tree3.types.string),
      /**
       * #property
       */
      treeMetadata: import_mobx_state_tree3.types.maybe(import_mobx_state_tree3.types.string)
    }).actions((self2) => ({
      /**
       * #action
       */
      setTree(tree) {
        self2.tree = tree;
      },
      /**
       * #action
       */
      setMSA(msa) {
        self2.msa = msa;
      },
      /**
       * #action
       */
      setTreeMetadata(treeMetadata) {
        self2.treeMetadata = treeMetadata;
      }
    })).postProcessSnapshot((snap) => {
      const { tree, msa, treeMetadata } = snap;
      const max3 = 5e4;
      return {
        tree: tree && tree.length > max3 ? void 0 : tree,
        msa: msa && msa.length > max3 ? void 0 : msa,
        treeMetadata: treeMetadata && treeMetadata.length > max3 ? void 0 : treeMetadata
      };
    });
  }
  var import_mobx_state_tree3;
  var init_DataModel = __esm({
    "node_modules/react-msaview/dist/model/DataModel.js"() {
      import_mobx_state_tree3 = __toESM(require_mobx_state_tree());
    }
  });

  // node_modules/react-msaview/dist/model/DialogQueue.js
  function DialogQueueSessionMixin() {
    return import_mobx_state_tree4.types.model("DialogQueueSessionMixin", {}).volatile(() => ({
      queueOfDialogs: []
    })).views((self2) => ({
      /**
       * #getter
       */
      get DialogComponent() {
        return self2.queueOfDialogs[0]?.[0];
      },
      /**
       * #getter
       */
      get DialogProps() {
        return self2.queueOfDialogs[0]?.[1];
      }
    })).actions((self2) => ({
      /**
       * #action
       */
      removeActiveDialog() {
        self2.queueOfDialogs = self2.queueOfDialogs.slice(1);
      },
      /**
       * #action
       */
      queueDialog(cb) {
        const [component, props] = cb(() => {
          this.removeActiveDialog();
        });
        self2.queueOfDialogs = [...self2.queueOfDialogs, [component, props]];
      }
    }));
  }
  var import_mobx_state_tree4;
  var init_DialogQueue = __esm({
    "node_modules/react-msaview/dist/model/DialogQueue.js"() {
      import_mobx_state_tree4 = __toESM(require_mobx_state_tree());
    }
  });

  // node_modules/react-msaview/dist/model/msaModel.js
  function MSAModelF() {
    return import_mobx_state_tree5.types.model({
      /**
       * #property
       * draw MSA tiles with a background color
       */
      bgColor: defaultBgColor,
      /**
       * #property
       * default color scheme name
       */
      colorSchemeName: defaultColorSchemeName
    }).actions((self2) => ({
      /**
       * #action
       * set color scheme name
       */
      setColorSchemeName(name) {
        self2.colorSchemeName = name;
      },
      /**
       * #action
       */
      setBgColor(arg) {
        self2.bgColor = arg;
      }
    }));
  }
  var import_mobx_state_tree5;
  var init_msaModel = __esm({
    "node_modules/react-msaview/dist/model/msaModel.js"() {
      import_mobx_state_tree5 = __toESM(require_mobx_state_tree());
      init_constants();
    }
  });

  // node_modules/react-msaview/dist/model/treeModel.js
  function TreeModelF() {
    return import_mobx_state_tree6.types.model({
      /**
       * #property
       */
      drawLabels: defaultDrawLabels,
      /**
       * #property
       * right-align the labels
       */
      labelsAlignRight: defaultLabelsAlignRight,
      /**
       * #property
       * width of the area the tree is drawn in, px
       */
      treeAreaWidth: import_mobx_state_tree6.types.optional(import_mobx_state_tree6.types.number, defaultTreeAreaWidth),
      /**
       * #property
       * width of the tree within the treeArea, px
       */
      treeWidth: import_mobx_state_tree6.types.optional(import_mobx_state_tree6.types.number, defaultTreeWidth),
      /**
       * #getter
       * synchronization that matches treeWidth to treeAreaWidth
       */
      treeWidthMatchesArea: defaultTreeWidthMatchesArea,
      /**
       * #property
       * use "branch length" e.g. evolutionary distance to draw tree branch
       * lengths. if false, the layout is a "cladogram" that does not take into
       * account evolutionary distances
       */
      showBranchLen: defaultShowBranchLen,
      /**
       * #property
       * draw tree, boolean
       */
      drawTree: defaultDrawTree,
      /**
       * #property
       * draw clickable node bubbles on the tree
       */
      drawNodeBubbles: defaultDrawNodeBubbles
    }).actions((self2) => ({
      /**
       * #action
       * synchronize the treewidth and treeareawidth
       */
      setTreeWidthMatchesArea(arg) {
        self2.treeWidthMatchesArea = arg;
      },
      /**
       * #action
       * set tree area width (px)
       */
      setTreeAreaWidth(n2) {
        self2.treeAreaWidth = Math.round(n2);
      },
      /**
       * #action
       * set tree width (px)
       */
      setTreeWidth(n2) {
        self2.treeWidth = Math.round(n2);
      },
      /**
       * #action
       */
      setLabelsAlignRight(arg) {
        self2.labelsAlignRight = arg;
      },
      /**
       * #action
       */
      setDrawTree(arg) {
        self2.drawTree = arg;
      },
      /**
       * #action
       */
      setShowBranchLen(arg) {
        self2.showBranchLen = arg;
      },
      /**
       * #action
       */
      setDrawNodeBubbles(arg) {
        self2.drawNodeBubbles = arg;
      },
      /**
       * #action
       */
      setDrawLabels(arg) {
        self2.drawLabels = arg;
      }
    }));
  }
  var import_mobx_state_tree6;
  var init_treeModel = __esm({
    "node_modules/react-msaview/dist/model/treeModel.js"() {
      import_mobx_state_tree6 = __toESM(require_mobx_state_tree());
      init_constants();
    }
  });

  // node_modules/react-msaview/dist/neighborJoining.js
  function getBlosum62Score(a2, b2) {
    const upper_a = a2.toUpperCase();
    const upper_b = b2.toUpperCase();
    return BLOSUM62[upper_a]?.[upper_b] ?? -4;
  }
  function computePairwiseDistance(seq1, seq2) {
    if (seq1.length !== seq2.length) {
      throw new Error("Sequences must have the same length (aligned)");
    }
    let matches2 = 0;
    let mismatches = 0;
    let totalScore = 0;
    let maxPossibleScore = 0;
    for (let i2 = 0; i2 < seq1.length; i2++) {
      const a2 = seq1[i2];
      const b2 = seq2[i2];
      if (a2 === "-" && b2 === "-") {
        continue;
      }
      if (a2 === "-" || b2 === "-") {
        mismatches++;
        continue;
      }
      const score = getBlosum62Score(a2, b2);
      totalScore += score;
      maxPossibleScore += Math.max(getBlosum62Score(a2, a2), getBlosum62Score(b2, b2));
      if (a2.toUpperCase() === b2.toUpperCase()) {
        matches2++;
      } else {
        mismatches++;
      }
    }
    const total = matches2 + mismatches;
    if (total === 0) {
      return 1;
    }
    if (maxPossibleScore <= 0) {
      return 1;
    }
    const normalizedScore = totalScore / maxPossibleScore;
    const clampedScore = Math.max(0.01, Math.min(1, normalizedScore));
    return -Math.log(clampedScore);
  }
  function computeDistanceMatrix(rows) {
    const n2 = rows.length;
    const distances = [];
    for (let i2 = 0; i2 < n2; i2++) {
      distances[i2] = [];
      for (let j2 = 0; j2 < n2; j2++) {
        if (i2 === j2) {
          distances[i2][j2] = 0;
        } else if (j2 < i2) {
          distances[i2][j2] = distances[j2][i2];
        } else {
          distances[i2][j2] = computePairwiseDistance(rows[i2][1], rows[j2][1]);
        }
      }
    }
    return distances;
  }
  function neighborJoining(distances, names) {
    const n2 = distances.length;
    if (n2 < 2) {
      return { name: names[0] };
    }
    if (n2 === 2) {
      const d3 = distances[0][1];
      return {
        left: { name: names[0] },
        right: { name: names[1] },
        leftLength: d3 / 2,
        rightLength: d3 / 2
      };
    }
    const D = [];
    for (let i2 = 0; i2 < n2; i2++) {
      D[i2] = [...distances[i2]];
    }
    const nodes = names.map((name) => ({ name }));
    let remaining = n2;
    while (remaining > 2) {
      const active = [];
      for (let i2 = 0; i2 < nodes.length; i2++) {
        if (nodes[i2] !== void 0) {
          active.push(i2);
        }
      }
      const r2 = /* @__PURE__ */ new Map();
      for (const i2 of active) {
        let sum3 = 0;
        for (const j2 of active) {
          if (i2 !== j2) {
            sum3 += D[i2][j2];
          }
        }
        r2.set(i2, sum3);
      }
      let minQ = Infinity;
      let minI = -1;
      let minJ = -1;
      for (let ai = 0; ai < active.length; ai++) {
        for (let aj = ai + 1; aj < active.length; aj++) {
          const i2 = active[ai];
          const j2 = active[aj];
          const q = (remaining - 2) * D[i2][j2] - r2.get(i2) - r2.get(j2);
          if (q < minQ) {
            minQ = q;
            minI = i2;
            minJ = j2;
          }
        }
      }
      const dij = D[minI][minJ];
      const ri = r2.get(minI);
      const rj = r2.get(minJ);
      let limbI;
      let limbJ;
      if (remaining > 2) {
        limbI = dij / 2 + (ri - rj) / (2 * (remaining - 2));
        limbJ = dij - limbI;
      } else {
        limbI = dij / 2;
        limbJ = dij / 2;
      }
      limbI = Math.max(0, limbI);
      limbJ = Math.max(0, limbJ);
      const newNode = {
        left: nodes[minI],
        right: nodes[minJ],
        leftLength: limbI,
        rightLength: limbJ
      };
      const newIdx = minI;
      for (const k2 of active) {
        if (k2 !== minI && k2 !== minJ) {
          const newDist = (D[minI][k2] + D[minJ][k2] - dij) / 2;
          D[newIdx][k2] = Math.max(0, newDist);
          D[k2][newIdx] = Math.max(0, newDist);
        }
      }
      nodes[minJ] = void 0;
      nodes[newIdx] = newNode;
      remaining--;
    }
    const finalActive = [];
    for (let i2 = 0; i2 < nodes.length; i2++) {
      if (nodes[i2] !== void 0) {
        finalActive.push(i2);
      }
    }
    if (finalActive.length === 2) {
      const i2 = finalActive[0];
      const j2 = finalActive[1];
      const d3 = D[i2][j2];
      return {
        left: nodes[i2],
        right: nodes[j2],
        leftLength: d3 / 2,
        rightLength: d3 / 2
      };
    }
    return nodes[finalActive[0]];
  }
  function nodeToNewick(node2, branchLength) {
    let result;
    if (node2.name !== void 0 && !node2.left && !node2.right) {
      const escapedName = node2.name.replace(/[():,;[\]]/g, "_");
      result = escapedName;
    } else {
      const leftNewick = node2.left ? nodeToNewick(node2.left, node2.leftLength) : "";
      const rightNewick = node2.right ? nodeToNewick(node2.right, node2.rightLength) : "";
      result = `(${leftNewick},${rightNewick})`;
    }
    if (branchLength !== void 0) {
      result += `:${branchLength.toFixed(6)}`;
    }
    return result;
  }
  function calculateNeighborJoiningTree(rows) {
    if (rows.length < 2) {
      throw new Error("Need at least 2 sequences to build a tree");
    }
    const names = rows.map((r2) => r2[0]);
    const distances = computeDistanceMatrix(rows);
    const tree = neighborJoining(distances, names);
    return nodeToNewick(tree) + ";";
  }
  var BLOSUM62;
  var init_neighborJoining = __esm({
    "node_modules/react-msaview/dist/neighborJoining.js"() {
      BLOSUM62 = {
        A: {
          A: 4,
          R: -1,
          N: -2,
          D: -2,
          C: 0,
          Q: -1,
          E: -1,
          G: 0,
          H: -2,
          I: -1,
          L: -1,
          K: -1,
          M: -1,
          F: -2,
          P: -1,
          S: 1,
          T: 0,
          W: -3,
          Y: -2,
          V: 0,
          B: -2,
          Z: -1,
          X: 0,
          "*": -4
        },
        R: {
          A: -1,
          R: 5,
          N: 0,
          D: -2,
          C: -3,
          Q: 1,
          E: 0,
          G: -2,
          H: 0,
          I: -3,
          L: -2,
          K: 2,
          M: -1,
          F: -3,
          P: -2,
          S: -1,
          T: -1,
          W: -3,
          Y: -2,
          V: -3,
          B: -1,
          Z: 0,
          X: -1,
          "*": -4
        },
        N: {
          A: -2,
          R: 0,
          N: 6,
          D: 1,
          C: -3,
          Q: 0,
          E: 0,
          G: 0,
          H: 1,
          I: -3,
          L: -3,
          K: 0,
          M: -2,
          F: -3,
          P: -2,
          S: 1,
          T: 0,
          W: -4,
          Y: -2,
          V: -3,
          B: 3,
          Z: 0,
          X: -1,
          "*": -4
        },
        D: {
          A: -2,
          R: -2,
          N: 1,
          D: 6,
          C: -3,
          Q: 0,
          E: 2,
          G: -1,
          H: -1,
          I: -3,
          L: -4,
          K: -1,
          M: -3,
          F: -3,
          P: -1,
          S: 0,
          T: -1,
          W: -4,
          Y: -3,
          V: -3,
          B: 4,
          Z: 1,
          X: -1,
          "*": -4
        },
        C: {
          A: 0,
          R: -3,
          N: -3,
          D: -3,
          C: 9,
          Q: -3,
          E: -4,
          G: -3,
          H: -3,
          I: -1,
          L: -1,
          K: -3,
          M: -1,
          F: -2,
          P: -3,
          S: -1,
          T: -1,
          W: -2,
          Y: -2,
          V: -1,
          B: -3,
          Z: -3,
          X: -2,
          "*": -4
        },
        Q: {
          A: -1,
          R: 1,
          N: 0,
          D: 0,
          C: -3,
          Q: 5,
          E: 2,
          G: -2,
          H: 0,
          I: -3,
          L: -2,
          K: 1,
          M: 0,
          F: -3,
          P: -1,
          S: 0,
          T: -1,
          W: -2,
          Y: -1,
          V: -2,
          B: 0,
          Z: 3,
          X: -1,
          "*": -4
        },
        E: {
          A: -1,
          R: 0,
          N: 0,
          D: 2,
          C: -4,
          Q: 2,
          E: 5,
          G: -2,
          H: 0,
          I: -3,
          L: -3,
          K: 1,
          M: -2,
          F: -3,
          P: -1,
          S: 0,
          T: -1,
          W: -3,
          Y: -2,
          V: -2,
          B: 1,
          Z: 4,
          X: -1,
          "*": -4
        },
        G: {
          A: 0,
          R: -2,
          N: 0,
          D: -1,
          C: -3,
          Q: -2,
          E: -2,
          G: 6,
          H: -2,
          I: -4,
          L: -4,
          K: -2,
          M: -3,
          F: -3,
          P: -2,
          S: 0,
          T: -2,
          W: -2,
          Y: -3,
          V: -3,
          B: -1,
          Z: -2,
          X: -1,
          "*": -4
        },
        H: {
          A: -2,
          R: 0,
          N: 1,
          D: -1,
          C: -3,
          Q: 0,
          E: 0,
          G: -2,
          H: 8,
          I: -3,
          L: -3,
          K: -1,
          M: -2,
          F: -1,
          P: -2,
          S: -1,
          T: -2,
          W: -2,
          Y: 2,
          V: -3,
          B: 0,
          Z: 0,
          X: -1,
          "*": -4
        },
        I: {
          A: -1,
          R: -3,
          N: -3,
          D: -3,
          C: -1,
          Q: -3,
          E: -3,
          G: -4,
          H: -3,
          I: 4,
          L: 2,
          K: -3,
          M: 1,
          F: 0,
          P: -3,
          S: -2,
          T: -1,
          W: -3,
          Y: -1,
          V: 3,
          B: -3,
          Z: -3,
          X: -1,
          "*": -4
        },
        L: {
          A: -1,
          R: -2,
          N: -3,
          D: -4,
          C: -1,
          Q: -2,
          E: -3,
          G: -4,
          H: -3,
          I: 2,
          L: 4,
          K: -2,
          M: 2,
          F: 0,
          P: -3,
          S: -2,
          T: -1,
          W: -2,
          Y: -1,
          V: 1,
          B: -4,
          Z: -3,
          X: -1,
          "*": -4
        },
        K: {
          A: -1,
          R: 2,
          N: 0,
          D: -1,
          C: -3,
          Q: 1,
          E: 1,
          G: -2,
          H: -1,
          I: -3,
          L: -2,
          K: 5,
          M: -1,
          F: -3,
          P: -1,
          S: 0,
          T: -1,
          W: -3,
          Y: -2,
          V: -2,
          B: 0,
          Z: 1,
          X: -1,
          "*": -4
        },
        M: {
          A: -1,
          R: -1,
          N: -2,
          D: -3,
          C: -1,
          Q: 0,
          E: -2,
          G: -3,
          H: -2,
          I: 1,
          L: 2,
          K: -1,
          M: 5,
          F: 0,
          P: -2,
          S: -1,
          T: -1,
          W: -1,
          Y: -1,
          V: 1,
          B: -3,
          Z: -1,
          X: -1,
          "*": -4
        },
        F: {
          A: -2,
          R: -3,
          N: -3,
          D: -3,
          C: -2,
          Q: -3,
          E: -3,
          G: -3,
          H: -1,
          I: 0,
          L: 0,
          K: -3,
          M: 0,
          F: 6,
          P: -4,
          S: -2,
          T: -2,
          W: 1,
          Y: 3,
          V: -1,
          B: -3,
          Z: -3,
          X: -1,
          "*": -4
        },
        P: {
          A: -1,
          R: -2,
          N: -2,
          D: -1,
          C: -3,
          Q: -1,
          E: -1,
          G: -2,
          H: -2,
          I: -3,
          L: -3,
          K: -1,
          M: -2,
          F: -4,
          P: 7,
          S: -1,
          T: -1,
          W: -4,
          Y: -3,
          V: -2,
          B: -2,
          Z: -1,
          X: -2,
          "*": -4
        },
        S: {
          A: 1,
          R: -1,
          N: 1,
          D: 0,
          C: -1,
          Q: 0,
          E: 0,
          G: 0,
          H: -1,
          I: -2,
          L: -2,
          K: 0,
          M: -1,
          F: -2,
          P: -1,
          S: 4,
          T: 1,
          W: -3,
          Y: -2,
          V: -2,
          B: 0,
          Z: 0,
          X: 0,
          "*": -4
        },
        T: {
          A: 0,
          R: -1,
          N: 0,
          D: -1,
          C: -1,
          Q: -1,
          E: -1,
          G: -2,
          H: -2,
          I: -1,
          L: -1,
          K: -1,
          M: -1,
          F: -2,
          P: -1,
          S: 1,
          T: 5,
          W: -2,
          Y: -2,
          V: 0,
          B: -1,
          Z: -1,
          X: 0,
          "*": -4
        },
        W: {
          A: -3,
          R: -3,
          N: -4,
          D: -4,
          C: -2,
          Q: -2,
          E: -3,
          G: -2,
          H: -2,
          I: -3,
          L: -2,
          K: -3,
          M: -1,
          F: 1,
          P: -4,
          S: -3,
          T: -2,
          W: 11,
          Y: 2,
          V: -3,
          B: -4,
          Z: -3,
          X: -2,
          "*": -4
        },
        Y: {
          A: -2,
          R: -2,
          N: -2,
          D: -3,
          C: -2,
          Q: -1,
          E: -2,
          G: -3,
          H: 2,
          I: -1,
          L: -1,
          K: -2,
          M: -1,
          F: 3,
          P: -3,
          S: -2,
          T: -2,
          W: 2,
          Y: 7,
          V: -1,
          B: -3,
          Z: -2,
          X: -1,
          "*": -4
        },
        V: {
          A: 0,
          R: -3,
          N: -3,
          D: -3,
          C: -1,
          Q: -2,
          E: -2,
          G: -3,
          H: -3,
          I: 3,
          L: 1,
          K: -2,
          M: 1,
          F: -1,
          P: -2,
          S: -2,
          T: 0,
          W: -3,
          Y: -1,
          V: 4,
          B: -3,
          Z: -2,
          X: -1,
          "*": -4
        },
        B: {
          A: -2,
          R: -1,
          N: 3,
          D: 4,
          C: -3,
          Q: 0,
          E: 1,
          G: -1,
          H: 0,
          I: -3,
          L: -4,
          K: 0,
          M: -3,
          F: -3,
          P: -2,
          S: 0,
          T: -1,
          W: -4,
          Y: -3,
          V: -3,
          B: 4,
          Z: 1,
          X: -1,
          "*": -4
        },
        Z: {
          A: -1,
          R: 0,
          N: 0,
          D: 1,
          C: -3,
          Q: 3,
          E: 4,
          G: -2,
          H: 0,
          I: -3,
          L: -3,
          K: 1,
          M: -1,
          F: -3,
          P: -1,
          S: 0,
          T: -1,
          W: -3,
          Y: -2,
          V: -2,
          B: 1,
          Z: 4,
          X: -1,
          "*": -4
        },
        X: {
          A: 0,
          R: -1,
          N: -1,
          D: -1,
          C: -2,
          Q: -1,
          E: -1,
          G: -1,
          H: -1,
          I: -1,
          L: -1,
          K: -1,
          M: -1,
          F: -1,
          P: -2,
          S: 0,
          T: 0,
          W: -2,
          Y: -1,
          V: -1,
          B: -1,
          Z: -1,
          X: -1,
          "*": -4
        },
        "*": {
          A: -4,
          R: -4,
          N: -4,
          D: -4,
          C: -4,
          Q: -4,
          E: -4,
          G: -4,
          H: -4,
          I: -4,
          L: -4,
          K: -4,
          M: -4,
          F: -4,
          P: -4,
          S: -4,
          T: -4,
          W: -4,
          Y: -4,
          V: -4,
          B: -4,
          Z: -4,
          X: -4,
          "*": 1
        }
      };
    }
  });

  // node_modules/react-msaview/dist/parseAsn1.js
  function parseAsn1(asnString) {
    const sections = extractSections(asnString.replace(/\s+/g, " ").replace(/\s*{\s*/g, "{").replace(/\s*}\s*/g, "}").replace(/\s*,\s*/g, ",").replace(/\s*::\s*=\s*/g, "::=").replace(/^.*?::=/, ""));
    const dict = Object.fromEntries(parseFdict(sections.fdict).map((r2) => [
      r2.id,
      remap[r2.name] || r2.name
    ]));
    return parseNodes(sections.nodes).map((node2) => {
      const { features, ...rest } = node2;
      return {
        ...rest,
        ...Object.fromEntries(features.map((f2) => [dict[f2.featureid], f2.value]))
      };
    });
  }
  function extractSections(asnString) {
    const sections = {};
    const cleanedString = asnString.trim();
    const contentString = cleanedString.startsWith("{") && cleanedString.endsWith("}") ? cleanedString.slice(1, -1).trim() : cleanedString;
    let currentPos = 0;
    while (currentPos < contentString.length) {
      while (currentPos < contentString.length && /\s/.test(contentString[currentPos])) {
        currentPos++;
      }
      if (currentPos >= contentString.length) {
        break;
      }
      const sectionNameStart = currentPos;
      while (currentPos < contentString.length && /\w/.test(contentString[currentPos])) {
        currentPos++;
      }
      if (currentPos >= contentString.length || contentString[currentPos] !== " " && contentString[currentPos] !== "{") {
        while (currentPos < contentString.length && contentString[currentPos] !== ",") {
          currentPos++;
        }
        if (currentPos < contentString.length) {
          currentPos++;
        }
        continue;
      }
      const sectionName = contentString.slice(sectionNameStart, currentPos).trim();
      while (currentPos < contentString.length && /\s/.test(contentString[currentPos])) {
        currentPos++;
      }
      if (currentPos >= contentString.length || contentString[currentPos] !== "{") {
        while (currentPos < contentString.length && contentString[currentPos] !== ",") {
          currentPos++;
        }
        if (currentPos < contentString.length) {
          currentPos++;
        }
        continue;
      }
      const sectionContentStart = currentPos + 1;
      let braceCount = 1;
      currentPos++;
      while (currentPos < contentString.length && braceCount > 0) {
        if (contentString[currentPos] === "{") {
          braceCount++;
        } else if (contentString[currentPos] === "}") {
          braceCount--;
        }
        currentPos++;
      }
      if (braceCount === 0) {
        const sectionContent = contentString.slice(sectionContentStart, currentPos - 1).trim();
        sections[sectionName] = sectionContent;
      }
      while (currentPos < contentString.length && contentString[currentPos] !== ",") {
        currentPos++;
      }
      if (currentPos < contentString.length) {
        currentPos++;
      }
    }
    return sections;
  }
  function parseFdict(fdictString) {
    const entries = [];
    let currentPos = 0;
    while (currentPos < fdictString.length) {
      while (currentPos < fdictString.length && /\s/.test(fdictString[currentPos])) {
        currentPos++;
      }
      if (currentPos >= fdictString.length) {
        break;
      }
      if (fdictString[currentPos] === "{") {
        const entryContentStart = currentPos + 1;
        let braceCount = 1;
        currentPos++;
        while (currentPos < fdictString.length && braceCount > 0) {
          if (fdictString[currentPos] === "{") {
            braceCount++;
          } else if (fdictString[currentPos] === "}") {
            braceCount--;
          }
          currentPos++;
        }
        if (braceCount === 0) {
          const entryContent = fdictString.slice(entryContentStart, currentPos - 1).trim();
          const entry = parseDictEntry(entryContent);
          if (entry) {
            entries.push(entry);
          }
        }
      } else {
        while (currentPos < fdictString.length && fdictString[currentPos] !== "{") {
          currentPos++;
        }
      }
    }
    return entries;
  }
  function parseDictEntry(entryString) {
    const idMatch = /id\s+(\d+)/.exec(entryString);
    const nameMatch = /name\s+"((?:[^"\\]|\\.)*)"/s.exec(entryString);
    if (idMatch && nameMatch) {
      const processedName = nameMatch[1].replace(/\\"/g, '"').replace(/\\\\/g, "\\");
      return {
        id: parseInt(idMatch[1], 10),
        name: processedName
      };
    }
    return null;
  }
  function parseNodes(nodesString) {
    const nodes = [];
    let currentPos = 0;
    while (currentPos < nodesString.length) {
      while (currentPos < nodesString.length && /\s/.test(nodesString[currentPos])) {
        currentPos++;
      }
      if (currentPos >= nodesString.length) {
        break;
      }
      if (nodesString[currentPos] === "{") {
        const nodeContentStart = currentPos + 1;
        let braceCount = 1;
        currentPos++;
        while (currentPos < nodesString.length && braceCount > 0) {
          if (nodesString[currentPos] === "{") {
            braceCount++;
          } else if (nodesString[currentPos] === "}") {
            braceCount--;
          }
          currentPos++;
        }
        if (braceCount === 0) {
          const nodeContent = nodesString.slice(nodeContentStart, currentPos - 1).trim();
          const node2 = parseNode(nodeContent);
          if (node2) {
            nodes.push(node2);
          }
        }
      } else {
        while (currentPos < nodesString.length && nodesString[currentPos] !== "{") {
          currentPos++;
        }
      }
    }
    return nodes;
  }
  function parseNode(nodeString) {
    const idMatch = /id\s+(\d+)/.exec(nodeString);
    const parentMatch = /parent\s+(\d+)/.exec(nodeString);
    if (idMatch) {
      const node2 = {
        id: parseInt(idMatch[1], 10)
      };
      if (parentMatch) {
        node2.parent = parseInt(parentMatch[1], 10);
      }
      const featuresIndex = nodeString.indexOf("features");
      if (featuresIndex !== -1) {
        const openBraceIndex = nodeString.indexOf("{", featuresIndex);
        if (openBraceIndex !== -1) {
          let braceCount = 1;
          let closeBraceIndex = openBraceIndex + 1;
          while (closeBraceIndex < nodeString.length && braceCount > 0) {
            if (nodeString[closeBraceIndex] === "{") {
              braceCount++;
            } else if (nodeString[closeBraceIndex] === "}") {
              braceCount--;
            }
            closeBraceIndex++;
          }
          if (braceCount === 0) {
            const featuresContent = nodeString.slice(openBraceIndex + 1, closeBraceIndex - 1).trim();
            node2.features = parseFeatures(featuresContent);
          }
        }
      }
      return node2;
    }
    return null;
  }
  function parseFeatures(featuresString) {
    const features = [];
    let currentPos = 0;
    while (currentPos < featuresString.length) {
      while (currentPos < featuresString.length && /\s/.test(featuresString[currentPos])) {
        currentPos++;
      }
      if (currentPos >= featuresString.length) {
        break;
      }
      if (featuresString[currentPos] === "{") {
        const featureContentStart = currentPos + 1;
        let braceCount = 1;
        currentPos++;
        while (currentPos < featuresString.length && braceCount > 0) {
          if (featuresString[currentPos] === "{") {
            braceCount++;
          } else if (featuresString[currentPos] === "}") {
            braceCount--;
          }
          currentPos++;
        }
        if (braceCount === 0) {
          const featureContent = featuresString.slice(featureContentStart, currentPos - 1).trim();
          const feature = parseFeature(featureContent);
          if (feature) {
            features.push(feature);
          }
        }
      } else {
        while (currentPos < featuresString.length && featuresString[currentPos] !== "{") {
          currentPos++;
        }
      }
    }
    return features;
  }
  function parseFeature(featureString) {
    const featureidMatch = /featureid\s+(\d+)/.exec(featureString);
    const valueMatch = /value\s+"((?:[^"\\]|\\.)*)"/s.exec(featureString);
    if (featureidMatch && valueMatch) {
      const processedValue = valueMatch[1].replace(/\\"/g, '"').replace(/\\\\/g, "\\");
      return {
        featureid: parseInt(featureidMatch[1], 10),
        value: processedValue
      };
    }
    return null;
  }
  var remap;
  var init_parseAsn1 = __esm({
    "node_modules/react-msaview/dist/parseAsn1.js"() {
      remap = {
        $NODE_COLLAPSED: "collapsed",
        $NODE_COLOR: "color",
        $LABEL_BG_COLOR: "color",
        "seq-id": "seqId",
        "seq-title": "seqTitle",
        "align-index": "alignIndex",
        "accession-nbr": "accessionNbr",
        "blast-name": "blastName",
        "common-name": "commonName",
        "leaf-count": "leafCount"
      };
    }
  });

  // node_modules/react-msaview/dist/reparseTree.js
  function reparseTree(tree) {
    return {
      ...tree,
      children: tree.children.map((r2) => r2.children.length ? reparseTree(r2) : {
        children: [r2],
        id: `${r2.id}-leafnode`,
        name: `${r2.name}-hidden`
      })
    };
  }
  var init_reparseTree = __esm({
    "node_modules/react-msaview/dist/reparseTree.js"() {
    }
  });

  // node_modules/react-msaview/dist/rowCoordinateCalculations.js
  function visibleColToGlobalCol(blanks, visibleCol) {
    let currentVisibleCol = 0;
    let blankArrayIndex = 0;
    let globalCol = 0;
    const blanksLen = blanks.length;
    while (blankArrayIndex < blanksLen && blanks[blankArrayIndex] === globalCol) {
      blankArrayIndex++;
      globalCol++;
    }
    while (currentVisibleCol < visibleCol) {
      currentVisibleCol++;
      globalCol++;
      while (blankArrayIndex < blanksLen && blanks[blankArrayIndex] === globalCol) {
        blankArrayIndex++;
        globalCol++;
      }
    }
    return globalCol;
  }
  function globalColToVisibleCol(blanks, globalCol) {
    let left = 0;
    let right = blanks.length - 1;
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      if (blanks[mid] === globalCol) {
        return void 0;
      }
      if (blanks[mid] < globalCol) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    const blanksBefore = left;
    return globalCol - blanksBefore;
  }
  function visibleColToSeqPos({ seq, blanks, visibleCol }) {
    const globalCol = visibleColToGlobalCol(blanks, visibleCol);
    const seqLen = seq.length;
    if (globalCol < seqLen && isBlank(seq[globalCol])) {
      return void 0;
    }
    let seqPos = 0;
    for (let i2 = 0; i2 < globalCol && i2 < seqLen; i2++) {
      if (!isBlank(seq[i2])) {
        seqPos++;
      }
    }
    return globalCol < seqLen ? seqPos : void 0;
  }
  function visibleColToSeqPosForRow({ rowName, visibleCol, rowMap, blanks }) {
    const seq = rowMap.get(rowName);
    return seq !== void 0 ? visibleColToSeqPos({ seq, visibleCol, blanks }) : void 0;
  }
  var init_rowCoordinateCalculations = __esm({
    "node_modules/react-msaview/dist/rowCoordinateCalculations.js"() {
      init_util();
    }
  });

  // node_modules/react-msaview/dist/seqPosToGlobalCol.js
  function seqPosToGlobalCol({ row, seqPos }) {
    let nonGapCount = 0;
    let globalCol = 0;
    while (globalCol < row.length) {
      if (!isBlank(row[globalCol])) {
        if (nonGapCount === seqPos) {
          return globalCol;
        }
        nonGapCount++;
      }
      globalCol++;
    }
    return seqPos === 0 ? 0 : globalCol;
  }
  var init_seqPosToGlobalCol = __esm({
    "node_modules/react-msaview/dist/seqPosToGlobalCol.js"() {
      init_util();
    }
  });

  // node_modules/react-msaview/dist/components/minimap/MinimapSVG.js
  var import_react76, import_mobx_react46, MinimapSVG, MinimapSVG_default;
  var init_MinimapSVG = __esm({
    "node_modules/react-msaview/dist/components/minimap/MinimapSVG.js"() {
      import_react76 = __toESM(require_react());
      import_mobx_react46 = __toESM(require_mobx_react());
      MinimapSVG = (0, import_mobx_react46.observer)(({ model }) => {
        const { scrollX, msaAreaWidth: W, minimapHeight: H2, colWidth, numColumns } = model;
        const BAR_HEIGHT = 12;
        const H22 = H2 - 12;
        const unit = W / numColumns / colWidth;
        const left = -scrollX;
        const right = left + W;
        const s2 = left * unit;
        const e2 = right * unit;
        const fillColor = "rgb(66, 119, 127)";
        const fillOpacity = 0.3;
        return import_react76.default.createElement(
          import_react76.default.Fragment,
          null,
          import_react76.default.createElement("rect", { x: 0, y: 0, width: W, height: BAR_HEIGHT, stroke: "#555", fill: "none" }),
          import_react76.default.createElement("rect", { x: Math.max(0, s2), y: 0, width: e2 - s2, height: BAR_HEIGHT, fill: fillColor, fillOpacity, stroke: "#555" }),
          import_react76.default.createElement(
            "g",
            { transform: `translate(0 ${BAR_HEIGHT})` },
            import_react76.default.createElement("polygon", { fill: fillColor, fillOpacity, points: [
              [e2, 0],
              [s2, 0],
              [0, H22],
              [W, H22]
            ].toString() })
          )
        );
      });
      MinimapSVG_default = MinimapSVG;
    }
  });

  // node_modules/react-msaview/dist/components/tracks/renderTracksSvg.js
  function renderConservationTrack({ model, ctx, offsetX, offsetY, trackHeight, blockSizeXOverride, highResScaleFactorOverride }) {
    const { blockSize, colWidth, highResScaleFactor, conservation } = model;
    const bx = blockSizeXOverride ?? blockSize;
    const k2 = highResScaleFactorOverride ?? highResScaleFactor;
    ctx.resetTransform();
    ctx.scale(k2, k2);
    ctx.translate(-offsetX, offsetY);
    const xStart = Math.max(0, Math.floor(offsetX / colWidth));
    const xEnd = Math.max(0, Math.ceil((offsetX + bx) / colWidth));
    for (let i2 = xStart; i2 < xEnd && i2 < conservation.length; i2++) {
      const value = conservation[i2];
      const barHeight = value * trackHeight;
      const x2 = i2 * colWidth;
      const hue = value * 120;
      ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
      ctx.fillRect(x2, trackHeight - barHeight, colWidth, barHeight);
    }
    ctx.resetTransform();
  }
  function renderTextTrack({ model, ctx, track, offsetX, offsetY, contrastScheme, blockSizeXOverride, highResScaleFactorOverride }) {
    const { blockSize, bgColor, colorScheme: modelColorScheme, colWidth, fontSize, rowHeight, highResScaleFactor } = model;
    const { customColorScheme, data } = track.model;
    const colorScheme = customColorScheme ?? modelColorScheme;
    const bx = blockSizeXOverride ?? blockSize;
    const k2 = highResScaleFactorOverride ?? highResScaleFactor;
    ctx.resetTransform();
    ctx.scale(k2, k2);
    ctx.translate(-offsetX, offsetY);
    ctx.textAlign = "center";
    ctx.font = ctx.font.replace(/\d+px/, `${fontSize}px`);
    const xStart = Math.max(0, Math.floor(offsetX / colWidth));
    const xEnd = Math.max(0, Math.ceil((offsetX + bx) / colWidth));
    const str = data?.slice(xStart, xEnd);
    for (let i2 = 0; str && i2 < str.length; i2++) {
      const letter = str[i2];
      const color = colorScheme[letter.toUpperCase()];
      const x2 = i2 * colWidth + offsetX - offsetX % colWidth;
      if (bgColor && color) {
        ctx.fillStyle = color;
        ctx.fillRect(x2, 0, colWidth, rowHeight);
      }
      if (rowHeight >= 10 && colWidth >= rowHeight / 2) {
        ctx.fillStyle = bgColor && color ? contrastScheme[letter.toUpperCase()] ?? "black" : "black";
        ctx.fillText(letter, x2 + colWidth / 2, rowHeight / 2 + 1);
      }
    }
    ctx.resetTransform();
  }
  function renderAllTracks({ model, ctx, offsetX, contrastScheme, blockSizeXOverride, highResScaleFactorOverride }) {
    const { turnedOnTracks } = model;
    let currentY = 0;
    for (const track of turnedOnTracks) {
      const trackHeight = track.model.height;
      if (track.model.id === "conservation") {
        renderConservationTrack({
          model,
          ctx,
          offsetX,
          offsetY: currentY,
          trackHeight,
          blockSizeXOverride,
          highResScaleFactorOverride
        });
      } else {
        renderTextTrack({
          model,
          ctx,
          track,
          offsetX,
          offsetY: currentY,
          contrastScheme,
          blockSizeXOverride,
          highResScaleFactorOverride
        });
      }
      currentY += trackHeight;
    }
  }
  var init_renderTracksSvg = __esm({
    "node_modules/react-msaview/dist/components/tracks/renderTracksSvg.js"() {
    }
  });

  // node_modules/svgcanvas/dist/svgcanvas.js
  var require_svgcanvas = __commonJS({
    "node_modules/svgcanvas/dist/svgcanvas.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function toString2(obj) {
        if (!obj) {
          return obj;
        }
        if (typeof obj === "string") {
          return obj;
        }
        return obj + "";
      }
      var ImageUtils = class {
        /**
         * Convert svg dataurl to canvas element
         * 
         * @private
         */
        async svg2canvas(svgDataURL, width, height) {
          const svgImage = await new Promise((resolve) => {
            var svgImage2 = new Image();
            svgImage2.onload = function() {
              resolve(svgImage2);
            };
            svgImage2.src = svgDataURL;
          });
          var canvas = document.createElement("canvas");
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(svgImage, 0, 0);
          return canvas;
        }
        toDataURL(svgNode, width, height, type, encoderOptions, options) {
          var xml = new XMLSerializer().serializeToString(svgNode);
          var isIE = document.documentMode;
          if (isIE) {
            var xmlns = /xmlns="http:\/\/www\.w3\.org\/2000\/svg".+xmlns="http:\/\/www\.w3\.org\/2000\/svg/gi;
            if (xmlns.test(xml)) {
              xml = xml.replace('xmlns="http://www.w3.org/2000/svg', 'xmlns:xlink="http://www.w3.org/1999/xlink');
            }
          }
          if (!options) {
            options = {};
          }
          var SVGDataURL = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(xml);
          if (type === "image/svg+xml" || !type) {
            if (options.async) {
              return Promise.resolve(SVGDataURL);
            }
            return SVGDataURL;
          }
          if (type === "image/jpeg" || type === "image/png") {
            if (!options.async) {
              throw new Error("svgcanvas: options.async must be set to true if type is image/jpeg | image/png");
            }
            return (async () => {
              const canvas = await this.svg2canvas(SVGDataURL, width, height);
              const dataUrl = canvas.toDataURL(type, encoderOptions);
              canvas.remove();
              return dataUrl;
            })();
          }
          throw new Error("svgcanvas: Unknown type for toDataURL, please use image/jpeg | image/png | image/svg+xml.");
        }
        getImageData(svgNode, width, height, sx, sy, sw, sh, options) {
          if (!options) {
            options = {};
          }
          if (!options.async) {
            throw new Error("svgcanvas: options.async must be set to true for getImageData");
          }
          const svgDataURL = this.toDataURL(svgNode, width, height, "image/svg+xml");
          return (async () => {
            const canvas = await this.svg2canvas(svgDataURL, width, height);
            const ctx = canvas.getContext("2d");
            const imageData = ctx.getImageData(sx, sy, sw, sh);
            canvas.remove();
            return imageData;
          })();
        }
      };
      var utils = new ImageUtils();
      var Context = (function() {
        var STYLES, Context2, CanvasGradient, CanvasPattern, namedEntities;
        function format(str, args) {
          var keys = Object.keys(args), i2;
          for (i2 = 0; i2 < keys.length; i2++) {
            str = str.replace(new RegExp("\\{" + keys[i2] + "\\}", "gi"), args[keys[i2]]);
          }
          return str;
        }
        function randomString(holder) {
          var chars, randomstring, i2;
          if (!holder) {
            throw new Error("cannot create a random attribute name for an undefined object");
          }
          chars = "ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
          randomstring = "";
          do {
            randomstring = "";
            for (i2 = 0; i2 < 12; i2++) {
              randomstring += chars[Math.floor(Math.random() * chars.length)];
            }
          } while (holder[randomstring]);
          return randomstring;
        }
        function createNamedToNumberedLookup(items, radix) {
          var i2, entity, lookup = {}, base10;
          items = items.split(",");
          radix = radix || 10;
          for (i2 = 0; i2 < items.length; i2 += 2) {
            entity = "&" + items[i2 + 1] + ";";
            base10 = parseInt(items[i2], radix);
            lookup[entity] = "&#" + base10 + ";";
          }
          lookup["\\xa0"] = "&#160;";
          return lookup;
        }
        function getTextAnchor(textAlign) {
          var mapping = { "left": "start", "right": "end", "center": "middle", "start": "start", "end": "end" };
          return mapping[textAlign] || mapping.start;
        }
        function getDominantBaseline(textBaseline) {
          var mapping = { "alphabetic": "alphabetic", "hanging": "hanging", "top": "text-before-edge", "bottom": "text-after-edge", "middle": "central" };
          return mapping[textBaseline] || mapping.alphabetic;
        }
        namedEntities = createNamedToNumberedLookup(
          "50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro",
          32
        );
        STYLES = {
          "strokeStyle": {
            svgAttr: "stroke",
            //corresponding svg attribute
            canvas: "#000000",
            //canvas default
            svg: "none",
            //svg default
            apply: "stroke"
            //apply on stroke() or fill()
          },
          "fillStyle": {
            svgAttr: "fill",
            canvas: "#000000",
            svg: null,
            //svg default is black, but we need to special case this to handle canvas stroke without fill
            apply: "fill"
          },
          "lineCap": {
            svgAttr: "stroke-linecap",
            canvas: "butt",
            svg: "butt",
            apply: "stroke"
          },
          "lineJoin": {
            svgAttr: "stroke-linejoin",
            canvas: "miter",
            svg: "miter",
            apply: "stroke"
          },
          "miterLimit": {
            svgAttr: "stroke-miterlimit",
            canvas: 10,
            svg: 4,
            apply: "stroke"
          },
          "lineWidth": {
            svgAttr: "stroke-width",
            canvas: 1,
            svg: 1,
            apply: "stroke"
          },
          "globalAlpha": {
            svgAttr: "opacity",
            canvas: 1,
            svg: 1,
            apply: "fill stroke"
          },
          "font": {
            //font converts to multiple svg attributes, there is custom logic for this
            canvas: "10px sans-serif"
          },
          "shadowColor": {
            canvas: "#000000"
          },
          "shadowOffsetX": {
            canvas: 0
          },
          "shadowOffsetY": {
            canvas: 0
          },
          "shadowBlur": {
            canvas: 0
          },
          "textAlign": {
            canvas: "start"
          },
          "textBaseline": {
            canvas: "alphabetic"
          },
          "lineDash": {
            svgAttr: "stroke-dasharray",
            canvas: [],
            svg: null,
            apply: "stroke"
          }
        };
        CanvasGradient = function(gradientNode, ctx) {
          this.__root = gradientNode;
          this.__ctx = ctx;
        };
        CanvasGradient.prototype.addColorStop = function(offset4, color) {
          var stop = this.__ctx.__createElement("stop"), regex, matches2;
          stop.setAttribute("offset", offset4);
          if (toString2(color).indexOf("rgba") !== -1) {
            regex = /rgba\(\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
            matches2 = regex.exec(color);
            stop.setAttribute("stop-color", format("rgb({r},{g},{b})", { r: matches2[1], g: matches2[2], b: matches2[3] }));
            stop.setAttribute("stop-opacity", matches2[4]);
          } else {
            stop.setAttribute("stop-color", toString2(color));
          }
          this.__root.appendChild(stop);
        };
        CanvasPattern = function(pattern, ctx) {
          this.__root = pattern;
          this.__ctx = ctx;
        };
        Context2 = function(o2) {
          var defaultOptions = { width: 500, height: 500, enableMirroring: false }, options;
          if (arguments.length > 1) {
            options = defaultOptions;
            options.width = arguments[0];
            options.height = arguments[1];
          } else if (!o2) {
            options = defaultOptions;
          } else {
            options = o2;
          }
          if (!(this instanceof Context2)) {
            return new Context2(options);
          }
          this.width = options.width || defaultOptions.width;
          this.height = options.height || defaultOptions.height;
          this.enableMirroring = options.enableMirroring !== void 0 ? options.enableMirroring : defaultOptions.enableMirroring;
          this.canvas = this;
          this.__document = options.document || document;
          if (options.ctx) {
            this.__ctx = options.ctx;
          } else {
            this.__canvas = this.__document.createElement("canvas");
            this.__ctx = this.__canvas.getContext("2d");
          }
          this.__setDefaultStyles();
          this.__styleStack = [this.__getStyleState()];
          this.__groupStack = [];
          this.__root = this.__document.createElementNS("http://www.w3.org/2000/svg", "svg");
          this.__root.setAttribute("version", 1.1);
          this.__root.setAttribute("xmlns", "http://www.w3.org/2000/svg");
          this.__root.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:xlink", "http://www.w3.org/1999/xlink");
          this.__root.setAttribute("width", this.width);
          this.__root.setAttribute("height", this.height);
          this.__ids = {};
          this.__defs = this.__document.createElementNS("http://www.w3.org/2000/svg", "defs");
          this.__root.appendChild(this.__defs);
          this.__currentElement = this.__document.createElementNS("http://www.w3.org/2000/svg", "g");
          this.__root.appendChild(this.__currentElement);
          this.resetTransform();
          this.__options = options;
          this.__id = Math.random().toString(16).substring(2, 8);
          this.__debug(`new`, o2);
        };
        Context2.prototype.__debug = function(...data) {
          if (!this.__options.debug) {
            return;
          }
          console.debug(`svgcanvas#${this.__id}:`, ...data);
        };
        Context2.prototype.__createElement = function(elementName, properties, resetFill) {
          if (typeof properties === "undefined") {
            properties = {};
          }
          var element = this.__document.createElementNS("http://www.w3.org/2000/svg", elementName), keys = Object.keys(properties), i2, key;
          if (resetFill) {
            element.setAttribute("fill", "none");
            element.setAttribute("stroke", "none");
          }
          for (i2 = 0; i2 < keys.length; i2++) {
            key = keys[i2];
            element.setAttribute(key, properties[key]);
          }
          return element;
        };
        Context2.prototype.__setDefaultStyles = function() {
          var keys = Object.keys(STYLES), i2, key;
          for (i2 = 0; i2 < keys.length; i2++) {
            key = keys[i2];
            this[key] = STYLES[key].canvas;
          }
        };
        Context2.prototype.__applyStyleState = function(styleState) {
          var keys = Object.keys(styleState), i2, key;
          for (i2 = 0; i2 < keys.length; i2++) {
            key = keys[i2];
            this[key] = styleState[key];
          }
        };
        Context2.prototype.__getStyleState = function() {
          var i2, styleState = {}, keys = Object.keys(STYLES), key;
          for (i2 = 0; i2 < keys.length; i2++) {
            key = keys[i2];
            styleState[key] = this[key];
          }
          return styleState;
        };
        Context2.prototype.__applyTransformation = function(element, matrix) {
          const { a: a2, b: b2, c: c2, d: d3, e: e2, f: f2 } = matrix || this.getTransform();
          element.setAttribute("transform", `matrix(${a2} ${b2} ${c2} ${d3} ${e2} ${f2})`);
        };
        Context2.prototype.__applyStyleToCurrentElement = function(type) {
          var currentElement = this.__currentElement;
          var currentStyleGroup = this.__currentElementsToStyle;
          if (currentStyleGroup) {
            currentElement.setAttribute(type, "");
            currentElement = currentStyleGroup.element;
            currentStyleGroup.children.forEach(function(node3) {
              node3.setAttribute(type, "");
            });
          }
          var keys = Object.keys(STYLES), i2, style, value, regex, matches2, id, nodeIndex, node2;
          for (i2 = 0; i2 < keys.length; i2++) {
            style = STYLES[keys[i2]];
            value = this[keys[i2]];
            if (style.apply) {
              if (value instanceof CanvasPattern) {
                if (value.__ctx) {
                  for (nodeIndex = 0; nodeIndex < value.__ctx.__defs.childNodes.length; nodeIndex++) {
                    node2 = value.__ctx.__defs.childNodes[nodeIndex];
                    id = node2.getAttribute("id");
                    this.__ids[id] = id;
                    this.__defs.appendChild(node2);
                  }
                }
                currentElement.setAttribute(style.apply, format("url(#{id})", { id: value.__root.getAttribute("id") }));
              } else if (value instanceof CanvasGradient) {
                currentElement.setAttribute(style.apply, format("url(#{id})", { id: value.__root.getAttribute("id") }));
              } else if (style.apply.indexOf(type) !== -1 && style.svg !== value) {
                if ((style.svgAttr === "stroke" || style.svgAttr === "fill") && value && value.indexOf("rgba") !== -1) {
                  regex = /rgba\(\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
                  matches2 = regex.exec(value);
                  currentElement.setAttribute(style.svgAttr, format("rgb({r},{g},{b})", { r: matches2[1], g: matches2[2], b: matches2[3] }));
                  var opacity = matches2[4];
                  var globalAlpha = this.globalAlpha;
                  if (globalAlpha != null) {
                    opacity *= globalAlpha;
                  }
                  currentElement.setAttribute(style.svgAttr + "-opacity", opacity);
                } else {
                  var attr2 = style.svgAttr;
                  if (keys[i2] === "globalAlpha") {
                    attr2 = type + "-" + style.svgAttr;
                    if (currentElement.getAttribute(attr2)) {
                      continue;
                    }
                  } else if (keys[i2] === "lineWidth") {
                    var scale = this.__getTransformScale();
                    value = value * Math.max(scale.x, scale.y);
                  }
                  currentElement.setAttribute(attr2, value);
                }
              }
            }
          }
        };
        Context2.prototype.__closestGroupOrSvg = function(node2) {
          node2 = node2 || this.__currentElement;
          if (node2.nodeName === "g" || node2.nodeName === "svg") {
            return node2;
          } else {
            return this.__closestGroupOrSvg(node2.parentNode);
          }
        };
        Context2.prototype.getSerializedSvg = function(fixNamedEntities) {
          var serialized = new XMLSerializer().serializeToString(this.__root), keys, i2, key, value, regexp, xmlns;
          xmlns = /xmlns="http:\/\/www\.w3\.org\/2000\/svg".+xmlns="http:\/\/www\.w3\.org\/2000\/svg/gi;
          if (xmlns.test(serialized)) {
            serialized = serialized.replace('xmlns="http://www.w3.org/2000/svg', 'xmlns:xlink="http://www.w3.org/1999/xlink');
          }
          if (fixNamedEntities) {
            keys = Object.keys(namedEntities);
            for (i2 = 0; i2 < keys.length; i2++) {
              key = keys[i2];
              value = namedEntities[key];
              regexp = new RegExp(key, "gi");
              if (regexp.test(serialized)) {
                serialized = serialized.replace(regexp, value);
              }
            }
          }
          return serialized;
        };
        Context2.prototype.getSvg = function() {
          return this.__root;
        };
        Context2.prototype.save = function() {
          var group = this.__createElement("g");
          var parent = this.__closestGroupOrSvg();
          this.__groupStack.push(parent);
          parent.appendChild(group);
          this.__currentElement = group;
          const style = this.__getStyleState();
          this.__debug("save style", style);
          this.__styleStack.push(style);
          if (!this.__transformMatrixStack) {
            this.__transformMatrixStack = [];
          }
          this.__transformMatrixStack.push(this.getTransform());
        };
        Context2.prototype.restore = function() {
          this.__currentElement = this.__groupStack.pop();
          this.__currentElementsToStyle = null;
          if (!this.__currentElement) {
            this.__currentElement = this.__root.childNodes[1];
          }
          var state = this.__styleStack.pop();
          this.__debug("restore style", state);
          this.__applyStyleState(state);
          if (this.__transformMatrixStack && this.__transformMatrixStack.length > 0) {
            this.setTransform(this.__transformMatrixStack.pop());
          }
        };
        Context2.prototype.beginPath = function() {
          var path, parent;
          this.__currentDefaultPath = "";
          this.__currentPosition = {};
          path = this.__createElement("path", {}, true);
          parent = this.__closestGroupOrSvg();
          parent.appendChild(path);
          this.__currentElement = path;
        };
        Context2.prototype.__applyCurrentDefaultPath = function() {
          var currentElement = this.__currentElement;
          if (currentElement.nodeName === "path") {
            currentElement.setAttribute("d", this.__currentDefaultPath);
          } else {
            console.error("Attempted to apply path command to node", currentElement.nodeName);
          }
        };
        Context2.prototype.__addPathCommand = function(command) {
          this.__currentDefaultPath += " ";
          this.__currentDefaultPath += command;
        };
        Context2.prototype.moveTo = function(x2, y2) {
          if (this.__currentElement.nodeName !== "path") {
            this.beginPath();
          }
          this.__currentPosition = { x: x2, y: y2 };
          this.__addPathCommand(format("M {x} {y}", {
            x: this.__matrixTransform(x2, y2).x,
            y: this.__matrixTransform(x2, y2).y
          }));
        };
        Context2.prototype.closePath = function() {
          if (this.__currentDefaultPath) {
            this.__addPathCommand("Z");
          }
        };
        Context2.prototype.lineTo = function(x2, y2) {
          this.__currentPosition = { x: x2, y: y2 };
          if (this.__currentDefaultPath.indexOf("M") > -1) {
            this.__addPathCommand(format("L {x} {y}", {
              x: this.__matrixTransform(x2, y2).x,
              y: this.__matrixTransform(x2, y2).y
            }));
          } else {
            this.__addPathCommand(format("M {x} {y}", {
              x: this.__matrixTransform(x2, y2).x,
              y: this.__matrixTransform(x2, y2).y
            }));
          }
        };
        Context2.prototype.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x2, y2) {
          this.__currentPosition = { x: x2, y: y2 };
          this.__addPathCommand(format(
            "C {cp1x} {cp1y} {cp2x} {cp2y} {x} {y}",
            {
              cp1x: this.__matrixTransform(cp1x, cp1y).x,
              cp1y: this.__matrixTransform(cp1x, cp1y).y,
              cp2x: this.__matrixTransform(cp2x, cp2y).x,
              cp2y: this.__matrixTransform(cp2x, cp2y).y,
              x: this.__matrixTransform(x2, y2).x,
              y: this.__matrixTransform(x2, y2).y
            }
          ));
        };
        Context2.prototype.quadraticCurveTo = function(cpx, cpy, x2, y2) {
          this.__currentPosition = { x: x2, y: y2 };
          this.__addPathCommand(format("Q {cpx} {cpy} {x} {y}", {
            cpx: this.__matrixTransform(cpx, cpy).x,
            cpy: this.__matrixTransform(cpx, cpy).y,
            x: this.__matrixTransform(x2, y2).x,
            y: this.__matrixTransform(x2, y2).y
          }));
        };
        var normalize2 = function(vector) {
          var len2 = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);
          return [vector[0] / len2, vector[1] / len2];
        };
        Context2.prototype.arcTo = function(x1, y1, x2, y2, radius2) {
          var x0 = this.__currentPosition && this.__currentPosition.x;
          var y0 = this.__currentPosition && this.__currentPosition.y;
          if (typeof x0 == "undefined" || typeof y0 == "undefined") {
            return;
          }
          if (radius2 < 0) {
            throw new Error("IndexSizeError: The radius provided (" + radius2 + ") is negative.");
          }
          if (x0 === x1 && y0 === y1 || x1 === x2 && y1 === y2 || radius2 === 0) {
            this.lineTo(x1, y1);
            return;
          }
          var unit_vec_p1_p0 = normalize2([x0 - x1, y0 - y1]);
          var unit_vec_p1_p2 = normalize2([x2 - x1, y2 - y1]);
          if (unit_vec_p1_p0[0] * unit_vec_p1_p2[1] === unit_vec_p1_p0[1] * unit_vec_p1_p2[0]) {
            this.lineTo(x1, y1);
            return;
          }
          var cos = unit_vec_p1_p0[0] * unit_vec_p1_p2[0] + unit_vec_p1_p0[1] * unit_vec_p1_p2[1];
          var theta = Math.acos(Math.abs(cos));
          var unit_vec_p1_origin = normalize2([
            unit_vec_p1_p0[0] + unit_vec_p1_p2[0],
            unit_vec_p1_p0[1] + unit_vec_p1_p2[1]
          ]);
          var len_p1_origin = radius2 / Math.sin(theta / 2);
          var x3 = x1 + len_p1_origin * unit_vec_p1_origin[0];
          var y3 = y1 + len_p1_origin * unit_vec_p1_origin[1];
          var unit_vec_origin_start_tangent = [
            -unit_vec_p1_p0[1],
            unit_vec_p1_p0[0]
          ];
          var unit_vec_origin_end_tangent = [
            unit_vec_p1_p2[1],
            -unit_vec_p1_p2[0]
          ];
          var getAngle = function(vector) {
            var x4 = vector[0];
            var y4 = vector[1];
            if (y4 >= 0) {
              return Math.acos(x4);
            } else {
              return -Math.acos(x4);
            }
          };
          var startAngle = getAngle(unit_vec_origin_start_tangent);
          var endAngle = getAngle(unit_vec_origin_end_tangent);
          this.lineTo(
            x3 + unit_vec_origin_start_tangent[0] * radius2,
            y3 + unit_vec_origin_start_tangent[1] * radius2
          );
          this.arc(x3, y3, radius2, startAngle, endAngle);
        };
        Context2.prototype.stroke = function() {
          if (this.__currentElement.nodeName === "path") {
            this.__currentElement.setAttribute("paint-order", "fill stroke markers");
          }
          this.__applyCurrentDefaultPath();
          this.__applyStyleToCurrentElement("stroke");
        };
        Context2.prototype.fill = function() {
          if (this.__currentElement.nodeName === "path") {
            this.__currentElement.setAttribute("paint-order", "stroke fill markers");
          }
          this.__applyCurrentDefaultPath();
          this.__applyStyleToCurrentElement("fill");
        };
        Context2.prototype.rect = function(x2, y2, width, height) {
          if (this.__currentElement.nodeName !== "path") {
            this.beginPath();
          }
          this.moveTo(x2, y2);
          this.lineTo(x2 + width, y2);
          this.lineTo(x2 + width, y2 + height);
          this.lineTo(x2, y2 + height);
          this.lineTo(x2, y2);
          this.closePath();
        };
        Context2.prototype.roundRect = function(x2, y2, w2, h2, radii) {
          if (this.__currentElement.nodeName !== "path") {
            this.beginPath();
          }
          let tl, tr, br, bl;
          if (typeof radii == "number") {
            tl = radii;
            tr = radii;
            br = radii;
            bl = radii;
          } else {
            [tl, tr, br, bl] = radii;
          }
          this.moveTo(x2 + tl, y2);
          this.arcTo(x2 + w2, y2, x2 + w2, y2 + h2, tr);
          this.arcTo(x2 + w2, y2 + h2, x2, y2 + h2, br);
          this.arcTo(x2, y2 + h2, x2, y2, bl);
          this.arcTo(x2, y2, x2 + w2, y2, tl);
          this.closePath();
        };
        Context2.prototype.fillRect = function(x2, y2, width, height) {
          let { a: a2, b: b2, c: c2, d: d3, e: e2, f: f2 } = this.getTransform();
          if (JSON.stringify([a2, b2, c2, d3, e2, f2]) === JSON.stringify([1, 0, 0, 1, 0, 0])) {
            if (x2 === 0 && y2 === 0 && width === this.width && height === this.height) {
              this.__clearCanvas();
            }
          }
          var rect, parent;
          rect = this.__createElement("rect", {
            x: x2,
            y: y2,
            width,
            height
          }, true);
          parent = this.__closestGroupOrSvg();
          parent.appendChild(rect);
          this.__currentElement = rect;
          this.__applyTransformation(rect);
          this.__applyStyleToCurrentElement("fill");
        };
        Context2.prototype.strokeRect = function(x2, y2, width, height) {
          var rect, parent;
          rect = this.__createElement("rect", {
            x: x2,
            y: y2,
            width,
            height
          }, true);
          parent = this.__closestGroupOrSvg();
          parent.appendChild(rect);
          this.__currentElement = rect;
          this.__applyTransformation(rect);
          this.__applyStyleToCurrentElement("stroke");
        };
        Context2.prototype.__clearCanvas = function() {
          var rootGroup = this.__root.childNodes[1];
          this.__root.removeChild(rootGroup);
          this.__currentElement = this.__document.createElementNS("http://www.w3.org/2000/svg", "g");
          this.__root.appendChild(this.__currentElement);
          this.__groupStack = [];
        };
        Context2.prototype.clearRect = function(x2, y2, width, height) {
          let { a: a2, b: b2, c: c2, d: d3, e: e2, f: f2 } = this.getTransform();
          if (JSON.stringify([a2, b2, c2, d3, e2, f2]) === JSON.stringify([1, 0, 0, 1, 0, 0])) {
            if (x2 === 0 && y2 === 0 && width === this.width && height === this.height) {
              this.__clearCanvas();
              return;
            }
          }
          var rect, parent = this.__closestGroupOrSvg();
          rect = this.__createElement("rect", {
            x: x2,
            y: y2,
            width,
            height,
            fill: "#FFFFFF"
          }, true);
          this.__applyTransformation(rect);
          parent.appendChild(rect);
        };
        Context2.prototype.createLinearGradient = function(x1, y1, x2, y2) {
          var grad = this.__createElement("linearGradient", {
            id: randomString(this.__ids),
            x1: x1 + "px",
            x2: x2 + "px",
            y1: y1 + "px",
            y2: y2 + "px",
            "gradientUnits": "userSpaceOnUse"
          }, false);
          this.__defs.appendChild(grad);
          return new CanvasGradient(grad, this);
        };
        Context2.prototype.createRadialGradient = function(x0, y0, r0, x1, y1, r1) {
          var grad = this.__createElement("radialGradient", {
            id: randomString(this.__ids),
            cx: x1 + "px",
            cy: y1 + "px",
            r: r1 + "px",
            fx: x0 + "px",
            fy: y0 + "px",
            "gradientUnits": "userSpaceOnUse"
          }, false);
          this.__defs.appendChild(grad);
          return new CanvasGradient(grad, this);
        };
        Context2.prototype.__applyText = function(text, x2, y2, action) {
          var el = document.createElement("span");
          el.setAttribute("style", "font:" + this.font);
          var style = el.style, parent = this.__closestGroupOrSvg(), textElement = this.__createElement("text", {
            "font-family": style.fontFamily,
            "font-size": style.fontSize,
            "font-style": style.fontStyle,
            "font-weight": style.fontWeight,
            // canvas doesn't support underline natively, but we do :)
            "text-decoration": this.__fontUnderline,
            "x": x2,
            "y": y2,
            "text-anchor": getTextAnchor(this.textAlign),
            "dominant-baseline": getDominantBaseline(this.textBaseline)
          }, true);
          textElement.appendChild(this.__document.createTextNode(text));
          this.__currentElement = textElement;
          this.__applyTransformation(textElement);
          this.__applyStyleToCurrentElement(action);
          if (this.__fontHref) {
            var a2 = this.__createElement("a");
            a2.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", this.__fontHref);
            a2.appendChild(textElement);
            textElement = a2;
          }
          parent.appendChild(textElement);
        };
        Context2.prototype.fillText = function(text, x2, y2) {
          this.__applyText(text, x2, y2, "fill");
        };
        Context2.prototype.strokeText = function(text, x2, y2) {
          this.__applyText(text, x2, y2, "stroke");
        };
        Context2.prototype.measureText = function(text) {
          this.__ctx.font = this.font;
          return this.__ctx.measureText(text);
        };
        Context2.prototype.arc = function(x2, y2, radius2, startAngle, endAngle, counterClockwise) {
          if (startAngle === endAngle) {
            return;
          }
          startAngle = startAngle % (2 * Math.PI);
          endAngle = endAngle % (2 * Math.PI);
          if (startAngle === endAngle) {
            endAngle = (endAngle + 2 * Math.PI - 1e-3 * (counterClockwise ? -1 : 1)) % (2 * Math.PI);
          }
          var endX = x2 + radius2 * Math.cos(endAngle), endY = y2 + radius2 * Math.sin(endAngle), startX = x2 + radius2 * Math.cos(startAngle), startY = y2 + radius2 * Math.sin(startAngle), sweepFlag = counterClockwise ? 0 : 1, largeArcFlag = 0, diff = endAngle - startAngle;
          if (diff < 0) {
            diff += 2 * Math.PI;
          }
          if (counterClockwise) {
            largeArcFlag = diff > Math.PI ? 0 : 1;
          } else {
            largeArcFlag = diff > Math.PI ? 1 : 0;
          }
          var scaleX = Math.hypot(this.__transformMatrix.a, this.__transformMatrix.b);
          var scaleY = Math.hypot(this.__transformMatrix.c, this.__transformMatrix.d);
          this.lineTo(startX, startY);
          this.__addPathCommand(format(
            "A {rx} {ry} {xAxisRotation} {largeArcFlag} {sweepFlag} {endX} {endY}",
            {
              rx: radius2 * scaleX,
              ry: radius2 * scaleY,
              xAxisRotation: 0,
              largeArcFlag,
              sweepFlag,
              endX: this.__matrixTransform(endX, endY).x,
              endY: this.__matrixTransform(endX, endY).y
            }
          ));
          this.__currentPosition = { x: endX, y: endY };
        };
        Context2.prototype.ellipse = function(x2, y2, radiusX, radiusY, rotation, startAngle, endAngle, counterClockwise) {
          if (startAngle === endAngle) {
            return;
          }
          var transformedCenter = this.__matrixTransform(x2, y2);
          x2 = transformedCenter.x;
          y2 = transformedCenter.y;
          var scale = this.__getTransformScale();
          radiusX = radiusX * scale.x;
          radiusY = radiusY * scale.y;
          rotation = rotation + this.__getTransformRotation();
          startAngle = startAngle % (2 * Math.PI);
          endAngle = endAngle % (2 * Math.PI);
          if (startAngle === endAngle) {
            endAngle = (endAngle + 2 * Math.PI - 1e-3 * (counterClockwise ? -1 : 1)) % (2 * Math.PI);
          }
          var endX = x2 + Math.cos(-rotation) * radiusX * Math.cos(endAngle) + Math.sin(-rotation) * radiusY * Math.sin(endAngle), endY = y2 - Math.sin(-rotation) * radiusX * Math.cos(endAngle) + Math.cos(-rotation) * radiusY * Math.sin(endAngle), startX = x2 + Math.cos(-rotation) * radiusX * Math.cos(startAngle) + Math.sin(-rotation) * radiusY * Math.sin(startAngle), startY = y2 - Math.sin(-rotation) * radiusX * Math.cos(startAngle) + Math.cos(-rotation) * radiusY * Math.sin(startAngle), sweepFlag = counterClockwise ? 0 : 1, largeArcFlag = 0, diff = endAngle - startAngle;
          if (diff < 0) {
            diff += 2 * Math.PI;
          }
          if (counterClockwise) {
            largeArcFlag = diff > Math.PI ? 0 : 1;
          } else {
            largeArcFlag = diff > Math.PI ? 1 : 0;
          }
          var currentTransform = this.__transformMatrix;
          this.resetTransform();
          this.lineTo(startX, startY);
          this.__transformMatrix = currentTransform;
          this.__addPathCommand(format(
            "A {rx} {ry} {xAxisRotation} {largeArcFlag} {sweepFlag} {endX} {endY}",
            {
              rx: radiusX,
              ry: radiusY,
              xAxisRotation: rotation * (180 / Math.PI),
              largeArcFlag,
              sweepFlag,
              endX,
              endY
            }
          ));
          this.__currentPosition = { x: endX, y: endY };
        };
        Context2.prototype.clip = function() {
          var group = this.__closestGroupOrSvg(), clipPath = this.__createElement("clipPath"), id = randomString(this.__ids), newGroup = this.__createElement("g");
          this.__applyCurrentDefaultPath();
          group.removeChild(this.__currentElement);
          clipPath.setAttribute("id", id);
          clipPath.appendChild(this.__currentElement);
          this.__defs.appendChild(clipPath);
          group.setAttribute("clip-path", format("url(#{id})", { id }));
          group.appendChild(newGroup);
          this.__currentElement = newGroup;
        };
        Context2.prototype.drawImage = function() {
          var args = Array.prototype.slice.call(arguments), image = args[0], dx, dy, dw, dh, sx = 0, sy = 0, sw, sh, parent, svg, defs, group, svgImage, canvas, context2, id;
          if (args.length === 3) {
            dx = args[1];
            dy = args[2];
            sw = image.width;
            sh = image.height;
            dw = sw;
            dh = sh;
          } else if (args.length === 5) {
            dx = args[1];
            dy = args[2];
            dw = args[3];
            dh = args[4];
            sw = image.width;
            sh = image.height;
          } else if (args.length === 9) {
            sx = args[1];
            sy = args[2];
            sw = args[3];
            sh = args[4];
            dx = args[5];
            dy = args[6];
            dw = args[7];
            dh = args[8];
          } else {
            throw new Error("Invalid number of arguments passed to drawImage: " + arguments.length);
          }
          parent = this.__closestGroupOrSvg();
          this.__currentElement;
          const matrix = this.getTransform().translate(dx, dy);
          if (image instanceof Context2) {
            svg = image.getSvg().cloneNode(true);
            if (svg.childNodes && svg.childNodes.length > 1) {
              defs = svg.childNodes[0];
              while (defs.childNodes.length) {
                id = defs.childNodes[0].getAttribute("id");
                this.__ids[id] = id;
                this.__defs.appendChild(defs.childNodes[0]);
              }
              group = svg.childNodes[1];
              if (group) {
                this.__applyTransformation(group, matrix);
                parent.appendChild(group);
              }
            }
          } else if (image.nodeName === "CANVAS" || image.nodeName === "IMG") {
            svgImage = this.__createElement("image");
            svgImage.setAttribute("width", dw);
            svgImage.setAttribute("height", dh);
            svgImage.setAttribute("preserveAspectRatio", "none");
            if (sx || sy || sw !== image.width || sh !== image.height) {
              canvas = this.__document.createElement("canvas");
              canvas.width = dw;
              canvas.height = dh;
              context2 = canvas.getContext("2d");
              context2.drawImage(image, sx, sy, sw, sh, 0, 0, dw, dh);
              image = canvas;
            }
            this.__applyTransformation(svgImage, matrix);
            svgImage.setAttributeNS(
              "http://www.w3.org/1999/xlink",
              "xlink:href",
              image.nodeName === "CANVAS" ? image.toDataURL() : image.getAttribute("src")
            );
            parent.appendChild(svgImage);
          }
        };
        Context2.prototype.createPattern = function(image, repetition) {
          var pattern = this.__document.createElementNS("http://www.w3.org/2000/svg", "pattern"), id = randomString(this.__ids), img;
          pattern.setAttribute("id", id);
          pattern.setAttribute("width", image.width);
          pattern.setAttribute("height", image.height);
          pattern.setAttribute("patternUnits", "userSpaceOnUse");
          if (image.nodeName === "CANVAS" || image.nodeName === "IMG") {
            img = this.__document.createElementNS("http://www.w3.org/2000/svg", "image");
            img.setAttribute("width", image.width);
            img.setAttribute("height", image.height);
            img.setAttributeNS(
              "http://www.w3.org/1999/xlink",
              "xlink:href",
              image.nodeName === "CANVAS" ? image.toDataURL() : image.getAttribute("src")
            );
            pattern.appendChild(img);
            this.__defs.appendChild(pattern);
          } else if (image instanceof Context2) {
            pattern.appendChild(image.__root.childNodes[1]);
            this.__defs.appendChild(pattern);
          }
          return new CanvasPattern(pattern, this);
        };
        Context2.prototype.setLineDash = function(dashArray) {
          if (dashArray && dashArray.length > 0) {
            this.lineDash = dashArray.join(",");
          } else {
            this.lineDash = null;
          }
        };
        Context2.prototype.setTransform = function(a2, b2, c2, d3, e2, f2) {
          if (a2 instanceof DOMMatrix) {
            this.__transformMatrix = new DOMMatrix([a2.a, a2.b, a2.c, a2.d, a2.e, a2.f]);
          } else {
            this.__transformMatrix = new DOMMatrix([a2, b2, c2, d3, e2, f2]);
          }
        };
        Context2.prototype.getTransform = function() {
          let { a: a2, b: b2, c: c2, d: d3, e: e2, f: f2 } = this.__transformMatrix;
          return new DOMMatrix([a2, b2, c2, d3, e2, f2]);
        };
        Context2.prototype.resetTransform = function() {
          this.setTransform(1, 0, 0, 1, 0, 0);
        };
        Context2.prototype.scale = function(x2, y2) {
          if (y2 === void 0) {
            y2 = x2;
          }
          if (isNaN(x2) || isNaN(y2) || !isFinite(x2) || !isFinite(y2)) {
            return;
          }
          let matrix = this.getTransform().scale(x2, y2);
          this.setTransform(matrix);
        };
        Context2.prototype.rotate = function(angle) {
          let matrix = this.getTransform().multiply(new DOMMatrix([
            Math.cos(angle),
            Math.sin(angle),
            -Math.sin(angle),
            Math.cos(angle),
            0,
            0
          ]));
          this.setTransform(matrix);
        };
        Context2.prototype.translate = function(x2, y2) {
          const matrix = this.getTransform().translate(x2, y2);
          this.setTransform(matrix);
        };
        Context2.prototype.transform = function(a2, b2, c2, d3, e2, f2) {
          const matrix = this.getTransform().multiply(new DOMMatrix([a2, b2, c2, d3, e2, f2]));
          this.setTransform(matrix);
        };
        Context2.prototype.__matrixTransform = function(x2, y2) {
          return new DOMPoint(x2, y2).matrixTransform(this.__transformMatrix);
        };
        Context2.prototype.__getTransformScale = function() {
          return {
            x: Math.hypot(this.__transformMatrix.a, this.__transformMatrix.b),
            y: Math.hypot(this.__transformMatrix.c, this.__transformMatrix.d)
          };
        };
        Context2.prototype.__getTransformRotation = function() {
          return Math.atan2(this.__transformMatrix.b, this.__transformMatrix.a);
        };
        Context2.prototype.getImageData = function(sx, sy, sw, sh, options) {
          return utils.getImageData(this.getSvg(), this.width, this.height, sx, sy, sw, sh, options);
        };
        Context2.prototype.drawFocusRing = function() {
        };
        Context2.prototype.createImageData = function() {
        };
        Context2.prototype.putImageData = function() {
        };
        Context2.prototype.globalCompositeOperation = function() {
        };
        return Context2;
      })();
      function SVGCanvasElement(options) {
        this.ctx = new Context(options);
        this.svg = this.ctx.__root;
        var svg = this.svg;
        var _this = this;
        var wrapper = document.createElement("div");
        wrapper.style.display = "inline-block";
        wrapper.appendChild(svg);
        this.wrapper = wrapper;
        Object.defineProperty(this, "className", {
          get: function() {
            return wrapper.getAttribute("class") || "";
          },
          set: function(val) {
            return wrapper.setAttribute("class", val);
          }
        });
        Object.defineProperty(this, "tagName", {
          get: function() {
            return "CANVAS";
          },
          set: function() {
          }
          // no-op
        });
        ["width", "height"].forEach(function(prop) {
          Object.defineProperty(_this, prop, {
            get: function() {
              return svg.getAttribute(prop) | 0;
            },
            set: function(val) {
              if (isNaN(val) || typeof val === "undefined") {
                return;
              }
              _this.ctx[prop] = val;
              svg.setAttribute(prop, val);
              return wrapper[prop] = val;
            }
          });
        });
        ["style", "id"].forEach(function(prop) {
          Object.defineProperty(_this, prop, {
            get: function() {
              return wrapper[prop];
            },
            set: function(val) {
              if (typeof val !== "undefined") {
                return wrapper[prop] = val;
              }
            }
          });
        });
        ["getBoundingClientRect"].forEach(function(fn) {
          _this[fn] = function() {
            return svg[fn]();
          };
        });
      }
      SVGCanvasElement.prototype.getContext = function(type) {
        if (type !== "2d") {
          throw new Error("Unsupported type of context for SVGCanvas");
        }
        return this.ctx;
      };
      SVGCanvasElement.prototype.toObjectURL = function() {
        var data = new XMLSerializer().serializeToString(this.svg);
        var svg = new Blob([data], { type: "image/svg+xml;charset=utf-8" });
        return URL.createObjectURL(svg);
      };
      SVGCanvasElement.prototype.toDataURL = function(type, encoderOptions, options) {
        return utils.toDataURL(this.svg, this.width, this.height, type, encoderOptions, options);
      };
      SVGCanvasElement.prototype.addEventListener = function() {
        return this.svg.addEventListener.apply(this.svg, arguments);
      };
      SVGCanvasElement.prototype.getElement = function() {
        return this.wrapper;
      };
      SVGCanvasElement.prototype.getAttribute = function(prop) {
        return this.wrapper.getAttribute(prop);
      };
      SVGCanvasElement.prototype.setAttribute = function(prop, val) {
        this.wrapper.setAttribute(prop, val);
      };
      exports.Context = Context;
      exports.Element = SVGCanvasElement;
    }
  });

  // node_modules/react-msaview/dist/renderToSvg.js
  var renderToSvg_exports = {};
  __export(renderToSvg_exports, {
    renderToSvg: () => renderToSvg
  });
  async function renderToSvg(model, opts) {
    await (0, import_mobx5.when)(() => !!model.dataInitialized);
    const { width, height, scrollX, scrollY, totalTrackAreaHeight } = model;
    const { exportType, theme, includeMinimap, includeTracks } = opts;
    const trackHeight = includeTracks ? totalTrackAreaHeight : 0;
    if (exportType === "entire") {
      return render({
        width: model.totalWidth + model.treeAreaWidth,
        height: model.totalHeight + trackHeight,
        contentHeight: model.totalHeight,
        trackHeight,
        theme,
        model,
        offsetY: 0,
        offsetX: 0,
        includeMinimap,
        includeTracks
      });
    }
    if (exportType === "viewport") {
      return render({
        width,
        height: height + (includeMinimap ? model.minimapHeight : 0) + trackHeight,
        contentHeight: height,
        trackHeight,
        theme,
        model,
        offsetY: -scrollY,
        offsetX: -scrollX,
        includeMinimap,
        includeTracks
      });
    }
    throw new Error("unknown export type");
  }
  async function render({ width, height, contentHeight, trackHeight, offsetX, offsetY, theme, model, includeMinimap, includeTracks }) {
    const { Context } = await Promise.resolve().then(() => __toESM(require_svgcanvas()));
    const Wrapper = includeMinimap ? MinimapWrapper : NullWrapper;
    return (0, import_util39.renderToStaticMarkup)(import_react77.default.createElement(
      SvgWrapper,
      { width, height },
      import_react77.default.createElement(
        Wrapper,
        { model },
        includeTracks && trackHeight > 0 ? import_react77.default.createElement(TrackRendering, { Context, model, theme, offsetX, width, trackHeight }) : null,
        import_react77.default.createElement(
          "g",
          { transform: trackHeight > 0 ? `translate(0 ${trackHeight})` : void 0 },
          import_react77.default.createElement(CoreRendering, { Context, model, theme, offsetX, offsetY, width, contentHeight })
        )
      )
    ));
  }
  function CoreRendering({ model, theme, width, contentHeight, offsetX, offsetY, Context }) {
    const { treeAreaWidth, colorScheme, id } = model;
    const clipId1 = `tree-${id}`;
    const clipId2 = `msa-${id}`;
    const contrastScheme = colorContrast(colorScheme, theme);
    const ctx1 = Context(width, contentHeight);
    const ctx2 = Context(width, contentHeight);
    renderBoxFeatureCanvasBlock({
      ctx: ctx2,
      offsetX,
      offsetY,
      model,
      blockSizeYOverride: contentHeight,
      highResScaleFactorOverride: 1
    });
    const msaAreaWidth = width - treeAreaWidth;
    renderTreeCanvas({
      model,
      offsetY,
      ctx: ctx1,
      theme,
      blockSizeYOverride: contentHeight,
      highResScaleFactorOverride: 1
    });
    renderMSABlock({
      model,
      theme,
      offsetY,
      offsetX,
      contrastScheme,
      ctx: ctx2,
      blockSizeXOverride: msaAreaWidth,
      blockSizeYOverride: contentHeight,
      highResScaleFactorOverride: 1
    });
    return import_react77.default.createElement(
      import_react77.default.Fragment,
      null,
      import_react77.default.createElement(
        "defs",
        null,
        import_react77.default.createElement(
          "clipPath",
          { id: clipId1 },
          import_react77.default.createElement("rect", { x: 0, y: 0, width: treeAreaWidth, height: contentHeight })
        )
      ),
      import_react77.default.createElement(
        "defs",
        null,
        import_react77.default.createElement(
          "clipPath",
          { id: clipId2 },
          import_react77.default.createElement("rect", { x: 0, y: 0, width: msaAreaWidth, height: contentHeight })
        )
      ),
      import_react77.default.createElement("g", { clipPath: `url(#${clipId1})`, dangerouslySetInnerHTML: { __html: ctx1.getSvg().innerHTML } }),
      import_react77.default.createElement("g", { clipPath: `url(#${clipId2})`, transform: `translate(${treeAreaWidth} 0)`, dangerouslySetInnerHTML: { __html: ctx2.getSvg().innerHTML } })
    );
  }
  function TrackRendering({ model, theme, width, trackHeight, offsetX, Context }) {
    const { treeAreaWidth, colorScheme, id } = model;
    const clipId = `tracks-${id}`;
    const contrastScheme = colorContrast(colorScheme, theme);
    const msaAreaWidth = width - treeAreaWidth;
    const ctx = Context(msaAreaWidth, trackHeight);
    renderAllTracks({
      model,
      ctx,
      offsetX,
      contrastScheme,
      blockSizeXOverride: msaAreaWidth,
      highResScaleFactorOverride: 1
    });
    return import_react77.default.createElement(
      "g",
      { transform: `translate(${treeAreaWidth} 0)` },
      import_react77.default.createElement(
        "defs",
        null,
        import_react77.default.createElement(
          "clipPath",
          { id: clipId },
          import_react77.default.createElement("rect", { x: 0, y: 0, width: msaAreaWidth, height: trackHeight })
        )
      ),
      import_react77.default.createElement("g", { clipPath: `url(#${clipId})`, dangerouslySetInnerHTML: { __html: ctx.getSvg().innerHTML } })
    );
  }
  function MinimapWrapper({ model, children }) {
    const { minimapHeight, treeAreaWidth } = model;
    return import_react77.default.createElement(
      import_react77.default.Fragment,
      null,
      import_react77.default.createElement(
        "g",
        { transform: `translate(${treeAreaWidth} 0)` },
        import_react77.default.createElement(MinimapSVG_default, { model })
      ),
      import_react77.default.createElement("g", { transform: `translate(0 ${minimapHeight})` }, children)
    );
  }
  function SvgWrapper({ width, height, children }) {
    return import_react77.default.createElement("svg", { width, height, xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", viewBox: [0, 0, width, height].toString() }, children);
  }
  function NullWrapper({ children }) {
    return children;
  }
  var import_react77, import_util39, import_mobx5;
  var init_renderToSvg = __esm({
    "node_modules/react-msaview/dist/renderToSvg.js"() {
      import_react77 = __toESM(require_react());
      import_util39 = __toESM(require_util());
      import_mobx5 = __toESM(require_mobx());
      init_MinimapSVG();
      init_renderBoxFeatureCanvasBlock();
      init_renderMSABlock();
      init_renderTracksSvg();
      init_renderTreeCanvas();
      init_util();
    }
  });

  // node_modules/react-msaview/dist/model.js
  function stateModelFactory() {
    return import_mobx_state_tree7.types.compose(DialogQueueSessionMixin(), TreeModelF(), MSAModelF(), import_mobx_state_tree7.types.model("MsaView", {
      /**
       * #property
       * id of view, randomly generated if not provided
       */
      id: import_mst.ElementId,
      /**
       * #property
       */
      showDomains: defaultShowDomains,
      /**
       * #property
       */
      hideGaps: defaultHideGaps,
      /**
       * #property
       */
      allowedGappyness: defaultAllowedGappyness,
      /**
       * #property
       */
      contrastLettering: defaultContrastLettering,
      /**
       * #property
       */
      subFeatureRows: defaultSubFeatureRows,
      /**
       * #property
       * hardcoded view type
       */
      type: import_mobx_state_tree7.types.literal("MsaView"),
      /**
       * #property
       */
      drawMsaLetters: defaultDrawMsaLetters,
      /**
       * #property
       * height of the div containing the view, px
       */
      height: import_mobx_state_tree7.types.optional(import_mobx_state_tree7.types.number, defaultHeight),
      /**
       * #property
       * height of each row, px
       */
      rowHeight: defaultRowHeight,
      /**
       * #property
       * scroll position, Y-offset, px
       */
      scrollY: defaultScrollY,
      /**
       * #property
       * scroll position, X-offset, px
       */
      scrollX: defaultScrollX,
      /**
       * #property
       * width of columns, px
       */
      colWidth: defaultColWidth,
      /**
       * #property
       * filehandle object for the tree
       */
      treeFilehandle: import_mobx_state_tree7.types.maybe(import_mst.FileLocation),
      /**
       * #property
       * filehandle object for the MSA (which could contain a tree e.g. with
       * stockholm files)
       */
      msaFilehandle: import_mobx_state_tree7.types.maybe(import_mst.FileLocation),
      /**
       * #property
       * filehandle object for tree metadata
       */
      treeMetadataFilehandle: import_mobx_state_tree7.types.maybe(import_mst.FileLocation),
      /**
       * #property
       * filehandle object for InterProScan GFF file
       */
      gffFilehandle: import_mobx_state_tree7.types.maybe(import_mst.FileLocation),
      /**
       * #property
       *
       */
      currentAlignment: defaultCurrentAlignment,
      /**
       * #property
       * array of tree parent nodes that are 'collapsed' (all children are
       * hidden)
       */
      collapsed: import_mobx_state_tree7.types.array(import_mobx_state_tree7.types.string),
      /**
       * #property
       * array of tree leaf nodes that are 'collapsed' (just that leaf node
       * is hidden)
       */
      collapsedLeaves: import_mobx_state_tree7.types.array(import_mobx_state_tree7.types.string),
      /**
       * #property
       * focus on particular subtree
       */
      showOnly: import_mobx_state_tree7.types.maybe(import_mobx_state_tree7.types.string),
      /**
       * #property
       * turned off tracks
       */
      turnedOffTracks: import_mobx_state_tree7.types.map(import_mobx_state_tree7.types.boolean),
      /**
       * #property
       * data from the loaded tree/msa/treeMetadata, generally loaded by
       * autorun
       */
      data: import_mobx_state_tree7.types.optional(DataModelF(), {
        tree: "",
        msa: "",
        treeMetadata: ""
      }),
      /**
       * #property
       */
      featureFilters: import_mobx_state_tree7.types.map(import_mobx_state_tree7.types.boolean),
      /**
       * #property
       */
      relativeTo: import_mobx_state_tree7.types.maybe(import_mobx_state_tree7.types.string)
    })).volatile(() => ({
      /**
       * #volatile
       */
      headerHeight: 0,
      /**
       * #volatile
       */
      status: void 0,
      /**
       * #volatile
       * high resolution scale factor, helps make canvas look better on hi-dpi
       * screens
       */
      highResScaleFactor: 2,
      /**
       * #volatile
       * obtained from localStorage
       */
      showZoomStar: (0, import_util41.localStorageGetBoolean)(showZoomStarKey, false),
      /**
       * #volatile
       */
      loadingMSA: false,
      /**
       * #volatile
       */
      loadingTree: false,
      /**
       * #volatile
       */
      volatileWidth: void 0,
      /**
       * #volatile
       * resize handle width between tree and msa area, px
       */
      resizeHandleWidth: 5,
      /**
       * #volatile
       * size of blocks of content to be drawn, px
       */
      blockSize: 500,
      /**
       * #volatile
       * the currently mouse-hovered row
       */
      mouseRow: void 0,
      /**
       * #volatile
       * the currently mouse-hovered column
       */
      mouseCol: void 0,
      /**
       * #volatile
       * the currently mouse-click row
       */
      mouseClickRow: void 0,
      /**
       * #volatile
       * the currently mouse-click column
       */
      mouseClickCol: void 0,
      /**
       * #volatile
       * the currently hovered tree node ID and its descendant leaf names
       */
      hoveredTreeNode: void 0,
      /**
       * #volatile
       * array of column indices to highlight
       */
      highlightedColumns: void 0,
      /**
       * #volatile
       * a dummy variable that is incremented when ref changes so autorun for
       * drawing canvas commands will run
       */
      nref: 0,
      /**
       * #volatile
       */
      minimapHeight: 56,
      /**
       * #volatile
       */
      marginLeft: 20,
      /**
       * #volatile
       */
      error: void 0,
      /**
       * #volatile
       */
      annotPos: void 0,
      /**
       * #volatile
       */
      interProAnnotations: void 0
    })).actions((self2) => ({
      /**
       * #action
       */
      drawRelativeTo(id) {
        self2.relativeTo = id;
      },
      /**
       * #action
       */
      setHideGaps(arg) {
        self2.hideGaps = arg;
      },
      /**
       * #action
       */
      setAllowedGappyness(arg) {
        self2.allowedGappyness = arg;
      },
      /**
       * #action
       */
      setContrastLettering(arg) {
        self2.contrastLettering = arg;
      },
      /**
       * #action
       */
      setLoadingMSA(arg) {
        self2.loadingMSA = arg;
      },
      /**
       * #action
       */
      setShowZoomStar(arg) {
        self2.showZoomStar = arg;
      },
      /**
       * #action
       */
      setLoadingTree(arg) {
        self2.loadingTree = arg;
      },
      /**
       * #action
       */
      setWidth(arg) {
        self2.volatileWidth = arg;
      },
      /**
       * #action
       * set the height of the view in px
       */
      setHeight(height) {
        self2.height = height;
      },
      /**
       * #action
       * set error state
       */
      setError(error2) {
        self2.error = error2;
      },
      /**
       * #action
       * set mouse position (row, column) in the MSA
       */
      setMousePos(col, row) {
        self2.mouseCol = col;
        self2.mouseRow = row;
      },
      /**
       * #action
       * set hovered tree node and its descendants
       */
      setHoveredTreeNode(nodeId) {
        if (!nodeId) {
          self2.hoveredTreeNode = void 0;
          return;
        }
        const node2 = self2.hierarchy.find((n2) => n2.data.id === nodeId);
        if (!node2) {
          self2.hoveredTreeNode = void 0;
          return;
        }
        const descendantNames = node2.leaves().map((leaf) => leaf.data.name);
        self2.hoveredTreeNode = { nodeId, descendantNames };
      },
      /**
       * #action
       * set highlighted columns
       */
      setHighlightedColumns(columns) {
        self2.highlightedColumns = columns;
      },
      /**
       * #action
       */
      setShowDomains(arg) {
        self2.showDomains = arg;
      },
      /**
       * #action
       */
      setSubFeatureRows(arg) {
        self2.subFeatureRows = arg;
      },
      /**
       * #action
       * set mouse click position (row, column) in the MSA
       */
      setMouseClickPos(col, row) {
        self2.mouseClickCol = col;
        self2.mouseClickRow = row;
      },
      /**
       * #action
       * set row height (px)
       */
      setRowHeight(n2) {
        self2.rowHeight = n2;
      },
      /**
       * #action
       * set col width (px)
       */
      setColWidth(n2) {
        self2.colWidth = n2;
      },
      /**
       * #action
       * set scroll Y-offset (px)
       */
      setScrollY(n2) {
        self2.scrollY = n2;
      },
      /**
       * #action
       *
       */
      setCurrentAlignment(n2) {
        self2.currentAlignment = n2;
      },
      /**
       * #action
       */
      toggleCollapsed(node2) {
        if (self2.collapsed.includes(node2)) {
          self2.collapsed.remove(node2);
        } else {
          self2.collapsed.push(node2);
        }
      },
      /**
       * #action
       */
      toggleCollapsedLeaf(node2) {
        if (self2.collapsedLeaves.includes(node2)) {
          self2.collapsedLeaves.remove(node2);
        } else {
          self2.collapsedLeaves.push(node2);
        }
      },
      /**
       * #action
       */
      setShowOnly(node2) {
        self2.showOnly = node2;
      },
      /**
       * #action
       */
      setData(data) {
        self2.data = (0, import_mobx_state_tree7.cast)(data);
      },
      /**
       * #action
       */
      setMSAFilehandle(msaFilehandle) {
        self2.msaFilehandle = msaFilehandle;
      },
      /**
       * #action
       */
      setTreeFilehandle(treeFilehandle) {
        self2.treeFilehandle = treeFilehandle;
      },
      /**
       * #action
       */
      setGFFFilehandle(gffFilehandle) {
        self2.gffFilehandle = gffFilehandle;
      },
      /**
       * #action
       */
      setMSA(result) {
        self2.data.setMSA(result);
      },
      /**
       * #action
       */
      setTree(result) {
        self2.data.setTree(result);
      },
      /**
       * #action
       */
      setTreeMetadata(result) {
        self2.data.setTreeMetadata(result);
      }
    })).views((self2) => ({
      /**
       * #getter
       * hideGaps takes effect when there are collapsed rows or allowedGappyness < 100
       */
      get hideGapsEffective() {
        return self2.hideGaps && (self2.collapsed.length > 0 || self2.collapsedLeaves.length > 0 || self2.allowedGappyness < 100);
      },
      /**
       * #getter
       */
      get realAllowedGappyness() {
        return this.hideGapsEffective ? self2.allowedGappyness : 100;
      },
      /**
       * #getter
       */
      get actuallyShowDomains() {
        return self2.showDomains && !!self2.interProAnnotations;
      },
      /**
       * #getter
       */
      get viewInitialized() {
        return self2.volatileWidth !== void 0;
      },
      /**
       * #getter
       */
      get width() {
        if (self2.volatileWidth === void 0) {
          throw new Error("not initialized");
        }
        return self2.volatileWidth;
      }
    })).views((self2) => ({
      /**
       * #method
       * unused here, but can be used by derived classes to add extra items
       */
      extraViewMenuItems() {
        return [];
      },
      /**
       * #getter
       */
      get colorScheme() {
        return colorSchemes_default[self2.colorSchemeName];
      },
      /**
       * #getter
       */
      get header() {
        return this.MSA?.getHeader() || {};
      },
      /**
       * #getter
       */
      get alignmentNames() {
        return this.MSA?.alignmentNames || [];
      },
      /**
       * #getter
       */
      get noTree() {
        return !!this.tree.noTree;
      },
      /**
       * #getter
       */
      get noDomains() {
        return !self2.interProAnnotations;
      },
      /**
       * #getter
       */
      menuItems() {
        return [];
      },
      /**
       * #getter
       */
      get treeMetadata() {
        return self2.data.treeMetadata ? JSON.parse(self2.data.treeMetadata) : {};
      },
      /**
       * #getter
       */
      get MSA() {
        const text = self2.data.msa;
        if (text) {
          if (sniff(text)) {
            return new StockholmMSA(text, self2.currentAlignment);
          } else if (A3mMSA.sniff(text)) {
            return new A3mMSA(text);
          } else if (text.startsWith(">")) {
            return new FastaMSA(text);
          } else if (text.startsWith("SEQ")) {
            return new EmfMSA(text);
          } else {
            return new ClustalMSA(text);
          }
        }
        return null;
      },
      /**
       * #getter
       */
      get numColumns() {
        return (this.MSA?.getWidth() || 0) - this.blanks.length;
      },
      /**
       * #getter
       */
      get tree() {
        const text = self2.data.tree;
        return reparseTree(text ? generateNodeIds(text.startsWith("BioTreeContainer") ? flatToTree(parseAsn1(text)) : parse3(text.startsWith("SEQ") ? parseEmfTree(text).tree : text)) : this.MSA?.getTree() || {
          noTree: true,
          children: [],
          id: "empty",
          name: "empty"
        });
      },
      /**
       * #getter
       */
      get rowNames() {
        return this.leaves.map((n2) => n2.data.name);
      },
      /**
       * #getter
       */
      get mouseOverRowName() {
        const { mouseRow } = self2;
        return mouseRow === void 0 ? void 0 : this.rowNames[mouseRow];
      },
      /**
       * #getter
       * Returns insertion info if mouse is hovering over an insertion indicator
       */
      get hoveredInsertion() {
        const { mouseCol, mouseRow } = self2;
        if (mouseCol === void 0 || mouseRow === void 0) {
          return void 0;
        }
        const rowName = this.rowNames[mouseRow];
        if (!rowName) {
          return void 0;
        }
        const insertions = this.insertionPositions.get(rowName);
        if (!insertions) {
          return void 0;
        }
        const insertion = insertions.find((ins) => ins.pos === mouseCol);
        if (insertion) {
          return {
            rowName,
            col: mouseCol,
            letters: insertion.letters
          };
        }
        return void 0;
      },
      /**
       * #getter
       */
      get root() {
        let hier = hierarchy(this.tree, (d3) => d3.children).sum((d3) => d3.children ? 0 : 1).sort((a2, b2) => ascending(a2.data.length || 1, b2.data.length || 1));
        if (self2.showOnly) {
          const res = hier.find((n2) => n2.data.id === self2.showOnly);
          if (res) {
            hier = res;
          }
        }
        ;
        [...self2.collapsed, ...self2.collapsedLeaves].map((collapsedId) => hier.find((node2) => node2.data.id === collapsedId)).filter(import_util41.notEmpty).forEach((node2) => {
          collapse(node2);
        });
        return hier;
      },
      /**
       * #getter
       * widget width minus the tree area gives the space for the MSA
       */
      get msaAreaWidth() {
        return self2.width - self2.treeAreaWidth;
      },
      /**
       * #getter
       */
      get treeAreaWidthMinusMargin() {
        return self2.treeAreaWidth - self2.marginLeft;
      },
      /**
       * #getter
       */
      get blanks() {
        const { hideGapsEffective, realAllowedGappyness } = self2;
        if (!hideGapsEffective) {
          return [];
        }
        const strs = this.leaves.map((leaf) => this.MSA?.getRow(leaf.data.name)).filter(import_util41.notEmpty);
        if (strs.length === 0) {
          return [];
        }
        const numCols = strs[0].length;
        const numRows = strs.length;
        const threshold = Math.ceil(realAllowedGappyness / 100 * numRows);
        const blankCounts = new Uint16Array(numCols);
        for (let j2 = 0; j2 < numRows; j2++) {
          const str = strs[j2];
          for (let i2 = 0; i2 < numCols; i2++) {
            if (str.charCodeAt(i2) - 45 >>> 0 <= 1) {
              blankCounts[i2]++;
            }
          }
        }
        const blanks = [];
        for (let i2 = 0; i2 < numCols; i2++) {
          if (blankCounts[i2] >= threshold) {
            blanks.push(i2);
          }
        }
        return blanks;
      },
      /**
       * #getter
       */
      get blanksSet() {
        return new Set(this.blanks);
      },
      /**
       * #getter
       * Returns a map of row name to array of insertions with display position and letters
       */
      get insertionPositions() {
        const { hideGapsEffective } = self2;
        const { blanks, rows } = this;
        const blanksLen = blanks.length;
        if (blanksLen === 0 || !hideGapsEffective) {
          return /* @__PURE__ */ new Map();
        }
        const result = /* @__PURE__ */ new Map();
        for (const [name, seq] of rows) {
          const insertions = [];
          let displayPos = 0;
          let blankIdx = 0;
          let currentInsertPos = -1;
          let letterChars = [];
          const seqLen = seq.length;
          for (let i2 = 0; i2 < seqLen; i2++) {
            if (blankIdx < blanksLen && blanks[blankIdx] === i2) {
              const code = seq.charCodeAt(i2);
              if (!(code - 45 >>> 0 <= 1)) {
                if (currentInsertPos === displayPos) {
                  letterChars.push(seq[i2]);
                } else {
                  if (letterChars.length > 0) {
                    insertions.push({
                      pos: currentInsertPos,
                      letters: letterChars.join("")
                    });
                  }
                  currentInsertPos = displayPos;
                  letterChars = [seq[i2]];
                }
              }
              blankIdx++;
            } else {
              displayPos++;
            }
          }
          if (letterChars.length > 0) {
            insertions.push({
              pos: currentInsertPos,
              letters: letterChars.join("")
            });
          }
          if (insertions.length > 0) {
            result.set(name, insertions);
          }
        }
        return result;
      },
      /**
       * #getter
       */
      get rows() {
        const MSA = this.MSA;
        return this.leaves.map((leaf) => [leaf.data.name, MSA?.getRow(leaf.data.name)]).filter((f2) => !!f2[1]);
      },
      /**
       * #getter
       */
      get numRows() {
        return this.rows.length;
      },
      /**
       * #getter
       */
      get rowMap() {
        return new Map(this.rows);
      },
      /**
       * #getter
       */
      get columns() {
        return Object.fromEntries(this.rows.map((row, index3) => [row[0], this.columns2d[index3]]));
      },
      /**
       * #getter
       */
      get columns2d() {
        const { hideGapsEffective } = self2;
        return this.rows.map((r2) => r2[1]).map((str) => hideGapsEffective ? skipBlanks(this.blanks, str) : str);
      },
      /**
       * #getter
       */
      get fontSize() {
        return Math.min(Math.max(6, self2.rowHeight - 3), 18);
      },
      /**
       * #getter
       */
      get colStats() {
        const r2 = [];
        const columns = this.columns2d;
        for (const column2 of columns) {
          for (let j2 = 0; j2 < column2.length; j2++) {
            const l2 = r2[j2] || {};
            const cj = column2[j2];
            if (!l2[cj]) {
              l2[cj] = 0;
            }
            l2[cj]++;
            r2[j2] = l2;
          }
        }
        return r2;
      },
      /**
       * #getter
       */
      get colStatsSums() {
        return this.colStats.map((val) => (0, import_util41.sum)(Object.values(val)));
      },
      /**
       * #getter
       * Pre-computed consensus letter and percent identity color per column.
       * Used by percent_identity_dynamic color scheme.
       */
      get colConsensus() {
        const { colStats, colStatsSums } = this;
        return colStats.map((stats, i2) => {
          const total = colStatsSums[i2];
          let maxCount = 0;
          let letter = "";
          for (const key in stats) {
            const val = stats[key];
            if (val > maxCount && key !== "-" && key !== ".") {
              maxCount = val;
              letter = key;
            }
          }
          const proportion = maxCount / total;
          return {
            letter,
            color: proportion > 0.4 ? `hsl(240, 30%, ${100 * Math.max(1 - proportion / 3, 0.3)}%)` : void 0
          };
        });
      },
      /**
       * #getter
       * Pre-computed ClustalX colors per column.
       * Returns a map of letter -> color for each column.
       * ref http://www.jalview.org/help/html/colourSchemes/clustal.html
       */
      get colClustalX() {
        const { colStats, colStatsSums } = this;
        return colStats.map((stats, i2) => {
          const total = colStatsSums[i2];
          const colors = {};
          const W = stats.W ?? 0;
          const L = stats.L ?? 0;
          const V = stats.V ?? 0;
          const I = stats.I ?? 0;
          const M2 = stats.M ?? 0;
          const A = stats.A ?? 0;
          const F = stats.F ?? 0;
          const C = stats.C ?? 0;
          const H2 = stats.H ?? 0;
          const P = stats.P ?? 0;
          const R = stats.R ?? 0;
          const K = stats.K ?? 0;
          const Q = stats.Q ?? 0;
          const E = stats.E ?? 0;
          const D = stats.D ?? 0;
          const T = stats.T ?? 0;
          const S2 = stats.S ?? 0;
          const G = stats.G ?? 0;
          const Y = stats.Y ?? 0;
          const N2 = stats.N ?? 0;
          const WLVIMAFCHPY = W + L + V + I + M2 + A + F + C + H2 + P + Y;
          const KR = K + R;
          const QE = Q + E;
          const ED = E + D;
          const TS = T + S2;
          if (WLVIMAFCHPY / total > 0.6) {
            colors.W = "rgb(128,179,230)";
            colors.L = "rgb(128,179,230)";
            colors.V = "rgb(128,179,230)";
            colors.A = "rgb(128,179,230)";
            colors.I = "rgb(128,179,230)";
            colors.M = "rgb(128,179,230)";
            colors.F = "rgb(128,179,230)";
            colors.C = "rgb(128,179,230)";
          }
          if (KR / total > 0.6 || K / total > 0.8 || R / total > 0.8 || Q / total > 0.8) {
            colors.K = "#d88";
            colors.R = "#d88";
          }
          if (KR / total > 0.6 || QE / total > 0.5 || E / total > 0.8 || Q / total > 0.8 || D / total > 0.8) {
            colors.E = "rgb(192, 72, 192)";
          }
          if (KR / total > 0.6 || ED / total > 0.5 || K / total > 0.8 || R / total > 0.8 || Q / total > 0.8) {
            colors.D = "rgb(204, 77, 204)";
          }
          if (N2 / total > 0.5 || Y / total > 0.85) {
            colors.N = "#8f8";
          }
          if (KR / total > 0.6 || QE / total > 0.6 || Q / total > 0.85 || E / total > 0.85 || K / total > 0.85 || R / total > 0.85) {
            colors.Q = "#8f8";
          }
          if (WLVIMAFCHPY / total > 0.6 || TS / total > 0.5 || S2 / total > 0.85 || T / total > 0.85) {
            colors.S = "rgb(26,204,26)";
            colors.T = "rgb(26,204,26)";
          }
          if (C / total > 0.85) {
            colors.C = "rgb(240, 128, 128)";
          }
          if (G / total > 0) {
            colors.G = "rgb(240, 144, 72)";
          }
          if (P / total > 0) {
            colors.P = "rgb(204, 204, 0)";
          }
          if (WLVIMAFCHPY / total > 0.6 || W / total > 0.85 || Y / total > 0.85 || A / total > 0.85 || C / total > 0.85 || P / total > 0.85 || Q / total > 0.85 || F / total > 0.85 || H2 / total > 0.85 || I / total > 0.85 || L / total > 0.85 || M2 / total > 0.85 || V / total > 0.85) {
            colors.H = "rgb(26, 179, 179)";
            colors.Y = "rgb(26, 179, 179)";
          }
          return colors;
        });
      },
      /**
       * #getter
       * Conservation score per column using Shannon entropy (biojs-msa style).
       * Conservation = (1 - H/Hmax) * (1 - gapFraction)
       * Returns values 0-1 where 1 = fully conserved, 0 = no conservation.
       */
      get conservation() {
        const { colStats, colStatsSums } = this;
        const alphabetSize = 20;
        const maxEntropy = Math.log2(alphabetSize);
        return colStats.map((stats, i2) => {
          const total = colStatsSums[i2];
          if (!total) {
            return 0;
          }
          const gapCount = (stats["-"] || 0) + (stats["."] || 0);
          const nonGapTotal = total - gapCount;
          if (nonGapTotal === 0) {
            return 0;
          }
          let entropy = 0;
          for (const letter of Object.keys(stats)) {
            if (letter === "-" || letter === ".") {
              continue;
            }
            const count3 = stats[letter];
            const freq = count3 / nonGapTotal;
            if (freq > 0) {
              entropy -= freq * Math.log2(freq);
            }
          }
          const gapFraction = gapCount / total;
          const conservation = Math.max(0, 1 - entropy / maxEntropy);
          return conservation * (1 - gapFraction);
        });
      },
      /**
       * #getter
       * generates a new tree that is clustered with x,y positions
       */
      get hierarchy() {
        const r2 = this.root;
        const clust = cluster_default().size([this.totalHeight, self2.treeWidth]).separation(() => 1);
        clust(r2);
        setBrLength(r2, r2.data.length = 0, self2.treeWidth / maxLength(r2));
        return r2;
      },
      /**
       * #getter
       */
      get totalHeight() {
        return this.root.leaves().length * self2.rowHeight;
      },
      /**
       * #getter
       */
      get leaves() {
        return this.hierarchy.leaves();
      },
      /**
       * #getter
       */
      get allBranchesLength0() {
        return this.hierarchy.links().every((s2) => !s2.source.data.length);
      },
      /**
       * #getter
       * effective showBranchLen accounting for allBranchesLength0
       */
      get showBranchLenEffective() {
        return this.allBranchesLength0 ? false : self2.showBranchLen;
      }
    })).views((self2) => ({
      /**
       * #getter
       */
      get totalWidth() {
        return self2.numColumns * self2.colWidth;
      }
    })).views((self2) => ({
      /**
       * #getter
       */
      get dataInitialized() {
        return (self2.data.msa || self2.data.tree) && !self2.error;
      },
      /**
       * #getter
       */
      get blocksX() {
        return blocksX({
          viewportWidth: self2.msaAreaWidth,
          viewportX: -self2.scrollX,
          blockSize: self2.blockSize,
          mapWidth: self2.totalWidth
        });
      },
      /**
       * #getter
       */
      get blocksY() {
        return blocksY({
          viewportHeight: self2.height,
          viewportY: -self2.scrollY,
          blockSize: self2.blockSize,
          mapHeight: self2.totalHeight
        });
      }
    })).views((self2) => ({
      /**
       * #getter
       */
      get blocks2d() {
        const ret = [];
        for (const by of self2.blocksY) {
          for (const bx of self2.blocksX) {
            ret.push([bx, by]);
          }
        }
        return ret;
      },
      /**
       * #getter
       */
      get isLoading() {
        return self2.loadingMSA || self2.loadingTree;
      },
      /**
       * #getter
       */
      get maxScrollX() {
        return Math.min(-self2.totalWidth + (self2.msaAreaWidth - 100), 0);
      },
      /**
       * #getter
       */
      get showMsaLetters() {
        return self2.drawMsaLetters && self2.rowHeight >= 5 && self2.colWidth > self2.rowHeight / 2;
      },
      /**
       * #getter
       */
      get showTreeText() {
        return self2.drawLabels && self2.rowHeight >= 5;
      }
    })).actions((self2) => ({
      /**
       * #action
       */
      setDrawMsaLetters(arg) {
        self2.drawMsaLetters = arg;
      },
      /**
       * #action
       * Calculate a neighbor joining tree from the current MSA using BLOSUM62 distances
       */
      calculateNeighborJoiningTreeFromMSA() {
        if (self2.rows.length < 2) {
          throw new Error("Need at least 2 sequences to build a tree");
        }
        const newickTree = calculateNeighborJoiningTree(self2.rows);
        self2.setTree(newickTree);
      },
      /**
       * #action
       */
      resetZoom() {
        self2.setColWidth(defaultColWidth);
        self2.setRowHeight(defaultRowHeight);
      },
      /**
       * #action
       */
      zoomOutHorizontal() {
        self2.colWidth = Math.max(1, Math.floor(self2.colWidth * 0.75));
        self2.scrollX = (0, import_util41.clamp)(self2.scrollX, self2.maxScrollX, 0);
      },
      /**
       * #action
       */
      zoomInHorizontal() {
        self2.colWidth = Math.ceil(self2.colWidth * 1.5);
        self2.scrollX = (0, import_util41.clamp)(self2.scrollX, self2.maxScrollX, 0);
      },
      /**
       * #action
       */
      zoomInVertical() {
        self2.rowHeight = Math.ceil(self2.rowHeight * 1.5);
      },
      /**
       * #action
       */
      zoomOutVertical() {
        self2.rowHeight = Math.max(1.5, Math.floor(self2.rowHeight * 0.75));
      },
      /**
       * #action
       */
      zoomIn() {
        (0, import_mobx6.transaction)(() => {
          self2.colWidth = Math.ceil(self2.colWidth * 1.5);
          self2.rowHeight = Math.ceil(self2.rowHeight * 1.5);
          self2.scrollX = (0, import_util41.clamp)(self2.scrollX, self2.maxScrollX, 0);
        });
      },
      /**
       * #action
       */
      zoomOut() {
        (0, import_mobx6.transaction)(() => {
          self2.colWidth = Math.max(1, Math.floor(self2.colWidth * 0.75));
          self2.rowHeight = Math.max(1.5, Math.floor(self2.rowHeight * 0.75));
          self2.scrollX = (0, import_util41.clamp)(self2.scrollX, self2.maxScrollX, 0);
        });
      },
      /**
       * #action
       */
      setInterProAnnotations(data) {
        self2.interProAnnotations = data;
      },
      /**
       * #action
       */
      doScrollY(deltaY) {
        self2.scrollY = (0, import_util41.clamp)(self2.scrollY + deltaY, -self2.totalHeight + 10, 0);
      },
      /**
       * #action
       */
      doScrollX(deltaX) {
        this.setScrollX(self2.scrollX + deltaX);
      },
      /**
       * #action
       */
      setScrollX(n2) {
        self2.scrollX = (0, import_util41.clamp)(n2, self2.maxScrollX, 0);
      },
      /**
       * #action
       */
      toggleTrack(id) {
        if (self2.turnedOffTracks.has(id)) {
          self2.turnedOffTracks.delete(id);
        } else {
          self2.turnedOffTracks.set(id, true);
        }
      },
      /**
       * #action
       */
      setStatus(status) {
        self2.status = status;
      }
    })).views((self2) => ({
      /**
       * #getter
       */
      get labelsWidth() {
        let x2 = 0;
        const { rowHeight, leaves, treeMetadata, fontSize } = self2;
        if (rowHeight > 5) {
          for (const node2 of leaves) {
            x2 = Math.max(measureTextCanvas(treeMetadata[node2.data.name]?.genome || node2.data.name, fontSize), x2);
          }
        }
        return x2;
      },
      /**
       * #getter
       */
      get secondaryStructureConsensus() {
        return self2.MSA?.secondaryStructureConsensus;
      },
      /**
       * #getter
       */
      get seqConsensus() {
        return self2.MSA?.seqConsensus;
      },
      /**
       * #getter
       */
      get adapterTrackModels() {
        const { rowHeight, MSA, hideGapsEffective, blanks } = self2;
        return MSA?.tracks.filter((t2) => t2.data).map((t2) => ({
          model: {
            ...t2,
            data: hideGapsEffective ? skipBlanks(blanks, t2.data) : t2.data,
            height: rowHeight
          },
          ReactComponent: TextTrack_default
        })) || [];
      },
      /**
       * #getter
       */
      get tracks() {
        const conservationTrack = {
          model: {
            id: "conservation",
            name: "Conservation",
            height: 40
          },
          ReactComponent: ConservationTrack_default
        };
        return [...this.adapterTrackModels, conservationTrack];
      },
      /**
       * #getter
       */
      get turnedOnTracks() {
        return this.tracks.filter((f2) => !self2.turnedOffTracks.has(f2.model.id));
      },
      /**
       * #getter
       */
      get showHorizontalScrollbar() {
        return self2.msaAreaWidth < self2.totalWidth;
      },
      /**
       * #getter
       */
      get rowNamesSet() {
        return new Map(self2.rowNames.map((r2, idx) => [r2, idx]));
      },
      /**
       * #method
       * Return a row-specific letter at a visible column, or undefined if gap.
       *
       * @param rowName - The name of the row
       * @param visibleCol - The visible column index (what the user sees on screen)
       * @returns The letter at that position, or undefined if it's a gap
       */
      visibleColToRowLetter(rowName, visibleCol) {
        const { rowMap, blanks } = self2;
        return rowMap.get(rowName)?.[visibleColToGlobalCol(blanks, visibleCol)];
      },
      /**
       * #method
       * Convert a visible column to a row-specific sequence position (0-based).
       * Returns undefined if the position is a gap in the sequence.
       *
       * @param rowName - The name of the row
       * @param visibleCol - The visible column index
       * @returns The sequence position (0-based), or undefined if it's a gap
       */
      visibleColToSeqPos(rowName, visibleCol) {
        return visibleColToSeqPosForRow({
          rowName,
          visibleCol,
          rowMap: self2.rowMap,
          blanks: self2.blanks
        });
      },
      /**
       * #method
       * Convert a visible column to a row-specific sequence position (1-based).
       * Returns undefined if the position is a gap in the sequence.
       *
       * @param rowName - The name of the row
       * @param visibleCol - The visible column index
       * @returns The sequence position (1-based), or undefined if it's a gap
       */
      visibleColToSeqPosOneBased(rowName, visibleCol) {
        const val = this.visibleColToSeqPos(rowName, visibleCol);
        return val !== void 0 ? val + 1 : void 0;
      },
      /**
       * #method
       * Convert a global column index to a visible column index.
       * Returns undefined if the column is hidden (in blanks).
       * This is the inverse of visibleColToGlobalCol.
       *
       * @param globalCol - The global column index in the full MSA
       * @returns The visible column index, or undefined if the column is hidden
       */
      globalColToVisibleCol(globalCol) {
        const { blanks, hideGapsEffective } = self2;
        if (!hideGapsEffective) {
          return globalCol;
        }
        return globalColToVisibleCol(blanks, globalCol);
      },
      /**
       * #method
       * Convert a sequence position (ungapped) to a global column index.
       *
       * @param rowName - The name of the row
       * @param seqPos - The sequence position (0-based, ungapped)
       * @returns The global column index in the full MSA
       */
      seqPosToGlobalCol(rowName, seqPos) {
        const { rowNames, rows } = self2;
        const index3 = rowNames.indexOf(rowName);
        return index3 !== -1 && rows[index3] ? seqPosToGlobalCol({
          row: rows[index3][1],
          seqPos
        }) : 0;
      },
      /**
       * #method
       * Convert a sequence position (ungapped) directly to a visible column index.
       * This combines seqPosToGlobalCol and globalColToVisibleCol.
       *
       * @param rowName - The name of the row
       * @param seqPos - The sequence position (0-based, ungapped)
       * @returns The visible column index, or undefined if the column is hidden
       */
      seqPosToVisibleCol(rowName, seqPos) {
        const globalCol = this.seqPosToGlobalCol(rowName, seqPos);
        return this.globalColToVisibleCol(globalCol);
      }
    })).views((self2) => ({
      /**
       * #getter
       * widget width minus the tree area gives the space for the MSA
       */
      get msaAreaHeight() {
        return self2.height - (self2.showHorizontalScrollbar ? self2.minimapHeight : 0) - self2.headerHeight;
      },
      /**
       * #getter
       * total height of track area (px)
       */
      get totalTrackAreaHeight() {
        return (0, import_util41.sum)(self2.turnedOnTracks.map((r2) => r2.model.height));
      },
      /**
       * #getter
       */
      get tidyInterProAnnotationTypes() {
        const types8 = /* @__PURE__ */ new Map();
        for (const annot of this.tidyInterProAnnotations) {
          types8.set(annot.accession, annot);
        }
        return types8;
      },
      /**
       * #getter
       */
      get tidyInterProAnnotations() {
        const ret = [];
        const { interProAnnotations } = self2;
        if (interProAnnotations) {
          for (const [id, val] of Object.entries(interProAnnotations)) {
            for (const { signature, locations } of val.matches) {
              const { entry } = signature;
              if (entry) {
                const { name, accession, description } = entry;
                for (const { start, end } of locations) {
                  ret.push({
                    id,
                    name,
                    accession,
                    description,
                    start,
                    end
                  });
                }
              }
            }
          }
        }
        return ret.toSorted((a2, b2) => len(b2) - len(a2));
      },
      /**
       * #getter
       */
      get tidyFilteredInterProAnnotations() {
        return this.tidyInterProAnnotations.filter((r2) => self2.featureFilters.get(r2.accession));
      },
      /**
       * #getter
       */
      get tidyFilteredGatheredInterProAnnotations() {
        return (0, import_util41.groupBy)(this.tidyFilteredInterProAnnotations, (r2) => r2.id);
      }
    })).views((self2) => ({
      /**
       * #getter
       */
      get showVerticalScrollbar() {
        return self2.msaAreaHeight < self2.totalHeight;
      }
    })).views((self2) => ({
      /**
       * #getter
       */
      get verticalScrollbarWidth() {
        return self2.showVerticalScrollbar ? 20 : 0;
      },
      /**
       * #getter
       */
      get fillPalette() {
        const arr = [...self2.tidyInterProAnnotationTypes.keys()];
        let i2 = 0;
        const map = {};
        for (const key of arr) {
          const k2 = Math.min(arr.length - 1, ggplotPalettes_default.length - 1);
          map[key] = ggplotPalettes_default[k2][i2];
          i2++;
        }
        return map;
      },
      /**
       * #getter
       */
      get strokePalette() {
        return Object.fromEntries(Object.entries(this.fillPalette).map(([key, val]) => [
          key,
          w(val).darken(0.1).toHex()
        ]));
      },
      /**
       * #method
       */
      getRowData(name) {
        return {
          data: self2.MSA?.getRowData(name),
          treeMetadata: self2.treeMetadata[name]
        };
      }
    })).actions((self2) => ({
      /**
       * #action
       */
      setHeaderHeight(arg) {
        self2.headerHeight = arg;
      },
      /**
       * #action
       */
      reset() {
        self2.setData({
          tree: "",
          msa: ""
        });
        self2.resetZoom();
        self2.setError(void 0);
        self2.setScrollY(0);
        self2.setScrollX(0);
        self2.setCurrentAlignment(0);
        self2.setTreeFilehandle(void 0);
        self2.setMSAFilehandle(void 0);
      },
      /**
       * #action
       */
      async exportSVG(opts) {
        const { renderToSvg: renderToSvg2 } = await Promise.resolve().then(() => (init_renderToSvg(), renderToSvg_exports));
        const html = await renderToSvg2(self2, opts);
        const blob = new Blob([html], { type: "image/svg+xml" });
        (0, import_file_saver.saveAs)(blob, "image.svg");
      },
      /**
       * #action
       * internal, used for drawing to canvas
       */
      incrementRef() {
        self2.nref++;
      },
      /**
       * #action
       */
      initFilter(arg) {
        const ret = self2.featureFilters.get(arg);
        if (ret === void 0) {
          self2.featureFilters.set(arg, true);
        }
      },
      /**
       * #action
       */
      setFilter(arg, flag) {
        self2.featureFilters.set(arg, flag);
      },
      /**
       * #action
       */
      fit() {
        self2.rowHeight = self2.msaAreaHeight / self2.numRows;
        self2.colWidth = self2.msaAreaWidth / self2.numColumns;
        self2.scrollX = 0;
        self2.scrollY = 0;
      },
      /**
       * #action
       */
      fitVertically() {
        self2.rowHeight = self2.msaAreaHeight / self2.numRows;
        self2.scrollY = 0;
      },
      /**
       * #action
       */
      fitHorizontally() {
        self2.colWidth = self2.msaAreaWidth / self2.numColumns;
        self2.scrollX = 0;
      },
      afterCreate() {
        (0, import_mobx_state_tree7.addDisposer)(self2, (0, import_mobx6.autorun)(() => {
          for (const key of self2.tidyInterProAnnotationTypes.keys()) {
            this.initFilter(key);
          }
        }));
        (0, import_mobx_state_tree7.addDisposer)(self2, (0, import_mobx6.autorun)(() => {
          (0, import_util41.localStorageSetBoolean)(showZoomStarKey, self2.showZoomStar);
        }));
        (0, import_mobx_state_tree7.addDisposer)(self2, (0, import_mobx6.autorun)(async () => {
          const { treeFilehandle } = self2;
          if (treeFilehandle) {
            try {
              self2.setLoadingTree(true);
              self2.setTree(await (0, import_util41.fetchAndMaybeUnzipText)((0, import_io.openLocation)(treeFilehandle)));
              if (treeFilehandle.locationType === "BlobLocation") {
                self2.setTreeFilehandle(void 0);
              }
            } catch (e2) {
              console.error(e2);
              self2.setError(e2);
            } finally {
              self2.setLoadingTree(false);
            }
          }
        }));
        (0, import_mobx_state_tree7.addDisposer)(self2, (0, import_mobx6.autorun)(async () => {
          const { treeMetadataFilehandle } = self2;
          if (treeMetadataFilehandle) {
            try {
              self2.setTreeMetadata(await (0, import_util41.fetchAndMaybeUnzipText)((0, import_io.openLocation)(treeMetadataFilehandle)));
            } catch (e2) {
              console.error(e2);
              self2.setError(e2);
            }
          }
        }));
        (0, import_mobx_state_tree7.addDisposer)(self2, (0, import_mobx6.autorun)(async () => {
          const { gffFilehandle } = self2;
          if (gffFilehandle) {
            try {
              const gffText = await (0, import_util41.fetchAndMaybeUnzipText)((0, import_io.openLocation)(gffFilehandle));
              const gffRecords = parseGFF(gffText);
              const interProResults = gffToInterProResults(gffRecords);
              self2.setInterProAnnotations(interProResults);
              self2.setShowDomains(true);
              if (gffFilehandle.locationType === "BlobLocation") {
                self2.setGFFFilehandle(void 0);
              }
            } catch (e2) {
              console.error(e2);
              self2.setError(e2);
            }
          }
        }));
        (0, import_mobx_state_tree7.addDisposer)(self2, (0, import_mobx6.autorun)(async () => {
          const { msaFilehandle } = self2;
          if (msaFilehandle) {
            try {
              self2.setLoadingMSA(true);
              self2.setError(void 0);
              const txt = await (0, import_util41.fetchAndMaybeUnzipText)((0, import_io.openLocation)(msaFilehandle));
              (0, import_mobx6.transaction)(() => {
                self2.setMSA(txt);
                if (msaFilehandle.locationType === "BlobLocation") {
                  self2.setMSAFilehandle(void 0);
                }
              });
            } catch (e2) {
              console.error(e2);
              self2.setError(e2);
            } finally {
              self2.setLoadingMSA(false);
            }
          }
        }));
        (0, import_mobx_state_tree7.addDisposer)(self2, (0, import_mobx6.autorun)(() => {
          if (self2.colorSchemeName.includes("dynamic")) {
            self2.colStats;
            self2.colStatsSums;
          }
          self2.columns;
        }));
        (0, import_mobx_state_tree7.addDisposer)(self2, (0, import_mobx6.autorun)(async () => {
          if (self2.treeWidthMatchesArea) {
            self2.setTreeWidth(Math.max(50, self2.treeAreaWidth - self2.labelsWidth - 10 - self2.marginLeft));
          }
        }));
      }
    })).postProcessSnapshot((result) => {
      const snap = result;
      const {
        data: { tree, msa, treeMetadata },
        // Main model properties
        showDomains,
        hideGaps,
        allowedGappyness,
        contrastLettering,
        subFeatureRows,
        drawMsaLetters,
        height,
        rowHeight,
        scrollY,
        scrollX,
        colWidth,
        currentAlignment,
        collapsed,
        collapsedLeaves,
        showOnly,
        turnedOffTracks,
        featureFilters,
        relativeTo,
        // MSA model properties
        bgColor,
        colorSchemeName,
        // Tree model properties
        drawLabels,
        labelsAlignRight,
        treeAreaWidth,
        treeWidth,
        treeWidthMatchesArea,
        showBranchLen,
        drawTree,
        drawNodeBubbles,
        // Always include
        ...rest
      } = snap;
      return {
        ...rest,
        data: {
          ...result.treeFilehandle ? {} : { tree },
          ...result.msaFilehandle ? {} : { msa },
          ...result.treeMetadataFilehandle ? {} : { treeMetadata }
        },
        // Main model - only include non-default values
        ...showDomains !== defaultShowDomains ? { showDomains } : {},
        ...hideGaps !== defaultHideGaps ? { hideGaps } : {},
        ...allowedGappyness !== defaultAllowedGappyness ? { allowedGappyness } : {},
        ...contrastLettering !== defaultContrastLettering ? { contrastLettering } : {},
        ...subFeatureRows !== defaultSubFeatureRows ? { subFeatureRows } : {},
        ...drawMsaLetters !== defaultDrawMsaLetters ? { drawMsaLetters } : {},
        ...height !== defaultHeight ? { height } : {},
        ...rowHeight !== defaultRowHeight ? { rowHeight } : {},
        ...scrollY !== defaultScrollY ? { scrollY } : {},
        ...scrollX !== defaultScrollX ? { scrollX } : {},
        ...colWidth !== defaultColWidth ? { colWidth } : {},
        ...currentAlignment !== defaultCurrentAlignment ? { currentAlignment } : {},
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        ...collapsed?.length ? { collapsed } : {},
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        ...collapsedLeaves?.length ? { collapsedLeaves } : {},
        ...showOnly !== void 0 ? { showOnly } : {},
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        ...turnedOffTracks && Object.keys(turnedOffTracks).length > 0 ? { turnedOffTracks } : {},
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        ...featureFilters && Object.keys(featureFilters).length > 0 ? { featureFilters } : {},
        ...relativeTo !== void 0 ? { relativeTo } : {},
        // MSA model - only include non-default values
        ...bgColor !== defaultBgColor ? { bgColor } : {},
        ...colorSchemeName !== defaultColorSchemeName ? { colorSchemeName } : {},
        // Tree model - only include non-default values
        ...drawLabels !== defaultDrawLabels ? { drawLabels } : {},
        ...labelsAlignRight !== defaultLabelsAlignRight ? { labelsAlignRight } : {},
        ...treeAreaWidth !== defaultTreeAreaWidth ? { treeAreaWidth } : {},
        ...treeWidth !== defaultTreeWidth ? { treeWidth } : {},
        ...treeWidthMatchesArea !== defaultTreeWidthMatchesArea ? { treeWidthMatchesArea } : {},
        ...showBranchLen !== defaultShowBranchLen ? { showBranchLen } : {},
        ...drawTree !== defaultDrawTree ? { drawTree } : {},
        ...drawNodeBubbles !== defaultDrawNodeBubbles ? { drawNodeBubbles } : {}
      };
    });
  }
  var import_util41, import_io, import_mst, import_file_saver, import_mobx6, import_mobx_state_tree7, showZoomStarKey, model_default;
  var init_model = __esm({
    "node_modules/react-msaview/dist/model.js"() {
      import_util41 = __toESM(require_util());
      import_io = __toESM(require_io());
      import_mst = __toESM(require_mst2());
      init_dist();
      init_colord();
      init_src();
      init_src2();
      import_file_saver = __toESM(require_FileSaver_min());
      import_mobx6 = __toESM(require_mobx());
      import_mobx_state_tree7 = __toESM(require_mobx_state_tree());
      init_calculateBlocks();
      init_colorSchemes();
      init_ConservationTrack();
      init_TextTrack();
      init_constants();
      init_flatToTree();
      init_ggplotPalettes();
      init_measureTextCanvas();
      init_DataModel();
      init_DialogQueue();
      init_msaModel();
      init_treeModel();
      init_neighborJoining();
      init_parseAsn1();
      init_reparseTree();
      init_rowCoordinateCalculations();
      init_seqPosToGlobalCol();
      init_util();
      showZoomStarKey = "msa-showZoomStar";
      model_default = stateModelFactory;
    }
  });

  // node_modules/react-msaview/dist/index.js
  var init_dist2 = __esm({
    "node_modules/react-msaview/dist/index.js"() {
      init_Loading2();
      init_model();
    }
  });

  // src/MsaViewPanel/components/ConnectStructureDialog.tsx
  var ConnectStructureDialog_exports = {};
  __export(ConnectStructureDialog_exports, {
    default: () => ConnectStructureDialog_default
  });
  var import_react78, import_ui20, import_util47, import_material41, import_mobx_react47, ConnectStructureDialog, ConnectStructureDialog_default;
  var init_ConnectStructureDialog = __esm({
    "src/MsaViewPanel/components/ConnectStructureDialog.tsx"() {
      "use strict";
      import_react78 = __toESM(require_react());
      import_ui20 = __toESM(require_ui());
      import_util47 = __toESM(require_util());
      import_material41 = __toESM(require_material());
      import_mobx_react47 = __toESM(require_mobx_react());
      ConnectStructureDialog = (0, import_mobx_react47.observer)(function ConnectStructureDialog2({
        model,
        handleClose
      }) {
        const session = (0, import_util47.getSession)(model);
        const [selectedViewId, setSelectedViewId] = (0, import_react78.useState)("");
        const [selectedStructureIdx, setSelectedStructureIdx] = (0, import_react78.useState)(0);
        const [selectedMsaRow, setSelectedMsaRow] = (0, import_react78.useState)(model.querySeqName);
        const [error2, setError] = (0, import_react78.useState)();
        const proteinViews = session.views.filter(
          (v2) => v2.type === "ProteinView"
        );
        const selectedView = proteinViews.find((v2) => v2.id === selectedViewId);
        const structures = selectedView?.structures ?? [];
        const msaRowNames = model.rows.map((r2) => r2[0]);
        const handleConnect = () => {
          if (!selectedViewId) {
            setError("Please select a protein view");
            return;
          }
          try {
            model.connectToStructure(
              selectedViewId,
              selectedStructureIdx,
              selectedMsaRow
            );
            handleClose();
          } catch (e2) {
            setError(e2 instanceof Error ? e2.message : String(e2));
          }
        };
        return /* @__PURE__ */ import_react78.default.createElement(
          import_ui20.Dialog,
          {
            maxWidth: "sm",
            title: "Connect to Protein Structure",
            open: true,
            onClose: handleClose
          },
          /* @__PURE__ */ import_react78.default.createElement(import_material41.DialogContent, null, proteinViews.length === 0 ? /* @__PURE__ */ import_react78.default.createElement(import_material41.Typography, { color: "textSecondary" }, "No protein views are currently open. Please open a protein structure view first.") : /* @__PURE__ */ import_react78.default.createElement(import_react78.default.Fragment, null, /* @__PURE__ */ import_react78.default.createElement(import_material41.FormControl, { fullWidth: true, sx: { mb: 2 } }, /* @__PURE__ */ import_react78.default.createElement(import_material41.InputLabel, null, "Protein View"), /* @__PURE__ */ import_react78.default.createElement(
            import_material41.Select,
            {
              value: selectedViewId,
              label: "Protein View",
              onChange: (e2) => {
                setSelectedViewId(e2.target.value);
                setSelectedStructureIdx(0);
              }
            },
            proteinViews.map((view) => /* @__PURE__ */ import_react78.default.createElement(import_material41.MenuItem, { key: view.id, value: view.id }, view.displayName ?? `ProteinView ${view.id}`))
          )), structures.length > 1 && /* @__PURE__ */ import_react78.default.createElement(import_material41.FormControl, { fullWidth: true, sx: { mb: 2 } }, /* @__PURE__ */ import_react78.default.createElement(import_material41.InputLabel, null, "Structure"), /* @__PURE__ */ import_react78.default.createElement(
            import_material41.Select,
            {
              value: selectedStructureIdx,
              label: "Structure",
              onChange: (e2) => {
                setSelectedStructureIdx(e2.target.value);
              }
            },
            structures.map(
              (structure, idx) => /* @__PURE__ */ import_react78.default.createElement(import_material41.MenuItem, { key: idx, value: idx }, structure.url ?? `Structure ${idx + 1}`)
            )
          )), /* @__PURE__ */ import_react78.default.createElement(import_material41.FormControl, { fullWidth: true, sx: { mb: 2 } }, /* @__PURE__ */ import_react78.default.createElement(import_material41.InputLabel, null, "MSA Row"), /* @__PURE__ */ import_react78.default.createElement(
            import_material41.Select,
            {
              value: selectedMsaRow,
              label: "MSA Row",
              onChange: (e2) => {
                setSelectedMsaRow(e2.target.value);
              }
            },
            msaRowNames.map((name) => /* @__PURE__ */ import_react78.default.createElement(import_material41.MenuItem, { key: name, value: name }, name))
          )), error2 && /* @__PURE__ */ import_react78.default.createElement(import_material41.Typography, { color: "error", sx: { mt: 1 } }, error2))),
          /* @__PURE__ */ import_react78.default.createElement(import_material41.DialogActions, null, /* @__PURE__ */ import_react78.default.createElement(import_material41.Button, { onClick: handleClose }, "Cancel"), /* @__PURE__ */ import_react78.default.createElement(
            import_material41.Button,
            {
              onClick: handleConnect,
              variant: "contained",
              disabled: proteinViews.length === 0 || !selectedViewId
            },
            "Connect"
          ))
        );
      });
      ConnectStructureDialog_default = ConnectStructureDialog;
    }
  });

  // src/MsaViewPanel/components/RIDLink.tsx
  function RIDLink({ baseUrl, rid }) {
    return /* @__PURE__ */ import_react80.default.createElement(import_material42.Typography, null, "RID ", rid, " (", /* @__PURE__ */ import_react80.default.createElement(ExternalLink, { href: `${baseUrl}?CMD=Get&RID=${rid}` }, "see status"), ")");
  }
  var import_react80, import_material42, RIDLink_default;
  var init_RIDLink = __esm({
    "src/MsaViewPanel/components/RIDLink.tsx"() {
      "use strict";
      import_react80 = __toESM(require_react());
      import_material42 = __toESM(require_material());
      init_ExternalLink();
      RIDLink_default = RIDLink;
    }
  });

  // src/MsaViewPanel/components/LoadingBLAST.tsx
  function RIDError({
    baseUrl,
    rid,
    error: error2
  }) {
    return /* @__PURE__ */ import_react81.default.createElement("div", null, rid ? /* @__PURE__ */ import_react81.default.createElement(RIDLink_default, { rid, baseUrl }) : null, /* @__PURE__ */ import_react81.default.createElement(import_ui21.ErrorMessage, { error: error2 }));
  }
  function RIDProgress({
    baseUrl,
    rid,
    progress
  }) {
    const { classes } = useStyles17();
    return /* @__PURE__ */ import_react81.default.createElement("div", { className: classes.loading }, rid ? /* @__PURE__ */ import_react81.default.createElement(RIDLink_default, { baseUrl, rid }) : null, /* @__PURE__ */ import_react81.default.createElement(import_material43.Typography, null, progress));
  }
  var import_react81, import_ui21, import_material43, import_mobx_react48, import_mui16, useStyles17, LoadingBLAST, LoadingBLAST_default;
  var init_LoadingBLAST = __esm({
    "src/MsaViewPanel/components/LoadingBLAST.tsx"() {
      "use strict";
      import_react81 = __toESM(require_react());
      import_ui21 = __toESM(require_ui());
      import_material43 = __toESM(require_material());
      import_mobx_react48 = __toESM(require_mobx_react());
      import_mui16 = __toESM(require_mui());
      init_RIDLink();
      useStyles17 = (0, import_mui16.makeStyles)()((theme) => ({
        margin: {
          padding: 20
        },
        loading: {
          background: theme.palette.background.paper
        }
      }));
      LoadingBLAST = (0, import_mobx_react48.observer)(function LoadingBLAST2({
        model,
        baseUrl
      }) {
        const { progress, rid, error: error2, processing } = model;
        const { classes } = useStyles17();
        return /* @__PURE__ */ import_react81.default.createElement("div", { className: classes.margin }, /* @__PURE__ */ import_react81.default.createElement(import_ui21.LoadingEllipses, { message: "Running NCBI BLAST", variant: "h5" }), error2 ? /* @__PURE__ */ import_react81.default.createElement(RIDError, { baseUrl, rid, error: error2 }) : rid ? /* @__PURE__ */ import_react81.default.createElement(RIDProgress, { baseUrl, rid, progress }) : null, /* @__PURE__ */ import_react81.default.createElement(import_material43.Typography, null, processing || "Initializing BLAST query"));
      });
      LoadingBLAST_default = LoadingBLAST;
    }
  });

  // src/MsaViewPanel/components/MsaViewPanel.tsx
  var MsaViewPanel_exports = {};
  __export(MsaViewPanel_exports, {
    default: () => MsaViewPanel_default
  });
  var import_react82, import_ui22, import_mobx_react49, MsaViewPanel, MsaViewPanel_default;
  var init_MsaViewPanel = __esm({
    "src/MsaViewPanel/components/MsaViewPanel.tsx"() {
      "use strict";
      import_react82 = __toESM(require_react());
      import_ui22 = __toESM(require_ui());
      import_mobx_react49 = __toESM(require_mobx_react());
      init_dist2();
      init_LoadingBLAST();
      MsaViewPanel = (0, import_mobx_react49.observer)(function MsaViewPanel2({
        model
      }) {
        const { blastParams, loadingStoredData } = model;
        return /* @__PURE__ */ import_react82.default.createElement("div", null, blastParams ? /* @__PURE__ */ import_react82.default.createElement(LoadingBLAST_default, { model, baseUrl: blastParams.baseUrl }) : loadingStoredData ? /* @__PURE__ */ import_react82.default.createElement("div", { style: { padding: 20 } }, /* @__PURE__ */ import_react82.default.createElement(import_ui22.LoadingEllipses, { message: "Loading MSA data", variant: "h6" })) : /* @__PURE__ */ import_react82.default.createElement(Loading_default, { model }));
      });
      MsaViewPanel_default = MsaViewPanel;
    }
  });

  // src/index.ts
  var index_exports = {};
  __export(index_exports, {
    default: () => MsaViewPlugin
  });
  var import_Plugin = __toESM(require_Plugin());
  var import_configuration5 = __toESM(require_configuration());
  var import_util50 = __toESM(require_util());

  // node_modules/@mui/icons-material/esm/GridOn.js
  init_createSvgIcon();
  var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
  var GridOn_default = (0, import_utils.createSvgIcon)(/* @__PURE__ */ (0, import_jsx_runtime.jsx)("path", {
    d: "M20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2M8 20H4v-4h4zm0-6H4v-4h4zm0-6H4V4h4zm6 12h-4v-4h4zm0-6h-4v-4h4zm0-6h-4V4h4zm6 12h-4v-4h4zm0-6h-4v-4h4zm0-6h-4V4h4z"
  }), "GridOn");

  // src/index.ts
  var import_mobx_state_tree9 = __toESM(require_mobx_state_tree());

  // package.json
  var version = "2.2.3";

  // src/AddHighlightModel/index.tsx
  var import_react4 = __toESM(require_react());

  // src/AddHighlightModel/HighlightComponents.tsx
  var import_react3 = __toESM(require_react());
  var import_mobx_react3 = __toESM(require_mobx_react());

  // src/AddHighlightModel/GenomeMouseoverHighlight.tsx
  var import_react = __toESM(require_react());
  var import_util = __toESM(require_util());
  var import_mobx_react = __toESM(require_mobx_react());

  // src/AddHighlightModel/util.ts
  var import_mui = __toESM(require_mui());
  var useStyles = (0, import_mui.makeStyles)()({
    highlight: {
      height: "100%",
      background: "rgba(255,255,0,0.2)",
      border: "1px solid rgba(50,50,0,0.2)",
      position: "absolute",
      zIndex: 99,
      textAlign: "center",
      pointerEvents: "none",
      overflow: "hidden"
    }
  });

  // src/AddHighlightModel/GenomeMouseoverHighlight.tsx
  var GenomeMouseoverHighlight = (0, import_mobx_react.observer)(function({
    model
  }) {
    const { hovered } = (0, import_util.getSession)(model);
    return hovered && typeof hovered === "object" && "hoverPosition" in hovered ? /* @__PURE__ */ import_react.default.createElement(GenomeMouseoverHighlightPostNullCheck, { model }) : null;
  });
  var GenomeMouseoverHighlightPostNullCheck = (0, import_mobx_react.observer)(function({
    model
  }) {
    const { classes } = useStyles();
    const session = (0, import_util.getSession)(model);
    if (session.views.some((s2) => s2.type === "MsaView")) {
      const { hovered } = session;
      const { offsetPx } = model;
      const { coord, refName } = hovered.hoverPosition;
      const s2 = model.bpToPx({ refName, coord: coord - 1 });
      const e2 = model.bpToPx({ refName, coord });
      if (s2 && e2) {
        const width = Math.max(Math.abs(e2.offsetPx - s2.offsetPx), 4);
        const left = Math.min(s2.offsetPx, e2.offsetPx) - offsetPx;
        return /* @__PURE__ */ import_react.default.createElement("div", { className: classes.highlight, style: { left, width } });
      }
    }
    return null;
  });
  var GenomeMouseoverHighlight_default = GenomeMouseoverHighlight;

  // src/AddHighlightModel/MsaToGenomeHighlight.tsx
  var import_react2 = __toESM(require_react());
  var import_util3 = __toESM(require_util());
  var import_mobx_react2 = __toESM(require_mobx_react());
  function getCanonicalName(assembly, s2) {
    return assembly.getCanonicalRefName(s2) ?? s2;
  }
  var MsaToGenomeHighlight = (0, import_mobx_react2.observer)(function MsaToGenomeHighlight2({
    model
  }) {
    const { classes } = useStyles();
    const { assemblyManager, views } = (0, import_util3.getSession)(model);
    const p2 = views.find((f2) => f2.type === "MsaView");
    const assembly = assemblyManager.get(model.assemblyNames[0]);
    return assembly ? /* @__PURE__ */ import_react2.default.createElement(import_react2.default.Fragment, null, p2?.connectedHighlights.map((r2, idx) => {
      const refName = getCanonicalName(assembly, r2.refName);
      const s2 = model.bpToPx({ refName, coord: r2.start });
      const e2 = model.bpToPx({ refName, coord: r2.end });
      if (s2 && e2) {
        const width = Math.max(Math.abs(e2.offsetPx - s2.offsetPx), 4);
        const left = Math.min(s2.offsetPx, e2.offsetPx) - model.offsetPx;
        return /* @__PURE__ */ import_react2.default.createElement(
          "div",
          {
            key: `${JSON.stringify(r2)}-${idx}`,
            className: classes.highlight,
            style: { left, width }
          }
        );
      } else {
        return null;
      }
    })) : null;
  });
  var MsaToGenomeHighlight_default = MsaToGenomeHighlight;

  // src/AddHighlightModel/HighlightComponents.tsx
  var HighlightComponents = (0, import_mobx_react3.observer)(function HighlightComponents2({
    model
  }) {
    return /* @__PURE__ */ import_react3.default.createElement(import_react3.default.Fragment, null, /* @__PURE__ */ import_react3.default.createElement(MsaToGenomeHighlight_default, { model }), /* @__PURE__ */ import_react3.default.createElement(GenomeMouseoverHighlight_default, { model }));
  });
  var HighlightComponents_default = HighlightComponents;

  // src/AddHighlightModel/index.tsx
  function AddHighlightComponentsModelF(pluginManager) {
    pluginManager.addToExtensionPoint(
      "LinearGenomeView-TracksContainerComponent",
      // @ts-expect-error
      (rest, { model }) => {
        return [
          ...rest,
          /* @__PURE__ */ import_react4.default.createElement(
            HighlightComponents_default,
            {
              key: "highlight_protein_viewer_msaview",
              model
            }
          )
        ];
      }
    );
  }

  // src/BgzipFastaMsaAdapter/index.ts
  var import_pluggableElementTypes = __toESM(require_pluggableElementTypes());

  // src/BgzipFastaMsaAdapter/configSchema.ts
  var import_configuration = __toESM(require_configuration());
  function configSchemaF(pluginManager) {
    const base4 = pluginManager.getAdapterType("BgzipFastaAdapter");
    return (0, import_configuration.ConfigurationSchema)(
      "BgzipFastaMsaAdapter",
      {
        msaRegex: {
          type: "string",
          defaultValue: "_"
        }
      },
      {
        baseConfiguration: base4?.configSchema
      }
    );
  }

  // src/BgzipFastaMsaAdapter/index.ts
  function BgzipFastaMsaAdapterF(pluginManager) {
    return pluginManager.addAdapterType(() => {
      return new import_pluggableElementTypes.AdapterType({
        name: "BgzipFastaMsaAdapter",
        configSchema: configSchemaF(pluginManager),
        adapterMetadata: {
          hiddenFromGUI: true
        },
        getAdapterClass: () => Promise.resolve().then(() => (init_BgzipFastaMsaAdapter(), BgzipFastaMsaAdapter_exports)).then((t2) => t2.default)
      });
    });
  }

  // src/LaunchMsaView/index.ts
  var import_util23 = __toESM(require_util());

  // node_modules/@mui/icons-material/esm/Add.js
  init_createSvgIcon();
  var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
  var Add_default = (0, import_utils.createSvgIcon)(/* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", {
    d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z"
  }), "Add");

  // src/LaunchMsaView/components/LaunchMsaViewDialog.tsx
  var import_react22 = __toESM(require_react());
  var import_ui6 = __toESM(require_ui());
  var import_material12 = __toESM(require_material());

  // src/LaunchMsaView/components/EnsemblGeneTree/EnsemblGeneTree.tsx
  var import_react12 = __toESM(require_react());
  var import_ui = __toESM(require_ui());
  var import_util11 = __toESM(require_util());
  var import_material3 = __toESM(require_material());
  var import_mobx_react4 = __toESM(require_mobx_react());
  var import_mui4 = __toESM(require_mui());

  // src/LaunchMsaView/components/EnsemblGeneTree/ensemblGeneTreeLaunchView.ts
  function ensemblGeneTreeLaunchView({
    session,
    newViewTitle,
    view,
    feature,
    data
  }) {
    session.addView("MsaView", {
      type: "MsaView",
      displayName: newViewTitle,
      colWidth: 10,
      rowHeight: 12,
      data,
      connectedViewId: view.id,
      connectedFeature: feature.toJSON()
    });
  }

  // node_modules/swr/dist/index/index.mjs
  var import_react7 = __toESM(require_react(), 1);
  var import_shim = __toESM(require_shim(), 1);

  // node_modules/swr/dist/_internal/config-context-12s-Dh3trQsc.mjs
  var import_react5 = __toESM(require_react(), 1);

  // node_modules/swr/dist/_internal/events.mjs
  var events_exports = {};
  __export(events_exports, {
    ERROR_REVALIDATE_EVENT: () => ERROR_REVALIDATE_EVENT,
    FOCUS_EVENT: () => FOCUS_EVENT,
    MUTATE_EVENT: () => MUTATE_EVENT,
    RECONNECT_EVENT: () => RECONNECT_EVENT
  });
  var FOCUS_EVENT = 0;
  var RECONNECT_EVENT = 1;
  var MUTATE_EVENT = 2;
  var ERROR_REVALIDATE_EVENT = 3;

  // node_modules/dequal/lite/index.mjs
  var has = Object.prototype.hasOwnProperty;
  function dequal(foo, bar) {
    var ctor, len2;
    if (foo === bar) return true;
    if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
      if (ctor === Date) return foo.getTime() === bar.getTime();
      if (ctor === RegExp) return foo.toString() === bar.toString();
      if (ctor === Array) {
        if ((len2 = foo.length) === bar.length) {
          while (len2-- && dequal(foo[len2], bar[len2])) ;
        }
        return len2 === -1;
      }
      if (!ctor || typeof foo === "object") {
        len2 = 0;
        for (ctor in foo) {
          if (has.call(foo, ctor) && ++len2 && !has.call(bar, ctor)) return false;
          if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
        }
        return Object.keys(bar).length === len2;
      }
    }
    return foo !== foo && bar !== bar;
  }

  // node_modules/swr/dist/_internal/config-context-12s-Dh3trQsc.mjs
  var SWRGlobalState = /* @__PURE__ */ new WeakMap();
  var noop2 = () => {
  };
  var UNDEFINED = (
    /*#__NOINLINE__*/
    noop2()
  );
  var OBJECT = Object;
  var isUndefined = (v2) => v2 === UNDEFINED;
  var isFunction2 = (v2) => typeof v2 == "function";
  var mergeObjects = (a2, b2) => ({
    ...a2,
    ...b2
  });
  var isPromiseLike = (x2) => isFunction2(x2.then);
  var EMPTY_CACHE = {};
  var INITIAL_CACHE = {};
  var STR_UNDEFINED = "undefined";
  var isWindowDefined = typeof window != STR_UNDEFINED;
  var isDocumentDefined = typeof document != STR_UNDEFINED;
  var isLegacyDeno = isWindowDefined && "Deno" in window;
  var hasRequestAnimationFrame = () => isWindowDefined && typeof window["requestAnimationFrame"] != STR_UNDEFINED;
  var createCacheHelper = (cache2, key) => {
    const state = SWRGlobalState.get(cache2);
    return [
      // Getter
      () => !isUndefined(key) && cache2.get(key) || EMPTY_CACHE,
      // Setter
      (info) => {
        if (!isUndefined(key)) {
          const prev2 = cache2.get(key);
          if (!(key in INITIAL_CACHE)) {
            INITIAL_CACHE[key] = prev2;
          }
          state[5](key, mergeObjects(prev2, info), prev2 || EMPTY_CACHE);
        }
      },
      // Subscriber
      state[6],
      // Get server cache snapshot
      () => {
        if (!isUndefined(key)) {
          if (key in INITIAL_CACHE) return INITIAL_CACHE[key];
        }
        return !isUndefined(key) && cache2.get(key) || EMPTY_CACHE;
      }
    ];
  };
  var online = true;
  var isOnline = () => online;
  var [onWindowEvent, offWindowEvent] = isWindowDefined && window.addEventListener ? [
    window.addEventListener.bind(window),
    window.removeEventListener.bind(window)
  ] : [
    noop2,
    noop2
  ];
  var isVisible = () => {
    const visibilityState = isDocumentDefined && document.visibilityState;
    return isUndefined(visibilityState) || visibilityState !== "hidden";
  };
  var initFocus = (callback) => {
    if (isDocumentDefined) {
      document.addEventListener("visibilitychange", callback);
    }
    onWindowEvent("focus", callback);
    return () => {
      if (isDocumentDefined) {
        document.removeEventListener("visibilitychange", callback);
      }
      offWindowEvent("focus", callback);
    };
  };
  var initReconnect = (callback) => {
    const onOnline = () => {
      online = true;
      callback();
    };
    const onOffline = () => {
      online = false;
    };
    onWindowEvent("online", onOnline);
    onWindowEvent("offline", onOffline);
    return () => {
      offWindowEvent("online", onOnline);
      offWindowEvent("offline", onOffline);
    };
  };
  var preset = {
    isOnline,
    isVisible
  };
  var defaultConfigOptions = {
    initFocus,
    initReconnect
  };
  var IS_REACT_LEGACY = !import_react5.default.useId;
  var IS_SERVER = !isWindowDefined || isLegacyDeno;
  var rAF = (f2) => hasRequestAnimationFrame() ? window["requestAnimationFrame"](f2) : setTimeout(f2, 1);
  var useIsomorphicLayoutEffect = IS_SERVER ? import_react5.useEffect : import_react5.useLayoutEffect;
  var navigatorConnection = typeof navigator !== "undefined" && navigator.connection;
  var slowConnection = !IS_SERVER && navigatorConnection && ([
    "slow-2g",
    "2g"
  ].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);
  var table = /* @__PURE__ */ new WeakMap();
  var getTypeName = (value) => OBJECT.prototype.toString.call(value);
  var isObjectTypeName = (typeName, type) => typeName === `[object ${type}]`;
  var counter = 0;
  var stableHash = (arg) => {
    const type = typeof arg;
    const typeName = getTypeName(arg);
    const isDate = isObjectTypeName(typeName, "Date");
    const isRegex = isObjectTypeName(typeName, "RegExp");
    const isPlainObject = isObjectTypeName(typeName, "Object");
    let result;
    let index3;
    if (OBJECT(arg) === arg && !isDate && !isRegex) {
      result = table.get(arg);
      if (result) return result;
      result = ++counter + "~";
      table.set(arg, result);
      if (Array.isArray(arg)) {
        result = "@";
        for (index3 = 0; index3 < arg.length; index3++) {
          result += stableHash(arg[index3]) + ",";
        }
        table.set(arg, result);
      }
      if (isPlainObject) {
        result = "#";
        const keys = OBJECT.keys(arg).sort();
        while (!isUndefined(index3 = keys.pop())) {
          if (!isUndefined(arg[index3])) {
            result += index3 + ":" + stableHash(arg[index3]) + ",";
          }
        }
        table.set(arg, result);
      }
    } else {
      result = isDate ? arg.toJSON() : type == "symbol" ? arg.toString() : type == "string" ? JSON.stringify(arg) : "" + arg;
    }
    return result;
  };
  var serialize = (key) => {
    if (isFunction2(key)) {
      try {
        key = key();
      } catch (err2) {
        key = "";
      }
    }
    const args = key;
    key = typeof key == "string" ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : "";
    return [
      key,
      args
    ];
  };
  var __timestamp = 0;
  var getTimestamp = () => ++__timestamp;
  async function internalMutate(...args) {
    const [cache2, _key, _data, _opts] = args;
    const options = mergeObjects({
      populateCache: true,
      throwOnError: true
    }, typeof _opts === "boolean" ? {
      revalidate: _opts
    } : _opts || {});
    let populateCache = options.populateCache;
    const rollbackOnErrorOption = options.rollbackOnError;
    let optimisticData = options.optimisticData;
    const rollbackOnError = (error2) => {
      return typeof rollbackOnErrorOption === "function" ? rollbackOnErrorOption(error2) : rollbackOnErrorOption !== false;
    };
    const throwOnError = options.throwOnError;
    if (isFunction2(_key)) {
      const keyFilter = _key;
      const matchedKeys = [];
      const it = cache2.keys();
      for (const key of it) {
        if (
          // Skip the special useSWRInfinite and useSWRSubscription keys.
          !/^\$(inf|sub)\$/.test(key) && keyFilter(cache2.get(key)._k)
        ) {
          matchedKeys.push(key);
        }
      }
      return Promise.all(matchedKeys.map(mutateByKey));
    }
    return mutateByKey(_key);
    async function mutateByKey(_k) {
      const [key] = serialize(_k);
      if (!key) return;
      const [get, set] = createCacheHelper(cache2, key);
      const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = SWRGlobalState.get(cache2);
      const startRevalidate = () => {
        const revalidators = EVENT_REVALIDATORS[key];
        const revalidate = isFunction2(options.revalidate) ? options.revalidate(get().data, _k) : options.revalidate !== false;
        if (revalidate) {
          delete FETCH[key];
          delete PRELOAD[key];
          if (revalidators && revalidators[0]) {
            return revalidators[0](MUTATE_EVENT).then(() => get().data);
          }
        }
        return get().data;
      };
      if (args.length < 3) {
        return startRevalidate();
      }
      let data = _data;
      let error2;
      let isError = false;
      const beforeMutationTs = getTimestamp();
      MUTATION[key] = [
        beforeMutationTs,
        0
      ];
      const hasOptimisticData = !isUndefined(optimisticData);
      const state = get();
      const displayedData = state.data;
      const currentData = state._c;
      const committedData = isUndefined(currentData) ? displayedData : currentData;
      if (hasOptimisticData) {
        optimisticData = isFunction2(optimisticData) ? optimisticData(committedData, displayedData) : optimisticData;
        set({
          data: optimisticData,
          _c: committedData
        });
      }
      if (isFunction2(data)) {
        try {
          data = data(committedData);
        } catch (err2) {
          error2 = err2;
          isError = true;
        }
      }
      if (data && isPromiseLike(data)) {
        data = await data.catch((err2) => {
          error2 = err2;
          isError = true;
        });
        if (beforeMutationTs !== MUTATION[key][0]) {
          if (isError) throw error2;
          return data;
        } else if (isError && hasOptimisticData && rollbackOnError(error2)) {
          populateCache = true;
          set({
            data: committedData,
            _c: UNDEFINED
          });
        }
      }
      if (populateCache) {
        if (!isError) {
          if (isFunction2(populateCache)) {
            const populateCachedData = populateCache(data, committedData);
            set({
              data: populateCachedData,
              error: UNDEFINED,
              _c: UNDEFINED
            });
          } else {
            set({
              data,
              error: UNDEFINED,
              _c: UNDEFINED
            });
          }
        }
      }
      MUTATION[key][1] = getTimestamp();
      Promise.resolve(startRevalidate()).then(() => {
        set({
          _c: UNDEFINED
        });
      });
      if (isError) {
        if (throwOnError) throw error2;
        return;
      }
      return data;
    }
  }
  var revalidateAllKeys = (revalidators, type) => {
    for (const key in revalidators) {
      if (revalidators[key][0]) revalidators[key][0](type);
    }
  };
  var initCache = (provider, options) => {
    if (!SWRGlobalState.has(provider)) {
      const opts = mergeObjects(defaultConfigOptions, options);
      const EVENT_REVALIDATORS = /* @__PURE__ */ Object.create(null);
      const mutate2 = internalMutate.bind(UNDEFINED, provider);
      let unmount = noop2;
      const subscriptions = /* @__PURE__ */ Object.create(null);
      const subscribe = (key, callback) => {
        const subs = subscriptions[key] || [];
        subscriptions[key] = subs;
        subs.push(callback);
        return () => subs.splice(subs.indexOf(callback), 1);
      };
      const setter = (key, value, prev2) => {
        provider.set(key, value);
        const subs = subscriptions[key];
        if (subs) {
          for (const fn of subs) {
            fn(value, prev2);
          }
        }
      };
      const initProvider = () => {
        if (!SWRGlobalState.has(provider)) {
          SWRGlobalState.set(provider, [
            EVENT_REVALIDATORS,
            /* @__PURE__ */ Object.create(null),
            /* @__PURE__ */ Object.create(null),
            /* @__PURE__ */ Object.create(null),
            mutate2,
            setter,
            subscribe
          ]);
          if (!IS_SERVER) {
            const releaseFocus = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));
            const releaseReconnect = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));
            unmount = () => {
              releaseFocus && releaseFocus();
              releaseReconnect && releaseReconnect();
              SWRGlobalState.delete(provider);
            };
          }
        }
      };
      initProvider();
      return [
        provider,
        mutate2,
        initProvider,
        unmount
      ];
    }
    return [
      provider,
      SWRGlobalState.get(provider)[4]
    ];
  };
  var onErrorRetry = (_, __, config2, revalidate, opts) => {
    const maxRetryCount = config2.errorRetryCount;
    const currentRetryCount = opts.retryCount;
    const timeout3 = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config2.errorRetryInterval;
    if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {
      return;
    }
    setTimeout(revalidate, timeout3, opts);
  };
  var compare = dequal;
  var [cache, mutate] = initCache(/* @__PURE__ */ new Map());
  var defaultConfig = mergeObjects(
    {
      // events
      onLoadingSlow: noop2,
      onSuccess: noop2,
      onError: noop2,
      onErrorRetry,
      onDiscarded: noop2,
      // switches
      revalidateOnFocus: true,
      revalidateOnReconnect: true,
      revalidateIfStale: true,
      shouldRetryOnError: true,
      // timeouts
      errorRetryInterval: slowConnection ? 1e4 : 5e3,
      focusThrottleInterval: 5 * 1e3,
      dedupingInterval: 2 * 1e3,
      loadingTimeout: slowConnection ? 5e3 : 3e3,
      // providers
      compare,
      isPaused: () => false,
      cache,
      mutate,
      fallback: {}
    },
    // use web preset by default
    preset
  );
  var mergeConfigs = (a2, b2) => {
    const v2 = mergeObjects(a2, b2);
    if (b2) {
      const { use: u1, fallback: f1 } = a2;
      const { use: u2, fallback: f2 } = b2;
      if (u1 && u2) {
        v2.use = u1.concat(u2);
      }
      if (f1 && f2) {
        v2.fallback = mergeObjects(f1, f2);
      }
    }
    return v2;
  };
  var SWRConfigContext = (0, import_react5.createContext)({});
  var SWRConfig = (props) => {
    const { value } = props;
    const parentConfig = (0, import_react5.useContext)(SWRConfigContext);
    const isFunctionalConfig = isFunction2(value);
    const config2 = (0, import_react5.useMemo)(() => isFunctionalConfig ? value(parentConfig) : value, [
      isFunctionalConfig,
      parentConfig,
      value
    ]);
    const extendedConfig = (0, import_react5.useMemo)(() => isFunctionalConfig ? config2 : mergeConfigs(parentConfig, config2), [
      isFunctionalConfig,
      parentConfig,
      config2
    ]);
    const provider = config2 && config2.provider;
    const cacheContextRef = (0, import_react5.useRef)(UNDEFINED);
    if (provider && !cacheContextRef.current) {
      cacheContextRef.current = initCache(provider(extendedConfig.cache || cache), config2);
    }
    const cacheContext = cacheContextRef.current;
    if (cacheContext) {
      extendedConfig.cache = cacheContext[0];
      extendedConfig.mutate = cacheContext[1];
    }
    useIsomorphicLayoutEffect(() => {
      if (cacheContext) {
        cacheContext[2] && cacheContext[2]();
        return cacheContext[3];
      }
    }, []);
    return (0, import_react5.createElement)(SWRConfigContext.Provider, mergeObjects(props, {
      value: extendedConfig
    }));
  };

  // node_modules/swr/dist/_internal/constants.mjs
  var INFINITE_PREFIX = "$inf$";

  // node_modules/swr/dist/_internal/index.mjs
  var import_react6 = __toESM(require_react(), 1);
  var enableDevtools = isWindowDefined && window.__SWR_DEVTOOLS_USE__;
  var use = enableDevtools ? window.__SWR_DEVTOOLS_USE__ : [];
  var setupDevTools = () => {
    if (enableDevtools) {
      window.__SWR_DEVTOOLS_REACT__ = import_react6.default;
    }
  };
  var normalize = (args) => {
    return isFunction2(args[1]) ? [
      args[0],
      args[1],
      args[2] || {}
    ] : [
      args[0],
      null,
      (args[1] === null ? args[2] : args[1]) || {}
    ];
  };
  var useSWRConfig = () => {
    const parentConfig = (0, import_react6.useContext)(SWRConfigContext);
    const mergedConfig = (0, import_react6.useMemo)(() => mergeObjects(defaultConfig, parentConfig), [
      parentConfig
    ]);
    return mergedConfig;
  };
  var middleware = (useSWRNext) => (key_, fetcher_, config2) => {
    const fetcher = fetcher_ && ((...args) => {
      const [key] = serialize(key_);
      const [, , , PRELOAD] = SWRGlobalState.get(cache);
      if (key.startsWith(INFINITE_PREFIX)) {
        return fetcher_(...args);
      }
      const req = PRELOAD[key];
      if (isUndefined(req)) return fetcher_(...args);
      delete PRELOAD[key];
      return req;
    });
    return useSWRNext(key_, fetcher, config2);
  };
  var BUILT_IN_MIDDLEWARE = use.concat(middleware);
  var withArgs = (hook) => {
    return function useSWRArgs(...args) {
      const fallbackConfig = useSWRConfig();
      const [key, fn, _config] = normalize(args);
      const config2 = mergeConfigs(fallbackConfig, _config);
      let next2 = hook;
      const { use: use3 } = config2;
      const middleware3 = (use3 || []).concat(BUILT_IN_MIDDLEWARE);
      for (let i2 = middleware3.length; i2--; ) {
        next2 = middleware3[i2](next2);
      }
      return next2(key, fn || config2.fetcher || null, config2);
    };
  };
  var subscribeCallback = (key, callbacks, callback) => {
    const keyedRevalidators = callbacks[key] || (callbacks[key] = []);
    keyedRevalidators.push(callback);
    return () => {
      const index3 = keyedRevalidators.indexOf(callback);
      if (index3 >= 0) {
        keyedRevalidators[index3] = keyedRevalidators[keyedRevalidators.length - 1];
        keyedRevalidators.pop();
      }
    };
  };
  setupDevTools();

  // node_modules/swr/dist/index/index.mjs
  var noop3 = () => {
  };
  var UNDEFINED2 = (
    /*#__NOINLINE__*/
    noop3()
  );
  var use2 = import_react7.default.use || // This extra generic is to avoid TypeScript mixing up the generic and JSX sytax
  // and emitting an error.
  // We assume that this is only for the `use(thenable)` case, not `use(context)`.
  // https://github.com/facebook/react/blob/aed00dacfb79d17c53218404c52b1c7aa59c4a89/packages/react-server/src/ReactFizzThenable.js#L45
  ((thenable) => {
    switch (thenable.status) {
      case "pending":
        throw thenable;
      case "fulfilled":
        return thenable.value;
      case "rejected":
        throw thenable.reason;
      default:
        thenable.status = "pending";
        thenable.then((v2) => {
          thenable.status = "fulfilled";
          thenable.value = v2;
        }, (e2) => {
          thenable.status = "rejected";
          thenable.reason = e2;
        });
        throw thenable;
    }
  });
  var WITH_DEDUPE = {
    dedupe: true
  };
  var resolvedUndef = Promise.resolve(UNDEFINED);
  var useSWRHandler = (_key, fetcher, config2) => {
    const { cache: cache2, compare: compare2, suspense, fallbackData, revalidateOnMount, revalidateIfStale, refreshInterval, refreshWhenHidden, refreshWhenOffline, keepPreviousData, strictServerPrefetchWarning } = config2;
    const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = SWRGlobalState.get(cache2);
    const [key, fnArg] = serialize(_key);
    const initialMountedRef = (0, import_react7.useRef)(false);
    const unmountedRef = (0, import_react7.useRef)(false);
    const keyRef = (0, import_react7.useRef)(key);
    const fetcherRef = (0, import_react7.useRef)(fetcher);
    const configRef = (0, import_react7.useRef)(config2);
    const getConfig = () => configRef.current;
    const isActive = () => getConfig().isVisible() && getConfig().isOnline();
    const [getCache, setCache, subscribeCache, getInitialCache] = createCacheHelper(cache2, key);
    const stateDependencies = (0, import_react7.useRef)({}).current;
    const fallback = isUndefined(fallbackData) ? isUndefined(config2.fallback) ? UNDEFINED : config2.fallback[key] : fallbackData;
    const isEqual = (prev2, current) => {
      for (const _ in stateDependencies) {
        const t2 = _;
        if (t2 === "data") {
          if (!compare2(prev2[t2], current[t2])) {
            if (!isUndefined(prev2[t2])) {
              return false;
            }
            if (!compare2(returnedData, current[t2])) {
              return false;
            }
          }
        } else {
          if (current[t2] !== prev2[t2]) {
            return false;
          }
        }
      }
      return true;
    };
    const getSnapshot = (0, import_react7.useMemo)(() => {
      const shouldStartRequest = (() => {
        if (!key) return false;
        if (!fetcher) return false;
        if (!isUndefined(revalidateOnMount)) return revalidateOnMount;
        if (getConfig().isPaused()) return false;
        if (suspense) return false;
        return revalidateIfStale !== false;
      })();
      const getSelectedCache = (state) => {
        const snapshot = mergeObjects(state);
        delete snapshot._k;
        if (!shouldStartRequest) {
          return snapshot;
        }
        return {
          isValidating: true,
          isLoading: true,
          ...snapshot
        };
      };
      const cachedData2 = getCache();
      const initialData = getInitialCache();
      const clientSnapshot = getSelectedCache(cachedData2);
      const serverSnapshot = cachedData2 === initialData ? clientSnapshot : getSelectedCache(initialData);
      let memorizedSnapshot = clientSnapshot;
      return [
        () => {
          const newSnapshot = getSelectedCache(getCache());
          const compareResult = isEqual(newSnapshot, memorizedSnapshot);
          if (compareResult) {
            memorizedSnapshot.data = newSnapshot.data;
            memorizedSnapshot.isLoading = newSnapshot.isLoading;
            memorizedSnapshot.isValidating = newSnapshot.isValidating;
            memorizedSnapshot.error = newSnapshot.error;
            return memorizedSnapshot;
          } else {
            memorizedSnapshot = newSnapshot;
            return newSnapshot;
          }
        },
        () => serverSnapshot
      ];
    }, [
      cache2,
      key
    ]);
    const cached = (0, import_shim.useSyncExternalStore)((0, import_react7.useCallback)(
      (callback) => subscribeCache(key, (current, prev2) => {
        if (!isEqual(prev2, current)) callback();
      }),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [
        cache2,
        key
      ]
    ), getSnapshot[0], getSnapshot[1]);
    const isInitialMount = !initialMountedRef.current;
    const hasRevalidator = EVENT_REVALIDATORS[key] && EVENT_REVALIDATORS[key].length > 0;
    const cachedData = cached.data;
    const data = isUndefined(cachedData) ? fallback && isPromiseLike(fallback) ? use2(fallback) : fallback : cachedData;
    const error2 = cached.error;
    const laggyDataRef = (0, import_react7.useRef)(data);
    const returnedData = keepPreviousData ? isUndefined(cachedData) ? isUndefined(laggyDataRef.current) ? data : laggyDataRef.current : cachedData : data;
    const hasKeyButNoData = key && isUndefined(data);
    const isHydration = !IS_SERVER && // eslint-disable-next-line react-hooks/rules-of-hooks
    (0, import_shim.useSyncExternalStore)(() => noop2, () => false, () => true);
    if (strictServerPrefetchWarning && isHydration && !suspense && hasKeyButNoData) {
      console.warn(`Missing pre-initiated data for serialized key "${key}" during server-side rendering. Data fethcing should be initiated on the server and provided to SWR via fallback data. You can set "strictServerPrefetchWarning: false" to disable this warning.`);
    }
    const shouldDoInitialRevalidation = (() => {
      if (hasRevalidator && !isUndefined(error2)) return false;
      if (isInitialMount && !isUndefined(revalidateOnMount)) return revalidateOnMount;
      if (getConfig().isPaused()) return false;
      if (suspense) return isUndefined(data) ? false : revalidateIfStale;
      return isUndefined(data) || revalidateIfStale;
    })();
    const defaultValidatingState = !!(key && fetcher && isInitialMount && shouldDoInitialRevalidation);
    const isValidating = isUndefined(cached.isValidating) ? defaultValidatingState : cached.isValidating;
    const isLoading = isUndefined(cached.isLoading) ? defaultValidatingState : cached.isLoading;
    const revalidate = (0, import_react7.useCallback)(
      async (revalidateOpts) => {
        const currentFetcher = fetcherRef.current;
        if (!key || !currentFetcher || unmountedRef.current || getConfig().isPaused()) {
          return false;
        }
        let newData;
        let startAt;
        let loading = true;
        const opts = revalidateOpts || {};
        const shouldStartNewRequest = !FETCH[key] || !opts.dedupe;
        const callbackSafeguard = () => {
          if (IS_REACT_LEGACY) {
            return !unmountedRef.current && key === keyRef.current && initialMountedRef.current;
          }
          return key === keyRef.current;
        };
        const finalState = {
          isValidating: false,
          isLoading: false
        };
        const finishRequestAndUpdateState = () => {
          setCache(finalState);
        };
        const cleanupState = () => {
          const requestInfo = FETCH[key];
          if (requestInfo && requestInfo[1] === startAt) {
            delete FETCH[key];
          }
        };
        const initialState = {
          isValidating: true
        };
        if (isUndefined(getCache().data)) {
          initialState.isLoading = true;
        }
        try {
          if (shouldStartNewRequest) {
            setCache(initialState);
            if (config2.loadingTimeout && isUndefined(getCache().data)) {
              setTimeout(() => {
                if (loading && callbackSafeguard()) {
                  getConfig().onLoadingSlow(key, config2);
                }
              }, config2.loadingTimeout);
            }
            FETCH[key] = [
              currentFetcher(fnArg),
              getTimestamp()
            ];
          }
          ;
          [newData, startAt] = FETCH[key];
          newData = await newData;
          if (shouldStartNewRequest) {
            setTimeout(cleanupState, config2.dedupingInterval);
          }
          if (!FETCH[key] || FETCH[key][1] !== startAt) {
            if (shouldStartNewRequest) {
              if (callbackSafeguard()) {
                getConfig().onDiscarded(key);
              }
            }
            return false;
          }
          finalState.error = UNDEFINED;
          const mutationInfo = MUTATION[key];
          if (!isUndefined(mutationInfo) && // case 1
          (startAt <= mutationInfo[0] || // case 2
          startAt <= mutationInfo[1] || // case 3
          mutationInfo[1] === 0)) {
            finishRequestAndUpdateState();
            if (shouldStartNewRequest) {
              if (callbackSafeguard()) {
                getConfig().onDiscarded(key);
              }
            }
            return false;
          }
          const cacheData = getCache().data;
          finalState.data = compare2(cacheData, newData) ? cacheData : newData;
          if (shouldStartNewRequest) {
            if (callbackSafeguard()) {
              getConfig().onSuccess(newData, key, config2);
            }
          }
        } catch (err2) {
          cleanupState();
          const currentConfig = getConfig();
          const { shouldRetryOnError } = currentConfig;
          if (!currentConfig.isPaused()) {
            finalState.error = err2;
            if (shouldStartNewRequest && callbackSafeguard()) {
              currentConfig.onError(err2, key, currentConfig);
              if (shouldRetryOnError === true || isFunction2(shouldRetryOnError) && shouldRetryOnError(err2)) {
                if (!getConfig().revalidateOnFocus || !getConfig().revalidateOnReconnect || isActive()) {
                  currentConfig.onErrorRetry(err2, key, currentConfig, (_opts) => {
                    const revalidators = EVENT_REVALIDATORS[key];
                    if (revalidators && revalidators[0]) {
                      revalidators[0](events_exports.ERROR_REVALIDATE_EVENT, _opts);
                    }
                  }, {
                    retryCount: (opts.retryCount || 0) + 1,
                    dedupe: true
                  });
                }
              }
            }
          }
        }
        loading = false;
        finishRequestAndUpdateState();
        return true;
      },
      // `setState` is immutable, and `eventsCallback`, `fnArg`, and
      // `keyValidating` are depending on `key`, so we can exclude them from
      // the deps array.
      //
      // FIXME:
      // `fn` and `config` might be changed during the lifecycle,
      // but they might be changed every render like this.
      // `useSWR('key', () => fetch('/api/'), { suspense: true })`
      // So we omit the values from the deps array
      // even though it might cause unexpected behaviors.
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [
        key,
        cache2
      ]
    );
    const boundMutate = (0, import_react7.useCallback)(
      // Use callback to make sure `keyRef.current` returns latest result every time
      (...args) => {
        return internalMutate(cache2, keyRef.current, ...args);
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      []
    );
    useIsomorphicLayoutEffect(() => {
      fetcherRef.current = fetcher;
      configRef.current = config2;
      if (!isUndefined(cachedData)) {
        laggyDataRef.current = cachedData;
      }
    });
    useIsomorphicLayoutEffect(() => {
      if (!key) return;
      const softRevalidate = revalidate.bind(UNDEFINED, WITH_DEDUPE);
      let nextFocusRevalidatedAt = 0;
      if (getConfig().revalidateOnFocus) {
        const initNow = Date.now();
        nextFocusRevalidatedAt = initNow + getConfig().focusThrottleInterval;
      }
      const onRevalidate = (type, opts = {}) => {
        if (type == events_exports.FOCUS_EVENT) {
          const now = Date.now();
          if (getConfig().revalidateOnFocus && now > nextFocusRevalidatedAt && isActive()) {
            nextFocusRevalidatedAt = now + getConfig().focusThrottleInterval;
            softRevalidate();
          }
        } else if (type == events_exports.RECONNECT_EVENT) {
          if (getConfig().revalidateOnReconnect && isActive()) {
            softRevalidate();
          }
        } else if (type == events_exports.MUTATE_EVENT) {
          return revalidate();
        } else if (type == events_exports.ERROR_REVALIDATE_EVENT) {
          return revalidate(opts);
        }
        return;
      };
      const unsubEvents = subscribeCallback(key, EVENT_REVALIDATORS, onRevalidate);
      unmountedRef.current = false;
      keyRef.current = key;
      initialMountedRef.current = true;
      setCache({
        _k: fnArg
      });
      if (shouldDoInitialRevalidation) {
        if (!FETCH[key]) {
          if (isUndefined(data) || IS_SERVER) {
            softRevalidate();
          } else {
            rAF(softRevalidate);
          }
        }
      }
      return () => {
        unmountedRef.current = true;
        unsubEvents();
      };
    }, [
      key
    ]);
    useIsomorphicLayoutEffect(() => {
      let timer;
      function next2() {
        const interval = isFunction2(refreshInterval) ? refreshInterval(getCache().data) : refreshInterval;
        if (interval && timer !== -1) {
          timer = setTimeout(execute, interval);
        }
      }
      function execute() {
        if (!getCache().error && (refreshWhenHidden || getConfig().isVisible()) && (refreshWhenOffline || getConfig().isOnline())) {
          revalidate(WITH_DEDUPE).then(next2);
        } else {
          next2();
        }
      }
      next2();
      return () => {
        if (timer) {
          clearTimeout(timer);
          timer = -1;
        }
      };
    }, [
      refreshInterval,
      refreshWhenHidden,
      refreshWhenOffline,
      key
    ]);
    (0, import_react7.useDebugValue)(returnedData);
    if (suspense) {
      if (!IS_REACT_LEGACY && IS_SERVER && hasKeyButNoData) {
        throw new Error("Fallback data is required when using Suspense in SSR.");
      }
      if (hasKeyButNoData) {
        fetcherRef.current = fetcher;
        configRef.current = config2;
        unmountedRef.current = false;
      }
      const req = PRELOAD[key];
      const mutateReq = !isUndefined(req) && hasKeyButNoData ? boundMutate(req) : resolvedUndef;
      use2(mutateReq);
      if (!isUndefined(error2) && hasKeyButNoData) {
        throw error2;
      }
      const revalidation = hasKeyButNoData ? revalidate(WITH_DEDUPE) : resolvedUndef;
      if (!isUndefined(returnedData) && hasKeyButNoData) {
        revalidation.status = "fulfilled";
        revalidation.value = true;
      }
      use2(revalidation);
    }
    const swrResponse = {
      mutate: boundMutate,
      get data() {
        stateDependencies.data = true;
        return returnedData;
      },
      get error() {
        stateDependencies.error = true;
        return error2;
      },
      get isValidating() {
        stateDependencies.isValidating = true;
        return isValidating;
      },
      get isLoading() {
        stateDependencies.isLoading = true;
        return isLoading;
      }
    };
    return swrResponse;
  };
  var SWRConfig2 = OBJECT.defineProperty(SWRConfig, "defaultValue", {
    value: defaultConfig
  });
  var useSWR = withArgs(useSWRHandler);

  // src/LaunchMsaView/components/EnsemblGeneTree/gatherSequencesFromTree.ts
  function gatherSequencesFromTree(tree, arr = []) {
    if (tree.children) {
      for (const child of tree.children) {
        if (child.sequence) {
          const id = child.sequence.id[0]?.accession;
          if (id) {
            arr.push({
              id,
              seq: child.sequence.mol_seq.seq,
              species: child.taxonomy.common_name || child.taxonomy.scientific_name,
              genomicLocString: child.sequence.mol_seq.location
            });
          }
        }
        gatherSequencesFromTree(child, arr);
      }
    }
    return arr;
  }

  // node_modules/pako/dist/pako.esm.mjs
  var Z_FIXED$1 = 4;
  var Z_BINARY = 0;
  var Z_TEXT = 1;
  var Z_UNKNOWN$1 = 2;
  function zero$1(buf) {
    let len2 = buf.length;
    while (--len2 >= 0) {
      buf[len2] = 0;
    }
  }
  var STORED_BLOCK = 0;
  var STATIC_TREES = 1;
  var DYN_TREES = 2;
  var MIN_MATCH$1 = 3;
  var MAX_MATCH$1 = 258;
  var LENGTH_CODES$1 = 29;
  var LITERALS$1 = 256;
  var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
  var D_CODES$1 = 30;
  var BL_CODES$1 = 19;
  var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
  var MAX_BITS$1 = 15;
  var Buf_size = 16;
  var MAX_BL_BITS = 7;
  var END_BLOCK = 256;
  var REP_3_6 = 16;
  var REPZ_3_10 = 17;
  var REPZ_11_138 = 18;
  var extra_lbits = (
    /* extra bits for each length code */
    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
  );
  var extra_dbits = (
    /* extra bits for each distance code */
    new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
  );
  var extra_blbits = (
    /* extra bits for each bit length code */
    new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
  );
  var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  var DIST_CODE_LEN = 512;
  var static_ltree = new Array((L_CODES$1 + 2) * 2);
  zero$1(static_ltree);
  var static_dtree = new Array(D_CODES$1 * 2);
  zero$1(static_dtree);
  var _dist_code = new Array(DIST_CODE_LEN);
  zero$1(_dist_code);
  var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
  zero$1(_length_code);
  var base_length = new Array(LENGTH_CODES$1);
  zero$1(base_length);
  var base_dist = new Array(D_CODES$1);
  zero$1(base_dist);
  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  }
  var static_l_desc;
  var static_d_desc;
  var static_bl_desc;
  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
  var d_code = (dist) => {
    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
  };
  var put_short = (s2, w2) => {
    s2.pending_buf[s2.pending++] = w2 & 255;
    s2.pending_buf[s2.pending++] = w2 >>> 8 & 255;
  };
  var send_bits = (s2, value, length2) => {
    if (s2.bi_valid > Buf_size - length2) {
      s2.bi_buf |= value << s2.bi_valid & 65535;
      put_short(s2, s2.bi_buf);
      s2.bi_buf = value >> Buf_size - s2.bi_valid;
      s2.bi_valid += length2 - Buf_size;
    } else {
      s2.bi_buf |= value << s2.bi_valid & 65535;
      s2.bi_valid += length2;
    }
  };
  var send_code = (s2, c2, tree) => {
    send_bits(
      s2,
      tree[c2 * 2],
      tree[c2 * 2 + 1]
      /*.Len*/
    );
  };
  var bi_reverse = (code, len2) => {
    let res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len2 > 0);
    return res >>> 1;
  };
  var bi_flush = (s2) => {
    if (s2.bi_valid === 16) {
      put_short(s2, s2.bi_buf);
      s2.bi_buf = 0;
      s2.bi_valid = 0;
    } else if (s2.bi_valid >= 8) {
      s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
      s2.bi_buf >>= 8;
      s2.bi_valid -= 8;
    }
  };
  var gen_bitlen = (s2, desc) => {
    const tree = desc.dyn_tree;
    const max_code = desc.max_code;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const extra = desc.stat_desc.extra_bits;
    const base4 = desc.stat_desc.extra_base;
    const max_length = desc.stat_desc.max_length;
    let h2;
    let n2, m2;
    let bits;
    let xbits;
    let f2;
    let overflow = 0;
    for (bits = 0; bits <= MAX_BITS$1; bits++) {
      s2.bl_count[bits] = 0;
    }
    tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
    for (h2 = s2.heap_max + 1; h2 < HEAP_SIZE$1; h2++) {
      n2 = s2.heap[h2];
      bits = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n2 * 2 + 1] = bits;
      if (n2 > max_code) {
        continue;
      }
      s2.bl_count[bits]++;
      xbits = 0;
      if (n2 >= base4) {
        xbits = extra[n2 - base4];
      }
      f2 = tree[n2 * 2];
      s2.opt_len += f2 * (bits + xbits);
      if (has_stree) {
        s2.static_len += f2 * (stree[n2 * 2 + 1] + xbits);
      }
    }
    if (overflow === 0) {
      return;
    }
    do {
      bits = max_length - 1;
      while (s2.bl_count[bits] === 0) {
        bits--;
      }
      s2.bl_count[bits]--;
      s2.bl_count[bits + 1] += 2;
      s2.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length; bits !== 0; bits--) {
      n2 = s2.bl_count[bits];
      while (n2 !== 0) {
        m2 = s2.heap[--h2];
        if (m2 > max_code) {
          continue;
        }
        if (tree[m2 * 2 + 1] !== bits) {
          s2.opt_len += (bits - tree[m2 * 2 + 1]) * tree[m2 * 2];
          tree[m2 * 2 + 1] = bits;
        }
        n2--;
      }
    }
  };
  var gen_codes = (tree, max_code, bl_count) => {
    const next_code = new Array(MAX_BITS$1 + 1);
    let code = 0;
    let bits;
    let n2;
    for (bits = 1; bits <= MAX_BITS$1; bits++) {
      code = code + bl_count[bits - 1] << 1;
      next_code[bits] = code;
    }
    for (n2 = 0; n2 <= max_code; n2++) {
      let len2 = tree[n2 * 2 + 1];
      if (len2 === 0) {
        continue;
      }
      tree[n2 * 2] = bi_reverse(next_code[len2]++, len2);
    }
  };
  var tr_static_init = () => {
    let n2;
    let bits;
    let length2;
    let code;
    let dist;
    const bl_count = new Array(MAX_BITS$1 + 1);
    length2 = 0;
    for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
      base_length[code] = length2;
      for (n2 = 0; n2 < 1 << extra_lbits[code]; n2++) {
        _length_code[length2++] = code;
      }
    }
    _length_code[length2 - 1] = code;
    dist = 0;
    for (code = 0; code < 16; code++) {
      base_dist[code] = dist;
      for (n2 = 0; n2 < 1 << extra_dbits[code]; n2++) {
        _dist_code[dist++] = code;
      }
    }
    dist >>= 7;
    for (; code < D_CODES$1; code++) {
      base_dist[code] = dist << 7;
      for (n2 = 0; n2 < 1 << extra_dbits[code] - 7; n2++) {
        _dist_code[256 + dist++] = code;
      }
    }
    for (bits = 0; bits <= MAX_BITS$1; bits++) {
      bl_count[bits] = 0;
    }
    n2 = 0;
    while (n2 <= 143) {
      static_ltree[n2 * 2 + 1] = 8;
      n2++;
      bl_count[8]++;
    }
    while (n2 <= 255) {
      static_ltree[n2 * 2 + 1] = 9;
      n2++;
      bl_count[9]++;
    }
    while (n2 <= 279) {
      static_ltree[n2 * 2 + 1] = 7;
      n2++;
      bl_count[7]++;
    }
    while (n2 <= 287) {
      static_ltree[n2 * 2 + 1] = 8;
      n2++;
      bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
    for (n2 = 0; n2 < D_CODES$1; n2++) {
      static_dtree[n2 * 2 + 1] = 5;
      static_dtree[n2 * 2] = bi_reverse(n2, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
  };
  var init_block = (s2) => {
    let n2;
    for (n2 = 0; n2 < L_CODES$1; n2++) {
      s2.dyn_ltree[n2 * 2] = 0;
    }
    for (n2 = 0; n2 < D_CODES$1; n2++) {
      s2.dyn_dtree[n2 * 2] = 0;
    }
    for (n2 = 0; n2 < BL_CODES$1; n2++) {
      s2.bl_tree[n2 * 2] = 0;
    }
    s2.dyn_ltree[END_BLOCK * 2] = 1;
    s2.opt_len = s2.static_len = 0;
    s2.sym_next = s2.matches = 0;
  };
  var bi_windup = (s2) => {
    if (s2.bi_valid > 8) {
      put_short(s2, s2.bi_buf);
    } else if (s2.bi_valid > 0) {
      s2.pending_buf[s2.pending++] = s2.bi_buf;
    }
    s2.bi_buf = 0;
    s2.bi_valid = 0;
  };
  var smaller = (tree, n2, m2, depth) => {
    const _n2 = n2 * 2;
    const _m2 = m2 * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m2];
  };
  var pqdownheap = (s2, tree, k2) => {
    const v2 = s2.heap[k2];
    let j2 = k2 << 1;
    while (j2 <= s2.heap_len) {
      if (j2 < s2.heap_len && smaller(tree, s2.heap[j2 + 1], s2.heap[j2], s2.depth)) {
        j2++;
      }
      if (smaller(tree, v2, s2.heap[j2], s2.depth)) {
        break;
      }
      s2.heap[k2] = s2.heap[j2];
      k2 = j2;
      j2 <<= 1;
    }
    s2.heap[k2] = v2;
  };
  var compress_block = (s2, ltree, dtree) => {
    let dist;
    let lc;
    let sx = 0;
    let code;
    let extra;
    if (s2.sym_next !== 0) {
      do {
        dist = s2.pending_buf[s2.sym_buf + sx++] & 255;
        dist += (s2.pending_buf[s2.sym_buf + sx++] & 255) << 8;
        lc = s2.pending_buf[s2.sym_buf + sx++];
        if (dist === 0) {
          send_code(s2, lc, ltree);
        } else {
          code = _length_code[lc];
          send_code(s2, code + LITERALS$1 + 1, ltree);
          extra = extra_lbits[code];
          if (extra !== 0) {
            lc -= base_length[code];
            send_bits(s2, lc, extra);
          }
          dist--;
          code = d_code(dist);
          send_code(s2, code, dtree);
          extra = extra_dbits[code];
          if (extra !== 0) {
            dist -= base_dist[code];
            send_bits(s2, dist, extra);
          }
        }
      } while (sx < s2.sym_next);
    }
    send_code(s2, END_BLOCK, ltree);
  };
  var build_tree = (s2, desc) => {
    const tree = desc.dyn_tree;
    const stree = desc.stat_desc.static_tree;
    const has_stree = desc.stat_desc.has_stree;
    const elems = desc.stat_desc.elems;
    let n2, m2;
    let max_code = -1;
    let node2;
    s2.heap_len = 0;
    s2.heap_max = HEAP_SIZE$1;
    for (n2 = 0; n2 < elems; n2++) {
      if (tree[n2 * 2] !== 0) {
        s2.heap[++s2.heap_len] = max_code = n2;
        s2.depth[n2] = 0;
      } else {
        tree[n2 * 2 + 1] = 0;
      }
    }
    while (s2.heap_len < 2) {
      node2 = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node2 * 2] = 1;
      s2.depth[node2] = 0;
      s2.opt_len--;
      if (has_stree) {
        s2.static_len -= stree[node2 * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n2 = s2.heap_len >> 1; n2 >= 1; n2--) {
      pqdownheap(s2, tree, n2);
    }
    node2 = elems;
    do {
      n2 = s2.heap[
        1
        /*SMALLEST*/
      ];
      s2.heap[
        1
        /*SMALLEST*/
      ] = s2.heap[s2.heap_len--];
      pqdownheap(
        s2,
        tree,
        1
        /*SMALLEST*/
      );
      m2 = s2.heap[
        1
        /*SMALLEST*/
      ];
      s2.heap[--s2.heap_max] = n2;
      s2.heap[--s2.heap_max] = m2;
      tree[node2 * 2] = tree[n2 * 2] + tree[m2 * 2];
      s2.depth[node2] = (s2.depth[n2] >= s2.depth[m2] ? s2.depth[n2] : s2.depth[m2]) + 1;
      tree[n2 * 2 + 1] = tree[m2 * 2 + 1] = node2;
      s2.heap[
        1
        /*SMALLEST*/
      ] = node2++;
      pqdownheap(
        s2,
        tree,
        1
        /*SMALLEST*/
      );
    } while (s2.heap_len >= 2);
    s2.heap[--s2.heap_max] = s2.heap[
      1
      /*SMALLEST*/
    ];
    gen_bitlen(s2, desc);
    gen_codes(tree, max_code, s2.bl_count);
  };
  var scan_tree = (s2, tree, max_code) => {
    let n2;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count3 = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n2 = 0; n2 <= max_code; n2++) {
      curlen = nextlen;
      nextlen = tree[(n2 + 1) * 2 + 1];
      if (++count3 < max_count && curlen === nextlen) {
        continue;
      } else if (count3 < min_count) {
        s2.bl_tree[curlen * 2] += count3;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s2.bl_tree[curlen * 2]++;
        }
        s2.bl_tree[REP_3_6 * 2]++;
      } else if (count3 <= 10) {
        s2.bl_tree[REPZ_3_10 * 2]++;
      } else {
        s2.bl_tree[REPZ_11_138 * 2]++;
      }
      count3 = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  };
  var send_tree = (s2, tree, max_code) => {
    let n2;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count3 = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n2 = 0; n2 <= max_code; n2++) {
      curlen = nextlen;
      nextlen = tree[(n2 + 1) * 2 + 1];
      if (++count3 < max_count && curlen === nextlen) {
        continue;
      } else if (count3 < min_count) {
        do {
          send_code(s2, curlen, s2.bl_tree);
        } while (--count3 !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s2, curlen, s2.bl_tree);
          count3--;
        }
        send_code(s2, REP_3_6, s2.bl_tree);
        send_bits(s2, count3 - 3, 2);
      } else if (count3 <= 10) {
        send_code(s2, REPZ_3_10, s2.bl_tree);
        send_bits(s2, count3 - 3, 3);
      } else {
        send_code(s2, REPZ_11_138, s2.bl_tree);
        send_bits(s2, count3 - 11, 7);
      }
      count3 = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  };
  var build_bl_tree = (s2) => {
    let max_blindex;
    scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
    scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
    build_tree(s2, s2.bl_desc);
    for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
      if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  };
  var send_all_trees = (s2, lcodes, dcodes, blcodes) => {
    let rank2;
    send_bits(s2, lcodes - 257, 5);
    send_bits(s2, dcodes - 1, 5);
    send_bits(s2, blcodes - 4, 4);
    for (rank2 = 0; rank2 < blcodes; rank2++) {
      send_bits(s2, s2.bl_tree[bl_order[rank2] * 2 + 1], 3);
    }
    send_tree(s2, s2.dyn_ltree, lcodes - 1);
    send_tree(s2, s2.dyn_dtree, dcodes - 1);
  };
  var detect_data_type = (s2) => {
    let block_mask = 4093624447;
    let n2;
    for (n2 = 0; n2 <= 31; n2++, block_mask >>>= 1) {
      if (block_mask & 1 && s2.dyn_ltree[n2 * 2] !== 0) {
        return Z_BINARY;
      }
    }
    if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
      return Z_TEXT;
    }
    for (n2 = 32; n2 < LITERALS$1; n2++) {
      if (s2.dyn_ltree[n2 * 2] !== 0) {
        return Z_TEXT;
      }
    }
    return Z_BINARY;
  };
  var static_init_done = false;
  var _tr_init$1 = (s2) => {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }
    s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
    s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
    s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
    s2.bi_buf = 0;
    s2.bi_valid = 0;
    init_block(s2);
  };
  var _tr_stored_block$1 = (s2, buf, stored_len, last) => {
    send_bits(s2, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    bi_windup(s2);
    put_short(s2, stored_len);
    put_short(s2, ~stored_len);
    if (stored_len) {
      s2.pending_buf.set(s2.window.subarray(buf, buf + stored_len), s2.pending);
    }
    s2.pending += stored_len;
  };
  var _tr_align$1 = (s2) => {
    send_bits(s2, STATIC_TREES << 1, 3);
    send_code(s2, END_BLOCK, static_ltree);
    bi_flush(s2);
  };
  var _tr_flush_block$1 = (s2, buf, stored_len, last) => {
    let opt_lenb, static_lenb;
    let max_blindex = 0;
    if (s2.level > 0) {
      if (s2.strm.data_type === Z_UNKNOWN$1) {
        s2.strm.data_type = detect_data_type(s2);
      }
      build_tree(s2, s2.l_desc);
      build_tree(s2, s2.d_desc);
      max_blindex = build_bl_tree(s2);
      opt_lenb = s2.opt_len + 3 + 7 >>> 3;
      static_lenb = s2.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block$1(s2, buf, stored_len, last);
    } else if (s2.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
      send_bits(s2, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s2, static_ltree, static_dtree);
    } else {
      send_bits(s2, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
    }
    init_block(s2);
    if (last) {
      bi_windup(s2);
    }
  };
  var _tr_tally$1 = (s2, dist, lc) => {
    s2.pending_buf[s2.sym_buf + s2.sym_next++] = dist;
    s2.pending_buf[s2.sym_buf + s2.sym_next++] = dist >> 8;
    s2.pending_buf[s2.sym_buf + s2.sym_next++] = lc;
    if (dist === 0) {
      s2.dyn_ltree[lc * 2]++;
    } else {
      s2.matches++;
      dist--;
      s2.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
      s2.dyn_dtree[d_code(dist) * 2]++;
    }
    return s2.sym_next === s2.sym_end;
  };
  var _tr_init_1 = _tr_init$1;
  var _tr_stored_block_1 = _tr_stored_block$1;
  var _tr_flush_block_1 = _tr_flush_block$1;
  var _tr_tally_1 = _tr_tally$1;
  var _tr_align_1 = _tr_align$1;
  var trees = {
    _tr_init: _tr_init_1,
    _tr_stored_block: _tr_stored_block_1,
    _tr_flush_block: _tr_flush_block_1,
    _tr_tally: _tr_tally_1,
    _tr_align: _tr_align_1
  };
  var adler32 = (adler, buf, len2, pos) => {
    let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n2 = 0;
    while (len2 !== 0) {
      n2 = len2 > 2e3 ? 2e3 : len2;
      len2 -= n2;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n2);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  };
  var adler32_1 = adler32;
  var makeTable = () => {
    let c2, table2 = [];
    for (var n2 = 0; n2 < 256; n2++) {
      c2 = n2;
      for (var k2 = 0; k2 < 8; k2++) {
        c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
      }
      table2[n2] = c2;
    }
    return table2;
  };
  var crcTable = new Uint32Array(makeTable());
  var crc32 = (crc, buf, len2, pos) => {
    const t2 = crcTable;
    const end = pos + len2;
    crc ^= -1;
    for (let i2 = pos; i2 < end; i2++) {
      crc = crc >>> 8 ^ t2[(crc ^ buf[i2]) & 255];
    }
    return crc ^ -1;
  };
  var crc32_1 = crc32;
  var messages = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  };
  var constants$2 = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  };
  var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
  var {
    Z_NO_FLUSH: Z_NO_FLUSH$2,
    Z_PARTIAL_FLUSH,
    Z_FULL_FLUSH: Z_FULL_FLUSH$1,
    Z_FINISH: Z_FINISH$3,
    Z_BLOCK: Z_BLOCK$1,
    Z_OK: Z_OK$3,
    Z_STREAM_END: Z_STREAM_END$3,
    Z_STREAM_ERROR: Z_STREAM_ERROR$2,
    Z_DATA_ERROR: Z_DATA_ERROR$2,
    Z_BUF_ERROR: Z_BUF_ERROR$1,
    Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
    Z_FILTERED,
    Z_HUFFMAN_ONLY,
    Z_RLE,
    Z_FIXED,
    Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
    Z_UNKNOWN,
    Z_DEFLATED: Z_DEFLATED$2
  } = constants$2;
  var MAX_MEM_LEVEL = 9;
  var MAX_WBITS$1 = 15;
  var DEF_MEM_LEVEL = 8;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  var PRESET_DICT = 32;
  var INIT_STATE = 42;
  var GZIP_STATE = 57;
  var EXTRA_STATE = 69;
  var NAME_STATE = 73;
  var COMMENT_STATE = 91;
  var HCRC_STATE = 103;
  var BUSY_STATE = 113;
  var FINISH_STATE = 666;
  var BS_NEED_MORE = 1;
  var BS_BLOCK_DONE = 2;
  var BS_FINISH_STARTED = 3;
  var BS_FINISH_DONE = 4;
  var OS_CODE = 3;
  var err = (strm, errorCode) => {
    strm.msg = messages[errorCode];
    return errorCode;
  };
  var rank = (f2) => {
    return f2 * 2 - (f2 > 4 ? 9 : 0);
  };
  var zero = (buf) => {
    let len2 = buf.length;
    while (--len2 >= 0) {
      buf[len2] = 0;
    }
  };
  var slide_hash = (s2) => {
    let n2, m2;
    let p2;
    let wsize = s2.w_size;
    n2 = s2.hash_size;
    p2 = n2;
    do {
      m2 = s2.head[--p2];
      s2.head[p2] = m2 >= wsize ? m2 - wsize : 0;
    } while (--n2);
    n2 = wsize;
    p2 = n2;
    do {
      m2 = s2.prev[--p2];
      s2.prev[p2] = m2 >= wsize ? m2 - wsize : 0;
    } while (--n2);
  };
  var HASH_ZLIB = (s2, prev2, data) => (prev2 << s2.hash_shift ^ data) & s2.hash_mask;
  var HASH = HASH_ZLIB;
  var flush_pending = (strm) => {
    const s2 = strm.state;
    let len2 = s2.pending;
    if (len2 > strm.avail_out) {
      len2 = strm.avail_out;
    }
    if (len2 === 0) {
      return;
    }
    strm.output.set(s2.pending_buf.subarray(s2.pending_out, s2.pending_out + len2), strm.next_out);
    strm.next_out += len2;
    s2.pending_out += len2;
    strm.total_out += len2;
    strm.avail_out -= len2;
    s2.pending -= len2;
    if (s2.pending === 0) {
      s2.pending_out = 0;
    }
  };
  var flush_block_only = (s2, last) => {
    _tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last);
    s2.block_start = s2.strstart;
    flush_pending(s2.strm);
  };
  var put_byte = (s2, b2) => {
    s2.pending_buf[s2.pending++] = b2;
  };
  var putShortMSB = (s2, b2) => {
    s2.pending_buf[s2.pending++] = b2 >>> 8 & 255;
    s2.pending_buf[s2.pending++] = b2 & 255;
  };
  var read_buf = (strm, buf, start, size4) => {
    let len2 = strm.avail_in;
    if (len2 > size4) {
      len2 = size4;
    }
    if (len2 === 0) {
      return 0;
    }
    strm.avail_in -= len2;
    buf.set(strm.input.subarray(strm.next_in, strm.next_in + len2), start);
    if (strm.state.wrap === 1) {
      strm.adler = adler32_1(strm.adler, buf, len2, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc32_1(strm.adler, buf, len2, start);
    }
    strm.next_in += len2;
    strm.total_in += len2;
    return len2;
  };
  var longest_match = (s2, cur_match) => {
    let chain_length = s2.max_chain_length;
    let scan = s2.strstart;
    let match2;
    let len2;
    let best_len = s2.prev_length;
    let nice_match = s2.nice_match;
    const limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
    const _win = s2.window;
    const wmask = s2.w_mask;
    const prev2 = s2.prev;
    const strend = s2.strstart + MAX_MATCH;
    let scan_end1 = _win[scan + best_len - 1];
    let scan_end = _win[scan + best_len];
    if (s2.prev_length >= s2.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s2.lookahead) {
      nice_match = s2.lookahead;
    }
    do {
      match2 = cur_match;
      if (_win[match2 + best_len] !== scan_end || _win[match2 + best_len - 1] !== scan_end1 || _win[match2] !== _win[scan] || _win[++match2] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match2++;
      do {
      } while (_win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && _win[++scan] === _win[++match2] && scan < strend);
      len2 = MAX_MATCH - (strend - scan);
      scan = strend - MAX_MATCH;
      if (len2 > best_len) {
        s2.match_start = cur_match;
        best_len = len2;
        if (len2 >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev2[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s2.lookahead) {
      return best_len;
    }
    return s2.lookahead;
  };
  var fill_window = (s2) => {
    const _w_size = s2.w_size;
    let n2, more, str;
    do {
      more = s2.window_size - s2.lookahead - s2.strstart;
      if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        s2.window.set(s2.window.subarray(_w_size, _w_size + _w_size - more), 0);
        s2.match_start -= _w_size;
        s2.strstart -= _w_size;
        s2.block_start -= _w_size;
        if (s2.insert > s2.strstart) {
          s2.insert = s2.strstart;
        }
        slide_hash(s2);
        more += _w_size;
      }
      if (s2.strm.avail_in === 0) {
        break;
      }
      n2 = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
      s2.lookahead += n2;
      if (s2.lookahead + s2.insert >= MIN_MATCH) {
        str = s2.strstart - s2.insert;
        s2.ins_h = s2.window[str];
        s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + 1]);
        while (s2.insert) {
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + MIN_MATCH - 1]);
          s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
          s2.head[s2.ins_h] = str;
          str++;
          s2.insert--;
          if (s2.lookahead + s2.insert < MIN_MATCH) {
            break;
          }
        }
      }
    } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
  };
  var deflate_stored = (s2, flush) => {
    let min_block = s2.pending_buf_size - 5 > s2.w_size ? s2.w_size : s2.pending_buf_size - 5;
    let len2, left, have, last = 0;
    let used = s2.strm.avail_in;
    do {
      len2 = 65535;
      have = s2.bi_valid + 42 >> 3;
      if (s2.strm.avail_out < have) {
        break;
      }
      have = s2.strm.avail_out - have;
      left = s2.strstart - s2.block_start;
      if (len2 > left + s2.strm.avail_in) {
        len2 = left + s2.strm.avail_in;
      }
      if (len2 > have) {
        len2 = have;
      }
      if (len2 < min_block && (len2 === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len2 !== left + s2.strm.avail_in)) {
        break;
      }
      last = flush === Z_FINISH$3 && len2 === left + s2.strm.avail_in ? 1 : 0;
      _tr_stored_block(s2, 0, 0, last);
      s2.pending_buf[s2.pending - 4] = len2;
      s2.pending_buf[s2.pending - 3] = len2 >> 8;
      s2.pending_buf[s2.pending - 2] = ~len2;
      s2.pending_buf[s2.pending - 1] = ~len2 >> 8;
      flush_pending(s2.strm);
      if (left) {
        if (left > len2) {
          left = len2;
        }
        s2.strm.output.set(s2.window.subarray(s2.block_start, s2.block_start + left), s2.strm.next_out);
        s2.strm.next_out += left;
        s2.strm.avail_out -= left;
        s2.strm.total_out += left;
        s2.block_start += left;
        len2 -= left;
      }
      if (len2) {
        read_buf(s2.strm, s2.strm.output, s2.strm.next_out, len2);
        s2.strm.next_out += len2;
        s2.strm.avail_out -= len2;
        s2.strm.total_out += len2;
      }
    } while (last === 0);
    used -= s2.strm.avail_in;
    if (used) {
      if (used >= s2.w_size) {
        s2.matches = 2;
        s2.window.set(s2.strm.input.subarray(s2.strm.next_in - s2.w_size, s2.strm.next_in), 0);
        s2.strstart = s2.w_size;
        s2.insert = s2.strstart;
      } else {
        if (s2.window_size - s2.strstart <= used) {
          s2.strstart -= s2.w_size;
          s2.window.set(s2.window.subarray(s2.w_size, s2.w_size + s2.strstart), 0);
          if (s2.matches < 2) {
            s2.matches++;
          }
          if (s2.insert > s2.strstart) {
            s2.insert = s2.strstart;
          }
        }
        s2.window.set(s2.strm.input.subarray(s2.strm.next_in - used, s2.strm.next_in), s2.strstart);
        s2.strstart += used;
        s2.insert += used > s2.w_size - s2.insert ? s2.w_size - s2.insert : used;
      }
      s2.block_start = s2.strstart;
    }
    if (s2.high_water < s2.strstart) {
      s2.high_water = s2.strstart;
    }
    if (last) {
      return BS_FINISH_DONE;
    }
    if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s2.strm.avail_in === 0 && s2.strstart === s2.block_start) {
      return BS_BLOCK_DONE;
    }
    have = s2.window_size - s2.strstart;
    if (s2.strm.avail_in > have && s2.block_start >= s2.w_size) {
      s2.block_start -= s2.w_size;
      s2.strstart -= s2.w_size;
      s2.window.set(s2.window.subarray(s2.w_size, s2.w_size + s2.strstart), 0);
      if (s2.matches < 2) {
        s2.matches++;
      }
      have += s2.w_size;
      if (s2.insert > s2.strstart) {
        s2.insert = s2.strstart;
      }
    }
    if (have > s2.strm.avail_in) {
      have = s2.strm.avail_in;
    }
    if (have) {
      read_buf(s2.strm, s2.window, s2.strstart, have);
      s2.strstart += have;
      s2.insert += have > s2.w_size - s2.insert ? s2.w_size - s2.insert : have;
    }
    if (s2.high_water < s2.strstart) {
      s2.high_water = s2.strstart;
    }
    have = s2.bi_valid + 42 >> 3;
    have = s2.pending_buf_size - have > 65535 ? 65535 : s2.pending_buf_size - have;
    min_block = have > s2.w_size ? s2.w_size : have;
    left = s2.strstart - s2.block_start;
    if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s2.strm.avail_in === 0 && left <= have) {
      len2 = left > have ? have : left;
      last = flush === Z_FINISH$3 && s2.strm.avail_in === 0 && len2 === left ? 1 : 0;
      _tr_stored_block(s2, s2.block_start, len2, last);
      s2.block_start += len2;
      flush_pending(s2.strm);
    }
    return last ? BS_FINISH_STARTED : BS_NEED_MORE;
  };
  var deflate_fast = (s2, flush) => {
    let hash_head;
    let bflush;
    for (; ; ) {
      if (s2.lookahead < MIN_LOOKAHEAD) {
        fill_window(s2);
        if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        if (s2.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s2.lookahead >= MIN_MATCH) {
        s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
        hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = s2.strstart;
      }
      if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
        s2.match_length = longest_match(s2, hash_head);
      }
      if (s2.match_length >= MIN_MATCH) {
        bflush = _tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
        s2.lookahead -= s2.match_length;
        if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
          s2.match_length--;
          do {
            s2.strstart++;
            s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
            hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = s2.strstart;
          } while (--s2.match_length !== 0);
          s2.strstart++;
        } else {
          s2.strstart += s2.match_length;
          s2.match_length = 0;
          s2.ins_h = s2.window[s2.strstart];
          s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + 1]);
        }
      } else {
        bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
      }
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH$3) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.sym_next) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  var deflate_slow = (s2, flush) => {
    let hash_head;
    let bflush;
    let max_insert;
    for (; ; ) {
      if (s2.lookahead < MIN_LOOKAHEAD) {
        fill_window(s2);
        if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        if (s2.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s2.lookahead >= MIN_MATCH) {
        s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
        hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = s2.strstart;
      }
      s2.prev_length = s2.match_length;
      s2.prev_match = s2.match_start;
      s2.match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
        s2.match_length = longest_match(s2, hash_head);
        if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
          s2.match_length = MIN_MATCH - 1;
        }
      }
      if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
        max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
        bflush = _tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
        s2.lookahead -= s2.prev_length - 1;
        s2.prev_length -= 2;
        do {
          if (++s2.strstart <= max_insert) {
            s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
            hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
            s2.head[s2.ins_h] = s2.strstart;
          }
        } while (--s2.prev_length !== 0);
        s2.match_available = 0;
        s2.match_length = MIN_MATCH - 1;
        s2.strstart++;
        if (bflush) {
          flush_block_only(s2, false);
          if (s2.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      } else if (s2.match_available) {
        bflush = _tr_tally(s2, 0, s2.window[s2.strstart - 1]);
        if (bflush) {
          flush_block_only(s2, false);
        }
        s2.strstart++;
        s2.lookahead--;
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        s2.match_available = 1;
        s2.strstart++;
        s2.lookahead--;
      }
    }
    if (s2.match_available) {
      bflush = _tr_tally(s2, 0, s2.window[s2.strstart - 1]);
      s2.match_available = 0;
    }
    s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH$3) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.sym_next) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  var deflate_rle = (s2, flush) => {
    let bflush;
    let prev2;
    let scan, strend;
    const _win = s2.window;
    for (; ; ) {
      if (s2.lookahead <= MAX_MATCH) {
        fill_window(s2);
        if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        if (s2.lookahead === 0) {
          break;
        }
      }
      s2.match_length = 0;
      if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
        scan = s2.strstart - 1;
        prev2 = _win[scan];
        if (prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan]) {
          strend = s2.strstart + MAX_MATCH;
          do {
          } while (prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && prev2 === _win[++scan] && scan < strend);
          s2.match_length = MAX_MATCH - (strend - scan);
          if (s2.match_length > s2.lookahead) {
            s2.match_length = s2.lookahead;
          }
        }
      }
      if (s2.match_length >= MIN_MATCH) {
        bflush = _tr_tally(s2, 1, s2.match_length - MIN_MATCH);
        s2.lookahead -= s2.match_length;
        s2.strstart += s2.match_length;
        s2.match_length = 0;
      } else {
        bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
        s2.lookahead--;
        s2.strstart++;
      }
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s2.insert = 0;
    if (flush === Z_FINISH$3) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.sym_next) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  var deflate_huff = (s2, flush) => {
    let bflush;
    for (; ; ) {
      if (s2.lookahead === 0) {
        fill_window(s2);
        if (s2.lookahead === 0) {
          if (flush === Z_NO_FLUSH$2) {
            return BS_NEED_MORE;
          }
          break;
        }
      }
      s2.match_length = 0;
      bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
      s2.lookahead--;
      s2.strstart++;
      if (bflush) {
        flush_block_only(s2, false);
        if (s2.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s2.insert = 0;
    if (flush === Z_FINISH$3) {
      flush_block_only(s2, true);
      if (s2.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s2.sym_next) {
      flush_block_only(s2, false);
      if (s2.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  };
  function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
  var configuration_table = [
    /*      good lazy nice chain */
    new Config(0, 0, 0, 0, deflate_stored),
    /* 0 store only */
    new Config(4, 4, 8, 4, deflate_fast),
    /* 1 max speed, no lazy matches */
    new Config(4, 5, 16, 8, deflate_fast),
    /* 2 */
    new Config(4, 6, 32, 32, deflate_fast),
    /* 3 */
    new Config(4, 4, 16, 16, deflate_slow),
    /* 4 lazy matches */
    new Config(8, 16, 32, 32, deflate_slow),
    /* 5 */
    new Config(8, 16, 128, 128, deflate_slow),
    /* 6 */
    new Config(8, 32, 128, 256, deflate_slow),
    /* 7 */
    new Config(32, 128, 258, 1024, deflate_slow),
    /* 8 */
    new Config(32, 258, 258, 4096, deflate_slow)
    /* 9 max compression */
  ];
  var lm_init = (s2) => {
    s2.window_size = 2 * s2.w_size;
    zero(s2.head);
    s2.max_lazy_match = configuration_table[s2.level].max_lazy;
    s2.good_match = configuration_table[s2.level].good_length;
    s2.nice_match = configuration_table[s2.level].nice_length;
    s2.max_chain_length = configuration_table[s2.level].max_chain;
    s2.strstart = 0;
    s2.block_start = 0;
    s2.lookahead = 0;
    s2.insert = 0;
    s2.match_length = s2.prev_length = MIN_MATCH - 1;
    s2.match_available = 0;
    s2.ins_h = 0;
  };
  function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED$2;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
    this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
    this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(MAX_BITS + 1);
    this.heap = new Uint16Array(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * L_CODES + 1);
    zero(this.depth);
    this.sym_buf = 0;
    this.lit_bufsize = 0;
    this.sym_next = 0;
    this.sym_end = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  }
  var deflateStateCheck = (strm) => {
    if (!strm) {
      return 1;
    }
    const s2 = strm.state;
    if (!s2 || s2.strm !== strm || s2.status !== INIT_STATE && //#ifdef GZIP
    s2.status !== GZIP_STATE && //#endif
    s2.status !== EXTRA_STATE && s2.status !== NAME_STATE && s2.status !== COMMENT_STATE && s2.status !== HCRC_STATE && s2.status !== BUSY_STATE && s2.status !== FINISH_STATE) {
      return 1;
    }
    return 0;
  };
  var deflateResetKeep = (strm) => {
    if (deflateStateCheck(strm)) {
      return err(strm, Z_STREAM_ERROR$2);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    const s2 = strm.state;
    s2.pending = 0;
    s2.pending_out = 0;
    if (s2.wrap < 0) {
      s2.wrap = -s2.wrap;
    }
    s2.status = //#ifdef GZIP
    s2.wrap === 2 ? GZIP_STATE : (
      //#endif
      s2.wrap ? INIT_STATE : BUSY_STATE
    );
    strm.adler = s2.wrap === 2 ? 0 : 1;
    s2.last_flush = -2;
    _tr_init(s2);
    return Z_OK$3;
  };
  var deflateReset = (strm) => {
    const ret = deflateResetKeep(strm);
    if (ret === Z_OK$3) {
      lm_init(strm.state);
    }
    return ret;
  };
  var deflateSetHeader = (strm, head) => {
    if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
      return Z_STREAM_ERROR$2;
    }
    strm.state.gzhead = head;
    return Z_OK$3;
  };
  var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
    if (!strm) {
      return Z_STREAM_ERROR$2;
    }
    let wrap = 1;
    if (level === Z_DEFAULT_COMPRESSION$1) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
      return err(strm, Z_STREAM_ERROR$2);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    const s2 = new DeflateState();
    strm.state = s2;
    s2.strm = strm;
    s2.status = INIT_STATE;
    s2.wrap = wrap;
    s2.gzhead = null;
    s2.w_bits = windowBits;
    s2.w_size = 1 << s2.w_bits;
    s2.w_mask = s2.w_size - 1;
    s2.hash_bits = memLevel + 7;
    s2.hash_size = 1 << s2.hash_bits;
    s2.hash_mask = s2.hash_size - 1;
    s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s2.window = new Uint8Array(s2.w_size * 2);
    s2.head = new Uint16Array(s2.hash_size);
    s2.prev = new Uint16Array(s2.w_size);
    s2.lit_bufsize = 1 << memLevel + 6;
    s2.pending_buf_size = s2.lit_bufsize * 4;
    s2.pending_buf = new Uint8Array(s2.pending_buf_size);
    s2.sym_buf = s2.lit_bufsize;
    s2.sym_end = (s2.lit_bufsize - 1) * 3;
    s2.level = level;
    s2.strategy = strategy;
    s2.method = method;
    return deflateReset(strm);
  };
  var deflateInit = (strm, level) => {
    return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
  };
  var deflate$2 = (strm, flush) => {
    if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
    }
    const s2 = strm.state;
    if (!strm.output || strm.avail_in !== 0 && !strm.input || s2.status === FINISH_STATE && flush !== Z_FINISH$3) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
    }
    const old_flush = s2.last_flush;
    s2.last_flush = flush;
    if (s2.pending !== 0) {
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s2.last_flush = -1;
        return Z_OK$3;
      }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
      return err(strm, Z_BUF_ERROR$1);
    }
    if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR$1);
    }
    if (s2.status === INIT_STATE && s2.wrap === 0) {
      s2.status = BUSY_STATE;
    }
    if (s2.status === INIT_STATE) {
      let header = Z_DEFLATED$2 + (s2.w_bits - 8 << 4) << 8;
      let level_flags = -1;
      if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
        level_flags = 0;
      } else if (s2.level < 6) {
        level_flags = 1;
      } else if (s2.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s2.strstart !== 0) {
        header |= PRESET_DICT;
      }
      header += 31 - header % 31;
      putShortMSB(s2, header);
      if (s2.strstart !== 0) {
        putShortMSB(s2, strm.adler >>> 16);
        putShortMSB(s2, strm.adler & 65535);
      }
      strm.adler = 1;
      s2.status = BUSY_STATE;
      flush_pending(strm);
      if (s2.pending !== 0) {
        s2.last_flush = -1;
        return Z_OK$3;
      }
    }
    if (s2.status === GZIP_STATE) {
      strm.adler = 0;
      put_byte(s2, 31);
      put_byte(s2, 139);
      put_byte(s2, 8);
      if (!s2.gzhead) {
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, 0);
        put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
        put_byte(s2, OS_CODE);
        s2.status = BUSY_STATE;
        flush_pending(strm);
        if (s2.pending !== 0) {
          s2.last_flush = -1;
          return Z_OK$3;
        }
      } else {
        put_byte(
          s2,
          (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16)
        );
        put_byte(s2, s2.gzhead.time & 255);
        put_byte(s2, s2.gzhead.time >> 8 & 255);
        put_byte(s2, s2.gzhead.time >> 16 & 255);
        put_byte(s2, s2.gzhead.time >> 24 & 255);
        put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
        put_byte(s2, s2.gzhead.os & 255);
        if (s2.gzhead.extra && s2.gzhead.extra.length) {
          put_byte(s2, s2.gzhead.extra.length & 255);
          put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
        }
        if (s2.gzhead.hcrc) {
          strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending, 0);
        }
        s2.gzindex = 0;
        s2.status = EXTRA_STATE;
      }
    }
    if (s2.status === EXTRA_STATE) {
      if (s2.gzhead.extra) {
        let beg = s2.pending;
        let left = (s2.gzhead.extra.length & 65535) - s2.gzindex;
        while (s2.pending + left > s2.pending_buf_size) {
          let copy4 = s2.pending_buf_size - s2.pending;
          s2.pending_buf.set(s2.gzhead.extra.subarray(s2.gzindex, s2.gzindex + copy4), s2.pending);
          s2.pending = s2.pending_buf_size;
          if (s2.gzhead.hcrc && s2.pending > beg) {
            strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
          }
          s2.gzindex += copy4;
          flush_pending(strm);
          if (s2.pending !== 0) {
            s2.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
          left -= copy4;
        }
        let gzhead_extra = new Uint8Array(s2.gzhead.extra);
        s2.pending_buf.set(gzhead_extra.subarray(s2.gzindex, s2.gzindex + left), s2.pending);
        s2.pending += left;
        if (s2.gzhead.hcrc && s2.pending > beg) {
          strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
        }
        s2.gzindex = 0;
      }
      s2.status = NAME_STATE;
    }
    if (s2.status === NAME_STATE) {
      if (s2.gzhead.name) {
        let beg = s2.pending;
        let val;
        do {
          if (s2.pending === s2.pending_buf_size) {
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            flush_pending(strm);
            if (s2.pending !== 0) {
              s2.last_flush = -1;
              return Z_OK$3;
            }
            beg = 0;
          }
          if (s2.gzindex < s2.gzhead.name.length) {
            val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s2, val);
        } while (val !== 0);
        if (s2.gzhead.hcrc && s2.pending > beg) {
          strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
        }
        s2.gzindex = 0;
      }
      s2.status = COMMENT_STATE;
    }
    if (s2.status === COMMENT_STATE) {
      if (s2.gzhead.comment) {
        let beg = s2.pending;
        let val;
        do {
          if (s2.pending === s2.pending_buf_size) {
            if (s2.gzhead.hcrc && s2.pending > beg) {
              strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
            }
            flush_pending(strm);
            if (s2.pending !== 0) {
              s2.last_flush = -1;
              return Z_OK$3;
            }
            beg = 0;
          }
          if (s2.gzindex < s2.gzhead.comment.length) {
            val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s2, val);
        } while (val !== 0);
        if (s2.gzhead.hcrc && s2.pending > beg) {
          strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
        }
      }
      s2.status = HCRC_STATE;
    }
    if (s2.status === HCRC_STATE) {
      if (s2.gzhead.hcrc) {
        if (s2.pending + 2 > s2.pending_buf_size) {
          flush_pending(strm);
          if (s2.pending !== 0) {
            s2.last_flush = -1;
            return Z_OK$3;
          }
        }
        put_byte(s2, strm.adler & 255);
        put_byte(s2, strm.adler >> 8 & 255);
        strm.adler = 0;
      }
      s2.status = BUSY_STATE;
      flush_pending(strm);
      if (s2.pending !== 0) {
        s2.last_flush = -1;
        return Z_OK$3;
      }
    }
    if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s2.status !== FINISH_STATE) {
      let bstate = s2.level === 0 ? deflate_stored(s2, flush) : s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush) : s2.strategy === Z_RLE ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s2.status = FINISH_STATE;
      }
      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
        }
        return Z_OK$3;
      }
      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH) {
          _tr_align(s2);
        } else if (flush !== Z_BLOCK$1) {
          _tr_stored_block(s2, 0, 0, false);
          if (flush === Z_FULL_FLUSH$1) {
            zero(s2.head);
            if (s2.lookahead === 0) {
              s2.strstart = 0;
              s2.block_start = 0;
              s2.insert = 0;
            }
          }
        }
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s2.last_flush = -1;
          return Z_OK$3;
        }
      }
    }
    if (flush !== Z_FINISH$3) {
      return Z_OK$3;
    }
    if (s2.wrap <= 0) {
      return Z_STREAM_END$3;
    }
    if (s2.wrap === 2) {
      put_byte(s2, strm.adler & 255);
      put_byte(s2, strm.adler >> 8 & 255);
      put_byte(s2, strm.adler >> 16 & 255);
      put_byte(s2, strm.adler >> 24 & 255);
      put_byte(s2, strm.total_in & 255);
      put_byte(s2, strm.total_in >> 8 & 255);
      put_byte(s2, strm.total_in >> 16 & 255);
      put_byte(s2, strm.total_in >> 24 & 255);
    } else {
      putShortMSB(s2, strm.adler >>> 16);
      putShortMSB(s2, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s2.wrap > 0) {
      s2.wrap = -s2.wrap;
    }
    return s2.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
  };
  var deflateEnd = (strm) => {
    if (deflateStateCheck(strm)) {
      return Z_STREAM_ERROR$2;
    }
    const status = strm.state.status;
    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
  };
  var deflateSetDictionary = (strm, dictionary) => {
    let dictLength = dictionary.length;
    if (deflateStateCheck(strm)) {
      return Z_STREAM_ERROR$2;
    }
    const s2 = strm.state;
    const wrap = s2.wrap;
    if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
      return Z_STREAM_ERROR$2;
    }
    if (wrap === 1) {
      strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
    }
    s2.wrap = 0;
    if (dictLength >= s2.w_size) {
      if (wrap === 0) {
        zero(s2.head);
        s2.strstart = 0;
        s2.block_start = 0;
        s2.insert = 0;
      }
      let tmpDict = new Uint8Array(s2.w_size);
      tmpDict.set(dictionary.subarray(dictLength - s2.w_size, dictLength), 0);
      dictionary = tmpDict;
      dictLength = s2.w_size;
    }
    const avail = strm.avail_in;
    const next2 = strm.next_in;
    const input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s2);
    while (s2.lookahead >= MIN_MATCH) {
      let str = s2.strstart;
      let n2 = s2.lookahead - (MIN_MATCH - 1);
      do {
        s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + MIN_MATCH - 1]);
        s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
        s2.head[s2.ins_h] = str;
        str++;
      } while (--n2);
      s2.strstart = str;
      s2.lookahead = MIN_MATCH - 1;
      fill_window(s2);
    }
    s2.strstart += s2.lookahead;
    s2.block_start = s2.strstart;
    s2.insert = s2.lookahead;
    s2.lookahead = 0;
    s2.match_length = s2.prev_length = MIN_MATCH - 1;
    s2.match_available = 0;
    strm.next_in = next2;
    strm.input = input;
    strm.avail_in = avail;
    s2.wrap = wrap;
    return Z_OK$3;
  };
  var deflateInit_1 = deflateInit;
  var deflateInit2_1 = deflateInit2;
  var deflateReset_1 = deflateReset;
  var deflateResetKeep_1 = deflateResetKeep;
  var deflateSetHeader_1 = deflateSetHeader;
  var deflate_2$1 = deflate$2;
  var deflateEnd_1 = deflateEnd;
  var deflateSetDictionary_1 = deflateSetDictionary;
  var deflateInfo = "pako deflate (from Nodeca project)";
  var deflate_1$2 = {
    deflateInit: deflateInit_1,
    deflateInit2: deflateInit2_1,
    deflateReset: deflateReset_1,
    deflateResetKeep: deflateResetKeep_1,
    deflateSetHeader: deflateSetHeader_1,
    deflate: deflate_2$1,
    deflateEnd: deflateEnd_1,
    deflateSetDictionary: deflateSetDictionary_1,
    deflateInfo
  };
  var _has = (obj, key) => {
    return Object.prototype.hasOwnProperty.call(obj, key);
  };
  var assign = function(obj) {
    const sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      const source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (const p2 in source) {
        if (_has(source, p2)) {
          obj[p2] = source[p2];
        }
      }
    }
    return obj;
  };
  var flattenChunks = (chunks) => {
    let len2 = 0;
    for (let i2 = 0, l2 = chunks.length; i2 < l2; i2++) {
      len2 += chunks[i2].length;
    }
    const result = new Uint8Array(len2);
    for (let i2 = 0, pos = 0, l2 = chunks.length; i2 < l2; i2++) {
      let chunk = chunks[i2];
      result.set(chunk, pos);
      pos += chunk.length;
    }
    return result;
  };
  var common = {
    assign,
    flattenChunks
  };
  var STR_APPLY_UIA_OK = true;
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (__) {
    STR_APPLY_UIA_OK = false;
  }
  var _utf8len = new Uint8Array(256);
  for (let q = 0; q < 256; q++) {
    _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
  }
  _utf8len[254] = _utf8len[254] = 1;
  var string2buf = (str) => {
    if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
      return new TextEncoder().encode(str);
    }
    let buf, c2, c22, m_pos, i2, str_len = str.length, buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c2 = str.charCodeAt(m_pos);
      if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
        c22 = str.charCodeAt(m_pos + 1);
        if ((c22 & 64512) === 56320) {
          c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
          m_pos++;
        }
      }
      buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
    }
    buf = new Uint8Array(buf_len);
    for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
      c2 = str.charCodeAt(m_pos);
      if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
        c22 = str.charCodeAt(m_pos + 1);
        if ((c22 & 64512) === 56320) {
          c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
          m_pos++;
        }
      }
      if (c2 < 128) {
        buf[i2++] = c2;
      } else if (c2 < 2048) {
        buf[i2++] = 192 | c2 >>> 6;
        buf[i2++] = 128 | c2 & 63;
      } else if (c2 < 65536) {
        buf[i2++] = 224 | c2 >>> 12;
        buf[i2++] = 128 | c2 >>> 6 & 63;
        buf[i2++] = 128 | c2 & 63;
      } else {
        buf[i2++] = 240 | c2 >>> 18;
        buf[i2++] = 128 | c2 >>> 12 & 63;
        buf[i2++] = 128 | c2 >>> 6 & 63;
        buf[i2++] = 128 | c2 & 63;
      }
    }
    return buf;
  };
  var buf2binstring = (buf, len2) => {
    if (len2 < 65534) {
      if (buf.subarray && STR_APPLY_UIA_OK) {
        return String.fromCharCode.apply(null, buf.length === len2 ? buf : buf.subarray(0, len2));
      }
    }
    let result = "";
    for (let i2 = 0; i2 < len2; i2++) {
      result += String.fromCharCode(buf[i2]);
    }
    return result;
  };
  var buf2string = (buf, max3) => {
    const len2 = max3 || buf.length;
    if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
      return new TextDecoder().decode(buf.subarray(0, max3));
    }
    let i2, out;
    const utf16buf = new Array(len2 * 2);
    for (out = 0, i2 = 0; i2 < len2; ) {
      let c2 = buf[i2++];
      if (c2 < 128) {
        utf16buf[out++] = c2;
        continue;
      }
      let c_len = _utf8len[c2];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i2 += c_len - 1;
        continue;
      }
      c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i2 < len2) {
        c2 = c2 << 6 | buf[i2++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c2 < 65536) {
        utf16buf[out++] = c2;
      } else {
        c2 -= 65536;
        utf16buf[out++] = 55296 | c2 >> 10 & 1023;
        utf16buf[out++] = 56320 | c2 & 1023;
      }
    }
    return buf2binstring(utf16buf, out);
  };
  var utf8border = (buf, max3) => {
    max3 = max3 || buf.length;
    if (max3 > buf.length) {
      max3 = buf.length;
    }
    let pos = max3 - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max3;
    }
    if (pos === 0) {
      return max3;
    }
    return pos + _utf8len[buf[pos]] > max3 ? pos : max3;
  };
  var strings = {
    string2buf,
    buf2string,
    utf8border
  };
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  var zstream = ZStream;
  var toString$1 = Object.prototype.toString;
  var {
    Z_NO_FLUSH: Z_NO_FLUSH$1,
    Z_SYNC_FLUSH,
    Z_FULL_FLUSH,
    Z_FINISH: Z_FINISH$2,
    Z_OK: Z_OK$2,
    Z_STREAM_END: Z_STREAM_END$2,
    Z_DEFAULT_COMPRESSION,
    Z_DEFAULT_STRATEGY,
    Z_DEFLATED: Z_DEFLATED$1
  } = constants$2;
  function Deflate$1(options) {
    this.options = common.assign({
      level: Z_DEFAULT_COMPRESSION,
      method: Z_DEFLATED$1,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: Z_DEFAULT_STRATEGY
    }, options || {});
    let opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zstream();
    this.strm.avail_out = 0;
    let status = deflate_1$2.deflateInit2(
      this.strm,
      opt.level,
      opt.method,
      opt.windowBits,
      opt.memLevel,
      opt.strategy
    );
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    if (opt.header) {
      deflate_1$2.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      let dict;
      if (typeof opt.dictionary === "string") {
        dict = strings.string2buf(opt.dictionary);
      } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = deflate_1$2.deflateSetDictionary(this.strm, dict);
      if (status !== Z_OK$2) {
        throw new Error(messages[status]);
      }
      this._dict_set = true;
    }
  }
  Deflate$1.prototype.push = function(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    let status, _flush_mode;
    if (this.ended) {
      return false;
    }
    if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
    else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
    if (typeof data === "string") {
      strm.input = strings.string2buf(data);
    } else if (toString$1.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      status = deflate_1$2.deflate(strm, _flush_mode);
      if (status === Z_STREAM_END$2) {
        if (strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
        }
        status = deflate_1$2.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK$2;
      }
      if (strm.avail_out === 0) {
        this.onData(strm.output);
        continue;
      }
      if (_flush_mode > 0 && strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
        strm.avail_out = 0;
        continue;
      }
      if (strm.avail_in === 0) break;
    }
    return true;
  };
  Deflate$1.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Deflate$1.prototype.onEnd = function(status) {
    if (status === Z_OK$2) {
      this.result = common.flattenChunks(this.chunks);
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function deflate$1(input, options) {
    const deflator = new Deflate$1(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || messages[deflator.err];
    }
    return deflator.result;
  }
  function deflateRaw$1(input, options) {
    options = options || {};
    options.raw = true;
    return deflate$1(input, options);
  }
  function gzip$1(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate$1(input, options);
  }
  var Deflate_1$1 = Deflate$1;
  var deflate_2 = deflate$1;
  var deflateRaw_1$1 = deflateRaw$1;
  var gzip_1$1 = gzip$1;
  var constants$1 = constants$2;
  var deflate_1$1 = {
    Deflate: Deflate_1$1,
    deflate: deflate_2,
    deflateRaw: deflateRaw_1$1,
    gzip: gzip_1$1,
    constants: constants$1
  };
  var BAD$1 = 16209;
  var TYPE$1 = 16191;
  var inffast = function inflate_fast(strm, start) {
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let dmax;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len2;
    let dist;
    let from2;
    let from_source;
    let input, output;
    const state = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state.dmax;
    wsize = state.wsize;
    whave = state.whave;
    wnext = state.wnext;
    s_window = state.window;
    hold = state.hold;
    bits = state.bits;
    lcode = state.lencode;
    dcode = state.distcode;
    lmask = (1 << state.lenbits) - 1;
    dmask = (1 << state.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len2 = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len2 += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    if (dist > dmax) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD$1;
                      break top;
                    }
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state.sane) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD$1;
                          break top;
                        }
                      }
                      from2 = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from2 += wsize - op;
                        if (op < len2) {
                          len2 -= op;
                          do {
                            output[_out++] = s_window[from2++];
                          } while (--op);
                          from2 = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from2 += wsize + wnext - op;
                        op -= wnext;
                        if (op < len2) {
                          len2 -= op;
                          do {
                            output[_out++] = s_window[from2++];
                          } while (--op);
                          from2 = 0;
                          if (wnext < len2) {
                            op = wnext;
                            len2 -= op;
                            do {
                              output[_out++] = s_window[from2++];
                            } while (--op);
                            from2 = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from2 += wnext - op;
                        if (op < len2) {
                          len2 -= op;
                          do {
                            output[_out++] = s_window[from2++];
                          } while (--op);
                          from2 = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len2 > 2) {
                        output[_out++] = from_source[from2++];
                        output[_out++] = from_source[from2++];
                        output[_out++] = from_source[from2++];
                        len2 -= 3;
                      }
                      if (len2) {
                        output[_out++] = from_source[from2++];
                        if (len2 > 1) {
                          output[_out++] = from_source[from2++];
                        }
                      }
                    } else {
                      from2 = _out - dist;
                      do {
                        output[_out++] = output[from2++];
                        output[_out++] = output[from2++];
                        output[_out++] = output[from2++];
                        len2 -= 3;
                      } while (len2 > 2);
                      if (len2) {
                        output[_out++] = output[from2++];
                        if (len2 > 1) {
                          output[_out++] = output[from2++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state.mode = BAD$1;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state.mode = TYPE$1;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state.mode = BAD$1;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len2 = bits >> 3;
    _in -= len2;
    bits -= len2 << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state.hold = hold;
    state.bits = bits;
    return;
  };
  var MAXBITS = 15;
  var ENOUGH_LENS$1 = 852;
  var ENOUGH_DISTS$1 = 592;
  var CODES$1 = 0;
  var LENS$1 = 1;
  var DISTS$1 = 2;
  var lbase = new Uint16Array([
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ]);
  var lext = new Uint8Array([
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ]);
  var dbase = new Uint16Array([
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ]);
  var dext = new Uint8Array([
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ]);
  var inflate_table = (type, lens, lens_index, codes, table2, table_index, work, opts) => {
    const bits = opts.bits;
    let len2 = 0;
    let sym = 0;
    let min2 = 0, max3 = 0;
    let root = 0;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask;
    let next2;
    let base4 = null;
    let match2;
    const count3 = new Uint16Array(MAXBITS + 1);
    const offs = new Uint16Array(MAXBITS + 1);
    let extra = null;
    let here_bits, here_op, here_val;
    for (len2 = 0; len2 <= MAXBITS; len2++) {
      count3[len2] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count3[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max3 = MAXBITS; max3 >= 1; max3--) {
      if (count3[max3] !== 0) {
        break;
      }
    }
    if (root > max3) {
      root = max3;
    }
    if (max3 === 0) {
      table2[table_index++] = 1 << 24 | 64 << 16 | 0;
      table2[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min2 = 1; min2 < max3; min2++) {
      if (count3[min2] !== 0) {
        break;
      }
    }
    if (root < min2) {
      root = min2;
    }
    left = 1;
    for (len2 = 1; len2 <= MAXBITS; len2++) {
      left <<= 1;
      left -= count3[len2];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === CODES$1 || max3 !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len2 = 1; len2 < MAXBITS; len2++) {
      offs[len2 + 1] = offs[len2] + count3[len2];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === CODES$1) {
      base4 = extra = work;
      match2 = 20;
    } else if (type === LENS$1) {
      base4 = lbase;
      extra = lext;
      match2 = 257;
    } else {
      base4 = dbase;
      extra = dext;
      match2 = 0;
    }
    huff = 0;
    sym = 0;
    len2 = min2;
    next2 = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
      return 1;
    }
    for (; ; ) {
      here_bits = len2 - drop;
      if (work[sym] + 1 < match2) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] >= match2) {
        here_op = extra[work[sym] - match2];
        here_val = base4[work[sym] - match2];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len2 - drop;
      fill = 1 << curr;
      min2 = fill;
      do {
        fill -= incr;
        table2[next2 + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len2 - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count3[len2] === 0) {
        if (len2 === max3) {
          break;
        }
        len2 = lens[lens_index + work[sym]];
      }
      if (len2 > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next2 += min2;
        curr = len2 - drop;
        left = 1 << curr;
        while (curr + drop < max3) {
          left -= count3[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
          return 1;
        }
        low = huff & mask;
        table2[low] = root << 24 | curr << 16 | next2 - table_index | 0;
      }
    }
    if (huff !== 0) {
      table2[next2 + huff] = len2 - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  };
  var inftrees = inflate_table;
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var {
    Z_FINISH: Z_FINISH$1,
    Z_BLOCK,
    Z_TREES,
    Z_OK: Z_OK$1,
    Z_STREAM_END: Z_STREAM_END$1,
    Z_NEED_DICT: Z_NEED_DICT$1,
    Z_STREAM_ERROR: Z_STREAM_ERROR$1,
    Z_DATA_ERROR: Z_DATA_ERROR$1,
    Z_MEM_ERROR: Z_MEM_ERROR$1,
    Z_BUF_ERROR,
    Z_DEFLATED
  } = constants$2;
  var HEAD = 16180;
  var FLAGS = 16181;
  var TIME = 16182;
  var OS = 16183;
  var EXLEN = 16184;
  var EXTRA = 16185;
  var NAME = 16186;
  var COMMENT = 16187;
  var HCRC = 16188;
  var DICTID = 16189;
  var DICT = 16190;
  var TYPE = 16191;
  var TYPEDO = 16192;
  var STORED = 16193;
  var COPY_ = 16194;
  var COPY = 16195;
  var TABLE = 16196;
  var LENLENS = 16197;
  var CODELENS = 16198;
  var LEN_ = 16199;
  var LEN = 16200;
  var LENEXT = 16201;
  var DIST = 16202;
  var DISTEXT = 16203;
  var MATCH = 16204;
  var LIT = 16205;
  var CHECK = 16206;
  var LENGTH = 16207;
  var DONE = 16208;
  var BAD = 16209;
  var MEM = 16210;
  var SYNC = 16211;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var MAX_WBITS = 15;
  var DEF_WBITS = MAX_WBITS;
  var zswap32 = (q) => {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  };
  function InflateState() {
    this.strm = null;
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
  var inflateStateCheck = (strm) => {
    if (!strm) {
      return 1;
    }
    const state = strm.state;
    if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
      return 1;
    }
    return 0;
  };
  var inflateResetKeep = (strm) => {
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    const state = strm.state;
    strm.total_in = strm.total_out = state.total = 0;
    strm.msg = "";
    if (state.wrap) {
      strm.adler = state.wrap & 1;
    }
    state.mode = HEAD;
    state.last = 0;
    state.havedict = 0;
    state.flags = -1;
    state.dmax = 32768;
    state.head = null;
    state.hold = 0;
    state.bits = 0;
    state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
    state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
    state.sane = 1;
    state.back = -1;
    return Z_OK$1;
  };
  var inflateReset = (strm) => {
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    const state = strm.state;
    state.wsize = 0;
    state.whave = 0;
    state.wnext = 0;
    return inflateResetKeep(strm);
  };
  var inflateReset2 = (strm, windowBits) => {
    let wrap;
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    const state = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 5;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR$1;
    }
    if (state.window !== null && state.wbits !== windowBits) {
      state.window = null;
    }
    state.wrap = wrap;
    state.wbits = windowBits;
    return inflateReset(strm);
  };
  var inflateInit2 = (strm, windowBits) => {
    if (!strm) {
      return Z_STREAM_ERROR$1;
    }
    const state = new InflateState();
    strm.state = state;
    state.strm = strm;
    state.window = null;
    state.mode = HEAD;
    const ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK$1) {
      strm.state = null;
    }
    return ret;
  };
  var inflateInit = (strm) => {
    return inflateInit2(strm, DEF_WBITS);
  };
  var virgin = true;
  var lenfix;
  var distfix;
  var fixedtables = (state) => {
    if (virgin) {
      lenfix = new Int32Array(512);
      distfix = new Int32Array(32);
      let sym = 0;
      while (sym < 144) {
        state.lens[sym++] = 8;
      }
      while (sym < 256) {
        state.lens[sym++] = 9;
      }
      while (sym < 280) {
        state.lens[sym++] = 7;
      }
      while (sym < 288) {
        state.lens[sym++] = 8;
      }
      inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
      sym = 0;
      while (sym < 32) {
        state.lens[sym++] = 5;
      }
      inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
      virgin = false;
    }
    state.lencode = lenfix;
    state.lenbits = 9;
    state.distcode = distfix;
    state.distbits = 5;
  };
  var updatewindow = (strm, src, end, copy4) => {
    let dist;
    const state = strm.state;
    if (state.window === null) {
      state.wsize = 1 << state.wbits;
      state.wnext = 0;
      state.whave = 0;
      state.window = new Uint8Array(state.wsize);
    }
    if (copy4 >= state.wsize) {
      state.window.set(src.subarray(end - state.wsize, end), 0);
      state.wnext = 0;
      state.whave = state.wsize;
    } else {
      dist = state.wsize - state.wnext;
      if (dist > copy4) {
        dist = copy4;
      }
      state.window.set(src.subarray(end - copy4, end - copy4 + dist), state.wnext);
      copy4 -= dist;
      if (copy4) {
        state.window.set(src.subarray(end - copy4, end), 0);
        state.wnext = copy4;
        state.whave = state.wsize;
      } else {
        state.wnext += dist;
        if (state.wnext === state.wsize) {
          state.wnext = 0;
        }
        if (state.whave < state.wsize) {
          state.whave += dist;
        }
      }
    }
    return 0;
  };
  var inflate$2 = (strm, flush) => {
    let state;
    let input, output;
    let next2;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in, _out;
    let copy4;
    let from2;
    let from_source;
    let here = 0;
    let here_bits, here_op, here_val;
    let last_bits, last_op, last_val;
    let len2;
    let ret;
    const hbuf = new Uint8Array(4);
    let opts;
    let n2;
    const order = (
      /* permutation of code lengths */
      new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
    );
    if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR$1;
    }
    state = strm.state;
    if (state.mode === TYPE) {
      state.mode = TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next2 = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state.hold;
    bits = state.bits;
    _in = have;
    _out = left;
    ret = Z_OK$1;
    inf_leave:
      for (; ; ) {
        switch (state.mode) {
          case HEAD:
            if (state.wrap === 0) {
              state.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (state.wrap & 2 && hold === 35615) {
              if (state.wbits === 0) {
                state.wbits = 15;
              }
              state.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state.mode = FLAGS;
              break;
            }
            if (state.head) {
              state.head.done = false;
            }
            if (!(state.wrap & 1) || /* check if zlib header allowed */
            (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len2 = (hold & 15) + 8;
            if (state.wbits === 0) {
              state.wbits = len2;
            }
            if (len2 > 15 || len2 > state.wbits) {
              strm.msg = "invalid window size";
              state.mode = BAD;
              break;
            }
            state.dmax = 1 << state.wbits;
            state.flags = 0;
            strm.adler = state.check = 1;
            state.mode = hold & 512 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.flags = hold;
            if ((state.flags & 255) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state.mode = BAD;
              break;
            }
            if (state.flags & 57344) {
              strm.msg = "unknown header flags set";
              state.mode = BAD;
              break;
            }
            if (state.head) {
              state.head.text = hold >> 8 & 1;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = TIME;
          /* falls through */
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.time = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state.check = crc32_1(state.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = OS;
          /* falls through */
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (state.head) {
              state.head.xflags = hold & 255;
              state.head.os = hold >> 8;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state.mode = EXLEN;
          /* falls through */
          case EXLEN:
            if (state.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              state.length = hold;
              if (state.head) {
                state.head.extra_len = hold;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32_1(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state.head) {
              state.head.extra = null;
            }
            state.mode = EXTRA;
          /* falls through */
          case EXTRA:
            if (state.flags & 1024) {
              copy4 = state.length;
              if (copy4 > have) {
                copy4 = have;
              }
              if (copy4) {
                if (state.head) {
                  len2 = state.head.extra_len - state.length;
                  if (!state.head.extra) {
                    state.head.extra = new Uint8Array(state.head.extra_len);
                  }
                  state.head.extra.set(
                    input.subarray(
                      next2,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      next2 + copy4
                    ),
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    len2
                  );
                }
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32_1(state.check, input, copy4, next2);
                }
                have -= copy4;
                next2 += copy4;
                state.length -= copy4;
              }
              if (state.length) {
                break inf_leave;
              }
            }
            state.length = 0;
            state.mode = NAME;
          /* falls through */
          case NAME:
            if (state.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy4 = 0;
              do {
                len2 = input[next2 + copy4++];
                if (state.head && len2 && state.length < 65536) {
                  state.head.name += String.fromCharCode(len2);
                }
              } while (len2 && copy4 < have);
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy4, next2);
              }
              have -= copy4;
              next2 += copy4;
              if (len2) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.name = null;
            }
            state.length = 0;
            state.mode = COMMENT;
          /* falls through */
          case COMMENT:
            if (state.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy4 = 0;
              do {
                len2 = input[next2 + copy4++];
                if (state.head && len2 && state.length < 65536) {
                  state.head.comment += String.fromCharCode(len2);
                }
              } while (len2 && copy4 < have);
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy4, next2);
              }
              have -= copy4;
              next2 += copy4;
              if (len2) {
                break inf_leave;
              }
            } else if (state.head) {
              state.head.comment = null;
            }
            state.mode = HCRC;
          /* falls through */
          case HCRC:
            if (state.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              if (state.wrap & 4 && hold !== (state.check & 65535)) {
                strm.msg = "header crc mismatch";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state.head) {
              state.head.hcrc = state.flags >> 9 & 1;
              state.head.done = true;
            }
            strm.adler = state.check = 0;
            state.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            strm.adler = state.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state.mode = DICT;
          /* falls through */
          case DICT:
            if (state.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next2;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              return Z_NEED_DICT$1;
            }
            strm.adler = state.check = 1;
            state.mode = TYPE;
          /* falls through */
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case TYPEDO:
            if (state.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state.mode = STORED;
                break;
              case 1:
                fixedtables(state);
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state.mode = BAD;
              break;
            }
            state.length = hold & 65535;
            hold = 0;
            bits = 0;
            state.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case COPY_:
            state.mode = COPY;
          /* falls through */
          case COPY:
            copy4 = state.length;
            if (copy4) {
              if (copy4 > have) {
                copy4 = have;
              }
              if (copy4 > left) {
                copy4 = left;
              }
              if (copy4 === 0) {
                break inf_leave;
              }
              output.set(input.subarray(next2, next2 + copy4), put);
              have -= copy4;
              next2 += copy4;
              left -= copy4;
              put += copy4;
              state.length -= copy4;
              break;
            }
            state.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            state.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state.nlen > 286 || state.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = LENLENS;
          /* falls through */
          case LENLENS:
            while (state.have < state.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              state.lens[order[state.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state.have < 19) {
              state.lens[order[state.have++]] = 0;
            }
            state.lencode = state.lendyn;
            state.lenbits = 7;
            opts = { bits: state.lenbits };
            ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state.mode = BAD;
              break;
            }
            state.have = 0;
            state.mode = CODELENS;
          /* falls through */
          case CODELENS:
            while (state.have < state.nlen + state.ndist) {
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state.lens[state.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n2 = here_bits + 2;
                  while (bits < n2) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  len2 = state.lens[state.have - 1];
                  copy4 = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n2 = here_bits + 3;
                  while (bits < n2) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len2 = 0;
                  copy4 = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n2 = here_bits + 7;
                  while (bits < n2) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next2++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len2 = 0;
                  copy4 = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state.have + copy4 > state.nlen + state.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                while (copy4--) {
                  state.lens[state.have++] = len2;
                }
              }
            }
            if (state.mode === BAD) {
              break;
            }
            if (state.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state.mode = BAD;
              break;
            }
            state.lenbits = 9;
            opts = { bits: state.lenbits };
            ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
            state.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state.mode = BAD;
              break;
            }
            state.distbits = 6;
            state.distcode = state.distdyn;
            opts = { bits: state.distbits };
            ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
            state.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state.mode = BAD;
              break;
            }
            state.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case LEN_:
            state.mode = LEN;
          /* falls through */
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next2;
              strm.avail_in = have;
              state.hold = hold;
              state.bits = bits;
              inffast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next2 = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state.hold;
              bits = state.bits;
              if (state.mode === TYPE) {
                state.back = -1;
              }
              break;
            }
            state.back = 0;
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            state.length = here_val;
            if (here_op === 0) {
              state.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state.back = -1;
              state.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state.mode = BAD;
              break;
            }
            state.extra = here_op & 15;
            state.mode = LENEXT;
          /* falls through */
          case LENEXT:
            if (state.extra) {
              n2 = state.extra;
              while (bits < n2) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              state.length += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            state.was = state.length;
            state.mode = DIST;
          /* falls through */
          case DIST:
            for (; ; ) {
              here = state.distcode[hold & (1 << state.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next2++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state.mode = BAD;
              break;
            }
            state.offset = here_val;
            state.extra = here_op & 15;
            state.mode = DISTEXT;
          /* falls through */
          case DISTEXT:
            if (state.extra) {
              n2 = state.extra;
              while (bits < n2) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              state.offset += hold & (1 << state.extra) - 1;
              hold >>>= state.extra;
              bits -= state.extra;
              state.back += state.extra;
            }
            if (state.offset > state.dmax) {
              strm.msg = "invalid distance too far back";
              state.mode = BAD;
              break;
            }
            state.mode = MATCH;
          /* falls through */
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy4 = _out - left;
            if (state.offset > copy4) {
              copy4 = state.offset - copy4;
              if (copy4 > state.whave) {
                if (state.sane) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
              }
              if (copy4 > state.wnext) {
                copy4 -= state.wnext;
                from2 = state.wsize - copy4;
              } else {
                from2 = state.wnext - copy4;
              }
              if (copy4 > state.length) {
                copy4 = state.length;
              }
              from_source = state.window;
            } else {
              from_source = output;
              from2 = put - state.offset;
              copy4 = state.length;
            }
            if (copy4 > left) {
              copy4 = left;
            }
            left -= copy4;
            state.length -= copy4;
            do {
              output[put++] = from_source[from2++];
            } while (--copy4);
            if (state.length === 0) {
              state.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state.length;
            left--;
            state.mode = LEN;
            break;
          case CHECK:
            if (state.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next2++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state.total += _out;
              if (state.wrap & 4 && _out) {
                strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
                state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
              }
              _out = left;
              if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
                strm.msg = "incorrect data check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = LENGTH;
          /* falls through */
          case LENGTH:
            if (state.wrap && state.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next2++] << bits;
                bits += 8;
              }
              if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state.mode = DONE;
          /* falls through */
          case DONE:
            ret = Z_STREAM_END$1;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR$1;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR$1;
          case SYNC:
          /* falls through */
          default:
            return Z_STREAM_ERROR$1;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next2;
    strm.avail_in = have;
    state.hold = hold;
    state.bits = bits;
    if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state.total += _out;
    if (state.wrap & 4 && _out) {
      strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
      state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
      ret = Z_BUF_ERROR;
    }
    return ret;
  };
  var inflateEnd = (strm) => {
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    let state = strm.state;
    if (state.window) {
      state.window = null;
    }
    strm.state = null;
    return Z_OK$1;
  };
  var inflateGetHeader = (strm, head) => {
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    const state = strm.state;
    if ((state.wrap & 2) === 0) {
      return Z_STREAM_ERROR$1;
    }
    state.head = head;
    head.done = false;
    return Z_OK$1;
  };
  var inflateSetDictionary = (strm, dictionary) => {
    const dictLength = dictionary.length;
    let state;
    let dictid;
    let ret;
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    state = strm.state;
    if (state.wrap !== 0 && state.mode !== DICT) {
      return Z_STREAM_ERROR$1;
    }
    if (state.mode === DICT) {
      dictid = 1;
      dictid = adler32_1(dictid, dictionary, dictLength, 0);
      if (dictid !== state.check) {
        return Z_DATA_ERROR$1;
      }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state.mode = MEM;
      return Z_MEM_ERROR$1;
    }
    state.havedict = 1;
    return Z_OK$1;
  };
  var inflateReset_1 = inflateReset;
  var inflateReset2_1 = inflateReset2;
  var inflateResetKeep_1 = inflateResetKeep;
  var inflateInit_1 = inflateInit;
  var inflateInit2_1 = inflateInit2;
  var inflate_2$1 = inflate$2;
  var inflateEnd_1 = inflateEnd;
  var inflateGetHeader_1 = inflateGetHeader;
  var inflateSetDictionary_1 = inflateSetDictionary;
  var inflateInfo = "pako inflate (from Nodeca project)";
  var inflate_1$2 = {
    inflateReset: inflateReset_1,
    inflateReset2: inflateReset2_1,
    inflateResetKeep: inflateResetKeep_1,
    inflateInit: inflateInit_1,
    inflateInit2: inflateInit2_1,
    inflate: inflate_2$1,
    inflateEnd: inflateEnd_1,
    inflateGetHeader: inflateGetHeader_1,
    inflateSetDictionary: inflateSetDictionary_1,
    inflateInfo
  };
  function GZheader() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
  var gzheader = GZheader;
  var toString = Object.prototype.toString;
  var {
    Z_NO_FLUSH,
    Z_FINISH,
    Z_OK,
    Z_STREAM_END,
    Z_NEED_DICT,
    Z_STREAM_ERROR,
    Z_DATA_ERROR,
    Z_MEM_ERROR
  } = constants$2;
  function Inflate$1(options) {
    this.options = common.assign({
      chunkSize: 1024 * 64,
      windowBits: 15,
      to: ""
    }, options || {});
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zstream();
    this.strm.avail_out = 0;
    let status = inflate_1$2.inflateInit2(
      this.strm,
      opt.windowBits
    );
    if (status !== Z_OK) {
      throw new Error(messages[status]);
    }
    this.header = new gzheader();
    inflate_1$2.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== Z_OK) {
          throw new Error(messages[status]);
        }
      }
    }
  }
  Inflate$1.prototype.push = function(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status, _flush_mode, last_avail_out;
    if (this.ended) return false;
    if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
    else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
    if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = inflate_1$2.inflate(strm, _flush_mode);
      if (status === Z_NEED_DICT && dictionary) {
        status = inflate_1$2.inflateSetDictionary(strm, dictionary);
        if (status === Z_OK) {
          status = inflate_1$2.inflate(strm, _flush_mode);
        } else if (status === Z_DATA_ERROR) {
          status = Z_NEED_DICT;
        }
      }
      while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
        inflate_1$2.inflateReset(strm);
        status = inflate_1$2.inflate(strm, _flush_mode);
      }
      switch (status) {
        case Z_STREAM_ERROR:
        case Z_DATA_ERROR:
        case Z_NEED_DICT:
        case Z_MEM_ERROR:
          this.onEnd(status);
          this.ended = true;
          return false;
      }
      last_avail_out = strm.avail_out;
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === Z_STREAM_END) {
          if (this.options.to === "string") {
            let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
            let tail = strm.next_out - next_out_utf8;
            let utf8str = strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
            this.onData(utf8str);
          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      }
      if (status === Z_OK && last_avail_out === 0) continue;
      if (status === Z_STREAM_END) {
        status = inflate_1$2.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }
      if (strm.avail_in === 0) break;
    }
    return true;
  };
  Inflate$1.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Inflate$1.prototype.onEnd = function(status) {
    if (status === Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = common.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function inflate$1(input, options) {
    const inflator = new Inflate$1(options);
    inflator.push(input);
    if (inflator.err) throw inflator.msg || messages[inflator.err];
    return inflator.result;
  }
  function inflateRaw$1(input, options) {
    options = options || {};
    options.raw = true;
    return inflate$1(input, options);
  }
  var Inflate_1$1 = Inflate$1;
  var inflate_2 = inflate$1;
  var inflateRaw_1$1 = inflateRaw$1;
  var ungzip$1 = inflate$1;
  var constants = constants$2;
  var inflate_1$1 = {
    Inflate: Inflate_1$1,
    inflate: inflate_2,
    inflateRaw: inflateRaw_1$1,
    ungzip: ungzip$1,
    constants
  };
  var { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
  var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;

  // src/utils/fetch.ts
  async function handleFetch(url, args) {
    const response = await fetch(url, args);
    if (!response.ok) {
      throw new Error(
        `HTTP ${response.status} fetching ${url} ${await response.text()}`
      );
    }
    return response;
  }
  async function textfetch(url, args) {
    const response = await handleFetch(url, args);
    return response.text();
  }
  async function jsonfetch(url, args) {
    const response = await handleFetch(url, args);
    return response.json();
  }
  function timeout(time) {
    return new Promise((res) => setTimeout(res, time));
  }
  async function fetchWithLocalStorageCache(key, fetchFn) {
    const cachedData = localStorage.getItem(key);
    if (cachedData) {
      try {
        return JSON.parse(cachedData);
      } catch (error2) {
        console.error(`Error parsing cached data for ${key}:`, error2);
        localStorage.removeItem(key);
      }
    }
    const data = await fetchFn();
    localStorage.setItem(key, JSON.stringify(data));
    return data;
  }

  // src/LaunchMsaView/components/EnsemblGeneTree/ensemblGeneTreeUtils.ts
  var base = "https://rest.ensembl.org";
  async function geneTreeFetcher(id2) {
    const id = id2.replace(/\..*/, "");
    const { species } = await fetchWithLocalStorageCache(
      `${id}-ensembl`,
      () => jsonfetch(
        `${base}/lookup/id/${id}?content-type=application/json`
      )
    );
    const treeBase = `${base}/genetree/member/id/${species}/${id}`;
    const geneTreeResult = await fetchWithLocalStorageCache(
      `${id}-msa`,
      () => jsonfetch(
        `${treeBase}?content-type=application/json;aligned=1;sequence=pep`
      )
    );
    const tree = await fetchWithLocalStorageCache(
      `${id}-tree`,
      () => textfetch(`${treeBase}?nh_format=simple;content-type=text/x-nh`)
    );
    const res = gatherSequencesFromTree(geneTreeResult.tree);
    return {
      geneTreeId: geneTreeResult.id,
      tree,
      msa: res.map((r2) => `>${r2.id}
${r2.seq}`).join("\n"),
      treeMetadata: JSON.stringify(
        Object.fromEntries(
          res.map(
            (r2) => [
              r2.id,
              {
                genome: r2.species
              }
            ]
          )
        )
      )
    };
  }

  // src/LaunchMsaView/components/EnsemblGeneTree/useGeneTree.ts
  function useGeneTree(geneId) {
    const { data, error: error2, isLoading } = useSWR(
      () => geneId ? ["geneTree", geneId] : null,
      ([, geneId2]) => geneTreeFetcher(geneId2),
      {
        revalidateOnFocus: false,
        revalidateOnReconnect: false,
        revalidateIfStale: false
      }
    );
    return { treeData: data, isTreeLoading: isLoading, treeError: error2 };
  }

  // src/LaunchMsaView/util.ts
  var import_util6 = __toESM(require_util());
  function getTranscriptFeatures(feature) {
    const subfeatures = feature.get("subfeatures") ?? [];
    const transcripts = subfeatures.filter(
      (f2) => (f2.get("type") === "mRNA" || f2.get("type") === "transcript") && f2.get("subfeatures")?.some((s2) => s2.get("type") === "CDS")
    );
    if (transcripts.length > 0) {
      return transcripts;
    }
    return [feature];
  }
  function getTranscriptLength(feature) {
    const cdsLen = (0, import_util6.sum)(
      feature.get("subfeatures")?.filter(
        (f2) => f2.get("type")?.toLowerCase() === "cds"
      ).map((s2) => s2.get("end") - s2.get("start")) ?? []
    );
    return {
      len: Math.floor(cdsLen / 3),
      mod: cdsLen % 3
    };
  }
  function getId(val) {
    return val?.get("name") ?? val?.get("id") ?? "";
  }
  function getTranscriptDisplayName(val) {
    return val === void 0 ? "" : [val.get("name"), val.get("id")].filter((f2) => !!f2).join(" ");
  }
  function getGeneDisplayName(val) {
    return val === void 0 ? "" : [
      val.get("gene_name") ?? val.get("name"),
      val.get("id") ? `(${val.get("id")})` : ""
    ].filter((f2) => !!f2).join(" ");
  }
  function getSortedTranscriptFeatures(feature) {
    return getTranscriptFeatures(feature).toSorted(
      (a2, b2) => getTranscriptLength(b2).len - getTranscriptLength(a2).len
    );
  }
  function cleanProteinSequence(seq) {
    return seq.replaceAll("*", "").replaceAll("&", "");
  }

  // src/LaunchMsaView/components/TranscriptSelector.tsx
  var import_react10 = __toESM(require_react());
  var import_material2 = __toESM(require_material());
  var import_mui3 = __toESM(require_mui());

  // src/components/ReadOnlyTextField2.tsx
  var import_react9 = __toESM(require_react());
  var import_mui2 = __toESM(require_mui());

  // src/components/TextField2.tsx
  var import_react8 = __toESM(require_react());
  var import_material = __toESM(require_material());
  function TextField2({ children, ...rest }) {
    return /* @__PURE__ */ import_react8.default.createElement("div", null, /* @__PURE__ */ import_react8.default.createElement(import_material.TextField, { ...rest }, children));
  }
  var TextField2_default = TextField2;

  // src/components/ReadOnlyTextField2.tsx
  var useStyles2 = (0, import_mui2.makeStyles)()({
    textAreaFont: {
      fontFamily: "Courier New"
    }
  });
  function ReadOnlyTextField2({ value }) {
    const { classes } = useStyles2();
    return /* @__PURE__ */ import_react9.default.createElement(
      TextField2_default,
      {
        variant: "outlined",
        multiline: true,
        minRows: 5,
        maxRows: 10,
        fullWidth: true,
        value,
        slotProps: {
          input: {
            readOnly: true,
            classes: {
              input: classes.textAreaFont
            }
          }
        }
      }
    );
  }

  // src/LaunchMsaView/components/TranscriptSelector.tsx
  var useStyles3 = (0, import_mui3.makeStyles)()({
    flex: {
      display: "flex"
    },
    minWidth: {
      minWidth: 300
    }
  });
  function TranscriptSelector({
    feature,
    options,
    selectedTranscript,
    onTranscriptChange,
    proteinSequence,
    validSet
  }) {
    const { classes } = useStyles3();
    const [showSequence, setShowSequence] = (0, import_react10.useState)(false);
    return /* @__PURE__ */ import_react10.default.createElement(import_react10.default.Fragment, null, /* @__PURE__ */ import_react10.default.createElement("div", { className: classes.flex }, /* @__PURE__ */ import_react10.default.createElement(
      TextField2_default,
      {
        variant: "outlined",
        label: `Choose isoform of ${getGeneDisplayName(feature)}`,
        select: true,
        className: classes.minWidth,
        value: getId(selectedTranscript),
        onChange: (event) => {
          onTranscriptChange(event.target.value);
        }
      },
      options.map((val) => {
        const inSet = validSet ? validSet.has(getId(val)) : true;
        const { len: len2, mod } = getTranscriptLength(val);
        return /* @__PURE__ */ import_react10.default.createElement(import_material2.MenuItem, { value: getId(val), key: val.id(), disabled: !inSet }, getTranscriptDisplayName(val), " (", len2, " aa)", " ", mod ? ` (possible fragment)` : "", validSet ? inSet ? " (has data)" : " (no data)" : "");
      })
    ), /* @__PURE__ */ import_react10.default.createElement("div", { style: { alignContent: "center", marginLeft: 20 } }, /* @__PURE__ */ import_react10.default.createElement(
      import_material2.Button,
      {
        variant: "contained",
        color: "primary",
        onClick: () => {
          setShowSequence(!showSequence);
        }
      },
      showSequence ? "Hide sequence" : "Show sequence"
    ))), showSequence && /* @__PURE__ */ import_react10.default.createElement(
      ReadOnlyTextField2,
      {
        value: proteinSequence ? `>${getTranscriptDisplayName(selectedTranscript)}
${proteinSequence}` : "Loading..."
      }
    ));
  }

  // src/LaunchMsaView/components/useTranscriptSelection.ts
  var import_react11 = __toESM(require_react());

  // src/LaunchMsaView/components/calculateProteinSequence.ts
  var import_util8 = __toESM(require_util());
  function stitch(subfeats, sequence) {
    return subfeats.map((sub) => sequence.slice(sub.start, sub.end)).join("");
  }
  function calculateProteinSequence({
    cds,
    sequence,
    codonTable
  }) {
    const str = stitch(cds, sequence);
    let protein = "";
    for (let i2 = 0; i2 < str.length; i2 += 3) {
      protein += codonTable[str.slice(i2, i2 + 3)] ?? "&";
    }
    return protein;
  }
  function revlist(list, seqlen) {
    return list.map((sub) => ({
      ...sub,
      start: seqlen - sub.end,
      end: seqlen - sub.start
    })).toSorted((a2, b2) => a2.start - b2.start);
  }
  function getProteinSequenceFromFeature({
    feature,
    seq
  }) {
    const { subfeatures, start, strand } = feature.toJSON();
    const cds = (0, import_util8.dedupe)(
      subfeatures?.toSorted((a2, b2) => a2.start - b2.start).map((sub) => ({
        ...sub,
        start: sub.start - start,
        end: sub.end - start
      })).filter((subfeature) => subfeature.type === "CDS") ?? [],
      (feat) => `${feat.start}-${feat.end}`
    );
    return calculateProteinSequence({
      cds: strand === -1 ? revlist(cds, seq.length) : cds,
      sequence: strand === -1 ? (0, import_util8.revcom)(seq) : seq,
      codonTable: (0, import_util8.generateCodonTable)(import_util8.defaultCodonTable)
    });
  }

  // src/LaunchMsaView/components/useSWRFeatureSequence.ts
  var import_util9 = __toESM(require_util());

  // src/LaunchMsaView/components/fetchSeq.ts
  var import_configuration3 = __toESM(require_configuration());
  async function fetchSeq({
    start,
    end,
    refName,
    session,
    assemblyName
  }) {
    const { assemblyManager, rpcManager } = session;
    const assembly = await assemblyManager.waitForAssembly(assemblyName);
    if (!assembly) {
      throw new Error("assembly not found");
    }
    const sessionId = "getSequence";
    const feats = await rpcManager.call(sessionId, "CoreGetFeatures", {
      adapterConfig: (0, import_configuration3.getConf)(assembly, ["sequence", "adapter"]),
      sessionId,
      regions: [
        {
          start,
          end,
          refName: assembly.getCanonicalRefName(refName),
          assemblyName
        }
      ]
    });
    return feats[0]?.get("seq") ?? "";
  }

  // src/LaunchMsaView/components/useSWRFeatureSequence.ts
  async function featureSequenceFetcher({
    feature,
    assemblyName,
    upDownBp,
    view
  }) {
    const session = (0, import_util9.getSession)(view);
    const { start, end, refName } = feature.toJSON();
    const b2 = start - upDownBp;
    const e2 = end + upDownBp;
    const [seq, upstream, downstream] = await Promise.all([
      fetchSeq({
        start,
        end,
        refName,
        assemblyName,
        session
      }),
      fetchSeq({
        start: Math.max(0, b2),
        end: start,
        refName,
        assemblyName,
        session
      }),
      fetchSeq({
        start: end,
        end: e2,
        refName,
        assemblyName,
        session
      })
    ]);
    return { seq, upstream, downstream };
  }
  function useSWRFeatureSequence({
    view,
    feature,
    upDownBp = 0,
    forceLoad = true
  }) {
    const assemblyName = view?.assemblyNames?.[0];
    const { data, error: error2 } = useSWR(
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      feature && assemblyName && view ? [feature.id(), assemblyName, upDownBp, forceLoad, "feature-sequence"] : null,
      () => featureSequenceFetcher({
        feature,
        assemblyName,
        upDownBp,
        view
      }),
      {
        revalidateOnFocus: false,
        revalidateOnReconnect: false,
        revalidateIfStale: false
      }
    );
    return {
      sequence: data,
      error: error2
    };
  }

  // src/LaunchMsaView/components/useFeatureSequence.ts
  function useFeatureSequence({
    view,
    feature,
    upDownBp = 0,
    forceLoad = true
  }) {
    const { sequence, error: error2 } = useSWRFeatureSequence({
      view,
      feature,
      upDownBp,
      forceLoad
    });
    const proteinSequence = sequence && !("error" in sequence) && feature ? getProteinSequenceFromFeature({
      seq: sequence.seq,
      feature
    }) : "";
    return {
      proteinSequence,
      sequence,
      error: error2
    };
  }

  // src/LaunchMsaView/components/useTranscriptSelection.ts
  function useTranscriptSelection({
    feature,
    view,
    validIds
  }) {
    const options = getSortedTranscriptFeatures(feature);
    const [selectedId, setSelectedId] = (0, import_react11.useState)(getId(options[0]));
    const selectedTranscript = options.find((val) => getId(val) === selectedId);
    const { proteinSequence, error: error2 } = useFeatureSequence({
      view,
      feature: selectedTranscript
    });
    const validSet = (0, import_react11.useMemo)(
      () => validIds ? new Set(validIds) : void 0,
      [validIds]
    );
    (0, import_react11.useEffect)(() => {
      if (validIds && validIds.length > 0 && !validIds.includes(selectedId)) {
        const validOption = options.find((opt) => validIds.includes(getId(opt)));
        if (validOption) {
          setSelectedId(getId(validOption));
        }
      }
    }, [validIds, options, selectedId]);
    return {
      options,
      selectedId,
      setSelectedId,
      selectedTranscript,
      proteinSequence,
      error: error2,
      validSet
    };
  }

  // src/LaunchMsaView/components/EnsemblGeneTree/EnsemblGeneTree.tsx
  var useStyles4 = (0, import_mui4.makeStyles)()({
    dialogContent: {
      width: "80em",
      display: "flex",
      flexDirection: "column",
      gap: 16
    }
  });
  var EnsemblGeneTree = (0, import_mobx_react4.observer)(function({
    model,
    feature,
    handleClose
  }) {
    const session = (0, import_util11.getSession)(model);
    const view = (0, import_util11.getContainingView)(model);
    const { classes } = useStyles4();
    const [launchViewError, setLaunchViewError] = (0, import_react12.useState)();
    const {
      options,
      selectedId,
      setSelectedId,
      selectedTranscript,
      proteinSequence,
      error: featureSequenceError
    } = useTranscriptSelection({ feature, view });
    const { treeData, isTreeLoading, treeError } = useGeneTree(selectedId);
    const loadingMessage = isTreeLoading ? "Loading tree data from Ensembl GeneTree" : void 0;
    const e2 = treeError ?? launchViewError ?? featureSequenceError;
    return /* @__PURE__ */ import_react12.default.createElement(import_react12.default.Fragment, null, /* @__PURE__ */ import_react12.default.createElement(import_material3.DialogContent, { className: classes.dialogContent }, e2 ? /* @__PURE__ */ import_react12.default.createElement(import_ui.ErrorMessage, { error: e2 }) : null, loadingMessage ? /* @__PURE__ */ import_react12.default.createElement(import_ui.LoadingEllipses, { message: loadingMessage }) : null, treeData ? /* @__PURE__ */ import_react12.default.createElement("div", null, /* @__PURE__ */ import_react12.default.createElement("div", null, "Found Ensembl Compara GeneTree: ", treeData.geneTreeId), /* @__PURE__ */ import_react12.default.createElement(
      import_material3.Link,
      {
        target: "_blank",
        href: `https://useast.ensembl.org/Multi/GeneTree/Image?gt=${treeData.geneTreeId}`
      },
      "See ",
      treeData.geneTreeId,
      " at Ensembl"
    )) : null, /* @__PURE__ */ import_react12.default.createElement(
      TranscriptSelector,
      {
        feature,
        options,
        selectedTranscript,
        onTranscriptChange: setSelectedId,
        proteinSequence
      }
    )), /* @__PURE__ */ import_react12.default.createElement(import_material3.DialogActions, null, /* @__PURE__ */ import_react12.default.createElement(
      import_material3.Button,
      {
        color: "primary",
        variant: "contained",
        onClick: () => {
          try {
            if (!treeData) {
              return;
            }
            setLaunchViewError(void 0);
            ensemblGeneTreeLaunchView({
              feature,
              view,
              session,
              newViewTitle: getGeneDisplayName(feature),
              data: treeData
            });
            handleClose();
          } catch (e3) {
            console.error(e3);
            setLaunchViewError(e3);
          }
        }
      },
      "Submit"
    ), /* @__PURE__ */ import_react12.default.createElement(
      import_material3.Button,
      {
        color: "secondary",
        variant: "contained",
        onClick: () => {
          handleClose();
        }
      },
      "Cancel"
    )));
  });
  var EnsemblGeneTree_default = EnsemblGeneTree;

  // src/LaunchMsaView/components/ManualMSALoader/ManualMSALoader.tsx
  var import_react13 = __toESM(require_react());
  var import_ui2 = __toESM(require_ui());
  var import_util13 = __toESM(require_util());
  var import_material4 = __toESM(require_material());
  var import_mobx_react5 = __toESM(require_mobx_react());
  var import_mui5 = __toESM(require_mui());

  // src/LaunchMsaView/components/ManualMSALoader/launchView.ts
  function launchView({
    session,
    newViewTitle,
    view,
    feature,
    msaFilehandle,
    treeFilehandle,
    querySeqName,
    data
  }) {
    session.addView("MsaView", {
      type: "MsaView",
      displayName: newViewTitle,
      connectedViewId: view.id,
      connectedFeature: feature.toJSON(),
      msaFilehandle,
      treeFilehandle,
      querySeqName,
      data
    });
  }

  // src/LaunchMsaView/components/ManualMSALoader/ManualMSALoader.tsx
  var useStyles5 = (0, import_mui5.makeStyles)()({
    dialogContent: {
      width: "80em"
    },
    textAreaFont: {
      fontFamily: "Courier New"
    }
  });
  var ManualMSALoader = (0, import_mobx_react5.observer)(function PreLoadedMSA2({
    model,
    feature,
    handleClose
  }) {
    const session = (0, import_util13.getSession)(model);
    const view = (0, import_util13.getContainingView)(model);
    const { classes } = useStyles5();
    const [launchViewError, setLaunchViewError] = (0, import_react13.useState)();
    const [inputMethod, setInputMethod] = (0, import_react13.useState)("file");
    const [msaText, setMsaText] = (0, import_react13.useState)("");
    const [treeText, setTreeText] = (0, import_react13.useState)("");
    const [msaFileLocation, setMsaFileLocation] = (0, import_react13.useState)();
    const [treeFileLocation, setTreeFileLocation] = (0, import_react13.useState)();
    const [querySeqName, setQuerySeqName] = (0, import_react13.useState)("");
    const {
      options,
      setSelectedId,
      selectedTranscript,
      proteinSequence,
      error: error2
    } = useTranscriptSelection({ feature, view });
    const e2 = launchViewError ?? error2;
    return /* @__PURE__ */ import_react13.default.createElement(import_react13.default.Fragment, null, /* @__PURE__ */ import_react13.default.createElement(import_material4.DialogContent, { className: classes.dialogContent }, e2 ? /* @__PURE__ */ import_react13.default.createElement(import_ui2.ErrorMessage, { error: e2 }) : null, /* @__PURE__ */ import_react13.default.createElement(import_material4.FormControl, { component: "fieldset" }, /* @__PURE__ */ import_react13.default.createElement(
      import_material4.RadioGroup,
      {
        row: true,
        value: inputMethod,
        onChange: (event) => {
          setInputMethod(event.target.value);
        }
      },
      /* @__PURE__ */ import_react13.default.createElement(
        import_material4.FormControlLabel,
        {
          value: "file",
          control: /* @__PURE__ */ import_react13.default.createElement(import_material4.Radio, null),
          label: "Open files"
        }
      ),
      /* @__PURE__ */ import_react13.default.createElement(
        import_material4.FormControlLabel,
        {
          value: "text",
          control: /* @__PURE__ */ import_react13.default.createElement(import_material4.Radio, null),
          label: "Paste text"
        }
      )
    )), /* @__PURE__ */ import_react13.default.createElement("div", { style: { marginBottom: 30 } }, inputMethod === "file" ? /* @__PURE__ */ import_react13.default.createElement("div", { style: { maxWidth: 500 } }, /* @__PURE__ */ import_react13.default.createElement(
      import_ui2.FileSelector,
      {
        name: "MSA File .aln (Clustal), .fa/.mfa (aligned FASTA), .stock (Stockholm), etc)",
        inline: true,
        location: msaFileLocation,
        setLocation: setMsaFileLocation
      }
    ), /* @__PURE__ */ import_react13.default.createElement(
      import_ui2.FileSelector,
      {
        name: "Tree file .nh (Newick) or .asn (NCBI COBALT ASN.1)",
        inline: true,
        location: treeFileLocation,
        setLocation: setTreeFileLocation
      }
    )) : /* @__PURE__ */ import_react13.default.createElement(import_react13.default.Fragment, null, /* @__PURE__ */ import_react13.default.createElement(
      TextField2_default,
      {
        variant: "outlined",
        name: "MSA",
        multiline: true,
        minRows: 5,
        style: { marginBottom: "20px" },
        maxRows: 10,
        fullWidth: true,
        placeholder: "Paste MSA here",
        value: msaText,
        onChange: (event) => {
          setMsaText(event.target.value);
        }
      }
    ), /* @__PURE__ */ import_react13.default.createElement(
      TextField2_default,
      {
        variant: "outlined",
        name: "Tree",
        multiline: true,
        minRows: 5,
        maxRows: 10,
        fullWidth: true,
        placeholder: "Paste newick tree (optional)",
        value: treeText,
        onChange: (event) => {
          setTreeText(event.target.value);
        }
      }
    ))), /* @__PURE__ */ import_react13.default.createElement(
      TranscriptSelector,
      {
        feature,
        options,
        selectedTranscript,
        onTranscriptChange: setSelectedId,
        proteinSequence
      }
    ), /* @__PURE__ */ import_react13.default.createElement(
      TextField2_default,
      {
        variant: "outlined",
        name: "MSA row name",
        fullWidth: true,
        required: true,
        style: { marginTop: 20 },
        placeholder: "Row name in MSA that corresponds to the selected transcript",
        helperText: "Required: Specify the name of the row in your MSA that should be aligned with the selected transcript",
        value: querySeqName,
        onChange: (event) => {
          setQuerySeqName(event.target.value);
        }
      }
    ), !querySeqName.trim() && /* @__PURE__ */ import_react13.default.createElement(import_material4.Alert, { severity: "warning", style: { marginTop: 10 } }, "Without specifying the MSA row name, clicking on the MSA will not navigate to the corresponding genome position, and hovering highlights will not work.")), /* @__PURE__ */ import_react13.default.createElement(import_material4.DialogActions, null, /* @__PURE__ */ import_react13.default.createElement(
      import_material4.Button,
      {
        color: "primary",
        variant: "contained",
        disabled: !selectedTranscript || inputMethod === "file" && !msaFileLocation || inputMethod === "text" && !msaText.trim(),
        onClick: () => {
          try {
            if (!selectedTranscript) {
              return;
            }
            setLaunchViewError(void 0);
            launchView({
              session,
              newViewTitle: getGeneDisplayName(selectedTranscript),
              view,
              feature: selectedTranscript,
              querySeqName: querySeqName.trim() || void 0,
              ...inputMethod === "file" ? {
                msaFilehandle: msaFileLocation,
                treeFilehandle: treeFileLocation
              } : {
                data: {
                  msa: msaText,
                  tree: treeText || void 0
                }
              }
            });
            handleClose();
          } catch (e3) {
            console.error(e3);
            setLaunchViewError(e3);
          }
        }
      },
      "Submit"
    ), /* @__PURE__ */ import_react13.default.createElement(
      import_material4.Button,
      {
        color: "secondary",
        variant: "contained",
        onClick: () => {
          handleClose();
        }
      },
      "Cancel"
    )));
  });
  var ManualMSALoader_default = ManualMSALoader;

  // src/LaunchMsaView/components/NCBIBlastQuery/NCBIBlastPanel.tsx
  var import_react19 = __toESM(require_react());
  var import_util20 = __toESM(require_util());
  init_Settings();
  var import_material10 = __toESM(require_material());

  // src/LaunchMsaView/components/NCBIBlastQuery/NCBIBlastAutomaticPanel.tsx
  var import_react14 = __toESM(require_react());
  var import_ui3 = __toESM(require_ui());
  var import_util16 = __toESM(require_util());
  var import_material5 = __toESM(require_material());
  var import_mobx_react6 = __toESM(require_mobx_react());
  var import_mui6 = __toESM(require_mui());

  // src/LaunchMsaView/components/NCBIBlastQuery/blastLaunchView.ts
  var import_util15 = __toESM(require_util());
  function blastLaunchView({
    newViewTitle,
    view,
    feature,
    blastParams
  }) {
    return (0, import_util15.getSession)(view).addView("MsaView", {
      type: "MsaView",
      displayName: newViewTitle,
      connectedViewId: view.id,
      connectedFeature: feature.toJSON(),
      drawNodeBubbles: true,
      colWidth: 10,
      rowHeight: 12,
      blastParams
    });
  }

  // src/LaunchMsaView/components/NCBIBlastQuery/NCBIBlastAutomaticPanel.tsx
  var useStyles6 = (0, import_mui6.makeStyles)()({
    dialogContent: {
      width: "80em"
    },
    textAreaFont: {
      fontFamily: "Courier New"
    }
  });
  var blastDatabaseOptions = ["nr", "nr_cluster_seq"];
  var msaAlgorithms = ["clustalo", "muscle", "kalign", "mafft"];
  var blastPrograms = ["blastp", "quick-blastp"];
  var NCBIBlastAutomaticPanel = (0, import_mobx_react6.observer)(function({
    handleClose,
    feature,
    model,
    children,
    baseUrl
  }) {
    const { classes } = useStyles6();
    const view = (0, import_util16.getContainingView)(model);
    const [launchViewError, setLaunchViewError] = (0, import_react14.useState)();
    const [selectedBlastDatabase, setSelectedBlastDatabase] = (0, import_react14.useState)("nr");
    const [selectedMsaAlgorithm, setSelectedMsaAlgorithm] = (0, import_react14.useState)("clustalo");
    const [selectedBlastProgram, setSelectedBlastProgram] = (0, import_react14.useState)("quick-blastp");
    const {
      options,
      setSelectedId,
      selectedTranscript,
      proteinSequence,
      error: proteinSequenceError
    } = useTranscriptSelection({ feature, view });
    (0, import_react14.useEffect)(() => {
      if (selectedBlastDatabase === "nr_cluster_seq") {
        setSelectedBlastProgram("blastp");
      }
    }, [selectedBlastDatabase]);
    const e2 = proteinSequenceError ?? launchViewError;
    const style = { width: 150 };
    return /* @__PURE__ */ import_react14.default.createElement(import_react14.default.Fragment, null, /* @__PURE__ */ import_react14.default.createElement(import_material5.DialogContent, { className: classes.dialogContent }, children, e2 ? /* @__PURE__ */ import_react14.default.createElement(import_ui3.ErrorMessage, { error: e2 }) : null, /* @__PURE__ */ import_react14.default.createElement(
      TextField2_default,
      {
        variant: "outlined",
        label: "BLAST database",
        style,
        select: true,
        value: selectedBlastDatabase,
        onChange: (event) => {
          setSelectedBlastDatabase(
            event.target.value
          );
        }
      },
      blastDatabaseOptions.map((val) => /* @__PURE__ */ import_react14.default.createElement(import_material5.MenuItem, { value: val, key: val }, val))
    ), /* @__PURE__ */ import_react14.default.createElement(
      TextField2_default,
      {
        variant: "outlined",
        label: "MSA Algorithm",
        style,
        select: true,
        value: selectedMsaAlgorithm,
        onChange: (event) => {
          setSelectedMsaAlgorithm(
            event.target.value
          );
        }
      },
      msaAlgorithms.map((val) => /* @__PURE__ */ import_react14.default.createElement(import_material5.MenuItem, { value: val, key: val }, val))
    ), /* @__PURE__ */ import_react14.default.createElement("div", { style: { display: "flex" } }, /* @__PURE__ */ import_react14.default.createElement(
      TextField2_default,
      {
        variant: "outlined",
        label: "BLAST program",
        disabled: selectedBlastDatabase === "nr_cluster_seq",
        style,
        select: true,
        value: selectedBlastProgram,
        onChange: (event) => {
          setSelectedBlastProgram(
            event.target.value
          );
        }
      },
      blastPrograms.map((val) => /* @__PURE__ */ import_react14.default.createElement(import_material5.MenuItem, { value: val, key: val }, val))
    ), selectedBlastDatabase === "nr_cluster_seq" ? /* @__PURE__ */ import_react14.default.createElement(
      import_material5.Typography,
      {
        variant: "subtitle2",
        style: {
          marginLeft: 4,
          alignContent: "center"
        }
      },
      "Can only use blastp on nr_cluster_seq"
    ) : null), /* @__PURE__ */ import_react14.default.createElement(
      TranscriptSelector,
      {
        feature,
        options,
        selectedTranscript,
        onTranscriptChange: setSelectedId,
        proteinSequence
      }
    ), /* @__PURE__ */ import_react14.default.createElement(import_material5.Typography, { style: { marginTop: 20 } }, "This panel will automatically submit a query to NCBI. Using blastp can take 10+ minutes to run, quick-blastp is generally a lot faster but is not available for the clustered database. After completion, all the hits will be run through a multiple sequence alignment. Note: we are not able to currently run NCBI COBALT automatically on the BLAST results, even though that is the method NCBI uses on their website. If you need a COBALT alignment, please use the manual approach of submitting BLAST yourself and downloading the resulting files")), /* @__PURE__ */ import_react14.default.createElement(import_material5.DialogActions, null, /* @__PURE__ */ import_react14.default.createElement(
      import_material5.Button,
      {
        color: "primary",
        variant: "contained",
        onClick: () => {
          try {
            if (!selectedTranscript) {
              return;
            }
            setLaunchViewError(void 0);
            blastLaunchView({
              feature: selectedTranscript,
              view,
              newViewTitle: `BLAST - ${getGeneDisplayName(feature)} - ${getTranscriptDisplayName(selectedTranscript)}`,
              blastParams: {
                baseUrl,
                blastProgram: selectedBlastProgram,
                blastDatabase: selectedBlastDatabase,
                msaAlgorithm: selectedMsaAlgorithm,
                selectedTranscript,
                proteinSequence
              }
            });
          } catch (e3) {
            console.error(e3);
            setLaunchViewError(e3);
          }
          handleClose();
        },
        disabled: !proteinSequence
      },
      "Submit"
    ), /* @__PURE__ */ import_react14.default.createElement(
      import_material5.Button,
      {
        color: "secondary",
        variant: "contained",
        onClick: () => {
          handleClose();
        }
      },
      "Cancel"
    )));
  });
  var NCBIBlastAutomaticPanel_default = NCBIBlastAutomaticPanel;

  // src/LaunchMsaView/components/NCBIBlastQuery/NCBIBlastManualPanel.tsx
  var import_react16 = __toESM(require_react());
  var import_ui4 = __toESM(require_ui());
  var import_util18 = __toESM(require_util());
  var import_material7 = __toESM(require_material());
  var import_mobx_react7 = __toESM(require_mobx_react());
  var import_mui7 = __toESM(require_mui());
  init_ExternalLink();
  var useStyles7 = (0, import_mui7.makeStyles)()({
    dialogContent: {
      width: "80em"
    },
    textAreaFont: {
      fontFamily: "Courier New"
    },
    ncbiLink: {
      wordBreak: "break-all",
      margin: 30,
      maxWidth: 600
    }
  });
  var NCBIBlastManualPanel = (0, import_mobx_react7.observer)(function({
    handleClose,
    feature,
    model,
    children,
    baseUrl
  }) {
    const { classes } = useStyles7();
    const view = (0, import_util18.getContainingView)(model);
    const { options, setSelectedId, selectedTranscript, proteinSequence, error: error2 } = useTranscriptSelection({ feature, view });
    const s2 = cleanProteinSequence(proteinSequence);
    const link = `${baseUrl}?PAGE_TYPE=BlastSearch&PAGE=Proteins&PROGRAM=blastp&QUERY=${s2}`;
    const link2 = `${baseUrl}?PAGE_TYPE=BlastSearch&PAGE=Proteins&PROGRAM=blastp&QUERY=${(0, import_util18.shorten2)(s2, 10)}`;
    return /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, /* @__PURE__ */ import_react16.default.createElement(import_material7.DialogContent, { className: classes.dialogContent }, children, error2 ? /* @__PURE__ */ import_react16.default.createElement(import_ui4.ErrorMessage, { error: error2 }) : null, /* @__PURE__ */ import_react16.default.createElement(
      TranscriptSelector,
      {
        feature,
        options,
        selectedTranscript,
        onTranscriptChange: setSelectedId,
        proteinSequence
      }
    ), proteinSequence ? /* @__PURE__ */ import_react16.default.createElement("div", { className: classes.ncbiLink }, "Link to NCBI BLAST: ", /* @__PURE__ */ import_react16.default.createElement(ExternalLink, { href: link }, link2)) : null, /* @__PURE__ */ import_react16.default.createElement(import_material7.Typography, { style: { marginTop: 20 } }, `Click the link above and run your BLAST query, and once you have results, click "Multiple Alignment" at the top of the results page to be redirected to COBALT, NCBI's multiple sequence aligner. Once COBALT completes, you can download an MSA (.aln file) and optionally a Newick tree (.nh) and paste the results into JBrowse`)), /* @__PURE__ */ import_react16.default.createElement(import_material7.DialogActions, null, /* @__PURE__ */ import_react16.default.createElement(
      import_material7.Button,
      {
        color: "primary",
        variant: "contained",
        onClick: () => {
          handleClose();
        }
      },
      "Submit"
    ), /* @__PURE__ */ import_react16.default.createElement(
      import_material7.Button,
      {
        color: "secondary",
        variant: "contained",
        onClick: () => {
          handleClose();
        }
      },
      "Close"
    )));
  });
  var NCBIBlastManualPanel_default = NCBIBlastManualPanel;

  // src/LaunchMsaView/components/NCBIBlastQuery/NCBIBlastMethodSelector.tsx
  var import_react17 = __toESM(require_react());
  var import_material8 = __toESM(require_material());
  function NCBIBlastMethodSelector({
    lookupMethod,
    setLookupMethod
  }) {
    return /* @__PURE__ */ import_react17.default.createElement(import_material8.FormControl, { component: "fieldset" }, /* @__PURE__ */ import_react17.default.createElement(
      import_material8.RadioGroup,
      {
        row: true,
        value: lookupMethod,
        onChange: (event) => {
          setLookupMethod(event.target.value);
        }
      },
      /* @__PURE__ */ import_react17.default.createElement(
        import_material8.FormControlLabel,
        {
          value: "automatic",
          control: /* @__PURE__ */ import_react17.default.createElement(import_material8.Radio, null),
          label: "Run NCBI BLAST and load results automatically"
        }
      ),
      /* @__PURE__ */ import_react17.default.createElement(
        import_material8.FormControlLabel,
        {
          value: "manual",
          control: /* @__PURE__ */ import_react17.default.createElement(import_material8.Radio, null),
          label: "Link to NCBI BLAST and import results manually"
        }
      )
    ));
  }

  // src/LaunchMsaView/components/NCBIBlastQuery/NCBISettingsDialog.tsx
  var import_react18 = __toESM(require_react());
  var import_material9 = __toESM(require_material());

  // src/LaunchMsaView/components/NCBIBlastQuery/consts.ts
  var BASE_BLAST_URL = "https://blast.ncbi.nlm.nih.gov/Blast.cgi";

  // src/LaunchMsaView/components/NCBIBlastQuery/NCBISettingsDialog.tsx
  function NCBISettingsDialog({
    handleClose,
    baseUrl
  }) {
    const [tempBaseUrl, setTempBaseUrl] = (0, import_react18.useState)(baseUrl);
    return /* @__PURE__ */ import_react18.default.createElement(
      import_material9.Dialog,
      {
        open: true,
        maxWidth: "lg",
        onClose: () => {
          handleClose();
        }
      },
      /* @__PURE__ */ import_react18.default.createElement(import_material9.DialogTitle, null, "BLAST Settings"),
      /* @__PURE__ */ import_react18.default.createElement(import_material9.DialogContent, null, /* @__PURE__ */ import_react18.default.createElement(
        TextField2_default,
        {
          autoFocus: true,
          margin: "dense",
          label: "BLAST Base URL",
          fullWidth: true,
          variant: "outlined",
          value: tempBaseUrl,
          style: { minWidth: "300px" },
          onChange: (e2) => {
            setTempBaseUrl(e2.target.value);
          }
        }
      ), /* @__PURE__ */ import_react18.default.createElement(
        import_material9.Button,
        {
          variant: "contained",
          onClick: () => {
            setTempBaseUrl(BASE_BLAST_URL);
          }
        },
        "Reset"
      )),
      /* @__PURE__ */ import_react18.default.createElement(import_material9.DialogActions, null, /* @__PURE__ */ import_react18.default.createElement(
        import_material9.Button,
        {
          variant: "contained",
          color: "secondary",
          onClick: () => {
            handleClose();
          }
        },
        "Cancel"
      ), /* @__PURE__ */ import_react18.default.createElement(
        import_material9.Button,
        {
          color: "primary",
          variant: "contained",
          onClick: () => {
            handleClose(tempBaseUrl);
          }
        },
        "Save"
      ))
    );
  }

  // src/LaunchMsaView/components/NCBIBlastQuery/NCBIBlastPanel.tsx
  function NCBIBlastPanel({
    handleClose,
    model,
    feature
  }) {
    const [lookupMethod, setLookupMethod] = (0, import_react19.useState)("automatic");
    const [baseUrl, setBaseUrl] = (0, import_util20.useLocalStorage)(
      "msa-blastRootUrl",
      BASE_BLAST_URL
    );
    const [settingsOpen, setSettingsOpen] = (0, import_react19.useState)(false);
    const Panel = lookupMethod === "automatic" ? NCBIBlastAutomaticPanel_default : NCBIBlastManualPanel_default;
    return /* @__PURE__ */ import_react19.default.createElement(import_react19.default.Fragment, null, /* @__PURE__ */ import_react19.default.createElement(
      import_material10.IconButton,
      {
        style: { float: "right" },
        size: "small",
        onClick: () => {
          setSettingsOpen(true);
        }
      },
      /* @__PURE__ */ import_react19.default.createElement(Settings_default, null)
    ), /* @__PURE__ */ import_react19.default.createElement(
      Panel,
      {
        model,
        feature,
        handleClose,
        baseUrl
      },
      /* @__PURE__ */ import_react19.default.createElement(
        NCBIBlastMethodSelector,
        {
          lookupMethod,
          setLookupMethod
        }
      )
    ), settingsOpen ? /* @__PURE__ */ import_react19.default.createElement(
      NCBISettingsDialog,
      {
        baseUrl,
        handleClose: (newUrl) => {
          if (newUrl) {
            setBaseUrl(newUrl);
          }
          setSettingsOpen(false);
        }
      }
    ) : null);
  }

  // src/LaunchMsaView/components/PreLoadedMSA/PreLoadedMSADataPanel.tsx
  var import_react20 = __toESM(require_react());
  var import_configuration4 = __toESM(require_configuration());
  var import_ui5 = __toESM(require_ui());
  var import_util21 = __toESM(require_util());
  var import_material11 = __toESM(require_material());
  var import_mobx_react8 = __toESM(require_mobx_react());
  var import_mui8 = __toESM(require_mui());

  // src/LaunchMsaView/components/PreLoadedMSA/consts.ts
  var swrFlags = {
    revalidateOnFocus: false,
    revalidateOnReconnect: false,
    revalidateIfStale: false,
    refreshWhenHidden: false,
    refreshWhenOffline: false,
    shouldRetryOnError: false
  };

  // src/LaunchMsaView/components/PreLoadedMSA/fetchMSAData.ts
  var import_dataAdapterCache = __toESM(require_dataAdapterCache());
  async function fetchMSAList({
    config: config2,
    pluginManager
  }) {
    const result = await (0, import_dataAdapterCache.getAdapter)(pluginManager, "msa", config2);
    return result.dataAdapter.getMSAList();
  }
  async function fetchMSA({
    config: config2,
    pluginManager,
    msaId
  }) {
    const result = await (0, import_dataAdapterCache.getAdapter)(pluginManager, "msa", config2);
    return result.dataAdapter.getMSA(msaId);
  }

  // src/LaunchMsaView/components/PreLoadedMSA/preCalculatedLaunchView.ts
  function preCalculatedLaunchView({
    session,
    newViewTitle,
    view,
    feature,
    data,
    querySeqName
  }) {
    session.addView("MsaView", {
      type: "MsaView",
      displayName: newViewTitle,
      treeAreaWidth: 200,
      querySeqName,
      treeWidth: 100,
      drawNodeBubbles: false,
      labelsAlignRight: true,
      showBranchLen: false,
      colWidth: 10,
      rowHeight: 12,
      colorSchemeName: "percent_identity_dynamic",
      data,
      connectedViewId: view.id,
      connectedFeature: feature.toJSON()
    });
  }

  // src/LaunchMsaView/components/PreLoadedMSA/PreLoadedMSADataPanel.tsx
  var useStyles8 = (0, import_mui8.makeStyles)()({
    dialogContent: {
      width: "80em"
    }
  });
  var PreLoadedMSA = (0, import_mobx_react8.observer)(function PreLoadedMSA22({
    model,
    feature,
    handleClose
  }) {
    const session = (0, import_util21.getSession)(model);
    const view = (0, import_util21.getContainingView)(model);
    const { classes } = useStyles8();
    const { pluginManager } = (0, import_util21.getEnv)(model);
    const { assemblyNames } = view;
    const [viewError, setViewError] = (0, import_react20.useState)();
    const { jbrowse } = session;
    const datasets = (0, import_configuration4.readConfObject)(jbrowse, ["msa", "datasets"]);
    const [selectedDatasetId, setSelectedDatasetId] = (0, import_react20.useState)(
      datasets?.[0]?.datasetId
    );
    const selectedDataset = datasets?.find((d3) => d3.datasetId === selectedDatasetId);
    const {
      data: msaList,
      isLoading: msaListLoading,
      error: msaListFetchError
    } = useSWR(
      selectedDatasetId ? `${selectedDatasetId}-msa-list` : "none-msa-list",
      () => selectedDataset ? fetchMSAList({
        config: selectedDataset.adapter,
        pluginManager
      }) : void 0,
      swrFlags
    );
    const {
      options: transcripts,
      selectedId,
      setSelectedId,
      selectedTranscript,
      proteinSequence,
      error: proteinSequenceError,
      validSet
    } = useTranscriptSelection({ feature, view, validIds: msaList });
    const {
      data: msaData,
      isLoading: msaDataLoading,
      error: msaDataFetchError
    } = useSWR(
      selectedId && selectedDatasetId ? `${selectedId}-${selectedId}-${msaList?.length}-msa` : "none-msa",
      () => selectedId && selectedDataset && msaList ? fetchMSA({
        msaId: selectedId,
        config: selectedDataset.adapter,
        pluginManager
      }) : void 0,
      swrFlags
    );
    const e2 = msaListFetchError ?? msaDataFetchError ?? proteinSequenceError ?? viewError;
    if (e2) {
      console.error(e2);
    }
    return /* @__PURE__ */ import_react20.default.createElement(import_react20.default.Fragment, null, /* @__PURE__ */ import_react20.default.createElement(import_material11.DialogContent, { className: classes.dialogContent }, e2 ? /* @__PURE__ */ import_react20.default.createElement(import_ui5.ErrorMessage, { error: e2 }) : null, /* @__PURE__ */ import_react20.default.createElement(
      TextField2_default,
      {
        select: true,
        label: "Select MSA dataset",
        value: selectedDatasetId,
        onChange: (event) => {
          setSelectedDatasetId(event.target.value);
        }
      },
      datasets && datasets.length > 0 ? datasets.map((d3) => /* @__PURE__ */ import_react20.default.createElement(import_material11.MenuItem, { key: d3.datasetId, value: d3.datasetId }, d3.name)) : /* @__PURE__ */ import_react20.default.createElement(import_material11.MenuItem, null, "No MSA datasets found")
    ), selectedDataset ? /* @__PURE__ */ import_react20.default.createElement("div", { style: { marginTop: 50 } }, !msaListLoading && msaDataLoading ? /* @__PURE__ */ import_react20.default.createElement(
      import_ui5.LoadingEllipses,
      {
        variant: "h6",
        message: `Loading MSA for (${selectedId})`
      }
    ) : null, msaListLoading ? /* @__PURE__ */ import_react20.default.createElement(
      import_ui5.LoadingEllipses,
      {
        variant: "h6",
        message: `Loading available MSAs for (${selectedDataset.name})`
      }
    ) : null, msaList ? /* @__PURE__ */ import_react20.default.createElement("div", null, /* @__PURE__ */ import_react20.default.createElement(import_ui5.SanitizedHTML, { html: selectedDataset.description }), /* @__PURE__ */ import_react20.default.createElement(
      TranscriptSelector,
      {
        feature,
        options: transcripts,
        selectedTranscript,
        onTranscriptChange: setSelectedId,
        proteinSequence,
        validSet
      }
    )) : null) : null), /* @__PURE__ */ import_react20.default.createElement(import_material11.DialogActions, null, /* @__PURE__ */ import_react20.default.createElement(
      import_material11.Button,
      {
        color: "primary",
        variant: "contained",
        disabled: !selectedTranscript || !msaData?.length,
        onClick: () => {
          try {
            if (!selectedTranscript || !msaData) {
              return;
            }
            const querySeqName = `${selectedId}_${assemblyNames[0]}`;
            preCalculatedLaunchView({
              session,
              newViewTitle: getGeneDisplayName(selectedTranscript),
              view,
              querySeqName,
              feature: selectedTranscript,
              data: {
                msa: msaData.map((r2) => `>${r2.get("refName")}
${r2.get("seq")}`).join("\n")
              }
            });
            handleClose();
          } catch (e3) {
            setViewError(e3);
          }
        }
      },
      "Submit"
    ), /* @__PURE__ */ import_react20.default.createElement(
      import_material11.Button,
      {
        color: "secondary",
        variant: "contained",
        onClick: () => {
          handleClose();
        }
      },
      "Cancel"
    )));
  });
  var PreLoadedMSADataPanel_default = PreLoadedMSA;

  // src/LaunchMsaView/components/TabPanel.tsx
  var import_react21 = __toESM(require_react());
  function TabPanel({
    children,
    value,
    index: index3,
    ...other
  }) {
    return /* @__PURE__ */ import_react21.default.createElement("div", { role: "tabpanel", hidden: value !== index3, ...other }, value === index3 && /* @__PURE__ */ import_react21.default.createElement("div", null, children));
  }

  // src/LaunchMsaView/components/LaunchMsaViewDialog.tsx
  var TABS = {
    NCBI_BLAST: 0,
    PRELOADED_MSA: 1,
    ENSEMBL_GENETREE: 2,
    MANUAL_MSA: 3
  };
  function LaunchMsaViewDialog({
    handleClose,
    feature,
    model
  }) {
    const [value, setValue] = (0, import_react22.useState)(TABS.NCBI_BLAST);
    const handleChange = (_event, newValue) => {
      setValue(newValue);
    };
    return /* @__PURE__ */ import_react22.default.createElement(import_ui6.Dialog, { maxWidth: "xl", title: "Launch MSA view", open: true, onClose: handleClose }, /* @__PURE__ */ import_react22.default.createElement(import_material12.Tabs, { value, onChange: handleChange }, /* @__PURE__ */ import_react22.default.createElement(import_material12.Tab, { label: "NCBI BLAST query", value: TABS.NCBI_BLAST }), /* @__PURE__ */ import_react22.default.createElement(import_material12.Tab, { label: "Pre-loaded MSA datasets", value: TABS.PRELOADED_MSA }), /* @__PURE__ */ import_react22.default.createElement(import_material12.Tab, { label: "Ensembl GeneTree", value: TABS.ENSEMBL_GENETREE }), /* @__PURE__ */ import_react22.default.createElement(import_material12.Tab, { label: "Manual upload", value: TABS.MANUAL_MSA })), /* @__PURE__ */ import_react22.default.createElement(TabPanel, { value, index: TABS.NCBI_BLAST }, /* @__PURE__ */ import_react22.default.createElement(
      NCBIBlastPanel,
      {
        handleClose,
        feature,
        model
      }
    )), /* @__PURE__ */ import_react22.default.createElement(TabPanel, { value, index: TABS.PRELOADED_MSA }, /* @__PURE__ */ import_react22.default.createElement(
      PreLoadedMSADataPanel_default,
      {
        model,
        feature,
        handleClose
      }
    )), /* @__PURE__ */ import_react22.default.createElement(TabPanel, { value, index: TABS.ENSEMBL_GENETREE }, /* @__PURE__ */ import_react22.default.createElement(
      EnsemblGeneTree_default,
      {
        model,
        feature,
        handleClose
      }
    )), /* @__PURE__ */ import_react22.default.createElement(TabPanel, { value, index: TABS.MANUAL_MSA }, /* @__PURE__ */ import_react22.default.createElement(
      ManualMSALoader_default,
      {
        model,
        feature,
        handleClose
      }
    )));
  }

  // src/LaunchMsaView/index.ts
  function isDisplay(elt) {
    return elt.name === "LinearBasicDisplay";
  }
  function extendStateModel(stateModel) {
    return stateModel.views(
      (self2) => {
        const superContextMenuItems = self2.contextMenuItems;
        return {
          contextMenuItems() {
            const feature = self2.contextMenuFeature;
            const track = (0, import_util23.getContainingTrack)(self2);
            const featureType = feature?.get("type");
            const showMsaMenuItem = feature && ["gene", "mRNA", "transcript"].includes(featureType);
            return [
              ...superContextMenuItems(),
              ...showMsaMenuItem ? [
                {
                  label: "Launch MSA view",
                  icon: Add_default,
                  onClick: () => {
                    (0, import_util23.getSession)(track).queueDialog((handleClose) => [
                      LaunchMsaViewDialog,
                      {
                        model: track,
                        handleClose,
                        feature
                      }
                    ]);
                  }
                }
              ] : []
            ];
          }
        };
      }
    );
  }
  function LaunchMsaViewF(pluginManager) {
    pluginManager.addToExtensionPoint(
      "Core-extendPluggableElement",
      (elt) => {
        if (isDisplay(elt)) {
          elt.stateModel = extendStateModel(elt.stateModel);
        }
        return elt;
      }
    );
  }

  // src/LaunchMsaViewExtensionPoint/index.ts
  function LaunchMsaViewExtensionPointF(pluginManager) {
    pluginManager.addToExtensionPoint(
      "LaunchView-MsaView",
      // @ts-expect-error
      ({
        session,
        data,
        msaFileLocation,
        treeFileLocation,
        connectedViewId,
        connectedFeature,
        displayName,
        colorSchemeName,
        colWidth,
        rowHeight,
        treeAreaWidth,
        treeWidth,
        drawNodeBubbles,
        labelsAlignRight,
        showBranchLen,
        querySeqName
      }) => {
        if (!data && !msaFileLocation) {
          throw new Error(
            "No MSA data or file location provided when launching MSA view"
          );
        }
        session.addView("MsaView", {
          type: "MsaView",
          displayName,
          connectedViewId,
          connectedFeature,
          colorSchemeName,
          colWidth,
          rowHeight,
          treeAreaWidth,
          treeWidth,
          drawNodeBubbles,
          labelsAlignRight,
          showBranchLen,
          init: {
            msaData: data?.msa,
            treeData: data?.tree,
            msaUrl: msaFileLocation?.uri,
            treeUrl: treeFileLocation?.uri,
            querySeqName
          }
        });
      }
    );
  }

  // src/MsaViewPanel/index.ts
  var import_react83 = __toESM(require_react());
  var import_ViewType = __toESM(require_ViewType());

  // src/MsaViewPanel/model.ts
  var import_react79 = __toESM(require_react());
  var import_pluggableElementTypes2 = __toESM(require_pluggableElementTypes());
  var import_util48 = __toESM(require_util());

  // node_modules/g2p_mapper/esm/index.js
  function* getPositions(f2, strand) {
    if (strand !== -1) {
      for (let pos = f2.start; pos < f2.end; pos++) {
        yield pos;
      }
    } else {
      for (let pos = f2.end - 1; pos >= f2.start; pos--) {
        yield pos;
      }
    }
  }
  function genomeToTranscriptSeqMapping(feature) {
    const strand = feature.strand;
    const refName = feature.refName;
    if (strand !== -1 && strand !== 1) {
      throw new Error(`Invalid strand value: ${strand}. Expected 1 or -1.`);
    }
    if (!refName) {
      throw new Error("refName is required");
    }
    const cdsFeatures = feature.subfeatures?.filter((f2) => f2.type === "CDS") ?? [];
    const seenKeys = /* @__PURE__ */ new Set();
    const cds = cdsFeatures.filter((f2) => {
      if (f2.start >= f2.end) {
        return false;
      }
      const key = `${f2.start}-${f2.end}`;
      if (seenKeys.has(key)) {
        return false;
      }
      seenKeys.add(key);
      return true;
    }).sort((a2, b2) => strand * (a2.start - b2.start));
    const g2p = {};
    const p2g = {};
    if (cds.length === 0) {
      return { g2p, p2g, refName, strand };
    }
    const firstPhase = cds[0]?.phase ?? 0;
    let proteinCounter = (3 - firstPhase) % 3;
    let lastProteinPos = -1;
    for (const f2 of cds) {
      for (const genomePos of getPositions(f2, strand)) {
        const proteinPos = Math.floor(proteinCounter++ / 3);
        g2p[genomePos] = proteinPos;
        if (proteinPos !== lastProteinPos) {
          p2g[proteinPos] = genomePos;
          lastProteinPos = proteinPos;
        }
      }
    }
    return {
      g2p,
      p2g,
      refName,
      strand
    };
  }

  // src/MsaViewPanel/model.ts
  var import_mobx7 = __toESM(require_mobx());
  var import_mobx_state_tree8 = __toESM(require_mobx_state_tree());
  init_dist2();

  // src/LaunchMsaView/components/util.ts
  function makeId(h2) {
    return `${h2.accession}-${h2.sciname.replaceAll(" ", "_")}`;
  }
  function strip(s2) {
    return s2.replace("-", "");
  }

  // src/utils/msa.ts
  var base3 = `https://www.ebi.ac.uk/Tools/services/rest`;
  async function runClustalOmega({
    sequence,
    onProgress
  }) {
    const jobId = await textfetch(`${base3}/clustalo/run`, {
      method: "POST",
      body: new URLSearchParams({
        email: "colin.diesh@gmail.com",
        sequence
      })
    });
    await wait2({ jobId, algorithm: "clustalo", onProgress });
    return {
      msa: await textfetch(`${base3}/clustalo/result/${jobId}/aln-clustal_num`),
      tree: await textfetch(`${base3}/clustalo/result/${jobId}/phylotree`)
    };
  }
  async function runMuscle({
    sequence,
    onProgress
  }) {
    const jobId = await textfetch(`${base3}/muscle/run`, {
      method: "POST",
      body: new URLSearchParams({
        email: "colin.diesh@gmail.com",
        format: "clw",
        tree: "tree1",
        sequence
      })
    });
    await wait2({ jobId, algorithm: "muscle", onProgress });
    return {
      msa: await textfetch(`${base3}/muscle/result/${jobId}/fa`),
      tree: await textfetch(`${base3}/muscle/result/${jobId}/phylotree`)
    };
  }
  async function runKalign({
    sequence,
    onProgress
  }) {
    const jobId = await textfetch(`${base3}/kalign/run`, {
      method: "POST",
      body: new URLSearchParams({
        email: "colin.diesh@gmail.com",
        stype: "protein",
        sequence
      })
    });
    await wait2({ jobId, algorithm: "kalign", onProgress });
    return {
      msa: await textfetch(`${base3}/kalign/result/${jobId}/fa`),
      tree: await textfetch(`${base3}/kalign/result/${jobId}/phylotree`)
    };
  }
  async function runMafft({
    sequence,
    onProgress
  }) {
    const jobId = await textfetch(`${base3}/mafft/run`, {
      method: "POST",
      body: new URLSearchParams({
        email: "colin.diesh@gmail.com",
        stype: "protein",
        sequence
      })
    });
    await wait2({ jobId, algorithm: "mafft", onProgress });
    return {
      msa: await textfetch(`${base3}/mafft/result/${jobId}/fa`),
      tree: await textfetch(`${base3}/mafft/result/${jobId}/phylotree`)
    };
  }
  async function wait2({
    onProgress,
    jobId,
    algorithm
  }) {
    while (true) {
      for (let i2 = 0; i2 < 10; i2++) {
        await timeout(1e3);
        onProgress(`Re-checking MSA status in... ${10 - i2}`);
      }
      const result = await textfetch(`${base3}/${algorithm}/status/${jobId}`);
      if (result === "FINISHED") {
        break;
      } else if (result.includes("FAILURE")) {
        throw new Error(`Failed to run: jobId ${jobId}`);
      }
    }
  }
  async function launchMSA({
    algorithm,
    sequence,
    onProgress
  }) {
    onProgress(`Launching ${algorithm} MSA...`);
    switch (algorithm) {
      case "clustalo": {
        return runClustalOmega({ sequence, onProgress });
      }
      case "muscle": {
        return runMuscle({ sequence, onProgress });
      }
      case "kalign": {
        return runKalign({ sequence, onProgress });
      }
      case "mafft": {
        return runMafft({ sequence, onProgress });
      }
      default: {
        throw new Error("unknown algorithm");
      }
    }
  }

  // src/utils/ncbiBlast.ts
  async function queryBlast({
    query,
    blastDatabase,
    blastProgram,
    baseUrl,
    onProgress,
    onRid
  }) {
    onProgress("Submitting to NCBI BLAST...");
    const { rid } = await initialQuery({
      query,
      blastDatabase,
      blastProgram,
      baseUrl
    });
    onRid(rid);
    await waitForRid({
      rid,
      onProgress,
      baseUrl
    });
    const ret = await jsonfetch(
      `${baseUrl}?CMD=Get&RID=${rid}&FORMAT_TYPE=JSON2_S&FORMAT_OBJECT=Alignment`
    );
    return {
      rid,
      hits: ret.BlastOutput2[0]?.report.results.search.hits ?? []
    };
  }
  async function initialQuery({
    query,
    blastProgram,
    blastDatabase,
    baseUrl
  }) {
    const res = await textfetch(baseUrl, {
      method: "POST",
      body: new URLSearchParams({
        CMD: "Put",
        PROGRAM: blastProgram === "quick-blastp" ? "blastp" : blastProgram,
        DATABASE: blastDatabase,
        QUERY: query,
        ...blastDatabase === "nr_clustered_seq" ? {
          CLUSTERED_DB: "on",
          DB_TYPE: "Experimental Databases"
        } : {},
        ...blastProgram === "quick-blastp" ? { BLAST_PROGRAMS: "kmerBlastp" } : {}
      })
    });
    const rid = /^ {4}RID = (.*$)/m.exec(res)?.[1];
    const rtoe = /^ {4}RTOE = (.*$)/m.exec(res)?.[1];
    if (!rid) {
      throw new Error("Failed to get RID from BLAST request");
    }
    return {
      rid,
      rtoe
    };
  }
  async function waitForRid({
    rid,
    onProgress,
    baseUrl
  }) {
    while (true) {
      const iter = 20;
      for (let i2 = 0; i2 < iter; i2++) {
        await timeout(1e3);
        onProgress(`Re-checking BLAST status in... ${iter - i2}`);
      }
      const res = await textfetch(
        `${baseUrl}?CMD=Get&FORMAT_OBJECT=SearchInfo&RID=${rid}`
      );
      const isWaiting = /\s+Status=WAITING/m.test(res);
      const isFailed = /\s+Status=FAILED/m.test(res);
      const isReady = /\s+Status=READY/m.test(res);
      const hasHits = /\s+ThereAreHits=yes/m.test(res);
      if (isWaiting) {
        continue;
      }
      if (isFailed) {
        throw new Error(`BLAST ${rid} failed`);
      }
      if (isReady) {
        if (hasHits) {
          return true;
        } else {
          throw new Error("No hits found");
        }
      }
    }
  }

  // src/MsaViewPanel/doLaunchBlast.ts
  async function doLaunchBlast({
    self: self2
  }) {
    const {
      baseUrl,
      blastDatabase,
      blastProgram,
      msaAlgorithm,
      proteinSequence
    } = self2.blastParams;
    const cleanedSeq = cleanProteinSequence(proteinSequence);
    const { hits } = await queryBlast({
      query: cleanedSeq,
      blastDatabase,
      blastProgram,
      baseUrl,
      onProgress: (arg) => {
        self2.setProgress(arg);
      },
      onRid: (rid) => {
        self2.setRid(rid);
      }
    });
    return launchMSA({
      algorithm: msaAlgorithm,
      sequence: [
        `>QUERY
${cleanedSeq}`,
        ...hits.map(
          (h2) => [
            makeId(
              h2.description[0] ?? {
                accession: "unknown",
                id: "unknown",
                sciname: "unknown"
              }
            ),
            strip(h2.hsps[0]?.hseq ?? "")
          ]
        ).map(([id, seq]) => `>${id}
${seq}`)
      ].join("\n"),
      onProgress: (arg) => {
        self2.setProgress(arg);
      }
    });
  }

  // src/MsaViewPanel/genomeToMSA.ts
  var import_util45 = __toESM(require_util());

  // src/MsaViewPanel/util.ts
  function checkHovered(hovered) {
    return typeof hovered === "object" && hovered !== null && "hoverFeature" in hovered && "hoverPosition" in hovered;
  }
  function getUniprotIdFromAlphaFoldUrl(url) {
    const match2 = /AF-([A-Z0-9]+)-F\d+/.exec(url);
    return match2?.[1];
  }

  // src/MsaViewPanel/genomeToMSA.ts
  function genomeToMSA({ model }) {
    const { hovered } = (0, import_util45.getSession)(model);
    const { querySeqName, transcriptToMsaMap, connectedView, mafRegion } = model;
    if (!connectedView?.initialized || !checkHovered(hovered)) {
      return void 0;
    }
    const { coord: hoverCoord, refName } = hovered.hoverPosition;
    if (mafRegion) {
      if (refName !== mafRegion.refName) {
        return void 0;
      }
      const viewAssemblies = connectedView.assemblyNames;
      if (!viewAssemblies.includes(mafRegion.assemblyName)) {
        return void 0;
      }
      if (hoverCoord < mafRegion.start || hoverCoord >= mafRegion.end) {
        return void 0;
      }
      const ungappedPos = hoverCoord - mafRegion.start;
      return model.seqPosToVisibleCol(querySeqName, ungappedPos);
    }
    if (transcriptToMsaMap) {
      const { g2p } = transcriptToMsaMap;
      const seqPos = g2p[hoverCoord];
      if (seqPos !== void 0) {
        return model.seqPosToVisibleCol(querySeqName, seqPos);
      }
    }
    return void 0;
  }

  // src/MsaViewPanel/structureConnection.ts
  function gappedToUngappedPosition(sequence, gappedPosition) {
    if (gappedPosition < 0 || gappedPosition >= sequence.length) {
      return void 0;
    }
    let ungapped = 0;
    for (let i2 = 0; i2 < gappedPosition; i2++) {
      if (sequence[i2] !== "-") {
        ungapped++;
      }
    }
    if (sequence[gappedPosition] === "-") {
      return void 0;
    }
    return ungapped;
  }
  function ungappedToGappedPosition(sequence, ungappedPosition) {
    let ungapped = 0;
    for (let i2 = 0; i2 < sequence.length; i2++) {
      const element = sequence[i2];
      if (element !== "-") {
        if (ungapped === ungappedPosition) {
          return i2;
        }
        ungapped++;
      }
    }
    return void 0;
  }
  function mapToRecord(map) {
    const record = {};
    for (const [key, value] of map) {
      record[key] = value;
    }
    return record;
  }

  // src/MsaViewPanel/msaCoordToGenomeCoord.ts
  function msaCoordToGenomeCoord({
    model,
    coord: mouseCol
  }) {
    const { querySeqName, transcriptToMsaMap, mafRegion } = model;
    const queryRow = model.rows.find((f2) => f2[0] === querySeqName);
    const querySeq = queryRow?.[1];
    if (!querySeq) {
      return void 0;
    }
    const ungappedPos = gappedToUngappedPosition(querySeq, mouseCol);
    if (ungappedPos === void 0) {
      return void 0;
    }
    if (mafRegion) {
      const genomePos = mafRegion.start + ungappedPos;
      if (genomePos >= mafRegion.end) {
        return void 0;
      }
      return {
        refName: mafRegion.refName,
        start: genomePos,
        end: genomePos + 1
      };
    }
    if (transcriptToMsaMap) {
      const { refName, p2g } = transcriptToMsaMap;
      const s2 = p2g[ungappedPos];
      const e2 = p2g[ungappedPos + 1];
      return s2 !== void 0 && e2 !== void 0 ? {
        refName,
        start: Math.min(s2, e2),
        end: Math.max(s2, e2)
      } : void 0;
    }
    return void 0;
  }

  // src/MsaViewPanel/msaDataStore.ts
  var DB_NAME = "jbrowse-msaview-data";
  var DB_VERSION = 1;
  var STORE_NAME = "msa-data";
  var dbPromise;
  var indexedDBAvailable;
  function checkIndexedDBAvailable() {
    if (indexedDBAvailable !== void 0) {
      return indexedDBAvailable;
    }
    try {
      if (typeof indexedDB === "undefined") {
        indexedDBAvailable = false;
        return false;
      }
      indexedDBAvailable = true;
      return true;
    } catch {
      indexedDBAvailable = false;
      return false;
    }
  }
  async function openDB() {
    if (!checkIndexedDBAvailable()) {
      return void 0;
    }
    if (dbPromise) {
      return dbPromise;
    }
    dbPromise = new Promise((resolve) => {
      try {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.addEventListener("error", () => {
          console.warn(
            "IndexedDB unavailable - MSA data will not persist across page refreshes"
          );
          indexedDBAvailable = false;
          resolve(void 0);
        });
        request.onsuccess = () => {
          resolve(request.result);
        };
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            const store = db.createObjectStore(STORE_NAME, { keyPath: "id" });
            store.createIndex("timestamp", "timestamp", { unique: false });
          }
        };
      } catch (e2) {
        console.warn("Failed to open IndexedDB:", e2);
        indexedDBAvailable = false;
        resolve(void 0);
      }
    });
    return dbPromise;
  }
  function generateDataStoreId() {
    return `msa-${Date.now()}-${Math.random().toString(36).slice(2, 11)}`;
  }
  async function storeMsaData(id, data) {
    const db = await openDB();
    if (!db) {
      return false;
    }
    return new Promise((resolve) => {
      try {
        const transaction2 = db.transaction(STORE_NAME, "readwrite");
        const store = transaction2.objectStore(STORE_NAME);
        const storedData = {
          id,
          msa: data.msa,
          tree: data.tree,
          treeMetadata: data.treeMetadata,
          timestamp: Date.now()
        };
        const request = store.put(storedData);
        request.addEventListener("error", () => {
          console.warn("Failed to store MSA data:", request.error);
          resolve(false);
        });
        request.onsuccess = () => {
          resolve(true);
        };
      } catch (e2) {
        console.warn("Failed to store MSA data:", e2);
        resolve(false);
      }
    });
  }
  async function retrieveMsaData(id) {
    const db = await openDB();
    if (!db) {
      return void 0;
    }
    return new Promise((resolve) => {
      try {
        const transaction2 = db.transaction(STORE_NAME, "readonly");
        const store = transaction2.objectStore(STORE_NAME);
        const request = store.get(id);
        request.addEventListener("error", () => {
          console.warn("Failed to retrieve MSA data:", request.error);
          resolve(void 0);
        });
        request.onsuccess = () => {
          const result = request.result;
          if (result) {
            resolve({
              msa: result.msa,
              tree: result.tree,
              treeMetadata: result.treeMetadata
            });
          } else {
            resolve(void 0);
          }
        };
      } catch (e2) {
        console.warn("Failed to retrieve MSA data:", e2);
        resolve(void 0);
      }
    });
  }
  async function cleanupOldData(maxAgeMs = 7 * 24 * 60 * 60 * 1e3) {
    const db = await openDB();
    if (!db) {
      return 0;
    }
    const cutoffTime = Date.now() - maxAgeMs;
    return new Promise((resolve) => {
      try {
        const transaction2 = db.transaction(STORE_NAME, "readwrite");
        const store = transaction2.objectStore(STORE_NAME);
        const index3 = store.index("timestamp");
        const range = IDBKeyRange.upperBound(cutoffTime);
        const request = index3.openCursor(range);
        let deletedCount = 0;
        request.addEventListener("error", () => {
          console.warn("Failed to cleanup old MSA data:", request.error);
          resolve(deletedCount);
        });
        request.onsuccess = (event) => {
          const cursor2 = event.target.result;
          if (cursor2) {
            cursor2.delete();
            deletedCount++;
            cursor2.continue();
          } else {
            resolve(deletedCount);
          }
        };
      } catch (e2) {
        console.warn("Failed to cleanup old MSA data:", e2);
        resolve(0);
      }
    });
  }

  // src/MsaViewPanel/pairwiseAlignment.ts
  var BLOSUM622 = {
    A: {
      A: 4,
      R: -1,
      N: -2,
      D: -2,
      C: 0,
      Q: -1,
      E: -1,
      G: 0,
      H: -2,
      I: -1,
      L: -1,
      K: -1,
      M: -1,
      F: -2,
      P: -1,
      S: 1,
      T: 0,
      W: -3,
      Y: -2,
      V: 0,
      B: -2,
      Z: -1,
      X: 0,
      "*": -4
    },
    R: {
      A: -1,
      R: 5,
      N: 0,
      D: -2,
      C: -3,
      Q: 1,
      E: 0,
      G: -2,
      H: 0,
      I: -3,
      L: -2,
      K: 2,
      M: -1,
      F: -3,
      P: -2,
      S: -1,
      T: -1,
      W: -3,
      Y: -2,
      V: -3,
      B: -1,
      Z: 0,
      X: -1,
      "*": -4
    },
    N: {
      A: -2,
      R: 0,
      N: 6,
      D: 1,
      C: -3,
      Q: 0,
      E: 0,
      G: 0,
      H: 1,
      I: -3,
      L: -3,
      K: 0,
      M: -2,
      F: -3,
      P: -2,
      S: 1,
      T: 0,
      W: -4,
      Y: -2,
      V: -3,
      B: 3,
      Z: 0,
      X: -1,
      "*": -4
    },
    D: {
      A: -2,
      R: -2,
      N: 1,
      D: 6,
      C: -3,
      Q: 0,
      E: 2,
      G: -1,
      H: -1,
      I: -3,
      L: -4,
      K: -1,
      M: -3,
      F: -3,
      P: -1,
      S: 0,
      T: -1,
      W: -4,
      Y: -3,
      V: -3,
      B: 4,
      Z: 1,
      X: -1,
      "*": -4
    },
    C: {
      A: 0,
      R: -3,
      N: -3,
      D: -3,
      C: 9,
      Q: -3,
      E: -4,
      G: -3,
      H: -3,
      I: -1,
      L: -1,
      K: -3,
      M: -1,
      F: -2,
      P: -3,
      S: -1,
      T: -1,
      W: -2,
      Y: -2,
      V: -1,
      B: -3,
      Z: -3,
      X: -2,
      "*": -4
    },
    Q: {
      A: -1,
      R: 1,
      N: 0,
      D: 0,
      C: -3,
      Q: 5,
      E: 2,
      G: -2,
      H: 0,
      I: -3,
      L: -2,
      K: 1,
      M: 0,
      F: -3,
      P: -1,
      S: 0,
      T: -1,
      W: -2,
      Y: -1,
      V: -2,
      B: 0,
      Z: 3,
      X: -1,
      "*": -4
    },
    E: {
      A: -1,
      R: 0,
      N: 0,
      D: 2,
      C: -4,
      Q: 2,
      E: 5,
      G: -2,
      H: 0,
      I: -3,
      L: -3,
      K: 1,
      M: -2,
      F: -3,
      P: -1,
      S: 0,
      T: -1,
      W: -3,
      Y: -2,
      V: -2,
      B: 1,
      Z: 4,
      X: -1,
      "*": -4
    },
    G: {
      A: 0,
      R: -2,
      N: 0,
      D: -1,
      C: -3,
      Q: -2,
      E: -2,
      G: 6,
      H: -2,
      I: -4,
      L: -4,
      K: -2,
      M: -3,
      F: -3,
      P: -2,
      S: 0,
      T: -2,
      W: -2,
      Y: -3,
      V: -3,
      B: -1,
      Z: -2,
      X: -1,
      "*": -4
    },
    H: {
      A: -2,
      R: 0,
      N: 1,
      D: -1,
      C: -3,
      Q: 0,
      E: 0,
      G: -2,
      H: 8,
      I: -3,
      L: -3,
      K: -1,
      M: -2,
      F: -1,
      P: -2,
      S: -1,
      T: -2,
      W: -2,
      Y: 2,
      V: -3,
      B: 0,
      Z: 0,
      X: -1,
      "*": -4
    },
    I: {
      A: -1,
      R: -3,
      N: -3,
      D: -3,
      C: -1,
      Q: -3,
      E: -3,
      G: -4,
      H: -3,
      I: 4,
      L: 2,
      K: -3,
      M: 1,
      F: 0,
      P: -3,
      S: -2,
      T: -1,
      W: -3,
      Y: -1,
      V: 3,
      B: -3,
      Z: -3,
      X: -1,
      "*": -4
    },
    L: {
      A: -1,
      R: -2,
      N: -3,
      D: -4,
      C: -1,
      Q: -2,
      E: -3,
      G: -4,
      H: -3,
      I: 2,
      L: 4,
      K: -2,
      M: 2,
      F: 0,
      P: -3,
      S: -2,
      T: -1,
      W: -2,
      Y: -1,
      V: 1,
      B: -4,
      Z: -3,
      X: -1,
      "*": -4
    },
    K: {
      A: -1,
      R: 2,
      N: 0,
      D: -1,
      C: -3,
      Q: 1,
      E: 1,
      G: -2,
      H: -1,
      I: -3,
      L: -2,
      K: 5,
      M: -1,
      F: -3,
      P: -1,
      S: 0,
      T: -1,
      W: -3,
      Y: -2,
      V: -2,
      B: 0,
      Z: 1,
      X: -1,
      "*": -4
    },
    M: {
      A: -1,
      R: -1,
      N: -2,
      D: -3,
      C: -1,
      Q: 0,
      E: -2,
      G: -3,
      H: -2,
      I: 1,
      L: 2,
      K: -1,
      M: 5,
      F: 0,
      P: -2,
      S: -1,
      T: -1,
      W: -1,
      Y: -1,
      V: 1,
      B: -3,
      Z: -1,
      X: -1,
      "*": -4
    },
    F: {
      A: -2,
      R: -3,
      N: -3,
      D: -3,
      C: -2,
      Q: -3,
      E: -3,
      G: -3,
      H: -1,
      I: 0,
      L: 0,
      K: -3,
      M: 0,
      F: 6,
      P: -4,
      S: -2,
      T: -2,
      W: 1,
      Y: 3,
      V: -1,
      B: -3,
      Z: -3,
      X: -1,
      "*": -4
    },
    P: {
      A: -1,
      R: -2,
      N: -2,
      D: -1,
      C: -3,
      Q: -1,
      E: -1,
      G: -2,
      H: -2,
      I: -3,
      L: -3,
      K: -1,
      M: -2,
      F: -4,
      P: 7,
      S: -1,
      T: -1,
      W: -4,
      Y: -3,
      V: -2,
      B: -2,
      Z: -1,
      X: -2,
      "*": -4
    },
    S: {
      A: 1,
      R: -1,
      N: 1,
      D: 0,
      C: -1,
      Q: 0,
      E: 0,
      G: 0,
      H: -1,
      I: -2,
      L: -2,
      K: 0,
      M: -1,
      F: -2,
      P: -1,
      S: 4,
      T: 1,
      W: -3,
      Y: -2,
      V: -2,
      B: 0,
      Z: 0,
      X: 0,
      "*": -4
    },
    T: {
      A: 0,
      R: -1,
      N: 0,
      D: -1,
      C: -1,
      Q: -1,
      E: -1,
      G: -2,
      H: -2,
      I: -1,
      L: -1,
      K: -1,
      M: -1,
      F: -2,
      P: -1,
      S: 1,
      T: 5,
      W: -2,
      Y: -2,
      V: 0,
      B: -1,
      Z: -1,
      X: 0,
      "*": -4
    },
    W: {
      A: -3,
      R: -3,
      N: -4,
      D: -4,
      C: -2,
      Q: -2,
      E: -3,
      G: -2,
      H: -2,
      I: -3,
      L: -2,
      K: -3,
      M: -1,
      F: 1,
      P: -4,
      S: -3,
      T: -2,
      W: 11,
      Y: 2,
      V: -3,
      B: -4,
      Z: -3,
      X: -2,
      "*": -4
    },
    Y: {
      A: -2,
      R: -2,
      N: -2,
      D: -3,
      C: -2,
      Q: -1,
      E: -2,
      G: -3,
      H: 2,
      I: -1,
      L: -1,
      K: -2,
      M: -1,
      F: 3,
      P: -3,
      S: -2,
      T: -2,
      W: 2,
      Y: 7,
      V: -1,
      B: -3,
      Z: -2,
      X: -1,
      "*": -4
    },
    V: {
      A: 0,
      R: -3,
      N: -3,
      D: -3,
      C: -1,
      Q: -2,
      E: -2,
      G: -3,
      H: -3,
      I: 3,
      L: 1,
      K: -2,
      M: 1,
      F: -1,
      P: -2,
      S: -2,
      T: 0,
      W: -3,
      Y: -1,
      V: 4,
      B: -3,
      Z: -2,
      X: -1,
      "*": -4
    },
    B: {
      A: -2,
      R: -1,
      N: 3,
      D: 4,
      C: -3,
      Q: 0,
      E: 1,
      G: -1,
      H: 0,
      I: -3,
      L: -4,
      K: 0,
      M: -3,
      F: -3,
      P: -2,
      S: 0,
      T: -1,
      W: -4,
      Y: -3,
      V: -3,
      B: 4,
      Z: 1,
      X: -1,
      "*": -4
    },
    Z: {
      A: -1,
      R: 0,
      N: 0,
      D: 1,
      C: -3,
      Q: 3,
      E: 4,
      G: -2,
      H: 0,
      I: -3,
      L: -3,
      K: 1,
      M: -1,
      F: -3,
      P: -1,
      S: 0,
      T: -1,
      W: -3,
      Y: -2,
      V: -2,
      B: 1,
      Z: 4,
      X: -1,
      "*": -4
    },
    X: {
      A: 0,
      R: -1,
      N: -1,
      D: -1,
      C: -2,
      Q: -1,
      E: -1,
      G: -1,
      H: -1,
      I: -1,
      L: -1,
      K: -1,
      M: -1,
      F: -1,
      P: -2,
      S: 0,
      T: 0,
      W: -2,
      Y: -1,
      V: -1,
      B: -1,
      Z: -1,
      X: -1,
      "*": -4
    },
    "*": {
      A: -4,
      R: -4,
      N: -4,
      D: -4,
      C: -4,
      Q: -4,
      E: -4,
      G: -4,
      H: -4,
      I: -4,
      L: -4,
      K: -4,
      M: -4,
      F: -4,
      P: -4,
      S: -4,
      T: -4,
      W: -4,
      Y: -4,
      V: -4,
      B: -4,
      Z: -4,
      X: -4,
      "*": 1
    }
  };
  function getScore(a2, b2) {
    const upper_a = a2.toUpperCase();
    const upper_b = b2.toUpperCase();
    return BLOSUM622[upper_a]?.[upper_b] ?? -4;
  }
  var GAP_OPEN = -10;
  var GAP_EXTEND = -0.5;
  function needlemanWunsch(seq1, seq2, gapOpen = GAP_OPEN, gapExtend = GAP_EXTEND) {
    const m2 = seq1.length;
    const n2 = seq2.length;
    const M2 = [];
    const Ix = [];
    const Iy = [];
    for (let i3 = 0; i3 <= m2; i3++) {
      M2[i3] = [];
      Ix[i3] = [];
      Iy[i3] = [];
      for (let j3 = 0; j3 <= n2; j3++) {
        M2[i3][j3] = -Infinity;
        Ix[i3][j3] = -Infinity;
        Iy[i3][j3] = -Infinity;
      }
    }
    M2[0][0] = 0;
    for (let i3 = 1; i3 <= m2; i3++) {
      Ix[i3][0] = gapOpen + (i3 - 1) * gapExtend;
    }
    for (let j3 = 1; j3 <= n2; j3++) {
      Iy[0][j3] = gapOpen + (j3 - 1) * gapExtend;
    }
    for (let i3 = 1; i3 <= m2; i3++) {
      for (let j3 = 1; j3 <= n2; j3++) {
        const matchScore = getScore(seq1[i3 - 1], seq2[j3 - 1]);
        M2[i3][j3] = Math.max(M2[i3 - 1][j3 - 1], Ix[i3 - 1][j3 - 1], Iy[i3 - 1][j3 - 1]) + matchScore;
        Ix[i3][j3] = Math.max(M2[i3 - 1][j3] + gapOpen, Ix[i3 - 1][j3] + gapExtend);
        Iy[i3][j3] = Math.max(M2[i3][j3 - 1] + gapOpen, Iy[i3][j3 - 1] + gapExtend);
      }
    }
    let alignedSeq1 = "";
    let alignedSeq2 = "";
    let i2 = m2;
    let j2 = n2;
    const finalScores = [M2[m2][n2], Ix[m2][n2], Iy[m2][n2]];
    const score = Math.max(...finalScores);
    let currentMatrix = score === M2[m2][n2] ? "M" : score === Ix[m2][n2] ? "Ix" : "Iy";
    while (i2 > 0 || j2 > 0) {
      if (currentMatrix === "M" && i2 > 0 && j2 > 0) {
        alignedSeq1 = seq1[i2 - 1] + alignedSeq1;
        alignedSeq2 = seq2[j2 - 1] + alignedSeq2;
        const matchScore = getScore(seq1[i2 - 1], seq2[j2 - 1]);
        const prevM = M2[i2 - 1][j2 - 1];
        const prevIx = Ix[i2 - 1][j2 - 1];
        if (M2[i2][j2] === prevM + matchScore) {
          currentMatrix = "M";
        } else if (M2[i2][j2] === prevIx + matchScore) {
          currentMatrix = "Ix";
        } else {
          currentMatrix = "Iy";
        }
        i2--;
        j2--;
      } else if (currentMatrix === "Ix" && i2 > 0) {
        alignedSeq1 = seq1[i2 - 1] + alignedSeq1;
        alignedSeq2 = "-" + alignedSeq2;
        currentMatrix = Ix[i2][j2] === M2[i2 - 1][j2] + gapOpen ? "M" : "Ix";
        i2--;
      } else if (j2 > 0) {
        alignedSeq1 = "-" + alignedSeq1;
        alignedSeq2 = seq2[j2 - 1] + alignedSeq2;
        currentMatrix = Iy[i2][j2] === M2[i2][j2 - 1] + gapOpen ? "M" : "Iy";
        j2--;
      } else {
        break;
      }
    }
    return { alignedSeq1, alignedSeq2, score };
  }
  function buildConsensus(alignedSeq1, alignedSeq2) {
    let consensus = "";
    for (let i2 = 0; i2 < alignedSeq1.length; i2++) {
      const a2 = alignedSeq1[i2];
      const b2 = alignedSeq2[i2];
      if (a2 === "-" || b2 === "-") {
        consensus += " ";
      } else if (a2.toUpperCase() === b2.toUpperCase()) {
        consensus += "|";
      } else {
        consensus += " ";
      }
    }
    return consensus;
  }
  function runPairwiseAlignment(seq1, seq2) {
    const { alignedSeq1, alignedSeq2 } = needlemanWunsch(seq1, seq2);
    return {
      consensus: buildConsensus(alignedSeq1, alignedSeq2),
      alns: [
        { id: "msa", seq: alignedSeq1 },
        { id: "structure", seq: alignedSeq2 }
      ]
    };
  }
  function buildAlignmentMaps(pairwiseAlignment) {
    const seq1 = pairwiseAlignment.alns[0].seq;
    const seq2 = pairwiseAlignment.alns[1].seq;
    if (seq1.length !== seq2.length) {
      throw new Error("Aligned sequences must have same length");
    }
    let pos1 = 0;
    let pos2 = 0;
    const seq1ToSeq2 = /* @__PURE__ */ new Map();
    const seq2ToSeq1 = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < seq1.length; i2++) {
      const c1 = seq1[i2];
      const c2 = seq2[i2];
      if (c1 !== "-" && c2 !== "-") {
        seq1ToSeq2.set(pos1, pos2);
        seq2ToSeq1.set(pos2, pos1);
        pos1++;
        pos2++;
      } else if (c1 === "-") {
        pos2++;
      } else {
        pos1++;
      }
    }
    return { seq1ToSeq2, seq2ToSeq1 };
  }

  // src/MsaViewPanel/model.ts
  var ConnectStructureDialog3 = (0, import_react79.lazy)(
    () => Promise.resolve().then(() => (init_ConnectStructureDialog(), ConnectStructureDialog_exports))
  );
  function highlightConnectedStructures(self2) {
    const { mouseCol, connectedProteinViews } = self2;
    if (connectedProteinViews.length === 0) {
      return;
    }
    for (const conn of connectedProteinViews) {
      const structure = conn.proteinView?.structures?.[conn.structureIdx];
      if (!structure) {
        continue;
      }
      if (mouseCol === void 0) {
        structure.clearHighlightFromExternal?.();
        continue;
      }
      const seq = self2.getSequenceByRowName(conn.msaRowName);
      if (!seq) {
        continue;
      }
      const msaUngapped = gappedToUngappedPosition(seq, mouseCol);
      if (msaUngapped === void 0) {
        structure.clearHighlightFromExternal?.();
        continue;
      }
      const structurePos = conn.msaToStructure[msaUngapped];
      if (structurePos === void 0) {
        structure.clearHighlightFromExternal?.();
      } else {
        structure.highlightFromExternal?.(structurePos);
      }
    }
  }
  function stateModelFactory2() {
    return import_mobx_state_tree8.types.compose(
      import_pluggableElementTypes2.BaseViewModel,
      model_default(),
      import_mobx_state_tree8.types.model("MsaView", {
        /**
         * #property
         */
        connectedViewId: import_mobx_state_tree8.types.maybe(import_mobx_state_tree8.types.string),
        /**
         * #property
         */
        connectedFeature: import_mobx_state_tree8.types.frozen(),
        /**
         * #property
         */
        connectedHighlights: import_mobx_state_tree8.types.array(
          import_mobx_state_tree8.types.model({
            refName: import_mobx_state_tree8.types.string,
            start: import_mobx_state_tree8.types.number,
            end: import_mobx_state_tree8.types.number
          })
        ),
        /**
         * #property
         */
        blastParams: import_mobx_state_tree8.types.frozen(),
        /**
         * #property
         */
        querySeqName: "QUERY",
        /**
         * #property
         * UniProt ID extracted from AlphaFold MSA URL
         */
        uniprotId: import_mobx_state_tree8.types.maybe(import_mobx_state_tree8.types.string),
        /**
         * #property
         */
        zoomToBaseLevel: false,
        /**
         * #property
         * used for loading the MSA view via session snapshots, e.g.
         * {
         *   "type": "MsaView",
         *   "init": {
         *     "msaUrl": "https://example.com/alignment.fa",
         *     "treeUrl": "https://example.com/tree.nh",
         *     "querySeqName": "ENST00000123_hg38"
         *   }
         * }
         */
        init: import_mobx_state_tree8.types.frozen(),
        /**
         * #property
         * connections to protein 3D structure views for synchronized highlighting
         */
        connectedStructures: import_mobx_state_tree8.types.array(import_mobx_state_tree8.types.frozen()),
        /**
         * #property
         * Reference ID for MSA data stored in IndexedDB (for large datasets)
         */
        dataStoreId: import_mobx_state_tree8.types.maybe(import_mobx_state_tree8.types.string),
        /**
         * #property
         * MAF region for coordinate mapping (used when launched from MAF viewer)
         */
        mafRegion: import_mobx_state_tree8.types.frozen()
      })
    ).volatile(() => ({
      /**
       * #volatile
       */
      rid: void 0,
      /**
       * #volatile
       */
      progress: "",
      /**
       * #volatile
       */
      error: void 0,
      /**
       * #volatile
       * True when loading MSA data from IndexedDB
       */
      loadingStoredData: false
    })).views((self2) => ({
      /**
       * #method
       * Get a row by name, returns [name, sequence] or undefined
       */
      getRowByName(rowName) {
        return self2.rows.find((r2) => r2[0] === rowName);
      },
      /**
       * #method
       * Get the sequence for a row by name
       */
      getSequenceByRowName(rowName) {
        return self2.rows.find((r2) => r2[0] === rowName)?.[1];
      }
    })).views((self2) => ({
      /**
       * #getter
       */
      get transcriptToMsaMap() {
        return self2.connectedFeature ? genomeToTranscriptSeqMapping(self2.connectedFeature) : void 0;
      },
      /**
       * #getter
       */
      get processing() {
        return !!self2.progress;
      },
      /**
       * #getter
       */
      get connectedView() {
        const { views } = (0, import_util48.getSession)(self2);
        return views.find((f2) => f2.id === self2.connectedViewId);
      },
      /**
       * #getter
       * Get connected protein views with their full model references
       */
      get connectedProteinViews() {
        const { views } = (0, import_util48.getSession)(self2);
        return self2.connectedStructures.map((conn) => {
          const proteinView = views.find(
            (v2) => v2.id === conn.proteinViewId
          );
          return proteinView ? { ...conn, proteinView } : void 0;
        }).filter((c2) => !!c2);
      }
    })).views((self2) => ({
      /**
       * #getter
       * Get the MSA column that corresponds to the currently hovered structure position
       * Returns the first match from any connected structure
       */
      get structureHoverCol() {
        for (const conn of self2.connectedProteinViews) {
          const structure = conn.proteinView?.structures?.[conn.structureIdx];
          const structurePos = structure?.hoverPosition?.structureSeqPos;
          if (structurePos !== void 0) {
            const msaUngapped = conn.structureToMsa[structurePos];
            if (msaUngapped !== void 0) {
              const seq = self2.getSequenceByRowName(conn.msaRowName);
              if (seq) {
                const globalCol = ungappedToGappedPosition(seq, msaUngapped);
                if (globalCol !== void 0) {
                  return self2.globalColToVisibleCol(globalCol);
                }
              }
            }
          }
        }
        return void 0;
      }
    })).views((self2) => ({
      /**
       * #getter
       * Returns a secondary highlight column from either:
       * 1. Structure hover (from connected protein 3D view)
       * 2. Genome hover (from connected linear genome view)
       */
      get mouseCol2() {
        const structureCol = self2.structureHoverCol;
        if (structureCol !== void 0) {
          return structureCol;
        }
        return genomeToMSA({ model: self2 });
      },
      /**
       * #getter
       */
      get clickCol2() {
        return void 0;
      }
    })).actions((self2) => ({
      /**
       * #action
       */
      setZoomToBaseLevel(arg) {
        self2.zoomToBaseLevel = arg;
      },
      /**
       * #action
       */
      setError(e2) {
        self2.error = e2;
      },
      /**
       * #action
       */
      setProgress(arg) {
        self2.progress = arg;
      },
      /**
       * #action
       */
      setRid(arg) {
        self2.rid = arg;
      },
      /**
       * #action
       */
      setConnectedHighlights(r2) {
        self2.connectedHighlights = (0, import_mobx_state_tree8.cast)(r2);
      },
      /**
       * #action
       */
      addToConnectedHighlights(r2) {
        self2.connectedHighlights.push(r2);
      },
      /**
       * #action
       */
      clearConnectedHighlights() {
        self2.connectedHighlights = (0, import_mobx_state_tree8.cast)([]);
      },
      /**
       * #action
       */
      setBlastParams(args) {
        self2.blastParams = args;
      },
      /**
       * #action
       */
      setInit(arg) {
        self2.init = arg;
      },
      /**
       * #action
       */
      setQuerySeqName(arg) {
        self2.querySeqName = arg;
      },
      /**
       * #action
       */
      setUniprotId(arg) {
        self2.uniprotId = arg;
      },
      /**
       * #action
       */
      setDataStoreId(arg) {
        self2.dataStoreId = arg;
      },
      /**
       * #action
       */
      setMafRegion(arg) {
        self2.mafRegion = arg;
      },
      /**
       * #action
       */
      setLoadingStoredData(arg) {
        self2.loadingStoredData = arg;
      },
      /**
       * #action
       */
      handleMsaClick(coord) {
        const { connectedView, zoomToBaseLevel } = self2;
        const { assemblyManager } = (0, import_util48.getSession)(self2);
        const r2 = msaCoordToGenomeCoord({ model: self2, coord });
        if (!r2 || !connectedView) {
          return;
        }
        if (zoomToBaseLevel) {
          connectedView.navTo(r2);
        } else {
          const r3 = assemblyManager.get(connectedView.assemblyNames[0])?.getCanonicalRefName(r2.refName) ?? r2.refName;
          connectedView.centerAt(r2.start, r3);
        }
      },
      /**
       * #action
       * Connect to a protein structure for synchronized highlighting
       */
      connectToStructure(proteinViewId, structureIdx, msaRowName) {
        const rowName = msaRowName ?? self2.querySeqName;
        const msaSequence = self2.getSequenceByRowName(rowName);
        if (!msaSequence) {
          throw new Error(`MSA row "${rowName}" not found`);
        }
        const ungappedMsaSequence = msaSequence.replaceAll("-", "");
        const { views } = (0, import_util48.getSession)(self2);
        const proteinView = views.find(
          (v2) => v2.id === proteinViewId
        );
        if (!proteinView) {
          throw new Error(`ProteinView "${proteinViewId}" not found`);
        }
        const structure = proteinView.structures?.[structureIdx];
        if (!structure) {
          throw new Error(`Structure at index ${structureIdx} not found`);
        }
        const structureSequence = structure.structureSequences?.[0];
        if (!structureSequence) {
          throw new Error("Structure sequence not available");
        }
        const alignment = runPairwiseAlignment(
          ungappedMsaSequence,
          structureSequence
        );
        const { seq1ToSeq2, seq2ToSeq1 } = buildAlignmentMaps(alignment);
        const connection = {
          proteinViewId,
          structureIdx,
          msaRowName: rowName,
          msaToStructure: mapToRecord(seq1ToSeq2),
          structureToMsa: mapToRecord(seq2ToSeq1)
        };
        self2.connectedStructures.push(connection);
      },
      /**
       * #action
       * Disconnect from a protein structure
       */
      disconnectFromStructure(proteinViewId, structureIdx) {
        const idx = self2.connectedStructures.findIndex(
          (c2) => c2.proteinViewId === proteinViewId && c2.structureIdx === structureIdx
        );
        if (idx !== -1) {
          self2.connectedStructures.splice(idx, 1);
        }
      },
      /**
       * #action
       * Disconnect from all protein structures
       */
      disconnectAllStructures() {
        self2.connectedStructures.clear();
      }
    })).actions((self2) => {
      const superSetMouseClickPos = self2.setMouseClickPos.bind(self2);
      return {
        /**
         * #action
         * overrides base setMouseClickPos to trigger navigation
         */
        setMouseClickPos(col, row) {
          superSetMouseClickPos(col, row);
          if (col !== void 0) {
            self2.handleMsaClick(col);
          }
        }
      };
    }).views((self2) => ({
      /**
       * #method
       * overrides base
       */
      extraViewMenuItems() {
        return [
          {
            label: "Zoom to base level on click?",
            checked: self2.zoomToBaseLevel,
            type: "checkbox",
            onClick: () => {
              self2.setZoomToBaseLevel(!self2.zoomToBaseLevel);
            }
          },
          {
            label: "Connect to protein structure...",
            onClick: () => {
              (0, import_util48.getSession)(self2).queueDialog((handleClose) => [
                ConnectStructureDialog3,
                {
                  model: self2,
                  handleClose
                }
              ]);
            }
          },
          ...self2.connectedStructures.length > 0 ? [
            {
              label: "Disconnect from protein structures",
              onClick: () => {
                self2.disconnectAllStructures();
              }
            }
          ] : []
        ];
      }
    })).actions((self2) => ({
      afterCreate() {
        cleanupOldData().catch((e2) => {
          console.error("Failed to cleanup old MSA data:", e2);
        });
        (0, import_mobx_state_tree8.addDisposer)(
          self2,
          (0, import_mobx7.autorun)(async () => {
            const { dataStoreId, rows } = self2;
            if (dataStoreId && rows.length === 0) {
              try {
                self2.setLoadingStoredData(true);
                const storedData = await retrieveMsaData(dataStoreId);
                if (storedData) {
                  if (storedData.msa) {
                    self2.setMSA(storedData.msa);
                  }
                  if (storedData.tree) {
                    self2.setTree(storedData.tree);
                  }
                }
              } catch (e2) {
                console.error("Failed to load MSA data from IndexedDB:", e2);
              } finally {
                self2.setLoadingStoredData(false);
              }
            }
          })
        );
        (0, import_mobx_state_tree8.addDisposer)(
          self2,
          (0, import_mobx7.autorun)(async () => {
            const { rows, dataStoreId } = self2;
            if (rows.length > 0 && !dataStoreId) {
              const hasFilehandle = !!(self2.msaFilehandle ?? self2.treeFilehandle);
              if (hasFilehandle) {
                return;
              }
              const msaData = self2.data.msa;
              const treeData = self2.data.tree;
              if (msaData || treeData) {
                try {
                  const newId = generateDataStoreId();
                  const success = await storeMsaData(newId, {
                    msa: msaData,
                    tree: treeData,
                    treeMetadata: self2.data.treeMetadata
                  });
                  if (success) {
                    self2.setDataStoreId(newId);
                  }
                } catch (e2) {
                  console.error("Failed to store MSA data to IndexedDB:", e2);
                }
              }
            }
          })
        );
        (0, import_mobx_state_tree8.addDisposer)(
          self2,
          (0, import_mobx7.autorun)(async () => {
            if (self2.blastParams) {
              try {
                self2.setProgress("Submitting query");
                self2.setError(void 0);
                const data = await doLaunchBlast({
                  self: self2
                });
                self2.setData(data);
                self2.setBlastParams(void 0);
              } catch (e2) {
                self2.setError(e2);
                console.error(e2);
              } finally {
                self2.setProgress("");
              }
            }
          })
        );
        (0, import_mobx_state_tree8.addDisposer)(
          self2,
          (0, import_mobx7.autorun)(async () => {
            const { init } = self2;
            if (init) {
              try {
                self2.setError(void 0);
                const {
                  msaData,
                  msaUrl,
                  treeData,
                  treeUrl,
                  querySeqName,
                  colorSchemeName
                } = init;
                console.log("MsaView init processing:", {
                  hasMsaData: !!msaData,
                  msaDataLength: msaData?.length,
                  msaUrl,
                  querySeqName,
                  colorSchemeName
                });
                if (msaUrl) {
                  const id = getUniprotIdFromAlphaFoldUrl(msaUrl);
                  if (id) {
                    self2.setUniprotId(id);
                    self2.setQuerySeqName("query");
                  }
                }
                if (querySeqName) {
                  self2.setQuerySeqName(querySeqName);
                }
                if (msaData) {
                  console.log("Setting MSA data, preview:", msaData.slice(0, 200));
                  self2.setMSA(msaData);
                  console.log("After setMSA, rows:", self2.rows.length, "columns:", self2.columns);
                } else if (msaUrl) {
                  const response = await fetch(msaUrl);
                  if (!response.ok) {
                    throw new Error(`Failed to fetch MSA: ${response.status}`);
                  }
                  const data = await response.text();
                  self2.setMSA(data);
                }
                if (treeData) {
                  self2.setTree(treeData);
                } else if (treeUrl) {
                  const response = await fetch(treeUrl);
                  if (!response.ok) {
                    throw new Error(`Failed to fetch tree: ${response.status}`);
                  }
                  const data = await response.text();
                  self2.setTree(data);
                }
                if (colorSchemeName) {
                  self2.setColorSchemeName(colorSchemeName);
                }
                self2.setInit(void 0);
              } catch (e2) {
                self2.setError(e2);
                console.error(e2);
              }
            }
          })
        );
        (0, import_mobx_state_tree8.addDisposer)(
          self2,
          (0, import_mobx7.autorun)(() => {
            const { mouseCol, mouseClickCol } = self2;
            const r1 = mouseCol === void 0 ? void 0 : msaCoordToGenomeCoord({ model: self2, coord: mouseCol });
            const r2 = mouseClickCol === void 0 ? void 0 : msaCoordToGenomeCoord({ model: self2, coord: mouseClickCol });
            self2.setConnectedHighlights([r1, r2].filter((f2) => !!f2));
          })
        );
        (0, import_mobx_state_tree8.addDisposer)(
          self2,
          (0, import_mobx7.autorun)(() => {
            highlightConnectedStructures(self2);
          })
        );
        (0, import_mobx_state_tree8.addDisposer)(
          self2,
          (0, import_mobx7.autorun)(() => {
            const { views } = (0, import_util48.getSession)(self2);
            const { connectedViewId, uniprotId, rows, connectedStructures } = self2;
            if (!uniprotId || rows.length === 0) {
              return;
            }
            for (const view of views) {
              const v2 = view;
              if (v2.type !== "ProteinView" || !v2.structures) {
                continue;
              }
              for (let structureIdx = 0; structureIdx < v2.structures.length; structureIdx++) {
                const structure = v2.structures[structureIdx];
                if (structure.connectedViewId !== connectedViewId) {
                  continue;
                }
                if (structure.uniprotId !== uniprotId) {
                  continue;
                }
                const alreadyConnected = connectedStructures.some(
                  (c2) => c2.proteinViewId === v2.id && c2.structureIdx === structureIdx
                );
                if (alreadyConnected) {
                  continue;
                }
                if (!structure.structureSequences?.[0]) {
                  continue;
                }
                try {
                  self2.connectToStructure(v2.id, structureIdx);
                } catch (e2) {
                  console.error("Failed to auto-connect to ProteinView:", e2);
                }
              }
            }
          })
        );
        (0, import_mobx_state_tree8.addDisposer)(
          self2,
          (0, import_mobx7.autorun)(() => {
            const { views } = (0, import_util48.getSession)(self2);
            const { connectedViewId, transcriptToMsaMap, querySeqName } = self2;
            if (!connectedViewId || !transcriptToMsaMap) {
              return;
            }
            const columns = [];
            for (const view of views) {
              const v2 = view;
              if (v2.type !== "ProteinView" || !v2.structures) {
                continue;
              }
              for (const structure of v2.structures) {
                if (structure.connectedViewId !== connectedViewId) {
                  continue;
                }
                const highlights = structure.hoverGenomeHighlights;
                if (!highlights || highlights.length === 0) {
                  continue;
                }
                const { g2p } = transcriptToMsaMap;
                for (const highlight of highlights) {
                  for (let coord = highlight.start; coord < highlight.end; coord++) {
                    const proteinPos = g2p[coord];
                    if (proteinPos !== void 0) {
                      const col = self2.seqPosToGlobalCol(
                        querySeqName,
                        proteinPos
                      );
                      if (!columns.includes(col)) {
                        columns.push(col);
                      }
                    }
                  }
                }
              }
            }
            const visibleColumns = columns.map((col) => self2.globalColToVisibleCol(col)).filter((col) => col !== void 0);
            self2.setHighlightedColumns(
              visibleColumns.length > 0 ? visibleColumns : void 0
            );
          })
        );
      }
    }));
  }

  // src/MsaViewPanel/index.ts
  var MsaViewPanel3 = (0, import_react83.lazy)(() => Promise.resolve().then(() => (init_MsaViewPanel(), MsaViewPanel_exports)));
  function MsaViewF(pluginManager) {
    pluginManager.addViewType(() => {
      return new import_ViewType.default({
        name: "MsaView",
        stateModel: stateModelFactory2(),
        ReactComponent: MsaViewPanel3
      });
    });
  }

  // src/index.ts
  var MsaViewPlugin = class extends import_Plugin.default {
    constructor() {
      super(...arguments);
      this.name = "MsaViewPlugin";
      this.version = version;
    }
    install(pluginManager) {
      MsaViewF(pluginManager);
      LaunchMsaViewF(pluginManager);
      LaunchMsaViewExtensionPointF(pluginManager);
      AddHighlightComponentsModelF(pluginManager);
      BgzipFastaMsaAdapterF(pluginManager);
    }
    configure(pluginManager) {
      if ((0, import_util50.isAbstractMenuManager)(pluginManager.rootModel)) {
        pluginManager.rootModel.appendToSubMenu(["Add"], {
          label: "Multiple sequence alignment view",
          icon: GridOn_default,
          onClick: (session) => {
            session.addView("MsaView", {});
          }
        });
      }
    }
    // @ts-expect-error
    rootConfigurationSchema(pluginManager) {
      return {
        msa: (0, import_configuration5.ConfigurationSchema)("MSA", {
          datasets: import_mobx_state_tree9.types.maybe(
            import_mobx_state_tree9.types.array(
              (0, import_configuration5.ConfigurationSchema)("MSAEntry", {
                datasetId: {
                  type: "string",
                  defaultValue: ""
                },
                description: {
                  type: "string",
                  defaultValue: ""
                },
                name: {
                  type: "string",
                  defaultValue: ""
                },
                adapter: pluginManager.pluggableConfigSchemaType("adapter")
              })
            )
          )
        })
      };
    }
  };
  return __toCommonJS(index_exports);
})();
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

canvas2svg/canvas2svg.js:
  (*!!
   *  Canvas 2 Svg v1.0.15
   *  A low level canvas to SVG converter. Uses a mock canvas context to build an SVG document.
   *
   *  Licensed under the MIT license:
   *  http://www.opensource.org/licenses/mit-license.php
   *
   *  Author:
   *  Kerry Liu
   *
   *  Copyright (c) 2014 Gliffy Inc.
   *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

dompurify/dist/purify.cjs.js:
  (*! @license DOMPurify 3.3.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.3.1/LICENSE *)

escape-html/index.js:
  (*!
   * escape-html
   * Copyright(c) 2012-2013 TJ Holowaychuk
   * Copyright(c) 2015 Andreas Lubbe
   * Copyright(c) 2015 Tiancheng "Timothy" Gu
   * MIT Licensed
   *)

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.4.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

svgcanvas/dist/svgcanvas.js:
  (*!!
   *  SVGCanvas v2.0.3
   *  Draw on SVG using Canvas's 2D Context API.
   *
   *  Licensed under the MIT license:
   *  http://www.opensource.org/licenses/mit-license.php
   *
   *  Author:
   *  Kerry Liu
   *  Zeno Zeng
   *
   *  Copyright (c) 2014 Gliffy Inc.
   *  Copyright (c) 2021 Zeno Zeng
   *)

pako/dist/pako.esm.mjs:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)
*/
